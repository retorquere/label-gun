"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/@actions/core/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/@actions/core/lib/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toCommandProperties = exports.toCommandValue = void 0;
      function toCommandValue(input2) {
        if (input2 === null || input2 === void 0) {
          return "";
        } else if (typeof input2 === "string" || input2 instanceof String) {
          return input2;
        }
        return JSON.stringify(input2);
      }
      exports.toCommandValue = toCommandValue;
      function toCommandProperties(annotationProperties) {
        if (!Object.keys(annotationProperties).length) {
          return {};
        }
        return {
          title: annotationProperties.title,
          file: annotationProperties.file,
          line: annotationProperties.startLine,
          endLine: annotationProperties.endLine,
          col: annotationProperties.startColumn,
          endColumn: annotationProperties.endColumn
        };
      }
      exports.toCommandProperties = toCommandProperties;
    }
  });

  // node_modules/@actions/core/lib/command.js
  var require_command = __commonJS({
    "node_modules/@actions/core/lib/command.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.issue = exports.issueCommand = void 0;
      var os = __importStar2(__require("os"));
      var utils_1 = require_utils();
      function issueCommand(command, properties, message) {
        const cmd = new Command(command, properties, message);
        process.stdout.write(cmd.toString() + os.EOL);
      }
      exports.issueCommand = issueCommand;
      function issue(name, message = "") {
        issueCommand(name, {}, message);
      }
      exports.issue = issue;
      var CMD_STRING = "::";
      var Command = class {
        constructor(command, properties, message) {
          if (!command) {
            command = "missing.command";
          }
          this.command = command;
          this.properties = properties;
          this.message = message;
        }
        toString() {
          let cmdStr = CMD_STRING + this.command;
          if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += " ";
            let first = true;
            for (const key in this.properties) {
              if (this.properties.hasOwnProperty(key)) {
                const val = this.properties[key];
                if (val) {
                  if (first) {
                    first = false;
                  } else {
                    cmdStr += ",";
                  }
                  cmdStr += `${key}=${escapeProperty(val)}`;
                }
              }
            }
          }
          cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
          return cmdStr;
        }
      };
      function escapeData(s) {
        return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
      }
      function escapeProperty(s) {
        return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
      }
    }
  });

  // node_modules/@actions/core/lib/file-command.js
  var require_file_command = __commonJS({
    "node_modules/@actions/core/lib/file-command.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
      var crypto = __importStar2(__require("crypto"));
      var fs = __importStar2(__require("fs"));
      var os = __importStar2(__require("os"));
      var utils_1 = require_utils();
      function issueFileCommand(command, message) {
        const filePath = process.env[`GITHUB_${command}`];
        if (!filePath) {
          throw new Error(`Unable to find environment variable for file command ${command}`);
        }
        if (!fs.existsSync(filePath)) {
          throw new Error(`Missing file at path: ${filePath}`);
        }
        fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
          encoding: "utf8"
        });
      }
      exports.issueFileCommand = issueFileCommand;
      function prepareKeyValueMessage(key, value) {
        const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
        const convertedValue = (0, utils_1.toCommandValue)(value);
        if (key.includes(delimiter)) {
          throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
        }
        if (convertedValue.includes(delimiter)) {
          throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
        }
        return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
      }
      exports.prepareKeyValueMessage = prepareKeyValueMessage;
    }
  });

  // node_modules/@actions/http-client/lib/proxy.js
  var require_proxy = __commonJS({
    "node_modules/@actions/http-client/lib/proxy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkBypass = exports.getProxyUrl = void 0;
      function getProxyUrl(reqUrl) {
        const usingSsl = reqUrl.protocol === "https:";
        if (checkBypass(reqUrl)) {
          return void 0;
        }
        const proxyVar = (() => {
          if (usingSsl) {
            return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
          } else {
            return process.env["http_proxy"] || process.env["HTTP_PROXY"];
          }
        })();
        if (proxyVar) {
          try {
            return new DecodedURL(proxyVar);
          } catch (_a) {
            if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
              return new DecodedURL(`http://${proxyVar}`);
          }
        } else {
          return void 0;
        }
      }
      exports.getProxyUrl = getProxyUrl;
      function checkBypass(reqUrl) {
        if (!reqUrl.hostname) {
          return false;
        }
        const reqHost = reqUrl.hostname;
        if (isLoopbackAddress(reqHost)) {
          return true;
        }
        const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
        if (!noProxy) {
          return false;
        }
        let reqPort;
        if (reqUrl.port) {
          reqPort = Number(reqUrl.port);
        } else if (reqUrl.protocol === "http:") {
          reqPort = 80;
        } else if (reqUrl.protocol === "https:") {
          reqPort = 443;
        }
        const upperReqHosts = [reqUrl.hostname.toUpperCase()];
        if (typeof reqPort === "number") {
          upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
        }
        for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
          if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
            return true;
          }
        }
        return false;
      }
      exports.checkBypass = checkBypass;
      function isLoopbackAddress(host) {
        const hostLower = host.toLowerCase();
        return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
      }
      var DecodedURL = class extends URL {
        constructor(url, base) {
          super(url, base);
          this._decodedUsername = decodeURIComponent(super.username);
          this._decodedPassword = decodeURIComponent(super.password);
        }
        get username() {
          return this._decodedUsername;
        }
        get password() {
          return this._decodedPassword;
        }
      };
    }
  });

  // node_modules/tunnel/lib/tunnel.js
  var require_tunnel = __commonJS({
    "node_modules/tunnel/lib/tunnel.js"(exports) {
      "use strict";
      var net = __require("net");
      var tls = __require("tls");
      var http = __require("http");
      var https = __require("https");
      var events = __require("events");
      var assert = __require("assert");
      var util = __require("util");
      exports.httpOverHttp = httpOverHttp;
      exports.httpsOverHttp = httpsOverHttp;
      exports.httpOverHttps = httpOverHttps;
      exports.httpsOverHttps = httpsOverHttps;
      function httpOverHttp(options) {
        var agent = new TunnelingAgent(options);
        agent.request = http.request;
        return agent;
      }
      function httpsOverHttp(options) {
        var agent = new TunnelingAgent(options);
        agent.request = http.request;
        agent.createSocket = createSecureSocket;
        agent.defaultPort = 443;
        return agent;
      }
      function httpOverHttps(options) {
        var agent = new TunnelingAgent(options);
        agent.request = https.request;
        return agent;
      }
      function httpsOverHttps(options) {
        var agent = new TunnelingAgent(options);
        agent.request = https.request;
        agent.createSocket = createSecureSocket;
        agent.defaultPort = 443;
        return agent;
      }
      function TunnelingAgent(options) {
        var self2 = this;
        self2.options = options || {};
        self2.proxyOptions = self2.options.proxy || {};
        self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
        self2.requests = [];
        self2.sockets = [];
        self2.on("free", function onFree(socket, host, port, localAddress) {
          var options2 = toOptions(host, port, localAddress);
          for (var i = 0, len = self2.requests.length; i < len; ++i) {
            var pending = self2.requests[i];
            if (pending.host === options2.host && pending.port === options2.port) {
              self2.requests.splice(i, 1);
              pending.request.onSocket(socket);
              return;
            }
          }
          socket.destroy();
          self2.removeSocket(socket);
        });
      }
      util.inherits(TunnelingAgent, events.EventEmitter);
      TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
        var self2 = this;
        var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
        if (self2.sockets.length >= this.maxSockets) {
          self2.requests.push(options);
          return;
        }
        self2.createSocket(options, function(socket) {
          socket.on("free", onFree);
          socket.on("close", onCloseOrRemove);
          socket.on("agentRemove", onCloseOrRemove);
          req.onSocket(socket);
          function onFree() {
            self2.emit("free", socket, options);
          }
          function onCloseOrRemove(err) {
            self2.removeSocket(socket);
            socket.removeListener("free", onFree);
            socket.removeListener("close", onCloseOrRemove);
            socket.removeListener("agentRemove", onCloseOrRemove);
          }
        });
      };
      TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
        var self2 = this;
        var placeholder = {};
        self2.sockets.push(placeholder);
        var connectOptions = mergeOptions({}, self2.proxyOptions, {
          method: "CONNECT",
          path: options.host + ":" + options.port,
          agent: false,
          headers: {
            host: options.host + ":" + options.port
          }
        });
        if (options.localAddress) {
          connectOptions.localAddress = options.localAddress;
        }
        if (connectOptions.proxyAuth) {
          connectOptions.headers = connectOptions.headers || {};
          connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
        }
        debug("making CONNECT request");
        var connectReq = self2.request(connectOptions);
        connectReq.useChunkedEncodingByDefault = false;
        connectReq.once("response", onResponse);
        connectReq.once("upgrade", onUpgrade);
        connectReq.once("connect", onConnect);
        connectReq.once("error", onError);
        connectReq.end();
        function onResponse(res) {
          res.upgrade = true;
        }
        function onUpgrade(res, socket, head) {
          process.nextTick(function() {
            onConnect(res, socket, head);
          });
        }
        function onConnect(res, socket, head) {
          connectReq.removeAllListeners();
          socket.removeAllListeners();
          if (res.statusCode !== 200) {
            debug(
              "tunneling socket could not be established, statusCode=%d",
              res.statusCode
            );
            socket.destroy();
            var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
            error.code = "ECONNRESET";
            options.request.emit("error", error);
            self2.removeSocket(placeholder);
            return;
          }
          if (head.length > 0) {
            debug("got illegal response body from proxy");
            socket.destroy();
            var error = new Error("got illegal response body from proxy");
            error.code = "ECONNRESET";
            options.request.emit("error", error);
            self2.removeSocket(placeholder);
            return;
          }
          debug("tunneling connection has established");
          self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
          return cb(socket);
        }
        function onError(cause) {
          connectReq.removeAllListeners();
          debug(
            "tunneling socket could not be established, cause=%s\n",
            cause.message,
            cause.stack
          );
          var error = new Error("tunneling socket could not be established, cause=" + cause.message);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
        }
      };
      TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
        var pos = this.sockets.indexOf(socket);
        if (pos === -1) {
          return;
        }
        this.sockets.splice(pos, 1);
        var pending = this.requests.shift();
        if (pending) {
          this.createSocket(pending, function(socket2) {
            pending.request.onSocket(socket2);
          });
        }
      };
      function createSecureSocket(options, cb) {
        var self2 = this;
        TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
          var hostHeader = options.request.getHeader("host");
          var tlsOptions = mergeOptions({}, self2.options, {
            socket,
            servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
          });
          var secureSocket = tls.connect(0, tlsOptions);
          self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
          cb(secureSocket);
        });
      }
      function toOptions(host, port, localAddress) {
        if (typeof host === "string") {
          return {
            host,
            port,
            localAddress
          };
        }
        return host;
      }
      function mergeOptions(target) {
        for (var i = 1, len = arguments.length; i < len; ++i) {
          var overrides = arguments[i];
          if (typeof overrides === "object") {
            var keys = Object.keys(overrides);
            for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
              var k = keys[j];
              if (overrides[k] !== void 0) {
                target[k] = overrides[k];
              }
            }
          }
        }
        return target;
      }
      var debug;
      if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
        debug = function() {
          var args = Array.prototype.slice.call(arguments);
          if (typeof args[0] === "string") {
            args[0] = "TUNNEL: " + args[0];
          } else {
            args.unshift("TUNNEL:");
          }
          console.error.apply(console, args);
        };
      } else {
        debug = function() {
        };
      }
      exports.debug = debug;
    }
  });

  // node_modules/tunnel/index.js
  var require_tunnel2 = __commonJS({
    "node_modules/tunnel/index.js"(exports, module) {
      module.exports = require_tunnel();
    }
  });

  // node_modules/undici/lib/core/symbols.js
  var require_symbols = __commonJS({
    "node_modules/undici/lib/core/symbols.js"(exports, module) {
      module.exports = {
        kClose: Symbol("close"),
        kDestroy: Symbol("destroy"),
        kDispatch: Symbol("dispatch"),
        kUrl: Symbol("url"),
        kWriting: Symbol("writing"),
        kResuming: Symbol("resuming"),
        kQueue: Symbol("queue"),
        kConnect: Symbol("connect"),
        kConnecting: Symbol("connecting"),
        kHeadersList: Symbol("headers list"),
        kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
        kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
        kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
        kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
        kKeepAlive: Symbol("keep alive"),
        kHeadersTimeout: Symbol("headers timeout"),
        kBodyTimeout: Symbol("body timeout"),
        kServerName: Symbol("server name"),
        kLocalAddress: Symbol("local address"),
        kHost: Symbol("host"),
        kNoRef: Symbol("no ref"),
        kBodyUsed: Symbol("used"),
        kRunning: Symbol("running"),
        kBlocking: Symbol("blocking"),
        kPending: Symbol("pending"),
        kSize: Symbol("size"),
        kBusy: Symbol("busy"),
        kQueued: Symbol("queued"),
        kFree: Symbol("free"),
        kConnected: Symbol("connected"),
        kClosed: Symbol("closed"),
        kNeedDrain: Symbol("need drain"),
        kReset: Symbol("reset"),
        kDestroyed: Symbol.for("nodejs.stream.destroyed"),
        kMaxHeadersSize: Symbol("max headers size"),
        kRunningIdx: Symbol("running index"),
        kPendingIdx: Symbol("pending index"),
        kError: Symbol("error"),
        kClients: Symbol("clients"),
        kClient: Symbol("client"),
        kParser: Symbol("parser"),
        kOnDestroyed: Symbol("destroy callbacks"),
        kPipelining: Symbol("pipelining"),
        kSocket: Symbol("socket"),
        kHostHeader: Symbol("host header"),
        kConnector: Symbol("connector"),
        kStrictContentLength: Symbol("strict content length"),
        kMaxRedirections: Symbol("maxRedirections"),
        kMaxRequests: Symbol("maxRequestsPerClient"),
        kProxy: Symbol("proxy agent options"),
        kCounter: Symbol("socket request counter"),
        kInterceptors: Symbol("dispatch interceptors"),
        kMaxResponseSize: Symbol("max response size"),
        kHTTP2Session: Symbol("http2Session"),
        kHTTP2SessionState: Symbol("http2Session state"),
        kHTTP2BuildRequest: Symbol("http2 build request"),
        kHTTP1BuildRequest: Symbol("http1 build request"),
        kHTTP2CopyHeaders: Symbol("http2 copy headers"),
        kHTTPConnVersion: Symbol("http connection version"),
        kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
        kConstruct: Symbol("constructable")
      };
    }
  });

  // node_modules/undici/lib/core/errors.js
  var require_errors = __commonJS({
    "node_modules/undici/lib/core/errors.js"(exports, module) {
      "use strict";
      var UndiciError = class extends Error {
        constructor(message) {
          super(message);
          this.name = "UndiciError";
          this.code = "UND_ERR";
        }
      };
      var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _ConnectTimeoutError);
          this.name = "ConnectTimeoutError";
          this.message = message || "Connect Timeout Error";
          this.code = "UND_ERR_CONNECT_TIMEOUT";
        }
      };
      var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _HeadersTimeoutError);
          this.name = "HeadersTimeoutError";
          this.message = message || "Headers Timeout Error";
          this.code = "UND_ERR_HEADERS_TIMEOUT";
        }
      };
      var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _HeadersOverflowError);
          this.name = "HeadersOverflowError";
          this.message = message || "Headers Overflow Error";
          this.code = "UND_ERR_HEADERS_OVERFLOW";
        }
      };
      var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _BodyTimeoutError);
          this.name = "BodyTimeoutError";
          this.message = message || "Body Timeout Error";
          this.code = "UND_ERR_BODY_TIMEOUT";
        }
      };
      var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
        constructor(message, statusCode, headers, body) {
          super(message);
          Error.captureStackTrace(this, _ResponseStatusCodeError);
          this.name = "ResponseStatusCodeError";
          this.message = message || "Response Status Code Error";
          this.code = "UND_ERR_RESPONSE_STATUS_CODE";
          this.body = body;
          this.status = statusCode;
          this.statusCode = statusCode;
          this.headers = headers;
        }
      };
      var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _InvalidArgumentError);
          this.name = "InvalidArgumentError";
          this.message = message || "Invalid Argument Error";
          this.code = "UND_ERR_INVALID_ARG";
        }
      };
      var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _InvalidReturnValueError);
          this.name = "InvalidReturnValueError";
          this.message = message || "Invalid Return Value Error";
          this.code = "UND_ERR_INVALID_RETURN_VALUE";
        }
      };
      var RequestAbortedError = class _RequestAbortedError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _RequestAbortedError);
          this.name = "AbortError";
          this.message = message || "Request aborted";
          this.code = "UND_ERR_ABORTED";
        }
      };
      var InformationalError = class _InformationalError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _InformationalError);
          this.name = "InformationalError";
          this.message = message || "Request information";
          this.code = "UND_ERR_INFO";
        }
      };
      var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _RequestContentLengthMismatchError);
          this.name = "RequestContentLengthMismatchError";
          this.message = message || "Request body length does not match content-length header";
          this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
        }
      };
      var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
          this.name = "ResponseContentLengthMismatchError";
          this.message = message || "Response body length does not match content-length header";
          this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
        }
      };
      var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _ClientDestroyedError);
          this.name = "ClientDestroyedError";
          this.message = message || "The client is destroyed";
          this.code = "UND_ERR_DESTROYED";
        }
      };
      var ClientClosedError = class _ClientClosedError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _ClientClosedError);
          this.name = "ClientClosedError";
          this.message = message || "The client is closed";
          this.code = "UND_ERR_CLOSED";
        }
      };
      var SocketError = class _SocketError extends UndiciError {
        constructor(message, socket) {
          super(message);
          Error.captureStackTrace(this, _SocketError);
          this.name = "SocketError";
          this.message = message || "Socket error";
          this.code = "UND_ERR_SOCKET";
          this.socket = socket;
        }
      };
      var NotSupportedError = class _NotSupportedError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _NotSupportedError);
          this.name = "NotSupportedError";
          this.message = message || "Not supported error";
          this.code = "UND_ERR_NOT_SUPPORTED";
        }
      };
      var BalancedPoolMissingUpstreamError = class extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, NotSupportedError);
          this.name = "MissingUpstreamError";
          this.message = message || "No upstream has been added to the BalancedPool";
          this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
        }
      };
      var HTTPParserError = class _HTTPParserError extends Error {
        constructor(message, code, data) {
          super(message);
          Error.captureStackTrace(this, _HTTPParserError);
          this.name = "HTTPParserError";
          this.code = code ? `HPE_${code}` : void 0;
          this.data = data ? data.toString() : void 0;
        }
      };
      var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
          this.name = "ResponseExceededMaxSizeError";
          this.message = message || "Response content exceeded max size";
          this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
        }
      };
      var RequestRetryError = class _RequestRetryError extends UndiciError {
        constructor(message, code, { headers, data }) {
          super(message);
          Error.captureStackTrace(this, _RequestRetryError);
          this.name = "RequestRetryError";
          this.message = message || "Request retry error";
          this.code = "UND_ERR_REQ_RETRY";
          this.statusCode = code;
          this.data = data;
          this.headers = headers;
        }
      };
      module.exports = {
        HTTPParserError,
        UndiciError,
        HeadersTimeoutError,
        HeadersOverflowError,
        BodyTimeoutError,
        RequestContentLengthMismatchError,
        ConnectTimeoutError,
        ResponseStatusCodeError,
        InvalidArgumentError,
        InvalidReturnValueError,
        RequestAbortedError,
        ClientDestroyedError,
        ClientClosedError,
        InformationalError,
        SocketError,
        NotSupportedError,
        ResponseContentLengthMismatchError,
        BalancedPoolMissingUpstreamError,
        ResponseExceededMaxSizeError,
        RequestRetryError
      };
    }
  });

  // node_modules/undici/lib/core/constants.js
  var require_constants = __commonJS({
    "node_modules/undici/lib/core/constants.js"(exports, module) {
      "use strict";
      var headerNameLowerCasedRecord = {};
      var wellknownHeaderNames = [
        "Accept",
        "Accept-Encoding",
        "Accept-Language",
        "Accept-Ranges",
        "Access-Control-Allow-Credentials",
        "Access-Control-Allow-Headers",
        "Access-Control-Allow-Methods",
        "Access-Control-Allow-Origin",
        "Access-Control-Expose-Headers",
        "Access-Control-Max-Age",
        "Access-Control-Request-Headers",
        "Access-Control-Request-Method",
        "Age",
        "Allow",
        "Alt-Svc",
        "Alt-Used",
        "Authorization",
        "Cache-Control",
        "Clear-Site-Data",
        "Connection",
        "Content-Disposition",
        "Content-Encoding",
        "Content-Language",
        "Content-Length",
        "Content-Location",
        "Content-Range",
        "Content-Security-Policy",
        "Content-Security-Policy-Report-Only",
        "Content-Type",
        "Cookie",
        "Cross-Origin-Embedder-Policy",
        "Cross-Origin-Opener-Policy",
        "Cross-Origin-Resource-Policy",
        "Date",
        "Device-Memory",
        "Downlink",
        "ECT",
        "ETag",
        "Expect",
        "Expect-CT",
        "Expires",
        "Forwarded",
        "From",
        "Host",
        "If-Match",
        "If-Modified-Since",
        "If-None-Match",
        "If-Range",
        "If-Unmodified-Since",
        "Keep-Alive",
        "Last-Modified",
        "Link",
        "Location",
        "Max-Forwards",
        "Origin",
        "Permissions-Policy",
        "Pragma",
        "Proxy-Authenticate",
        "Proxy-Authorization",
        "RTT",
        "Range",
        "Referer",
        "Referrer-Policy",
        "Refresh",
        "Retry-After",
        "Sec-WebSocket-Accept",
        "Sec-WebSocket-Extensions",
        "Sec-WebSocket-Key",
        "Sec-WebSocket-Protocol",
        "Sec-WebSocket-Version",
        "Server",
        "Server-Timing",
        "Service-Worker-Allowed",
        "Service-Worker-Navigation-Preload",
        "Set-Cookie",
        "SourceMap",
        "Strict-Transport-Security",
        "Supports-Loading-Mode",
        "TE",
        "Timing-Allow-Origin",
        "Trailer",
        "Transfer-Encoding",
        "Upgrade",
        "Upgrade-Insecure-Requests",
        "User-Agent",
        "Vary",
        "Via",
        "WWW-Authenticate",
        "X-Content-Type-Options",
        "X-DNS-Prefetch-Control",
        "X-Frame-Options",
        "X-Permitted-Cross-Domain-Policies",
        "X-Powered-By",
        "X-Requested-With",
        "X-XSS-Protection"
      ];
      for (let i = 0; i < wellknownHeaderNames.length; ++i) {
        const key = wellknownHeaderNames[i];
        const lowerCasedKey = key.toLowerCase();
        headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
      }
      Object.setPrototypeOf(headerNameLowerCasedRecord, null);
      module.exports = {
        wellknownHeaderNames,
        headerNameLowerCasedRecord
      };
    }
  });

  // node_modules/undici/lib/core/util.js
  var require_util = __commonJS({
    "node_modules/undici/lib/core/util.js"(exports, module) {
      "use strict";
      var assert = __require("assert");
      var { kDestroyed, kBodyUsed } = require_symbols();
      var { IncomingMessage } = __require("http");
      var stream = __require("stream");
      var net = __require("net");
      var { InvalidArgumentError } = require_errors();
      var { Blob: Blob2 } = __require("buffer");
      var nodeUtil = __require("util");
      var { stringify } = __require("querystring");
      var { headerNameLowerCasedRecord } = require_constants();
      var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
      function nop() {
      }
      function isStream(obj) {
        return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
      }
      function isBlobLike(object) {
        return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
      function buildURL(url, queryParams) {
        if (url.includes("?") || url.includes("#")) {
          throw new Error('Query params cannot be passed when url already contains "?" or "#".');
        }
        const stringified = stringify(queryParams);
        if (stringified) {
          url += "?" + stringified;
        }
        return url;
      }
      function parseURL(url) {
        if (typeof url === "string") {
          url = new URL(url);
          if (!/^https?:/.test(url.origin || url.protocol)) {
            throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
          }
          return url;
        }
        if (!url || typeof url !== "object") {
          throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
        }
        if (!/^https?:/.test(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        if (!(url instanceof URL)) {
          if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
            throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
          }
          if (url.path != null && typeof url.path !== "string") {
            throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
          }
          if (url.pathname != null && typeof url.pathname !== "string") {
            throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
          }
          if (url.hostname != null && typeof url.hostname !== "string") {
            throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
          }
          if (url.origin != null && typeof url.origin !== "string") {
            throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
          }
          const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
          let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
          let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
          if (origin.endsWith("/")) {
            origin = origin.substring(0, origin.length - 1);
          }
          if (path && !path.startsWith("/")) {
            path = `/${path}`;
          }
          url = new URL(origin + path);
        }
        return url;
      }
      function parseOrigin(url) {
        url = parseURL(url);
        if (url.pathname !== "/" || url.search || url.hash) {
          throw new InvalidArgumentError("invalid url");
        }
        return url;
      }
      function getHostname(host) {
        if (host[0] === "[") {
          const idx2 = host.indexOf("]");
          assert(idx2 !== -1);
          return host.substring(1, idx2);
        }
        const idx = host.indexOf(":");
        if (idx === -1) return host;
        return host.substring(0, idx);
      }
      function getServerName(host) {
        if (!host) {
          return null;
        }
        assert.strictEqual(typeof host, "string");
        const servername = getHostname(host);
        if (net.isIP(servername)) {
          return "";
        }
        return servername;
      }
      function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
      function isAsyncIterable(obj) {
        return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
      }
      function isIterable(obj) {
        return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
      }
      function bodyLength(body) {
        if (body == null) {
          return 0;
        } else if (isStream(body)) {
          const state = body._readableState;
          return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
        } else if (isBlobLike(body)) {
          return body.size != null ? body.size : null;
        } else if (isBuffer(body)) {
          return body.byteLength;
        }
        return null;
      }
      function isDestroyed(stream2) {
        return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
      }
      function isReadableAborted(stream2) {
        const state = stream2 && stream2._readableState;
        return isDestroyed(stream2) && state && !state.endEmitted;
      }
      function destroy(stream2, err) {
        if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
          return;
        }
        if (typeof stream2.destroy === "function") {
          if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
            stream2.socket = null;
          }
          stream2.destroy(err);
        } else if (err) {
          process.nextTick((stream3, err2) => {
            stream3.emit("error", err2);
          }, stream2, err);
        }
        if (stream2.destroyed !== true) {
          stream2[kDestroyed] = true;
        }
      }
      var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
      function parseKeepAliveTimeout(val) {
        const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
        return m ? parseInt(m[1], 10) * 1e3 : null;
      }
      function headerNameToString(value) {
        return headerNameLowerCasedRecord[value] || value.toLowerCase();
      }
      function parseHeaders(headers, obj = {}) {
        if (!Array.isArray(headers)) return headers;
        for (let i = 0; i < headers.length; i += 2) {
          const key = headers[i].toString().toLowerCase();
          let val = obj[key];
          if (!val) {
            if (Array.isArray(headers[i + 1])) {
              obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
            } else {
              obj[key] = headers[i + 1].toString("utf8");
            }
          } else {
            if (!Array.isArray(val)) {
              val = [val];
              obj[key] = val;
            }
            val.push(headers[i + 1].toString("utf8"));
          }
        }
        if ("content-length" in obj && "content-disposition" in obj) {
          obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
        }
        return obj;
      }
      function parseRawHeaders(headers) {
        const ret = [];
        let hasContentLength = false;
        let contentDispositionIdx = -1;
        for (let n = 0; n < headers.length; n += 2) {
          const key = headers[n + 0].toString();
          const val = headers[n + 1].toString("utf8");
          if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
            ret.push(key, val);
            hasContentLength = true;
          } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
            contentDispositionIdx = ret.push(key, val) - 1;
          } else {
            ret.push(key, val);
          }
        }
        if (hasContentLength && contentDispositionIdx !== -1) {
          ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
        }
        return ret;
      }
      function isBuffer(buffer) {
        return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
      }
      function validateHandler(handler2, method, upgrade) {
        if (!handler2 || typeof handler2 !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        if (typeof handler2.onConnect !== "function") {
          throw new InvalidArgumentError("invalid onConnect method");
        }
        if (typeof handler2.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        if (typeof handler2.onBodySent !== "function" && handler2.onBodySent !== void 0) {
          throw new InvalidArgumentError("invalid onBodySent method");
        }
        if (upgrade || method === "CONNECT") {
          if (typeof handler2.onUpgrade !== "function") {
            throw new InvalidArgumentError("invalid onUpgrade method");
          }
        } else {
          if (typeof handler2.onHeaders !== "function") {
            throw new InvalidArgumentError("invalid onHeaders method");
          }
          if (typeof handler2.onData !== "function") {
            throw new InvalidArgumentError("invalid onData method");
          }
          if (typeof handler2.onComplete !== "function") {
            throw new InvalidArgumentError("invalid onComplete method");
          }
        }
      }
      function isDisturbed(body) {
        return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
      }
      function isErrored(body) {
        return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
          nodeUtil.inspect(body)
        )));
      }
      function isReadable(body) {
        return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
          nodeUtil.inspect(body)
        )));
      }
      function getSocketInfo(socket) {
        return {
          localAddress: socket.localAddress,
          localPort: socket.localPort,
          remoteAddress: socket.remoteAddress,
          remotePort: socket.remotePort,
          remoteFamily: socket.remoteFamily,
          timeout: socket.timeout,
          bytesWritten: socket.bytesWritten,
          bytesRead: socket.bytesRead
        };
      }
      async function* convertIterableToBuffer(iterable) {
        for await (const chunk of iterable) {
          yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }
      }
      var ReadableStream;
      function ReadableStreamFrom(iterable) {
        if (!ReadableStream) {
          ReadableStream = __require("stream/web").ReadableStream;
        }
        if (ReadableStream.from) {
          return ReadableStream.from(convertIterableToBuffer(iterable));
        }
        let iterator;
        return new ReadableStream(
          {
            async start() {
              iterator = iterable[Symbol.asyncIterator]();
            },
            async pull(controller) {
              const { done, value } = await iterator.next();
              if (done) {
                queueMicrotask(() => {
                  controller.close();
                });
              } else {
                const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
                controller.enqueue(new Uint8Array(buf));
              }
              return controller.desiredSize > 0;
            },
            async cancel(reason) {
              await iterator.return();
            }
          },
          0
        );
      }
      function isFormDataLike(object) {
        return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
      }
      function throwIfAborted(signal) {
        if (!signal) {
          return;
        }
        if (typeof signal.throwIfAborted === "function") {
          signal.throwIfAborted();
        } else {
          if (signal.aborted) {
            const err = new Error("The operation was aborted");
            err.name = "AbortError";
            throw err;
          }
        }
      }
      function addAbortListener(signal, listener) {
        if ("addEventListener" in signal) {
          signal.addEventListener("abort", listener, { once: true });
          return () => signal.removeEventListener("abort", listener);
        }
        signal.addListener("abort", listener);
        return () => signal.removeListener("abort", listener);
      }
      var hasToWellFormed = !!String.prototype.toWellFormed;
      function toUSVString(val) {
        if (hasToWellFormed) {
          return `${val}`.toWellFormed();
        } else if (nodeUtil.toUSVString) {
          return nodeUtil.toUSVString(val);
        }
        return `${val}`;
      }
      function parseRangeHeader(range) {
        if (range == null || range === "") return { start: 0, end: null, size: null };
        const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
        return m ? {
          start: parseInt(m[1]),
          end: m[2] ? parseInt(m[2]) : null,
          size: m[3] ? parseInt(m[3]) : null
        } : null;
      }
      var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
      kEnumerableProperty.enumerable = true;
      module.exports = {
        kEnumerableProperty,
        nop,
        isDisturbed,
        isErrored,
        isReadable,
        toUSVString,
        isReadableAborted,
        isBlobLike,
        parseOrigin,
        parseURL,
        getServerName,
        isStream,
        isIterable,
        isAsyncIterable,
        isDestroyed,
        headerNameToString,
        parseRawHeaders,
        parseHeaders,
        parseKeepAliveTimeout,
        destroy,
        bodyLength,
        deepClone,
        ReadableStreamFrom,
        isBuffer,
        validateHandler,
        getSocketInfo,
        isFormDataLike,
        buildURL,
        throwIfAborted,
        addAbortListener,
        parseRangeHeader,
        nodeMajor,
        nodeMinor,
        nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
        safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
      };
    }
  });

  // node_modules/undici/lib/timers.js
  var require_timers = __commonJS({
    "node_modules/undici/lib/timers.js"(exports, module) {
      "use strict";
      var fastNow = Date.now();
      var fastNowTimeout;
      var fastTimers = [];
      function onTimeout() {
        fastNow = Date.now();
        let len = fastTimers.length;
        let idx = 0;
        while (idx < len) {
          const timer = fastTimers[idx];
          if (timer.state === 0) {
            timer.state = fastNow + timer.delay;
          } else if (timer.state > 0 && fastNow >= timer.state) {
            timer.state = -1;
            timer.callback(timer.opaque);
          }
          if (timer.state === -1) {
            timer.state = -2;
            if (idx !== len - 1) {
              fastTimers[idx] = fastTimers.pop();
            } else {
              fastTimers.pop();
            }
            len -= 1;
          } else {
            idx += 1;
          }
        }
        if (fastTimers.length > 0) {
          refreshTimeout();
        }
      }
      function refreshTimeout() {
        if (fastNowTimeout && fastNowTimeout.refresh) {
          fastNowTimeout.refresh();
        } else {
          clearTimeout(fastNowTimeout);
          fastNowTimeout = setTimeout(onTimeout, 1e3);
          if (fastNowTimeout.unref) {
            fastNowTimeout.unref();
          }
        }
      }
      var Timeout = class {
        constructor(callback, delay, opaque) {
          this.callback = callback;
          this.delay = delay;
          this.opaque = opaque;
          this.state = -2;
          this.refresh();
        }
        refresh() {
          if (this.state === -2) {
            fastTimers.push(this);
            if (!fastNowTimeout || fastTimers.length === 1) {
              refreshTimeout();
            }
          }
          this.state = 0;
        }
        clear() {
          this.state = -1;
        }
      };
      module.exports = {
        setTimeout(callback, delay, opaque) {
          return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
        },
        clearTimeout(timeout) {
          if (timeout instanceof Timeout) {
            timeout.clear();
          } else {
            clearTimeout(timeout);
          }
        }
      };
    }
  });

  // node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
  var require_sbmh = __commonJS({
    "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports, module) {
      "use strict";
      var EventEmitter = __require("node:events").EventEmitter;
      var inherits = __require("node:util").inherits;
      function SBMH(needle) {
        if (typeof needle === "string") {
          needle = Buffer.from(needle);
        }
        if (!Buffer.isBuffer(needle)) {
          throw new TypeError("The needle has to be a String or a Buffer.");
        }
        const needleLength = needle.length;
        if (needleLength === 0) {
          throw new Error("The needle cannot be an empty String/Buffer.");
        }
        if (needleLength > 256) {
          throw new Error("The needle cannot have a length bigger than 256.");
        }
        this.maxMatches = Infinity;
        this.matches = 0;
        this._occ = new Array(256).fill(needleLength);
        this._lookbehind_size = 0;
        this._needle = needle;
        this._bufpos = 0;
        this._lookbehind = Buffer.alloc(needleLength);
        for (var i = 0; i < needleLength - 1; ++i) {
          this._occ[needle[i]] = needleLength - 1 - i;
        }
      }
      inherits(SBMH, EventEmitter);
      SBMH.prototype.reset = function() {
        this._lookbehind_size = 0;
        this.matches = 0;
        this._bufpos = 0;
      };
      SBMH.prototype.push = function(chunk, pos) {
        if (!Buffer.isBuffer(chunk)) {
          chunk = Buffer.from(chunk, "binary");
        }
        const chlen = chunk.length;
        this._bufpos = pos || 0;
        let r;
        while (r !== chlen && this.matches < this.maxMatches) {
          r = this._sbmh_feed(chunk);
        }
        return r;
      };
      SBMH.prototype._sbmh_feed = function(data) {
        const len = data.length;
        const needle = this._needle;
        const needleLength = needle.length;
        const lastNeedleChar = needle[needleLength - 1];
        let pos = -this._lookbehind_size;
        let ch;
        if (pos < 0) {
          while (pos < 0 && pos <= len - needleLength) {
            ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
            if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
              this._lookbehind_size = 0;
              ++this.matches;
              this.emit("info", true);
              return this._bufpos = pos + needleLength;
            }
            pos += this._occ[ch];
          }
          if (pos < 0) {
            while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
              ++pos;
            }
          }
          if (pos >= 0) {
            this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
            this._lookbehind_size = 0;
          } else {
            const bytesToCutOff = this._lookbehind_size + pos;
            if (bytesToCutOff > 0) {
              this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
            }
            this._lookbehind.copy(
              this._lookbehind,
              0,
              bytesToCutOff,
              this._lookbehind_size - bytesToCutOff
            );
            this._lookbehind_size -= bytesToCutOff;
            data.copy(this._lookbehind, this._lookbehind_size);
            this._lookbehind_size += len;
            this._bufpos = len;
            return len;
          }
        }
        pos += (pos >= 0) * this._bufpos;
        if (data.indexOf(needle, pos) !== -1) {
          pos = data.indexOf(needle, pos);
          ++this.matches;
          if (pos > 0) {
            this.emit("info", true, data, this._bufpos, pos);
          } else {
            this.emit("info", true);
          }
          return this._bufpos = pos + needleLength;
        } else {
          pos = len - needleLength;
        }
        while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
          data.subarray(pos, pos + len - pos),
          needle.subarray(0, len - pos)
        ) !== 0)) {
          ++pos;
        }
        if (pos < len) {
          data.copy(this._lookbehind, 0, pos, pos + (len - pos));
          this._lookbehind_size = len - pos;
        }
        if (pos > 0) {
          this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
        }
        this._bufpos = len;
        return len;
      };
      SBMH.prototype._sbmh_lookup_char = function(data, pos) {
        return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
      };
      SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
        for (var i = 0; i < len; ++i) {
          if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
            return false;
          }
        }
        return true;
      };
      module.exports = SBMH;
    }
  });

  // node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
  var require_PartStream = __commonJS({
    "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports, module) {
      "use strict";
      var inherits = __require("node:util").inherits;
      var ReadableStream = __require("node:stream").Readable;
      function PartStream(opts) {
        ReadableStream.call(this, opts);
      }
      inherits(PartStream, ReadableStream);
      PartStream.prototype._read = function(n) {
      };
      module.exports = PartStream;
    }
  });

  // node_modules/@fastify/busboy/lib/utils/getLimit.js
  var require_getLimit = __commonJS({
    "node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports, module) {
      "use strict";
      module.exports = function getLimit(limits, name, defaultLimit) {
        if (!limits || limits[name] === void 0 || limits[name] === null) {
          return defaultLimit;
        }
        if (typeof limits[name] !== "number" || isNaN(limits[name])) {
          throw new TypeError("Limit " + name + " is not a valid number");
        }
        return limits[name];
      };
    }
  });

  // node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
  var require_HeaderParser = __commonJS({
    "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports, module) {
      "use strict";
      var EventEmitter = __require("node:events").EventEmitter;
      var inherits = __require("node:util").inherits;
      var getLimit = require_getLimit();
      var StreamSearch = require_sbmh();
      var B_DCRLF = Buffer.from("\r\n\r\n");
      var RE_CRLF = /\r\n/g;
      var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
      function HeaderParser(cfg) {
        EventEmitter.call(this);
        cfg = cfg || {};
        const self2 = this;
        this.nread = 0;
        this.maxed = false;
        this.npairs = 0;
        this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
        this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
        this.buffer = "";
        this.header = {};
        this.finished = false;
        this.ss = new StreamSearch(B_DCRLF);
        this.ss.on("info", function(isMatch, data, start, end) {
          if (data && !self2.maxed) {
            if (self2.nread + end - start >= self2.maxHeaderSize) {
              end = self2.maxHeaderSize - self2.nread + start;
              self2.nread = self2.maxHeaderSize;
              self2.maxed = true;
            } else {
              self2.nread += end - start;
            }
            self2.buffer += data.toString("binary", start, end);
          }
          if (isMatch) {
            self2._finish();
          }
        });
      }
      inherits(HeaderParser, EventEmitter);
      HeaderParser.prototype.push = function(data) {
        const r = this.ss.push(data);
        if (this.finished) {
          return r;
        }
      };
      HeaderParser.prototype.reset = function() {
        this.finished = false;
        this.buffer = "";
        this.header = {};
        this.ss.reset();
      };
      HeaderParser.prototype._finish = function() {
        if (this.buffer) {
          this._parseHeader();
        }
        this.ss.matches = this.ss.maxMatches;
        const header = this.header;
        this.header = {};
        this.buffer = "";
        this.finished = true;
        this.nread = this.npairs = 0;
        this.maxed = false;
        this.emit("header", header);
      };
      HeaderParser.prototype._parseHeader = function() {
        if (this.npairs === this.maxHeaderPairs) {
          return;
        }
        const lines = this.buffer.split(RE_CRLF);
        const len = lines.length;
        let m, h;
        for (var i = 0; i < len; ++i) {
          if (lines[i].length === 0) {
            continue;
          }
          if (lines[i][0] === "	" || lines[i][0] === " ") {
            if (h) {
              this.header[h][this.header[h].length - 1] += lines[i];
              continue;
            }
          }
          const posColon = lines[i].indexOf(":");
          if (posColon === -1 || posColon === 0) {
            return;
          }
          m = RE_HDR.exec(lines[i]);
          h = m[1].toLowerCase();
          this.header[h] = this.header[h] || [];
          this.header[h].push(m[2] || "");
          if (++this.npairs === this.maxHeaderPairs) {
            break;
          }
        }
      };
      module.exports = HeaderParser;
    }
  });

  // node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
  var require_Dicer = __commonJS({
    "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports, module) {
      "use strict";
      var WritableStream = __require("node:stream").Writable;
      var inherits = __require("node:util").inherits;
      var StreamSearch = require_sbmh();
      var PartStream = require_PartStream();
      var HeaderParser = require_HeaderParser();
      var DASH = 45;
      var B_ONEDASH = Buffer.from("-");
      var B_CRLF = Buffer.from("\r\n");
      var EMPTY_FN = function() {
      };
      function Dicer(cfg) {
        if (!(this instanceof Dicer)) {
          return new Dicer(cfg);
        }
        WritableStream.call(this, cfg);
        if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
          throw new TypeError("Boundary required");
        }
        if (typeof cfg.boundary === "string") {
          this.setBoundary(cfg.boundary);
        } else {
          this._bparser = void 0;
        }
        this._headerFirst = cfg.headerFirst;
        this._dashes = 0;
        this._parts = 0;
        this._finished = false;
        this._realFinish = false;
        this._isPreamble = true;
        this._justMatched = false;
        this._firstWrite = true;
        this._inHeader = true;
        this._part = void 0;
        this._cb = void 0;
        this._ignoreData = false;
        this._partOpts = { highWaterMark: cfg.partHwm };
        this._pause = false;
        const self2 = this;
        this._hparser = new HeaderParser(cfg);
        this._hparser.on("header", function(header) {
          self2._inHeader = false;
          self2._part.emit("header", header);
        });
      }
      inherits(Dicer, WritableStream);
      Dicer.prototype.emit = function(ev) {
        if (ev === "finish" && !this._realFinish) {
          if (!this._finished) {
            const self2 = this;
            process.nextTick(function() {
              self2.emit("error", new Error("Unexpected end of multipart data"));
              if (self2._part && !self2._ignoreData) {
                const type = self2._isPreamble ? "Preamble" : "Part";
                self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
                self2._part.push(null);
                process.nextTick(function() {
                  self2._realFinish = true;
                  self2.emit("finish");
                  self2._realFinish = false;
                });
                return;
              }
              self2._realFinish = true;
              self2.emit("finish");
              self2._realFinish = false;
            });
          }
        } else {
          WritableStream.prototype.emit.apply(this, arguments);
        }
      };
      Dicer.prototype._write = function(data, encoding, cb) {
        if (!this._hparser && !this._bparser) {
          return cb();
        }
        if (this._headerFirst && this._isPreamble) {
          if (!this._part) {
            this._part = new PartStream(this._partOpts);
            if (this.listenerCount("preamble") !== 0) {
              this.emit("preamble", this._part);
            } else {
              this._ignore();
            }
          }
          const r = this._hparser.push(data);
          if (!this._inHeader && r !== void 0 && r < data.length) {
            data = data.slice(r);
          } else {
            return cb();
          }
        }
        if (this._firstWrite) {
          this._bparser.push(B_CRLF);
          this._firstWrite = false;
        }
        this._bparser.push(data);
        if (this._pause) {
          this._cb = cb;
        } else {
          cb();
        }
      };
      Dicer.prototype.reset = function() {
        this._part = void 0;
        this._bparser = void 0;
        this._hparser = void 0;
      };
      Dicer.prototype.setBoundary = function(boundary) {
        const self2 = this;
        this._bparser = new StreamSearch("\r\n--" + boundary);
        this._bparser.on("info", function(isMatch, data, start, end) {
          self2._oninfo(isMatch, data, start, end);
        });
      };
      Dicer.prototype._ignore = function() {
        if (this._part && !this._ignoreData) {
          this._ignoreData = true;
          this._part.on("error", EMPTY_FN);
          this._part.resume();
        }
      };
      Dicer.prototype._oninfo = function(isMatch, data, start, end) {
        let buf;
        const self2 = this;
        let i = 0;
        let r;
        let shouldWriteMore = true;
        if (!this._part && this._justMatched && data) {
          while (this._dashes < 2 && start + i < end) {
            if (data[start + i] === DASH) {
              ++i;
              ++this._dashes;
            } else {
              if (this._dashes) {
                buf = B_ONEDASH;
              }
              this._dashes = 0;
              break;
            }
          }
          if (this._dashes === 2) {
            if (start + i < end && this.listenerCount("trailer") !== 0) {
              this.emit("trailer", data.slice(start + i, end));
            }
            this.reset();
            this._finished = true;
            if (self2._parts === 0) {
              self2._realFinish = true;
              self2.emit("finish");
              self2._realFinish = false;
            }
          }
          if (this._dashes) {
            return;
          }
        }
        if (this._justMatched) {
          this._justMatched = false;
        }
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          this._part._read = function(n) {
            self2._unpause();
          };
          if (this._isPreamble && this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
            this.emit("part", this._part);
          } else {
            this._ignore();
          }
          if (!this._isPreamble) {
            this._inHeader = true;
          }
        }
        if (data && start < end && !this._ignoreData) {
          if (this._isPreamble || !this._inHeader) {
            if (buf) {
              shouldWriteMore = this._part.push(buf);
            }
            shouldWriteMore = this._part.push(data.slice(start, end));
            if (!shouldWriteMore) {
              this._pause = true;
            }
          } else if (!this._isPreamble && this._inHeader) {
            if (buf) {
              this._hparser.push(buf);
            }
            r = this._hparser.push(data.slice(start, end));
            if (!this._inHeader && r !== void 0 && r < end) {
              this._oninfo(false, data, start + r, end);
            }
          }
        }
        if (isMatch) {
          this._hparser.reset();
          if (this._isPreamble) {
            this._isPreamble = false;
          } else {
            if (start !== end) {
              ++this._parts;
              this._part.on("end", function() {
                if (--self2._parts === 0) {
                  if (self2._finished) {
                    self2._realFinish = true;
                    self2.emit("finish");
                    self2._realFinish = false;
                  } else {
                    self2._unpause();
                  }
                }
              });
            }
          }
          this._part.push(null);
          this._part = void 0;
          this._ignoreData = false;
          this._justMatched = true;
          this._dashes = 0;
        }
      };
      Dicer.prototype._unpause = function() {
        if (!this._pause) {
          return;
        }
        this._pause = false;
        if (this._cb) {
          const cb = this._cb;
          this._cb = void 0;
          cb();
        }
      };
      module.exports = Dicer;
    }
  });

  // node_modules/@fastify/busboy/lib/utils/decodeText.js
  var require_decodeText = __commonJS({
    "node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports, module) {
      "use strict";
      var utf8Decoder = new TextDecoder("utf-8");
      var textDecoders = /* @__PURE__ */ new Map([
        ["utf-8", utf8Decoder],
        ["utf8", utf8Decoder]
      ]);
      function getDecoder(charset) {
        let lc;
        while (true) {
          switch (charset) {
            case "utf-8":
            case "utf8":
              return decoders.utf8;
            case "latin1":
            case "ascii":
            // TODO: Make these a separate, strict decoder?
            case "us-ascii":
            case "iso-8859-1":
            case "iso8859-1":
            case "iso88591":
            case "iso_8859-1":
            case "windows-1252":
            case "iso_8859-1:1987":
            case "cp1252":
            case "x-cp1252":
              return decoders.latin1;
            case "utf16le":
            case "utf-16le":
            case "ucs2":
            case "ucs-2":
              return decoders.utf16le;
            case "base64":
              return decoders.base64;
            default:
              if (lc === void 0) {
                lc = true;
                charset = charset.toLowerCase();
                continue;
              }
              return decoders.other.bind(charset);
          }
        }
      }
      var decoders = {
        utf8: (data, sourceEncoding) => {
          if (data.length === 0) {
            return "";
          }
          if (typeof data === "string") {
            data = Buffer.from(data, sourceEncoding);
          }
          return data.utf8Slice(0, data.length);
        },
        latin1: (data, sourceEncoding) => {
          if (data.length === 0) {
            return "";
          }
          if (typeof data === "string") {
            return data;
          }
          return data.latin1Slice(0, data.length);
        },
        utf16le: (data, sourceEncoding) => {
          if (data.length === 0) {
            return "";
          }
          if (typeof data === "string") {
            data = Buffer.from(data, sourceEncoding);
          }
          return data.ucs2Slice(0, data.length);
        },
        base64: (data, sourceEncoding) => {
          if (data.length === 0) {
            return "";
          }
          if (typeof data === "string") {
            data = Buffer.from(data, sourceEncoding);
          }
          return data.base64Slice(0, data.length);
        },
        other: (data, sourceEncoding) => {
          if (data.length === 0) {
            return "";
          }
          if (typeof data === "string") {
            data = Buffer.from(data, sourceEncoding);
          }
          if (textDecoders.has(exports.toString())) {
            try {
              return textDecoders.get(exports).decode(data);
            } catch {
            }
          }
          return typeof data === "string" ? data : data.toString();
        }
      };
      function decodeText(text, sourceEncoding, destEncoding) {
        if (text) {
          return getDecoder(destEncoding)(text, sourceEncoding);
        }
        return text;
      }
      module.exports = decodeText;
    }
  });

  // node_modules/@fastify/busboy/lib/utils/parseParams.js
  var require_parseParams = __commonJS({
    "node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports, module) {
      "use strict";
      var decodeText = require_decodeText();
      var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
      var EncodedLookup = {
        "%00": "\0",
        "%01": "",
        "%02": "",
        "%03": "",
        "%04": "",
        "%05": "",
        "%06": "",
        "%07": "\x07",
        "%08": "\b",
        "%09": "	",
        "%0a": "\n",
        "%0A": "\n",
        "%0b": "\v",
        "%0B": "\v",
        "%0c": "\f",
        "%0C": "\f",
        "%0d": "\r",
        "%0D": "\r",
        "%0e": "",
        "%0E": "",
        "%0f": "",
        "%0F": "",
        "%10": "",
        "%11": "",
        "%12": "",
        "%13": "",
        "%14": "",
        "%15": "",
        "%16": "",
        "%17": "",
        "%18": "",
        "%19": "",
        "%1a": "",
        "%1A": "",
        "%1b": "\x1B",
        "%1B": "\x1B",
        "%1c": "",
        "%1C": "",
        "%1d": "",
        "%1D": "",
        "%1e": "",
        "%1E": "",
        "%1f": "",
        "%1F": "",
        "%20": " ",
        "%21": "!",
        "%22": '"',
        "%23": "#",
        "%24": "$",
        "%25": "%",
        "%26": "&",
        "%27": "'",
        "%28": "(",
        "%29": ")",
        "%2a": "*",
        "%2A": "*",
        "%2b": "+",
        "%2B": "+",
        "%2c": ",",
        "%2C": ",",
        "%2d": "-",
        "%2D": "-",
        "%2e": ".",
        "%2E": ".",
        "%2f": "/",
        "%2F": "/",
        "%30": "0",
        "%31": "1",
        "%32": "2",
        "%33": "3",
        "%34": "4",
        "%35": "5",
        "%36": "6",
        "%37": "7",
        "%38": "8",
        "%39": "9",
        "%3a": ":",
        "%3A": ":",
        "%3b": ";",
        "%3B": ";",
        "%3c": "<",
        "%3C": "<",
        "%3d": "=",
        "%3D": "=",
        "%3e": ">",
        "%3E": ">",
        "%3f": "?",
        "%3F": "?",
        "%40": "@",
        "%41": "A",
        "%42": "B",
        "%43": "C",
        "%44": "D",
        "%45": "E",
        "%46": "F",
        "%47": "G",
        "%48": "H",
        "%49": "I",
        "%4a": "J",
        "%4A": "J",
        "%4b": "K",
        "%4B": "K",
        "%4c": "L",
        "%4C": "L",
        "%4d": "M",
        "%4D": "M",
        "%4e": "N",
        "%4E": "N",
        "%4f": "O",
        "%4F": "O",
        "%50": "P",
        "%51": "Q",
        "%52": "R",
        "%53": "S",
        "%54": "T",
        "%55": "U",
        "%56": "V",
        "%57": "W",
        "%58": "X",
        "%59": "Y",
        "%5a": "Z",
        "%5A": "Z",
        "%5b": "[",
        "%5B": "[",
        "%5c": "\\",
        "%5C": "\\",
        "%5d": "]",
        "%5D": "]",
        "%5e": "^",
        "%5E": "^",
        "%5f": "_",
        "%5F": "_",
        "%60": "`",
        "%61": "a",
        "%62": "b",
        "%63": "c",
        "%64": "d",
        "%65": "e",
        "%66": "f",
        "%67": "g",
        "%68": "h",
        "%69": "i",
        "%6a": "j",
        "%6A": "j",
        "%6b": "k",
        "%6B": "k",
        "%6c": "l",
        "%6C": "l",
        "%6d": "m",
        "%6D": "m",
        "%6e": "n",
        "%6E": "n",
        "%6f": "o",
        "%6F": "o",
        "%70": "p",
        "%71": "q",
        "%72": "r",
        "%73": "s",
        "%74": "t",
        "%75": "u",
        "%76": "v",
        "%77": "w",
        "%78": "x",
        "%79": "y",
        "%7a": "z",
        "%7A": "z",
        "%7b": "{",
        "%7B": "{",
        "%7c": "|",
        "%7C": "|",
        "%7d": "}",
        "%7D": "}",
        "%7e": "~",
        "%7E": "~",
        "%7f": "\x7F",
        "%7F": "\x7F",
        "%80": "\x80",
        "%81": "\x81",
        "%82": "\x82",
        "%83": "\x83",
        "%84": "\x84",
        "%85": "\x85",
        "%86": "\x86",
        "%87": "\x87",
        "%88": "\x88",
        "%89": "\x89",
        "%8a": "\x8A",
        "%8A": "\x8A",
        "%8b": "\x8B",
        "%8B": "\x8B",
        "%8c": "\x8C",
        "%8C": "\x8C",
        "%8d": "\x8D",
        "%8D": "\x8D",
        "%8e": "\x8E",
        "%8E": "\x8E",
        "%8f": "\x8F",
        "%8F": "\x8F",
        "%90": "\x90",
        "%91": "\x91",
        "%92": "\x92",
        "%93": "\x93",
        "%94": "\x94",
        "%95": "\x95",
        "%96": "\x96",
        "%97": "\x97",
        "%98": "\x98",
        "%99": "\x99",
        "%9a": "\x9A",
        "%9A": "\x9A",
        "%9b": "\x9B",
        "%9B": "\x9B",
        "%9c": "\x9C",
        "%9C": "\x9C",
        "%9d": "\x9D",
        "%9D": "\x9D",
        "%9e": "\x9E",
        "%9E": "\x9E",
        "%9f": "\x9F",
        "%9F": "\x9F",
        "%a0": "\xA0",
        "%A0": "\xA0",
        "%a1": "\xA1",
        "%A1": "\xA1",
        "%a2": "\xA2",
        "%A2": "\xA2",
        "%a3": "\xA3",
        "%A3": "\xA3",
        "%a4": "\xA4",
        "%A4": "\xA4",
        "%a5": "\xA5",
        "%A5": "\xA5",
        "%a6": "\xA6",
        "%A6": "\xA6",
        "%a7": "\xA7",
        "%A7": "\xA7",
        "%a8": "\xA8",
        "%A8": "\xA8",
        "%a9": "\xA9",
        "%A9": "\xA9",
        "%aa": "\xAA",
        "%Aa": "\xAA",
        "%aA": "\xAA",
        "%AA": "\xAA",
        "%ab": "\xAB",
        "%Ab": "\xAB",
        "%aB": "\xAB",
        "%AB": "\xAB",
        "%ac": "\xAC",
        "%Ac": "\xAC",
        "%aC": "\xAC",
        "%AC": "\xAC",
        "%ad": "\xAD",
        "%Ad": "\xAD",
        "%aD": "\xAD",
        "%AD": "\xAD",
        "%ae": "\xAE",
        "%Ae": "\xAE",
        "%aE": "\xAE",
        "%AE": "\xAE",
        "%af": "\xAF",
        "%Af": "\xAF",
        "%aF": "\xAF",
        "%AF": "\xAF",
        "%b0": "\xB0",
        "%B0": "\xB0",
        "%b1": "\xB1",
        "%B1": "\xB1",
        "%b2": "\xB2",
        "%B2": "\xB2",
        "%b3": "\xB3",
        "%B3": "\xB3",
        "%b4": "\xB4",
        "%B4": "\xB4",
        "%b5": "\xB5",
        "%B5": "\xB5",
        "%b6": "\xB6",
        "%B6": "\xB6",
        "%b7": "\xB7",
        "%B7": "\xB7",
        "%b8": "\xB8",
        "%B8": "\xB8",
        "%b9": "\xB9",
        "%B9": "\xB9",
        "%ba": "\xBA",
        "%Ba": "\xBA",
        "%bA": "\xBA",
        "%BA": "\xBA",
        "%bb": "\xBB",
        "%Bb": "\xBB",
        "%bB": "\xBB",
        "%BB": "\xBB",
        "%bc": "\xBC",
        "%Bc": "\xBC",
        "%bC": "\xBC",
        "%BC": "\xBC",
        "%bd": "\xBD",
        "%Bd": "\xBD",
        "%bD": "\xBD",
        "%BD": "\xBD",
        "%be": "\xBE",
        "%Be": "\xBE",
        "%bE": "\xBE",
        "%BE": "\xBE",
        "%bf": "\xBF",
        "%Bf": "\xBF",
        "%bF": "\xBF",
        "%BF": "\xBF",
        "%c0": "\xC0",
        "%C0": "\xC0",
        "%c1": "\xC1",
        "%C1": "\xC1",
        "%c2": "\xC2",
        "%C2": "\xC2",
        "%c3": "\xC3",
        "%C3": "\xC3",
        "%c4": "\xC4",
        "%C4": "\xC4",
        "%c5": "\xC5",
        "%C5": "\xC5",
        "%c6": "\xC6",
        "%C6": "\xC6",
        "%c7": "\xC7",
        "%C7": "\xC7",
        "%c8": "\xC8",
        "%C8": "\xC8",
        "%c9": "\xC9",
        "%C9": "\xC9",
        "%ca": "\xCA",
        "%Ca": "\xCA",
        "%cA": "\xCA",
        "%CA": "\xCA",
        "%cb": "\xCB",
        "%Cb": "\xCB",
        "%cB": "\xCB",
        "%CB": "\xCB",
        "%cc": "\xCC",
        "%Cc": "\xCC",
        "%cC": "\xCC",
        "%CC": "\xCC",
        "%cd": "\xCD",
        "%Cd": "\xCD",
        "%cD": "\xCD",
        "%CD": "\xCD",
        "%ce": "\xCE",
        "%Ce": "\xCE",
        "%cE": "\xCE",
        "%CE": "\xCE",
        "%cf": "\xCF",
        "%Cf": "\xCF",
        "%cF": "\xCF",
        "%CF": "\xCF",
        "%d0": "\xD0",
        "%D0": "\xD0",
        "%d1": "\xD1",
        "%D1": "\xD1",
        "%d2": "\xD2",
        "%D2": "\xD2",
        "%d3": "\xD3",
        "%D3": "\xD3",
        "%d4": "\xD4",
        "%D4": "\xD4",
        "%d5": "\xD5",
        "%D5": "\xD5",
        "%d6": "\xD6",
        "%D6": "\xD6",
        "%d7": "\xD7",
        "%D7": "\xD7",
        "%d8": "\xD8",
        "%D8": "\xD8",
        "%d9": "\xD9",
        "%D9": "\xD9",
        "%da": "\xDA",
        "%Da": "\xDA",
        "%dA": "\xDA",
        "%DA": "\xDA",
        "%db": "\xDB",
        "%Db": "\xDB",
        "%dB": "\xDB",
        "%DB": "\xDB",
        "%dc": "\xDC",
        "%Dc": "\xDC",
        "%dC": "\xDC",
        "%DC": "\xDC",
        "%dd": "\xDD",
        "%Dd": "\xDD",
        "%dD": "\xDD",
        "%DD": "\xDD",
        "%de": "\xDE",
        "%De": "\xDE",
        "%dE": "\xDE",
        "%DE": "\xDE",
        "%df": "\xDF",
        "%Df": "\xDF",
        "%dF": "\xDF",
        "%DF": "\xDF",
        "%e0": "\xE0",
        "%E0": "\xE0",
        "%e1": "\xE1",
        "%E1": "\xE1",
        "%e2": "\xE2",
        "%E2": "\xE2",
        "%e3": "\xE3",
        "%E3": "\xE3",
        "%e4": "\xE4",
        "%E4": "\xE4",
        "%e5": "\xE5",
        "%E5": "\xE5",
        "%e6": "\xE6",
        "%E6": "\xE6",
        "%e7": "\xE7",
        "%E7": "\xE7",
        "%e8": "\xE8",
        "%E8": "\xE8",
        "%e9": "\xE9",
        "%E9": "\xE9",
        "%ea": "\xEA",
        "%Ea": "\xEA",
        "%eA": "\xEA",
        "%EA": "\xEA",
        "%eb": "\xEB",
        "%Eb": "\xEB",
        "%eB": "\xEB",
        "%EB": "\xEB",
        "%ec": "\xEC",
        "%Ec": "\xEC",
        "%eC": "\xEC",
        "%EC": "\xEC",
        "%ed": "\xED",
        "%Ed": "\xED",
        "%eD": "\xED",
        "%ED": "\xED",
        "%ee": "\xEE",
        "%Ee": "\xEE",
        "%eE": "\xEE",
        "%EE": "\xEE",
        "%ef": "\xEF",
        "%Ef": "\xEF",
        "%eF": "\xEF",
        "%EF": "\xEF",
        "%f0": "\xF0",
        "%F0": "\xF0",
        "%f1": "\xF1",
        "%F1": "\xF1",
        "%f2": "\xF2",
        "%F2": "\xF2",
        "%f3": "\xF3",
        "%F3": "\xF3",
        "%f4": "\xF4",
        "%F4": "\xF4",
        "%f5": "\xF5",
        "%F5": "\xF5",
        "%f6": "\xF6",
        "%F6": "\xF6",
        "%f7": "\xF7",
        "%F7": "\xF7",
        "%f8": "\xF8",
        "%F8": "\xF8",
        "%f9": "\xF9",
        "%F9": "\xF9",
        "%fa": "\xFA",
        "%Fa": "\xFA",
        "%fA": "\xFA",
        "%FA": "\xFA",
        "%fb": "\xFB",
        "%Fb": "\xFB",
        "%fB": "\xFB",
        "%FB": "\xFB",
        "%fc": "\xFC",
        "%Fc": "\xFC",
        "%fC": "\xFC",
        "%FC": "\xFC",
        "%fd": "\xFD",
        "%Fd": "\xFD",
        "%fD": "\xFD",
        "%FD": "\xFD",
        "%fe": "\xFE",
        "%Fe": "\xFE",
        "%fE": "\xFE",
        "%FE": "\xFE",
        "%ff": "\xFF",
        "%Ff": "\xFF",
        "%fF": "\xFF",
        "%FF": "\xFF"
      };
      function encodedReplacer(match) {
        return EncodedLookup[match];
      }
      var STATE_KEY = 0;
      var STATE_VALUE = 1;
      var STATE_CHARSET = 2;
      var STATE_LANG = 3;
      function parseParams(str) {
        const res = [];
        let state = STATE_KEY;
        let charset = "";
        let inquote = false;
        let escaping = false;
        let p = 0;
        let tmp = "";
        const len = str.length;
        for (var i = 0; i < len; ++i) {
          const char = str[i];
          if (char === "\\" && inquote) {
            if (escaping) {
              escaping = false;
            } else {
              escaping = true;
              continue;
            }
          } else if (char === '"') {
            if (!escaping) {
              if (inquote) {
                inquote = false;
                state = STATE_KEY;
              } else {
                inquote = true;
              }
              continue;
            } else {
              escaping = false;
            }
          } else {
            if (escaping && inquote) {
              tmp += "\\";
            }
            escaping = false;
            if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
              if (state === STATE_CHARSET) {
                state = STATE_LANG;
                charset = tmp.substring(1);
              } else {
                state = STATE_VALUE;
              }
              tmp = "";
              continue;
            } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
              state = char === "*" ? STATE_CHARSET : STATE_VALUE;
              res[p] = [tmp, void 0];
              tmp = "";
              continue;
            } else if (!inquote && char === ";") {
              state = STATE_KEY;
              if (charset) {
                if (tmp.length) {
                  tmp = decodeText(
                    tmp.replace(RE_ENCODED, encodedReplacer),
                    "binary",
                    charset
                  );
                }
                charset = "";
              } else if (tmp.length) {
                tmp = decodeText(tmp, "binary", "utf8");
              }
              if (res[p] === void 0) {
                res[p] = tmp;
              } else {
                res[p][1] = tmp;
              }
              tmp = "";
              ++p;
              continue;
            } else if (!inquote && (char === " " || char === "	")) {
              continue;
            }
          }
          tmp += char;
        }
        if (charset && tmp.length) {
          tmp = decodeText(
            tmp.replace(RE_ENCODED, encodedReplacer),
            "binary",
            charset
          );
        } else if (tmp) {
          tmp = decodeText(tmp, "binary", "utf8");
        }
        if (res[p] === void 0) {
          if (tmp) {
            res[p] = tmp;
          }
        } else {
          res[p][1] = tmp;
        }
        return res;
      }
      module.exports = parseParams;
    }
  });

  // node_modules/@fastify/busboy/lib/utils/basename.js
  var require_basename = __commonJS({
    "node_modules/@fastify/busboy/lib/utils/basename.js"(exports, module) {
      "use strict";
      module.exports = function basename(path) {
        if (typeof path !== "string") {
          return "";
        }
        for (var i = path.length - 1; i >= 0; --i) {
          switch (path.charCodeAt(i)) {
            case 47:
            // '/'
            case 92:
              path = path.slice(i + 1);
              return path === ".." || path === "." ? "" : path;
          }
        }
        return path === ".." || path === "." ? "" : path;
      };
    }
  });

  // node_modules/@fastify/busboy/lib/types/multipart.js
  var require_multipart = __commonJS({
    "node_modules/@fastify/busboy/lib/types/multipart.js"(exports, module) {
      "use strict";
      var { Readable } = __require("node:stream");
      var { inherits } = __require("node:util");
      var Dicer = require_Dicer();
      var parseParams = require_parseParams();
      var decodeText = require_decodeText();
      var basename = require_basename();
      var getLimit = require_getLimit();
      var RE_BOUNDARY = /^boundary$/i;
      var RE_FIELD = /^form-data$/i;
      var RE_CHARSET = /^charset$/i;
      var RE_FILENAME = /^filename$/i;
      var RE_NAME = /^name$/i;
      Multipart.detect = /^multipart\/form-data/i;
      function Multipart(boy, cfg) {
        let i;
        let len;
        const self2 = this;
        let boundary;
        const limits = cfg.limits;
        const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
        const parsedConType = cfg.parsedConType || [];
        const defCharset = cfg.defCharset || "utf8";
        const preservePath = cfg.preservePath;
        const fileOpts = { highWaterMark: cfg.fileHwm };
        for (i = 0, len = parsedConType.length; i < len; ++i) {
          if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
            boundary = parsedConType[i][1];
            break;
          }
        }
        function checkFinished() {
          if (nends === 0 && finished && !boy._done) {
            finished = false;
            self2.end();
          }
        }
        if (typeof boundary !== "string") {
          throw new Error("Multipart: Boundary not found");
        }
        const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
        const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
        const filesLimit = getLimit(limits, "files", Infinity);
        const fieldsLimit = getLimit(limits, "fields", Infinity);
        const partsLimit = getLimit(limits, "parts", Infinity);
        const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
        const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
        let nfiles = 0;
        let nfields = 0;
        let nends = 0;
        let curFile;
        let curField;
        let finished = false;
        this._needDrain = false;
        this._pause = false;
        this._cb = void 0;
        this._nparts = 0;
        this._boy = boy;
        const parserCfg = {
          boundary,
          maxHeaderPairs: headerPairsLimit,
          maxHeaderSize: headerSizeLimit,
          partHwm: fileOpts.highWaterMark,
          highWaterMark: cfg.highWaterMark
        };
        this.parser = new Dicer(parserCfg);
        this.parser.on("drain", function() {
          self2._needDrain = false;
          if (self2._cb && !self2._pause) {
            const cb = self2._cb;
            self2._cb = void 0;
            cb();
          }
        }).on("part", function onPart(part) {
          if (++self2._nparts > partsLimit) {
            self2.parser.removeListener("part", onPart);
            self2.parser.on("part", skipPart);
            boy.hitPartsLimit = true;
            boy.emit("partsLimit");
            return skipPart(part);
          }
          if (curField) {
            const field = curField;
            field.emit("end");
            field.removeAllListeners("end");
          }
          part.on("header", function(header) {
            let contype;
            let fieldname;
            let parsed;
            let charset;
            let encoding;
            let filename;
            let nsize = 0;
            if (header["content-type"]) {
              parsed = parseParams(header["content-type"][0]);
              if (parsed[0]) {
                contype = parsed[0].toLowerCase();
                for (i = 0, len = parsed.length; i < len; ++i) {
                  if (RE_CHARSET.test(parsed[i][0])) {
                    charset = parsed[i][1].toLowerCase();
                    break;
                  }
                }
              }
            }
            if (contype === void 0) {
              contype = "text/plain";
            }
            if (charset === void 0) {
              charset = defCharset;
            }
            if (header["content-disposition"]) {
              parsed = parseParams(header["content-disposition"][0]);
              if (!RE_FIELD.test(parsed[0])) {
                return skipPart(part);
              }
              for (i = 0, len = parsed.length; i < len; ++i) {
                if (RE_NAME.test(parsed[i][0])) {
                  fieldname = parsed[i][1];
                } else if (RE_FILENAME.test(parsed[i][0])) {
                  filename = parsed[i][1];
                  if (!preservePath) {
                    filename = basename(filename);
                  }
                }
              }
            } else {
              return skipPart(part);
            }
            if (header["content-transfer-encoding"]) {
              encoding = header["content-transfer-encoding"][0].toLowerCase();
            } else {
              encoding = "7bit";
            }
            let onData, onEnd;
            if (isPartAFile(fieldname, contype, filename)) {
              if (nfiles === filesLimit) {
                if (!boy.hitFilesLimit) {
                  boy.hitFilesLimit = true;
                  boy.emit("filesLimit");
                }
                return skipPart(part);
              }
              ++nfiles;
              if (boy.listenerCount("file") === 0) {
                self2.parser._ignore();
                return;
              }
              ++nends;
              const file = new FileStream(fileOpts);
              curFile = file;
              file.on("end", function() {
                --nends;
                self2._pause = false;
                checkFinished();
                if (self2._cb && !self2._needDrain) {
                  const cb = self2._cb;
                  self2._cb = void 0;
                  cb();
                }
              });
              file._read = function(n) {
                if (!self2._pause) {
                  return;
                }
                self2._pause = false;
                if (self2._cb && !self2._needDrain) {
                  const cb = self2._cb;
                  self2._cb = void 0;
                  cb();
                }
              };
              boy.emit("file", fieldname, file, filename, encoding, contype);
              onData = function(data) {
                if ((nsize += data.length) > fileSizeLimit) {
                  const extralen = fileSizeLimit - nsize + data.length;
                  if (extralen > 0) {
                    file.push(data.slice(0, extralen));
                  }
                  file.truncated = true;
                  file.bytesRead = fileSizeLimit;
                  part.removeAllListeners("data");
                  file.emit("limit");
                  return;
                } else if (!file.push(data)) {
                  self2._pause = true;
                }
                file.bytesRead = nsize;
              };
              onEnd = function() {
                curFile = void 0;
                file.push(null);
              };
            } else {
              if (nfields === fieldsLimit) {
                if (!boy.hitFieldsLimit) {
                  boy.hitFieldsLimit = true;
                  boy.emit("fieldsLimit");
                }
                return skipPart(part);
              }
              ++nfields;
              ++nends;
              let buffer = "";
              let truncated = false;
              curField = part;
              onData = function(data) {
                if ((nsize += data.length) > fieldSizeLimit) {
                  const extralen = fieldSizeLimit - (nsize - data.length);
                  buffer += data.toString("binary", 0, extralen);
                  truncated = true;
                  part.removeAllListeners("data");
                } else {
                  buffer += data.toString("binary");
                }
              };
              onEnd = function() {
                curField = void 0;
                if (buffer.length) {
                  buffer = decodeText(buffer, "binary", charset);
                }
                boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
                --nends;
                checkFinished();
              };
            }
            part._readableState.sync = false;
            part.on("data", onData);
            part.on("end", onEnd);
          }).on("error", function(err) {
            if (curFile) {
              curFile.emit("error", err);
            }
          });
        }).on("error", function(err) {
          boy.emit("error", err);
        }).on("finish", function() {
          finished = true;
          checkFinished();
        });
      }
      Multipart.prototype.write = function(chunk, cb) {
        const r = this.parser.write(chunk);
        if (r && !this._pause) {
          cb();
        } else {
          this._needDrain = !r;
          this._cb = cb;
        }
      };
      Multipart.prototype.end = function() {
        const self2 = this;
        if (self2.parser.writable) {
          self2.parser.end();
        } else if (!self2._boy._done) {
          process.nextTick(function() {
            self2._boy._done = true;
            self2._boy.emit("finish");
          });
        }
      };
      function skipPart(part) {
        part.resume();
      }
      function FileStream(opts) {
        Readable.call(this, opts);
        this.bytesRead = 0;
        this.truncated = false;
      }
      inherits(FileStream, Readable);
      FileStream.prototype._read = function(n) {
      };
      module.exports = Multipart;
    }
  });

  // node_modules/@fastify/busboy/lib/utils/Decoder.js
  var require_Decoder = __commonJS({
    "node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports, module) {
      "use strict";
      var RE_PLUS = /\+/g;
      var HEX = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      function Decoder() {
        this.buffer = void 0;
      }
      Decoder.prototype.write = function(str) {
        str = str.replace(RE_PLUS, " ");
        let res = "";
        let i = 0;
        let p = 0;
        const len = str.length;
        for (; i < len; ++i) {
          if (this.buffer !== void 0) {
            if (!HEX[str.charCodeAt(i)]) {
              res += "%" + this.buffer;
              this.buffer = void 0;
              --i;
            } else {
              this.buffer += str[i];
              ++p;
              if (this.buffer.length === 2) {
                res += String.fromCharCode(parseInt(this.buffer, 16));
                this.buffer = void 0;
              }
            }
          } else if (str[i] === "%") {
            if (i > p) {
              res += str.substring(p, i);
              p = i;
            }
            this.buffer = "";
            ++p;
          }
        }
        if (p < len && this.buffer === void 0) {
          res += str.substring(p);
        }
        return res;
      };
      Decoder.prototype.reset = function() {
        this.buffer = void 0;
      };
      module.exports = Decoder;
    }
  });

  // node_modules/@fastify/busboy/lib/types/urlencoded.js
  var require_urlencoded = __commonJS({
    "node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports, module) {
      "use strict";
      var Decoder = require_Decoder();
      var decodeText = require_decodeText();
      var getLimit = require_getLimit();
      var RE_CHARSET = /^charset$/i;
      UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
      function UrlEncoded(boy, cfg) {
        const limits = cfg.limits;
        const parsedConType = cfg.parsedConType;
        this.boy = boy;
        this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
        this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
        this.fieldsLimit = getLimit(limits, "fields", Infinity);
        let charset;
        for (var i = 0, len = parsedConType.length; i < len; ++i) {
          if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
            charset = parsedConType[i][1].toLowerCase();
            break;
          }
        }
        if (charset === void 0) {
          charset = cfg.defCharset || "utf8";
        }
        this.decoder = new Decoder();
        this.charset = charset;
        this._fields = 0;
        this._state = "key";
        this._checkingBytes = true;
        this._bytesKey = 0;
        this._bytesVal = 0;
        this._key = "";
        this._val = "";
        this._keyTrunc = false;
        this._valTrunc = false;
        this._hitLimit = false;
      }
      UrlEncoded.prototype.write = function(data, cb) {
        if (this._fields === this.fieldsLimit) {
          if (!this.boy.hitFieldsLimit) {
            this.boy.hitFieldsLimit = true;
            this.boy.emit("fieldsLimit");
          }
          return cb();
        }
        let idxeq;
        let idxamp;
        let i;
        let p = 0;
        const len = data.length;
        while (p < len) {
          if (this._state === "key") {
            idxeq = idxamp = void 0;
            for (i = p; i < len; ++i) {
              if (!this._checkingBytes) {
                ++p;
              }
              if (data[i] === 61) {
                idxeq = i;
                break;
              } else if (data[i] === 38) {
                idxamp = i;
                break;
              }
              if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
                this._hitLimit = true;
                break;
              } else if (this._checkingBytes) {
                ++this._bytesKey;
              }
            }
            if (idxeq !== void 0) {
              if (idxeq > p) {
                this._key += this.decoder.write(data.toString("binary", p, idxeq));
              }
              this._state = "val";
              this._hitLimit = false;
              this._checkingBytes = true;
              this._val = "";
              this._bytesVal = 0;
              this._valTrunc = false;
              this.decoder.reset();
              p = idxeq + 1;
            } else if (idxamp !== void 0) {
              ++this._fields;
              let key;
              const keyTrunc = this._keyTrunc;
              if (idxamp > p) {
                key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
              } else {
                key = this._key;
              }
              this._hitLimit = false;
              this._checkingBytes = true;
              this._key = "";
              this._bytesKey = 0;
              this._keyTrunc = false;
              this.decoder.reset();
              if (key.length) {
                this.boy.emit(
                  "field",
                  decodeText(key, "binary", this.charset),
                  "",
                  keyTrunc,
                  false
                );
              }
              p = idxamp + 1;
              if (this._fields === this.fieldsLimit) {
                return cb();
              }
            } else if (this._hitLimit) {
              if (i > p) {
                this._key += this.decoder.write(data.toString("binary", p, i));
              }
              p = i;
              if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
                this._checkingBytes = false;
                this._keyTrunc = true;
              }
            } else {
              if (p < len) {
                this._key += this.decoder.write(data.toString("binary", p));
              }
              p = len;
            }
          } else {
            idxamp = void 0;
            for (i = p; i < len; ++i) {
              if (!this._checkingBytes) {
                ++p;
              }
              if (data[i] === 38) {
                idxamp = i;
                break;
              }
              if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
                this._hitLimit = true;
                break;
              } else if (this._checkingBytes) {
                ++this._bytesVal;
              }
            }
            if (idxamp !== void 0) {
              ++this._fields;
              if (idxamp > p) {
                this._val += this.decoder.write(data.toString("binary", p, idxamp));
              }
              this.boy.emit(
                "field",
                decodeText(this._key, "binary", this.charset),
                decodeText(this._val, "binary", this.charset),
                this._keyTrunc,
                this._valTrunc
              );
              this._state = "key";
              this._hitLimit = false;
              this._checkingBytes = true;
              this._key = "";
              this._bytesKey = 0;
              this._keyTrunc = false;
              this.decoder.reset();
              p = idxamp + 1;
              if (this._fields === this.fieldsLimit) {
                return cb();
              }
            } else if (this._hitLimit) {
              if (i > p) {
                this._val += this.decoder.write(data.toString("binary", p, i));
              }
              p = i;
              if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
                this._checkingBytes = false;
                this._valTrunc = true;
              }
            } else {
              if (p < len) {
                this._val += this.decoder.write(data.toString("binary", p));
              }
              p = len;
            }
          }
        }
        cb();
      };
      UrlEncoded.prototype.end = function() {
        if (this.boy._done) {
          return;
        }
        if (this._state === "key" && this._key.length > 0) {
          this.boy.emit(
            "field",
            decodeText(this._key, "binary", this.charset),
            "",
            this._keyTrunc,
            false
          );
        } else if (this._state === "val") {
          this.boy.emit(
            "field",
            decodeText(this._key, "binary", this.charset),
            decodeText(this._val, "binary", this.charset),
            this._keyTrunc,
            this._valTrunc
          );
        }
        this.boy._done = true;
        this.boy.emit("finish");
      };
      module.exports = UrlEncoded;
    }
  });

  // node_modules/@fastify/busboy/lib/main.js
  var require_main = __commonJS({
    "node_modules/@fastify/busboy/lib/main.js"(exports, module) {
      "use strict";
      var WritableStream = __require("node:stream").Writable;
      var { inherits } = __require("node:util");
      var Dicer = require_Dicer();
      var MultipartParser = require_multipart();
      var UrlencodedParser = require_urlencoded();
      var parseParams = require_parseParams();
      function Busboy(opts) {
        if (!(this instanceof Busboy)) {
          return new Busboy(opts);
        }
        if (typeof opts !== "object") {
          throw new TypeError("Busboy expected an options-Object.");
        }
        if (typeof opts.headers !== "object") {
          throw new TypeError("Busboy expected an options-Object with headers-attribute.");
        }
        if (typeof opts.headers["content-type"] !== "string") {
          throw new TypeError("Missing Content-Type-header.");
        }
        const {
          headers,
          ...streamOptions
        } = opts;
        this.opts = {
          autoDestroy: false,
          ...streamOptions
        };
        WritableStream.call(this, this.opts);
        this._done = false;
        this._parser = this.getParserByHeaders(headers);
        this._finished = false;
      }
      inherits(Busboy, WritableStream);
      Busboy.prototype.emit = function(ev) {
        if (ev === "finish") {
          if (!this._done) {
            this._parser?.end();
            return;
          } else if (this._finished) {
            return;
          }
          this._finished = true;
        }
        WritableStream.prototype.emit.apply(this, arguments);
      };
      Busboy.prototype.getParserByHeaders = function(headers) {
        const parsed = parseParams(headers["content-type"]);
        const cfg = {
          defCharset: this.opts.defCharset,
          fileHwm: this.opts.fileHwm,
          headers,
          highWaterMark: this.opts.highWaterMark,
          isPartAFile: this.opts.isPartAFile,
          limits: this.opts.limits,
          parsedConType: parsed,
          preservePath: this.opts.preservePath
        };
        if (MultipartParser.detect.test(parsed[0])) {
          return new MultipartParser(this, cfg);
        }
        if (UrlencodedParser.detect.test(parsed[0])) {
          return new UrlencodedParser(this, cfg);
        }
        throw new Error("Unsupported Content-Type.");
      };
      Busboy.prototype._write = function(chunk, encoding, cb) {
        this._parser.write(chunk, cb);
      };
      module.exports = Busboy;
      module.exports.default = Busboy;
      module.exports.Busboy = Busboy;
      module.exports.Dicer = Dicer;
    }
  });

  // node_modules/undici/lib/fetch/constants.js
  var require_constants2 = __commonJS({
    "node_modules/undici/lib/fetch/constants.js"(exports, module) {
      "use strict";
      var { MessageChannel: MessageChannel2, receiveMessageOnPort } = __require("worker_threads");
      var corsSafeListedMethods = ["GET", "HEAD", "POST"];
      var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
      var nullBodyStatus = [101, 204, 205, 304];
      var redirectStatus = [301, 302, 303, 307, 308];
      var redirectStatusSet = new Set(redirectStatus);
      var badPorts = [
        "1",
        "7",
        "9",
        "11",
        "13",
        "15",
        "17",
        "19",
        "20",
        "21",
        "22",
        "23",
        "25",
        "37",
        "42",
        "43",
        "53",
        "69",
        "77",
        "79",
        "87",
        "95",
        "101",
        "102",
        "103",
        "104",
        "109",
        "110",
        "111",
        "113",
        "115",
        "117",
        "119",
        "123",
        "135",
        "137",
        "139",
        "143",
        "161",
        "179",
        "389",
        "427",
        "465",
        "512",
        "513",
        "514",
        "515",
        "526",
        "530",
        "531",
        "532",
        "540",
        "548",
        "554",
        "556",
        "563",
        "587",
        "601",
        "636",
        "989",
        "990",
        "993",
        "995",
        "1719",
        "1720",
        "1723",
        "2049",
        "3659",
        "4045",
        "5060",
        "5061",
        "6000",
        "6566",
        "6665",
        "6666",
        "6667",
        "6668",
        "6669",
        "6697",
        "10080"
      ];
      var badPortsSet = new Set(badPorts);
      var referrerPolicy = [
        "",
        "no-referrer",
        "no-referrer-when-downgrade",
        "same-origin",
        "origin",
        "strict-origin",
        "origin-when-cross-origin",
        "strict-origin-when-cross-origin",
        "unsafe-url"
      ];
      var referrerPolicySet = new Set(referrerPolicy);
      var requestRedirect = ["follow", "manual", "error"];
      var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
      var safeMethodsSet = new Set(safeMethods);
      var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
      var requestCredentials = ["omit", "same-origin", "include"];
      var requestCache = [
        "default",
        "no-store",
        "reload",
        "no-cache",
        "force-cache",
        "only-if-cached"
      ];
      var requestBodyHeader = [
        "content-encoding",
        "content-language",
        "content-location",
        "content-type",
        // See https://github.com/nodejs/undici/issues/2021
        // 'Content-Length' is a forbidden header name, which is typically
        // removed in the Headers implementation. However, undici doesn't
        // filter out headers, so we add it here.
        "content-length"
      ];
      var requestDuplex = [
        "half"
      ];
      var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
      var forbiddenMethodsSet = new Set(forbiddenMethods);
      var subresource = [
        "audio",
        "audioworklet",
        "font",
        "image",
        "manifest",
        "paintworklet",
        "script",
        "style",
        "track",
        "video",
        "xslt",
        ""
      ];
      var subresourceSet = new Set(subresource);
      var DOMException2 = globalThis.DOMException ?? (() => {
        try {
          atob("~");
        } catch (err) {
          return Object.getPrototypeOf(err).constructor;
        }
      })();
      var channel;
      var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
      // structuredClone was added in v17.0.0, but fetch supports v16.8
      function structuredClone2(value, options = void 0) {
        if (arguments.length === 0) {
          throw new TypeError("missing argument");
        }
        if (!channel) {
          channel = new MessageChannel2();
        }
        channel.port1.unref();
        channel.port2.unref();
        channel.port1.postMessage(value, options?.transfer);
        return receiveMessageOnPort(channel.port2).message;
      };
      module.exports = {
        DOMException: DOMException2,
        structuredClone,
        subresource,
        forbiddenMethods,
        requestBodyHeader,
        referrerPolicy,
        requestRedirect,
        requestMode,
        requestCredentials,
        requestCache,
        redirectStatus,
        corsSafeListedMethods,
        nullBodyStatus,
        safeMethods,
        badPorts,
        requestDuplex,
        subresourceSet,
        badPortsSet,
        redirectStatusSet,
        corsSafeListedMethodsSet,
        safeMethodsSet,
        forbiddenMethodsSet,
        referrerPolicySet
      };
    }
  });

  // node_modules/undici/lib/fetch/global.js
  var require_global = __commonJS({
    "node_modules/undici/lib/fetch/global.js"(exports, module) {
      "use strict";
      var globalOrigin = Symbol.for("undici.globalOrigin.1");
      function getGlobalOrigin() {
        return globalThis[globalOrigin];
      }
      function setGlobalOrigin(newOrigin) {
        if (newOrigin === void 0) {
          Object.defineProperty(globalThis, globalOrigin, {
            value: void 0,
            writable: true,
            enumerable: false,
            configurable: false
          });
          return;
        }
        const parsedURL = new URL(newOrigin);
        if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
          throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
        }
        Object.defineProperty(globalThis, globalOrigin, {
          value: parsedURL,
          writable: true,
          enumerable: false,
          configurable: false
        });
      }
      module.exports = {
        getGlobalOrigin,
        setGlobalOrigin
      };
    }
  });

  // node_modules/undici/lib/fetch/util.js
  var require_util2 = __commonJS({
    "node_modules/undici/lib/fetch/util.js"(exports, module) {
      "use strict";
      var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants2();
      var { getGlobalOrigin } = require_global();
      var { performance: performance2 } = __require("perf_hooks");
      var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
      var assert = __require("assert");
      var { isUint8Array } = __require("util/types");
      var supportedHashes = [];
      var crypto;
      try {
        crypto = __require("crypto");
        const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
        supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
      } catch {
      }
      function responseURL(response) {
        const urlList = response.urlList;
        const length = urlList.length;
        return length === 0 ? null : urlList[length - 1].toString();
      }
      function responseLocationURL(response, requestFragment) {
        if (!redirectStatusSet.has(response.status)) {
          return null;
        }
        let location = response.headersList.get("location");
        if (location !== null && isValidHeaderValue(location)) {
          location = new URL(location, responseURL(response));
        }
        if (location && !location.hash) {
          location.hash = requestFragment;
        }
        return location;
      }
      function requestCurrentURL(request2) {
        return request2.urlList[request2.urlList.length - 1];
      }
      function requestBadPort(request2) {
        const url = requestCurrentURL(request2);
        if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
          return "blocked";
        }
        return "allowed";
      }
      function isErrorLike(object) {
        return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
      }
      function isValidReasonPhrase(statusText) {
        for (let i = 0; i < statusText.length; ++i) {
          const c = statusText.charCodeAt(i);
          if (!(c === 9 || // HTAB
          c >= 32 && c <= 126 || // SP / VCHAR
          c >= 128 && c <= 255)) {
            return false;
          }
        }
        return true;
      }
      function isTokenCharCode(c) {
        switch (c) {
          case 34:
          case 40:
          case 41:
          case 44:
          case 47:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 91:
          case 92:
          case 93:
          case 123:
          case 125:
            return false;
          default:
            return c >= 33 && c <= 126;
        }
      }
      function isValidHTTPToken(characters) {
        if (characters.length === 0) {
          return false;
        }
        for (let i = 0; i < characters.length; ++i) {
          if (!isTokenCharCode(characters.charCodeAt(i))) {
            return false;
          }
        }
        return true;
      }
      function isValidHeaderName(potentialValue) {
        return isValidHTTPToken(potentialValue);
      }
      function isValidHeaderValue(potentialValue) {
        if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
          return false;
        }
        if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
          return false;
        }
        return true;
      }
      function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {
        const { headersList } = actualResponse;
        const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
        let policy = "";
        if (policyHeader.length > 0) {
          for (let i = policyHeader.length; i !== 0; i--) {
            const token2 = policyHeader[i - 1].trim();
            if (referrerPolicyTokens.has(token2)) {
              policy = token2;
              break;
            }
          }
        }
        if (policy !== "") {
          request2.referrerPolicy = policy;
        }
      }
      function crossOriginResourcePolicyCheck() {
        return "allowed";
      }
      function corsCheck() {
        return "success";
      }
      function TAOCheck() {
        return "success";
      }
      function appendFetchMetadata(httpRequest) {
        let header = null;
        header = httpRequest.mode;
        httpRequest.headersList.set("sec-fetch-mode", header);
      }
      function appendRequestOriginHeader(request2) {
        let serializedOrigin = request2.origin;
        if (request2.responseTainting === "cors" || request2.mode === "websocket") {
          if (serializedOrigin) {
            request2.headersList.append("origin", serializedOrigin);
          }
        } else if (request2.method !== "GET" && request2.method !== "HEAD") {
          switch (request2.referrerPolicy) {
            case "no-referrer":
              serializedOrigin = null;
              break;
            case "no-referrer-when-downgrade":
            case "strict-origin":
            case "strict-origin-when-cross-origin":
              if (request2.origin && urlHasHttpsScheme(request2.origin) && !urlHasHttpsScheme(requestCurrentURL(request2))) {
                serializedOrigin = null;
              }
              break;
            case "same-origin":
              if (!sameOrigin(request2, requestCurrentURL(request2))) {
                serializedOrigin = null;
              }
              break;
            default:
          }
          if (serializedOrigin) {
            request2.headersList.append("origin", serializedOrigin);
          }
        }
      }
      function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
        return performance2.now();
      }
      function createOpaqueTimingInfo(timingInfo) {
        return {
          startTime: timingInfo.startTime ?? 0,
          redirectStartTime: 0,
          redirectEndTime: 0,
          postRedirectStartTime: timingInfo.startTime ?? 0,
          finalServiceWorkerStartTime: 0,
          finalNetworkResponseStartTime: 0,
          finalNetworkRequestStartTime: 0,
          endTime: 0,
          encodedBodySize: 0,
          decodedBodySize: 0,
          finalConnectionTimingInfo: null
        };
      }
      function makePolicyContainer() {
        return {
          referrerPolicy: "strict-origin-when-cross-origin"
        };
      }
      function clonePolicyContainer(policyContainer) {
        return {
          referrerPolicy: policyContainer.referrerPolicy
        };
      }
      function determineRequestsReferrer(request2) {
        const policy = request2.referrerPolicy;
        assert(policy);
        let referrerSource = null;
        if (request2.referrer === "client") {
          const globalOrigin = getGlobalOrigin();
          if (!globalOrigin || globalOrigin.origin === "null") {
            return "no-referrer";
          }
          referrerSource = new URL(globalOrigin);
        } else if (request2.referrer instanceof URL) {
          referrerSource = request2.referrer;
        }
        let referrerURL = stripURLForReferrer(referrerSource);
        const referrerOrigin = stripURLForReferrer(referrerSource, true);
        if (referrerURL.toString().length > 4096) {
          referrerURL = referrerOrigin;
        }
        const areSameOrigin = sameOrigin(request2, referrerURL);
        const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request2.url);
        switch (policy) {
          case "origin":
            return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
          case "unsafe-url":
            return referrerURL;
          case "same-origin":
            return areSameOrigin ? referrerOrigin : "no-referrer";
          case "origin-when-cross-origin":
            return areSameOrigin ? referrerURL : referrerOrigin;
          case "strict-origin-when-cross-origin": {
            const currentURL = requestCurrentURL(request2);
            if (sameOrigin(referrerURL, currentURL)) {
              return referrerURL;
            }
            if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
              return "no-referrer";
            }
            return referrerOrigin;
          }
          case "strict-origin":
          // eslint-disable-line
          /**
             * 1. If referrerURL is a potentially trustworthy URL and
             * requests current URL is not a potentially trustworthy URL,
             * then return no referrer.
             * 2. Return referrerOrigin
            */
          case "no-referrer-when-downgrade":
          // eslint-disable-line
          /**
           * 1. If referrerURL is a potentially trustworthy URL and
           * requests current URL is not a potentially trustworthy URL,
           * then return no referrer.
           * 2. Return referrerOrigin
          */
          default:
            return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
        }
      }
      function stripURLForReferrer(url, originOnly) {
        assert(url instanceof URL);
        if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
          return "no-referrer";
        }
        url.username = "";
        url.password = "";
        url.hash = "";
        if (originOnly) {
          url.pathname = "";
          url.search = "";
        }
        return url;
      }
      function isURLPotentiallyTrustworthy(url) {
        if (!(url instanceof URL)) {
          return false;
        }
        if (url.href === "about:blank" || url.href === "about:srcdoc") {
          return true;
        }
        if (url.protocol === "data:") return true;
        if (url.protocol === "file:") return true;
        return isOriginPotentiallyTrustworthy(url.origin);
        function isOriginPotentiallyTrustworthy(origin) {
          if (origin == null || origin === "null") return false;
          const originAsURL = new URL(origin);
          if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
            return true;
          }
          if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
            return true;
          }
          return false;
        }
      }
      function bytesMatch(bytes, metadataList) {
        if (crypto === void 0) {
          return true;
        }
        const parsedMetadata = parseMetadata(metadataList);
        if (parsedMetadata === "no metadata") {
          return true;
        }
        if (parsedMetadata.length === 0) {
          return true;
        }
        const strongest = getStrongestMetadata(parsedMetadata);
        const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
        for (const item of metadata) {
          const algorithm = item.algo;
          const expectedValue = item.hash;
          let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
          if (actualValue[actualValue.length - 1] === "=") {
            if (actualValue[actualValue.length - 2] === "=") {
              actualValue = actualValue.slice(0, -2);
            } else {
              actualValue = actualValue.slice(0, -1);
            }
          }
          if (compareBase64Mixed(actualValue, expectedValue)) {
            return true;
          }
        }
        return false;
      }
      var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
      function parseMetadata(metadata) {
        const result = [];
        let empty = true;
        for (const token2 of metadata.split(" ")) {
          empty = false;
          const parsedToken = parseHashWithOptions.exec(token2);
          if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
            continue;
          }
          const algorithm = parsedToken.groups.algo.toLowerCase();
          if (supportedHashes.includes(algorithm)) {
            result.push(parsedToken.groups);
          }
        }
        if (empty === true) {
          return "no metadata";
        }
        return result;
      }
      function getStrongestMetadata(metadataList) {
        let algorithm = metadataList[0].algo;
        if (algorithm[3] === "5") {
          return algorithm;
        }
        for (let i = 1; i < metadataList.length; ++i) {
          const metadata = metadataList[i];
          if (metadata.algo[3] === "5") {
            algorithm = "sha512";
            break;
          } else if (algorithm[3] === "3") {
            continue;
          } else if (metadata.algo[3] === "3") {
            algorithm = "sha384";
          }
        }
        return algorithm;
      }
      function filterMetadataListByAlgorithm(metadataList, algorithm) {
        if (metadataList.length === 1) {
          return metadataList;
        }
        let pos = 0;
        for (let i = 0; i < metadataList.length; ++i) {
          if (metadataList[i].algo === algorithm) {
            metadataList[pos++] = metadataList[i];
          }
        }
        metadataList.length = pos;
        return metadataList;
      }
      function compareBase64Mixed(actualValue, expectedValue) {
        if (actualValue.length !== expectedValue.length) {
          return false;
        }
        for (let i = 0; i < actualValue.length; ++i) {
          if (actualValue[i] !== expectedValue[i]) {
            if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
              continue;
            }
            return false;
          }
        }
        return true;
      }
      function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {
      }
      function sameOrigin(A, B) {
        if (A.origin === B.origin && A.origin === "null") {
          return true;
        }
        if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
          return true;
        }
        return false;
      }
      function createDeferredPromise() {
        let res;
        let rej;
        const promise = new Promise((resolve, reject) => {
          res = resolve;
          rej = reject;
        });
        return { promise, resolve: res, reject: rej };
      }
      function isAborted(fetchParams) {
        return fetchParams.controller.state === "aborted";
      }
      function isCancelled(fetchParams) {
        return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
      }
      var normalizeMethodRecord = {
        delete: "DELETE",
        DELETE: "DELETE",
        get: "GET",
        GET: "GET",
        head: "HEAD",
        HEAD: "HEAD",
        options: "OPTIONS",
        OPTIONS: "OPTIONS",
        post: "POST",
        POST: "POST",
        put: "PUT",
        PUT: "PUT"
      };
      Object.setPrototypeOf(normalizeMethodRecord, null);
      function normalizeMethod(method) {
        return normalizeMethodRecord[method.toLowerCase()] ?? method;
      }
      function serializeJavascriptValueToJSONString(value) {
        const result = JSON.stringify(value);
        if (result === void 0) {
          throw new TypeError("Value is not JSON serializable");
        }
        assert(typeof result === "string");
        return result;
      }
      var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
      function makeIterator(iterator, name, kind) {
        const object = {
          index: 0,
          kind,
          target: iterator
        };
        const i = {
          next() {
            if (Object.getPrototypeOf(this) !== i) {
              throw new TypeError(
                `'next' called on an object that does not implement interface ${name} Iterator.`
              );
            }
            const { index, kind: kind2, target } = object;
            const values = target();
            const len = values.length;
            if (index >= len) {
              return { value: void 0, done: true };
            }
            const pair = values[index];
            object.index = index + 1;
            return iteratorResult(pair, kind2);
          },
          // The class string of an iterator prototype object for a given interface is the
          // result of concatenating the identifier of the interface and the string " Iterator".
          [Symbol.toStringTag]: `${name} Iterator`
        };
        Object.setPrototypeOf(i, esIteratorPrototype);
        return Object.setPrototypeOf({}, i);
      }
      function iteratorResult(pair, kind) {
        let result;
        switch (kind) {
          case "key": {
            result = pair[0];
            break;
          }
          case "value": {
            result = pair[1];
            break;
          }
          case "key+value": {
            result = pair;
            break;
          }
        }
        return { value: result, done: false };
      }
      async function fullyReadBody(body, processBody, processBodyError) {
        const successSteps = processBody;
        const errorSteps = processBodyError;
        let reader;
        try {
          reader = body.stream.getReader();
        } catch (e) {
          errorSteps(e);
          return;
        }
        try {
          const result = await readAllBytes(reader);
          successSteps(result);
        } catch (e) {
          errorSteps(e);
        }
      }
      var ReadableStream = globalThis.ReadableStream;
      function isReadableStreamLike(stream) {
        if (!ReadableStream) {
          ReadableStream = __require("stream/web").ReadableStream;
        }
        return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
      }
      var MAXIMUM_ARGUMENT_LENGTH = 65535;
      function isomorphicDecode(input2) {
        if (input2.length < MAXIMUM_ARGUMENT_LENGTH) {
          return String.fromCharCode(...input2);
        }
        return input2.reduce((previous, current) => previous + String.fromCharCode(current), "");
      }
      function readableStreamClose(controller) {
        try {
          controller.close();
        } catch (err) {
          if (!err.message.includes("Controller is already closed")) {
            throw err;
          }
        }
      }
      function isomorphicEncode(input2) {
        for (let i = 0; i < input2.length; i++) {
          assert(input2.charCodeAt(i) <= 255);
        }
        return input2;
      }
      async function readAllBytes(reader) {
        const bytes = [];
        let byteLength = 0;
        while (true) {
          const { done, value: chunk } = await reader.read();
          if (done) {
            return Buffer.concat(bytes, byteLength);
          }
          if (!isUint8Array(chunk)) {
            throw new TypeError("Received non-Uint8Array chunk");
          }
          bytes.push(chunk);
          byteLength += chunk.length;
        }
      }
      function urlIsLocal(url) {
        assert("protocol" in url);
        const protocol = url.protocol;
        return protocol === "about:" || protocol === "blob:" || protocol === "data:";
      }
      function urlHasHttpsScheme(url) {
        if (typeof url === "string") {
          return url.startsWith("https:");
        }
        return url.protocol === "https:";
      }
      function urlIsHttpHttpsScheme(url) {
        assert("protocol" in url);
        const protocol = url.protocol;
        return protocol === "http:" || protocol === "https:";
      }
      var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
      module.exports = {
        isAborted,
        isCancelled,
        createDeferredPromise,
        ReadableStreamFrom,
        toUSVString,
        tryUpgradeRequestToAPotentiallyTrustworthyURL,
        coarsenedSharedCurrentTime,
        determineRequestsReferrer,
        makePolicyContainer,
        clonePolicyContainer,
        appendFetchMetadata,
        appendRequestOriginHeader,
        TAOCheck,
        corsCheck,
        crossOriginResourcePolicyCheck,
        createOpaqueTimingInfo,
        setRequestReferrerPolicyOnRedirect,
        isValidHTTPToken,
        requestBadPort,
        requestCurrentURL,
        responseURL,
        responseLocationURL,
        isBlobLike,
        isURLPotentiallyTrustworthy,
        isValidReasonPhrase,
        sameOrigin,
        normalizeMethod,
        serializeJavascriptValueToJSONString,
        makeIterator,
        isValidHeaderName,
        isValidHeaderValue,
        hasOwn,
        isErrorLike,
        fullyReadBody,
        bytesMatch,
        isReadableStreamLike,
        readableStreamClose,
        isomorphicEncode,
        isomorphicDecode,
        urlIsLocal,
        urlHasHttpsScheme,
        urlIsHttpHttpsScheme,
        readAllBytes,
        normalizeMethodRecord,
        parseMetadata
      };
    }
  });

  // node_modules/undici/lib/fetch/symbols.js
  var require_symbols2 = __commonJS({
    "node_modules/undici/lib/fetch/symbols.js"(exports, module) {
      "use strict";
      module.exports = {
        kUrl: Symbol("url"),
        kHeaders: Symbol("headers"),
        kSignal: Symbol("signal"),
        kState: Symbol("state"),
        kGuard: Symbol("guard"),
        kRealm: Symbol("realm")
      };
    }
  });

  // node_modules/undici/lib/fetch/webidl.js
  var require_webidl = __commonJS({
    "node_modules/undici/lib/fetch/webidl.js"(exports, module) {
      "use strict";
      var { types } = __require("util");
      var { hasOwn, toUSVString } = require_util2();
      var webidl = {};
      webidl.converters = {};
      webidl.util = {};
      webidl.errors = {};
      webidl.errors.exception = function(message) {
        return new TypeError(`${message.header}: ${message.message}`);
      };
      webidl.errors.conversionFailed = function(context2) {
        const plural = context2.types.length === 1 ? "" : " one of";
        const message = `${context2.argument} could not be converted to${plural}: ${context2.types.join(", ")}.`;
        return webidl.errors.exception({
          header: context2.prefix,
          message
        });
      };
      webidl.errors.invalidArgument = function(context2) {
        return webidl.errors.exception({
          header: context2.prefix,
          message: `"${context2.value}" is an invalid ${context2.type}.`
        });
      };
      webidl.brandCheck = function(V, I, opts = void 0) {
        if (opts?.strict !== false && !(V instanceof I)) {
          throw new TypeError("Illegal invocation");
        } else {
          return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
        }
      };
      webidl.argumentLengthCheck = function({ length }, min, ctx) {
        if (length < min) {
          throw webidl.errors.exception({
            message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
            ...ctx
          });
        }
      };
      webidl.illegalConstructor = function() {
        throw webidl.errors.exception({
          header: "TypeError",
          message: "Illegal constructor"
        });
      };
      webidl.util.Type = function(V) {
        switch (typeof V) {
          case "undefined":
            return "Undefined";
          case "boolean":
            return "Boolean";
          case "string":
            return "String";
          case "symbol":
            return "Symbol";
          case "number":
            return "Number";
          case "bigint":
            return "BigInt";
          case "function":
          case "object": {
            if (V === null) {
              return "Null";
            }
            return "Object";
          }
        }
      };
      webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
        let upperBound;
        let lowerBound;
        if (bitLength === 64) {
          upperBound = Math.pow(2, 53) - 1;
          if (signedness === "unsigned") {
            lowerBound = 0;
          } else {
            lowerBound = Math.pow(-2, 53) + 1;
          }
        } else if (signedness === "unsigned") {
          lowerBound = 0;
          upperBound = Math.pow(2, bitLength) - 1;
        } else {
          lowerBound = Math.pow(-2, bitLength) - 1;
          upperBound = Math.pow(2, bitLength - 1) - 1;
        }
        let x = Number(V);
        if (x === 0) {
          x = 0;
        }
        if (opts.enforceRange === true) {
          if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
            throw webidl.errors.exception({
              header: "Integer conversion",
              message: `Could not convert ${V} to an integer.`
            });
          }
          x = webidl.util.IntegerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw webidl.errors.exception({
              header: "Integer conversion",
              message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
            });
          }
          return x;
        }
        if (!Number.isNaN(x) && opts.clamp === true) {
          x = Math.min(Math.max(x, lowerBound), upperBound);
          if (Math.floor(x) % 2 === 0) {
            x = Math.floor(x);
          } else {
            x = Math.ceil(x);
          }
          return x;
        }
        if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          return 0;
        }
        x = webidl.util.IntegerPart(x);
        x = x % Math.pow(2, bitLength);
        if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
          return x - Math.pow(2, bitLength);
        }
        return x;
      };
      webidl.util.IntegerPart = function(n) {
        const r = Math.floor(Math.abs(n));
        if (n < 0) {
          return -1 * r;
        }
        return r;
      };
      webidl.sequenceConverter = function(converter) {
        return (V) => {
          if (webidl.util.Type(V) !== "Object") {
            throw webidl.errors.exception({
              header: "Sequence",
              message: `Value of type ${webidl.util.Type(V)} is not an Object.`
            });
          }
          const method = V?.[Symbol.iterator]?.();
          const seq = [];
          if (method === void 0 || typeof method.next !== "function") {
            throw webidl.errors.exception({
              header: "Sequence",
              message: "Object is not an iterator."
            });
          }
          while (true) {
            const { done, value } = method.next();
            if (done) {
              break;
            }
            seq.push(converter(value));
          }
          return seq;
        };
      };
      webidl.recordConverter = function(keyConverter, valueConverter) {
        return (O) => {
          if (webidl.util.Type(O) !== "Object") {
            throw webidl.errors.exception({
              header: "Record",
              message: `Value of type ${webidl.util.Type(O)} is not an Object.`
            });
          }
          const result = {};
          if (!types.isProxy(O)) {
            const keys2 = Object.keys(O);
            for (const key of keys2) {
              const typedKey = keyConverter(key);
              const typedValue = valueConverter(O[key]);
              result[typedKey] = typedValue;
            }
            return result;
          }
          const keys = Reflect.ownKeys(O);
          for (const key of keys) {
            const desc = Reflect.getOwnPropertyDescriptor(O, key);
            if (desc?.enumerable) {
              const typedKey = keyConverter(key);
              const typedValue = valueConverter(O[key]);
              result[typedKey] = typedValue;
            }
          }
          return result;
        };
      };
      webidl.interfaceConverter = function(i) {
        return (V, opts = {}) => {
          if (opts.strict !== false && !(V instanceof i)) {
            throw webidl.errors.exception({
              header: i.name,
              message: `Expected ${V} to be an instance of ${i.name}.`
            });
          }
          return V;
        };
      };
      webidl.dictionaryConverter = function(converters) {
        return (dictionary) => {
          const type = webidl.util.Type(dictionary);
          const dict = {};
          if (type === "Null" || type === "Undefined") {
            return dict;
          } else if (type !== "Object") {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
            });
          }
          for (const options of converters) {
            const { key, defaultValue, required, converter } = options;
            if (required === true) {
              if (!hasOwn(dictionary, key)) {
                throw webidl.errors.exception({
                  header: "Dictionary",
                  message: `Missing required key "${key}".`
                });
              }
            }
            let value = dictionary[key];
            const hasDefault = hasOwn(options, "defaultValue");
            if (hasDefault && value !== null) {
              value = value ?? defaultValue;
            }
            if (required || hasDefault || value !== void 0) {
              value = converter(value);
              if (options.allowedValues && !options.allowedValues.includes(value)) {
                throw webidl.errors.exception({
                  header: "Dictionary",
                  message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
                });
              }
              dict[key] = value;
            }
          }
          return dict;
        };
      };
      webidl.nullableConverter = function(converter) {
        return (V) => {
          if (V === null) {
            return V;
          }
          return converter(V);
        };
      };
      webidl.converters.DOMString = function(V, opts = {}) {
        if (V === null && opts.legacyNullToEmptyString) {
          return "";
        }
        if (typeof V === "symbol") {
          throw new TypeError("Could not convert argument of type symbol to string.");
        }
        return String(V);
      };
      webidl.converters.ByteString = function(V) {
        const x = webidl.converters.DOMString(V);
        for (let index = 0; index < x.length; index++) {
          if (x.charCodeAt(index) > 255) {
            throw new TypeError(
              `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
            );
          }
        }
        return x;
      };
      webidl.converters.USVString = toUSVString;
      webidl.converters.boolean = function(V) {
        const x = Boolean(V);
        return x;
      };
      webidl.converters.any = function(V) {
        return V;
      };
      webidl.converters["long long"] = function(V) {
        const x = webidl.util.ConvertToInt(V, 64, "signed");
        return x;
      };
      webidl.converters["unsigned long long"] = function(V) {
        const x = webidl.util.ConvertToInt(V, 64, "unsigned");
        return x;
      };
      webidl.converters["unsigned long"] = function(V) {
        const x = webidl.util.ConvertToInt(V, 32, "unsigned");
        return x;
      };
      webidl.converters["unsigned short"] = function(V, opts) {
        const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
        return x;
      };
      webidl.converters.ArrayBuffer = function(V, opts = {}) {
        if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
          throw webidl.errors.conversionFailed({
            prefix: `${V}`,
            argument: `${V}`,
            types: ["ArrayBuffer"]
          });
        }
        if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
          throw webidl.errors.exception({
            header: "ArrayBuffer",
            message: "SharedArrayBuffer is not allowed."
          });
        }
        return V;
      };
      webidl.converters.TypedArray = function(V, T, opts = {}) {
        if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
          throw webidl.errors.conversionFailed({
            prefix: `${T.name}`,
            argument: `${V}`,
            types: [T.name]
          });
        }
        if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
          throw webidl.errors.exception({
            header: "ArrayBuffer",
            message: "SharedArrayBuffer is not allowed."
          });
        }
        return V;
      };
      webidl.converters.DataView = function(V, opts = {}) {
        if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
          throw webidl.errors.exception({
            header: "DataView",
            message: "Object is not a DataView."
          });
        }
        if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
          throw webidl.errors.exception({
            header: "ArrayBuffer",
            message: "SharedArrayBuffer is not allowed."
          });
        }
        return V;
      };
      webidl.converters.BufferSource = function(V, opts = {}) {
        if (types.isAnyArrayBuffer(V)) {
          return webidl.converters.ArrayBuffer(V, opts);
        }
        if (types.isTypedArray(V)) {
          return webidl.converters.TypedArray(V, V.constructor);
        }
        if (types.isDataView(V)) {
          return webidl.converters.DataView(V, opts);
        }
        throw new TypeError(`Could not convert ${V} to a BufferSource.`);
      };
      webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
        webidl.converters.ByteString
      );
      webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
        webidl.converters["sequence<ByteString>"]
      );
      webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
        webidl.converters.ByteString,
        webidl.converters.ByteString
      );
      module.exports = {
        webidl
      };
    }
  });

  // node_modules/undici/lib/fetch/dataURL.js
  var require_dataURL = __commonJS({
    "node_modules/undici/lib/fetch/dataURL.js"(exports, module) {
      var assert = __require("assert");
      var { atob: atob2 } = __require("buffer");
      var { isomorphicDecode } = require_util2();
      var encoder = new TextEncoder();
      var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
      var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
      var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
      function dataURLProcessor(dataURL) {
        assert(dataURL.protocol === "data:");
        let input2 = URLSerializer(dataURL, true);
        input2 = input2.slice(5);
        const position = { position: 0 };
        let mimeType = collectASequenceOfCodePointsFast(
          ",",
          input2,
          position
        );
        const mimeTypeLength = mimeType.length;
        mimeType = removeASCIIWhitespace(mimeType, true, true);
        if (position.position >= input2.length) {
          return "failure";
        }
        position.position++;
        const encodedBody = input2.slice(mimeTypeLength + 1);
        let body = stringPercentDecode(encodedBody);
        if (/;(\u0020){0,}base64$/i.test(mimeType)) {
          const stringBody = isomorphicDecode(body);
          body = forgivingBase64(stringBody);
          if (body === "failure") {
            return "failure";
          }
          mimeType = mimeType.slice(0, -6);
          mimeType = mimeType.replace(/(\u0020)+$/, "");
          mimeType = mimeType.slice(0, -1);
        }
        if (mimeType.startsWith(";")) {
          mimeType = "text/plain" + mimeType;
        }
        let mimeTypeRecord = parseMIMEType(mimeType);
        if (mimeTypeRecord === "failure") {
          mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
        }
        return { mimeType: mimeTypeRecord, body };
      }
      function URLSerializer(url, excludeFragment = false) {
        if (!excludeFragment) {
          return url.href;
        }
        const href = url.href;
        const hashLength = url.hash.length;
        return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
      }
      function collectASequenceOfCodePoints(condition, input2, position) {
        let result = "";
        while (position.position < input2.length && condition(input2[position.position])) {
          result += input2[position.position];
          position.position++;
        }
        return result;
      }
      function collectASequenceOfCodePointsFast(char, input2, position) {
        const idx = input2.indexOf(char, position.position);
        const start = position.position;
        if (idx === -1) {
          position.position = input2.length;
          return input2.slice(start);
        }
        position.position = idx;
        return input2.slice(start, position.position);
      }
      function stringPercentDecode(input2) {
        const bytes = encoder.encode(input2);
        return percentDecode(bytes);
      }
      function percentDecode(input2) {
        const output = [];
        for (let i = 0; i < input2.length; i++) {
          const byte = input2[i];
          if (byte !== 37) {
            output.push(byte);
          } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input2[i + 1], input2[i + 2]))) {
            output.push(37);
          } else {
            const nextTwoBytes = String.fromCharCode(input2[i + 1], input2[i + 2]);
            const bytePoint = Number.parseInt(nextTwoBytes, 16);
            output.push(bytePoint);
            i += 2;
          }
        }
        return Uint8Array.from(output);
      }
      function parseMIMEType(input2) {
        input2 = removeHTTPWhitespace(input2, true, true);
        const position = { position: 0 };
        const type = collectASequenceOfCodePointsFast(
          "/",
          input2,
          position
        );
        if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
          return "failure";
        }
        if (position.position > input2.length) {
          return "failure";
        }
        position.position++;
        let subtype = collectASequenceOfCodePointsFast(
          ";",
          input2,
          position
        );
        subtype = removeHTTPWhitespace(subtype, false, true);
        if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
          return "failure";
        }
        const typeLowercase = type.toLowerCase();
        const subtypeLowercase = subtype.toLowerCase();
        const mimeType = {
          type: typeLowercase,
          subtype: subtypeLowercase,
          /** @type {Map<string, string>} */
          parameters: /* @__PURE__ */ new Map(),
          // https://mimesniff.spec.whatwg.org/#mime-type-essence
          essence: `${typeLowercase}/${subtypeLowercase}`
        };
        while (position.position < input2.length) {
          position.position++;
          collectASequenceOfCodePoints(
            // https://fetch.spec.whatwg.org/#http-whitespace
            (char) => HTTP_WHITESPACE_REGEX.test(char),
            input2,
            position
          );
          let parameterName = collectASequenceOfCodePoints(
            (char) => char !== ";" && char !== "=",
            input2,
            position
          );
          parameterName = parameterName.toLowerCase();
          if (position.position < input2.length) {
            if (input2[position.position] === ";") {
              continue;
            }
            position.position++;
          }
          if (position.position > input2.length) {
            break;
          }
          let parameterValue = null;
          if (input2[position.position] === '"') {
            parameterValue = collectAnHTTPQuotedString(input2, position, true);
            collectASequenceOfCodePointsFast(
              ";",
              input2,
              position
            );
          } else {
            parameterValue = collectASequenceOfCodePointsFast(
              ";",
              input2,
              position
            );
            parameterValue = removeHTTPWhitespace(parameterValue, false, true);
            if (parameterValue.length === 0) {
              continue;
            }
          }
          if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
            mimeType.parameters.set(parameterName, parameterValue);
          }
        }
        return mimeType;
      }
      function forgivingBase64(data) {
        data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
        if (data.length % 4 === 0) {
          data = data.replace(/=?=$/, "");
        }
        if (data.length % 4 === 1) {
          return "failure";
        }
        if (/[^+/0-9A-Za-z]/.test(data)) {
          return "failure";
        }
        const binary = atob2(data);
        const bytes = new Uint8Array(binary.length);
        for (let byte = 0; byte < binary.length; byte++) {
          bytes[byte] = binary.charCodeAt(byte);
        }
        return bytes;
      }
      function collectAnHTTPQuotedString(input2, position, extractValue) {
        const positionStart = position.position;
        let value = "";
        assert(input2[position.position] === '"');
        position.position++;
        while (true) {
          value += collectASequenceOfCodePoints(
            (char) => char !== '"' && char !== "\\",
            input2,
            position
          );
          if (position.position >= input2.length) {
            break;
          }
          const quoteOrBackslash = input2[position.position];
          position.position++;
          if (quoteOrBackslash === "\\") {
            if (position.position >= input2.length) {
              value += "\\";
              break;
            }
            value += input2[position.position];
            position.position++;
          } else {
            assert(quoteOrBackslash === '"');
            break;
          }
        }
        if (extractValue) {
          return value;
        }
        return input2.slice(positionStart, position.position);
      }
      function serializeAMimeType(mimeType) {
        assert(mimeType !== "failure");
        const { parameters, essence } = mimeType;
        let serialization = essence;
        for (let [name, value] of parameters.entries()) {
          serialization += ";";
          serialization += name;
          serialization += "=";
          if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
            value = value.replace(/(\\|")/g, "\\$1");
            value = '"' + value;
            value += '"';
          }
          serialization += value;
        }
        return serialization;
      }
      function isHTTPWhiteSpace(char) {
        return char === "\r" || char === "\n" || char === "	" || char === " ";
      }
      function removeHTTPWhitespace(str, leading = true, trailing = true) {
        let lead = 0;
        let trail = str.length - 1;
        if (leading) {
          for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++) ;
        }
        if (trailing) {
          for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--) ;
        }
        return str.slice(lead, trail + 1);
      }
      function isASCIIWhitespace(char) {
        return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
      }
      function removeASCIIWhitespace(str, leading = true, trailing = true) {
        let lead = 0;
        let trail = str.length - 1;
        if (leading) {
          for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++) ;
        }
        if (trailing) {
          for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--) ;
        }
        return str.slice(lead, trail + 1);
      }
      module.exports = {
        dataURLProcessor,
        URLSerializer,
        collectASequenceOfCodePoints,
        collectASequenceOfCodePointsFast,
        stringPercentDecode,
        parseMIMEType,
        collectAnHTTPQuotedString,
        serializeAMimeType
      };
    }
  });

  // node_modules/undici/lib/fetch/file.js
  var require_file = __commonJS({
    "node_modules/undici/lib/fetch/file.js"(exports, module) {
      "use strict";
      var { Blob: Blob2, File: NativeFile } = __require("buffer");
      var { types } = __require("util");
      var { kState } = require_symbols2();
      var { isBlobLike } = require_util2();
      var { webidl } = require_webidl();
      var { parseMIMEType, serializeAMimeType } = require_dataURL();
      var { kEnumerableProperty } = require_util();
      var encoder = new TextEncoder();
      var File = class _File extends Blob2 {
        constructor(fileBits, fileName, options = {}) {
          webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
          fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
          fileName = webidl.converters.USVString(fileName);
          options = webidl.converters.FilePropertyBag(options);
          const n = fileName;
          let t = options.type;
          let d;
          substep: {
            if (t) {
              t = parseMIMEType(t);
              if (t === "failure") {
                t = "";
                break substep;
              }
              t = serializeAMimeType(t).toLowerCase();
            }
            d = options.lastModified;
          }
          super(processBlobParts(fileBits, options), { type: t });
          this[kState] = {
            name: n,
            lastModified: d,
            type: t
          };
        }
        get name() {
          webidl.brandCheck(this, _File);
          return this[kState].name;
        }
        get lastModified() {
          webidl.brandCheck(this, _File);
          return this[kState].lastModified;
        }
        get type() {
          webidl.brandCheck(this, _File);
          return this[kState].type;
        }
      };
      var FileLike = class _FileLike {
        constructor(blobLike, fileName, options = {}) {
          const n = fileName;
          const t = options.type;
          const d = options.lastModified ?? Date.now();
          this[kState] = {
            blobLike,
            name: n,
            type: t,
            lastModified: d
          };
        }
        stream(...args) {
          webidl.brandCheck(this, _FileLike);
          return this[kState].blobLike.stream(...args);
        }
        arrayBuffer(...args) {
          webidl.brandCheck(this, _FileLike);
          return this[kState].blobLike.arrayBuffer(...args);
        }
        slice(...args) {
          webidl.brandCheck(this, _FileLike);
          return this[kState].blobLike.slice(...args);
        }
        text(...args) {
          webidl.brandCheck(this, _FileLike);
          return this[kState].blobLike.text(...args);
        }
        get size() {
          webidl.brandCheck(this, _FileLike);
          return this[kState].blobLike.size;
        }
        get type() {
          webidl.brandCheck(this, _FileLike);
          return this[kState].blobLike.type;
        }
        get name() {
          webidl.brandCheck(this, _FileLike);
          return this[kState].name;
        }
        get lastModified() {
          webidl.brandCheck(this, _FileLike);
          return this[kState].lastModified;
        }
        get [Symbol.toStringTag]() {
          return "File";
        }
      };
      Object.defineProperties(File.prototype, {
        [Symbol.toStringTag]: {
          value: "File",
          configurable: true
        },
        name: kEnumerableProperty,
        lastModified: kEnumerableProperty
      });
      webidl.converters.Blob = webidl.interfaceConverter(Blob2);
      webidl.converters.BlobPart = function(V, opts) {
        if (webidl.util.Type(V) === "Object") {
          if (isBlobLike(V)) {
            return webidl.converters.Blob(V, { strict: false });
          }
          if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
            return webidl.converters.BufferSource(V, opts);
          }
        }
        return webidl.converters.USVString(V, opts);
      };
      webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
        webidl.converters.BlobPart
      );
      webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
        {
          key: "lastModified",
          converter: webidl.converters["long long"],
          get defaultValue() {
            return Date.now();
          }
        },
        {
          key: "type",
          converter: webidl.converters.DOMString,
          defaultValue: ""
        },
        {
          key: "endings",
          converter: (value) => {
            value = webidl.converters.DOMString(value);
            value = value.toLowerCase();
            if (value !== "native") {
              value = "transparent";
            }
            return value;
          },
          defaultValue: "transparent"
        }
      ]);
      function processBlobParts(parts, options) {
        const bytes = [];
        for (const element of parts) {
          if (typeof element === "string") {
            let s = element;
            if (options.endings === "native") {
              s = convertLineEndingsNative(s);
            }
            bytes.push(encoder.encode(s));
          } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
            if (!element.buffer) {
              bytes.push(new Uint8Array(element));
            } else {
              bytes.push(
                new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
              );
            }
          } else if (isBlobLike(element)) {
            bytes.push(element);
          }
        }
        return bytes;
      }
      function convertLineEndingsNative(s) {
        let nativeLineEnding = "\n";
        if (process.platform === "win32") {
          nativeLineEnding = "\r\n";
        }
        return s.replace(/\r?\n/g, nativeLineEnding);
      }
      function isFileLike(object) {
        return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
      }
      module.exports = { File, FileLike, isFileLike };
    }
  });

  // node_modules/undici/lib/fetch/formdata.js
  var require_formdata = __commonJS({
    "node_modules/undici/lib/fetch/formdata.js"(exports, module) {
      "use strict";
      var { isBlobLike, toUSVString, makeIterator } = require_util2();
      var { kState } = require_symbols2();
      var { File: UndiciFile, FileLike, isFileLike } = require_file();
      var { webidl } = require_webidl();
      var { Blob: Blob2, File: NativeFile } = __require("buffer");
      var File = NativeFile ?? UndiciFile;
      var FormData = class _FormData {
        constructor(form) {
          if (form !== void 0) {
            throw webidl.errors.conversionFailed({
              prefix: "FormData constructor",
              argument: "Argument 1",
              types: ["undefined"]
            });
          }
          this[kState] = [];
        }
        append(name, value, filename = void 0) {
          webidl.brandCheck(this, _FormData);
          webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
          if (arguments.length === 3 && !isBlobLike(value)) {
            throw new TypeError(
              "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
            );
          }
          name = webidl.converters.USVString(name);
          value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
          filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
          const entry = makeEntry(name, value, filename);
          this[kState].push(entry);
        }
        delete(name) {
          webidl.brandCheck(this, _FormData);
          webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
          name = webidl.converters.USVString(name);
          this[kState] = this[kState].filter((entry) => entry.name !== name);
        }
        get(name) {
          webidl.brandCheck(this, _FormData);
          webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
          name = webidl.converters.USVString(name);
          const idx = this[kState].findIndex((entry) => entry.name === name);
          if (idx === -1) {
            return null;
          }
          return this[kState][idx].value;
        }
        getAll(name) {
          webidl.brandCheck(this, _FormData);
          webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
          name = webidl.converters.USVString(name);
          return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
        }
        has(name) {
          webidl.brandCheck(this, _FormData);
          webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
          name = webidl.converters.USVString(name);
          return this[kState].findIndex((entry) => entry.name === name) !== -1;
        }
        set(name, value, filename = void 0) {
          webidl.brandCheck(this, _FormData);
          webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
          if (arguments.length === 3 && !isBlobLike(value)) {
            throw new TypeError(
              "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
            );
          }
          name = webidl.converters.USVString(name);
          value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
          filename = arguments.length === 3 ? toUSVString(filename) : void 0;
          const entry = makeEntry(name, value, filename);
          const idx = this[kState].findIndex((entry2) => entry2.name === name);
          if (idx !== -1) {
            this[kState] = [
              ...this[kState].slice(0, idx),
              entry,
              ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
            ];
          } else {
            this[kState].push(entry);
          }
        }
        entries() {
          webidl.brandCheck(this, _FormData);
          return makeIterator(
            () => this[kState].map((pair) => [pair.name, pair.value]),
            "FormData",
            "key+value"
          );
        }
        keys() {
          webidl.brandCheck(this, _FormData);
          return makeIterator(
            () => this[kState].map((pair) => [pair.name, pair.value]),
            "FormData",
            "key"
          );
        }
        values() {
          webidl.brandCheck(this, _FormData);
          return makeIterator(
            () => this[kState].map((pair) => [pair.name, pair.value]),
            "FormData",
            "value"
          );
        }
        /**
         * @param {(value: string, key: string, self: FormData) => void} callbackFn
         * @param {unknown} thisArg
         */
        forEach(callbackFn, thisArg = globalThis) {
          webidl.brandCheck(this, _FormData);
          webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
          if (typeof callbackFn !== "function") {
            throw new TypeError(
              "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
            );
          }
          for (const [key, value] of this) {
            callbackFn.apply(thisArg, [value, key, this]);
          }
        }
      };
      FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
      Object.defineProperties(FormData.prototype, {
        [Symbol.toStringTag]: {
          value: "FormData",
          configurable: true
        }
      });
      function makeEntry(name, value, filename) {
        name = Buffer.from(name).toString("utf8");
        if (typeof value === "string") {
          value = Buffer.from(value).toString("utf8");
        } else {
          if (!isFileLike(value)) {
            value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
          }
          if (filename !== void 0) {
            const options = {
              type: value.type,
              lastModified: value.lastModified
            };
            value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
          }
        }
        return { name, value };
      }
      module.exports = { FormData };
    }
  });

  // node_modules/undici/lib/fetch/body.js
  var require_body = __commonJS({
    "node_modules/undici/lib/fetch/body.js"(exports, module) {
      "use strict";
      var Busboy = require_main();
      var util = require_util();
      var {
        ReadableStreamFrom,
        isBlobLike,
        isReadableStreamLike,
        readableStreamClose,
        createDeferredPromise,
        fullyReadBody
      } = require_util2();
      var { FormData } = require_formdata();
      var { kState } = require_symbols2();
      var { webidl } = require_webidl();
      var { DOMException: DOMException2, structuredClone } = require_constants2();
      var { Blob: Blob2, File: NativeFile } = __require("buffer");
      var { kBodyUsed } = require_symbols();
      var assert = __require("assert");
      var { isErrored } = require_util();
      var { isUint8Array, isArrayBuffer } = __require("util/types");
      var { File: UndiciFile } = require_file();
      var { parseMIMEType, serializeAMimeType } = require_dataURL();
      var ReadableStream = globalThis.ReadableStream;
      var File = NativeFile ?? UndiciFile;
      var textEncoder = new TextEncoder();
      var textDecoder = new TextDecoder();
      function extractBody(object, keepalive = false) {
        if (!ReadableStream) {
          ReadableStream = __require("stream/web").ReadableStream;
        }
        let stream = null;
        if (object instanceof ReadableStream) {
          stream = object;
        } else if (isBlobLike(object)) {
          stream = object.stream();
        } else {
          stream = new ReadableStream({
            async pull(controller) {
              controller.enqueue(
                typeof source === "string" ? textEncoder.encode(source) : source
              );
              queueMicrotask(() => readableStreamClose(controller));
            },
            start() {
            },
            type: void 0
          });
        }
        assert(isReadableStreamLike(stream));
        let action = null;
        let source = null;
        let length = null;
        let type = null;
        if (typeof object === "string") {
          source = object;
          type = "text/plain;charset=UTF-8";
        } else if (object instanceof URLSearchParams) {
          source = object.toString();
          type = "application/x-www-form-urlencoded;charset=UTF-8";
        } else if (isArrayBuffer(object)) {
          source = new Uint8Array(object.slice());
        } else if (ArrayBuffer.isView(object)) {
          source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
        } else if (util.isFormDataLike(object)) {
          const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
          const prefix = `--${boundary}\r
Content-Disposition: form-data`;
          const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
          const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
          const blobParts = [];
          const rn = new Uint8Array([13, 10]);
          length = 0;
          let hasUnknownSizeValue = false;
          for (const [name, value] of object) {
            if (typeof value === "string") {
              const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
              blobParts.push(chunk2);
              length += chunk2.byteLength;
            } else {
              const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
              blobParts.push(chunk2, value, rn);
              if (typeof value.size === "number") {
                length += chunk2.byteLength + value.size + rn.byteLength;
              } else {
                hasUnknownSizeValue = true;
              }
            }
          }
          const chunk = textEncoder.encode(`--${boundary}--`);
          blobParts.push(chunk);
          length += chunk.byteLength;
          if (hasUnknownSizeValue) {
            length = null;
          }
          source = object;
          action = async function* () {
            for (const part of blobParts) {
              if (part.stream) {
                yield* part.stream();
              } else {
                yield part;
              }
            }
          };
          type = "multipart/form-data; boundary=" + boundary;
        } else if (isBlobLike(object)) {
          source = object;
          length = object.size;
          if (object.type) {
            type = object.type;
          }
        } else if (typeof object[Symbol.asyncIterator] === "function") {
          if (keepalive) {
            throw new TypeError("keepalive");
          }
          if (util.isDisturbed(object) || object.locked) {
            throw new TypeError(
              "Response body object should not be disturbed or locked"
            );
          }
          stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
        }
        if (typeof source === "string" || util.isBuffer(source)) {
          length = Buffer.byteLength(source);
        }
        if (action != null) {
          let iterator;
          stream = new ReadableStream({
            async start() {
              iterator = action(object)[Symbol.asyncIterator]();
            },
            async pull(controller) {
              const { value, done } = await iterator.next();
              if (done) {
                queueMicrotask(() => {
                  controller.close();
                });
              } else {
                if (!isErrored(stream)) {
                  controller.enqueue(new Uint8Array(value));
                }
              }
              return controller.desiredSize > 0;
            },
            async cancel(reason) {
              await iterator.return();
            },
            type: void 0
          });
        }
        const body = { stream, source, length };
        return [body, type];
      }
      function safelyExtractBody(object, keepalive = false) {
        if (!ReadableStream) {
          ReadableStream = __require("stream/web").ReadableStream;
        }
        if (object instanceof ReadableStream) {
          assert(!util.isDisturbed(object), "The body has already been consumed.");
          assert(!object.locked, "The stream is locked.");
        }
        return extractBody(object, keepalive);
      }
      function cloneBody(body) {
        const [out1, out2] = body.stream.tee();
        const out2Clone = structuredClone(out2, { transfer: [out2] });
        const [, finalClone] = out2Clone.tee();
        body.stream = out1;
        return {
          stream: finalClone,
          length: body.length,
          source: body.source
        };
      }
      async function* consumeBody(body) {
        if (body) {
          if (isUint8Array(body)) {
            yield body;
          } else {
            const stream = body.stream;
            if (util.isDisturbed(stream)) {
              throw new TypeError("The body has already been consumed.");
            }
            if (stream.locked) {
              throw new TypeError("The stream is locked.");
            }
            stream[kBodyUsed] = true;
            yield* stream;
          }
        }
      }
      function throwIfAborted(state) {
        if (state.aborted) {
          throw new DOMException2("The operation was aborted.", "AbortError");
        }
      }
      function bodyMixinMethods(instance) {
        const methods = {
          blob() {
            return specConsumeBody(this, (bytes) => {
              let mimeType = bodyMimeType(this);
              if (mimeType === "failure") {
                mimeType = "";
              } else if (mimeType) {
                mimeType = serializeAMimeType(mimeType);
              }
              return new Blob2([bytes], { type: mimeType });
            }, instance);
          },
          arrayBuffer() {
            return specConsumeBody(this, (bytes) => {
              return new Uint8Array(bytes).buffer;
            }, instance);
          },
          text() {
            return specConsumeBody(this, utf8DecodeBytes, instance);
          },
          json() {
            return specConsumeBody(this, parseJSONFromBytes, instance);
          },
          async formData() {
            webidl.brandCheck(this, instance);
            throwIfAborted(this[kState]);
            const contentType = this.headers.get("Content-Type");
            if (/multipart\/form-data/.test(contentType)) {
              const headers = {};
              for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
              const responseFormData = new FormData();
              let busboy;
              try {
                busboy = new Busboy({
                  headers,
                  preservePath: true
                });
              } catch (err) {
                throw new DOMException2(`${err}`, "AbortError");
              }
              busboy.on("field", (name, value) => {
                responseFormData.append(name, value);
              });
              busboy.on("file", (name, value, filename, encoding, mimeType) => {
                const chunks = [];
                if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                  let base64chunk = "";
                  value.on("data", (chunk) => {
                    base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                    const end = base64chunk.length - base64chunk.length % 4;
                    chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                    base64chunk = base64chunk.slice(end);
                  });
                  value.on("end", () => {
                    chunks.push(Buffer.from(base64chunk, "base64"));
                    responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                  });
                } else {
                  value.on("data", (chunk) => {
                    chunks.push(chunk);
                  });
                  value.on("end", () => {
                    responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                  });
                }
              });
              const busboyResolve = new Promise((resolve, reject) => {
                busboy.on("finish", resolve);
                busboy.on("error", (err) => reject(new TypeError(err)));
              });
              if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
              busboy.end();
              await busboyResolve;
              return responseFormData;
            } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
              let entries;
              try {
                let text = "";
                const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
                for await (const chunk of consumeBody(this[kState].body)) {
                  if (!isUint8Array(chunk)) {
                    throw new TypeError("Expected Uint8Array chunk");
                  }
                  text += streamingDecoder.decode(chunk, { stream: true });
                }
                text += streamingDecoder.decode();
                entries = new URLSearchParams(text);
              } catch (err) {
                throw Object.assign(new TypeError(), { cause: err });
              }
              const formData = new FormData();
              for (const [name, value] of entries) {
                formData.append(name, value);
              }
              return formData;
            } else {
              await Promise.resolve();
              throwIfAborted(this[kState]);
              throw webidl.errors.exception({
                header: `${instance.name}.formData`,
                message: "Could not parse content as FormData."
              });
            }
          }
        };
        return methods;
      }
      function mixinBody(prototype) {
        Object.assign(prototype.prototype, bodyMixinMethods(prototype));
      }
      async function specConsumeBody(object, convertBytesToJSValue, instance) {
        webidl.brandCheck(object, instance);
        throwIfAborted(object[kState]);
        if (bodyUnusable(object[kState].body)) {
          throw new TypeError("Body is unusable");
        }
        const promise = createDeferredPromise();
        const errorSteps = (error) => promise.reject(error);
        const successSteps = (data) => {
          try {
            promise.resolve(convertBytesToJSValue(data));
          } catch (e) {
            errorSteps(e);
          }
        };
        if (object[kState].body == null) {
          successSteps(new Uint8Array());
          return promise.promise;
        }
        await fullyReadBody(object[kState].body, successSteps, errorSteps);
        return promise.promise;
      }
      function bodyUnusable(body) {
        return body != null && (body.stream.locked || util.isDisturbed(body.stream));
      }
      function utf8DecodeBytes(buffer) {
        if (buffer.length === 0) {
          return "";
        }
        if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
          buffer = buffer.subarray(3);
        }
        const output = textDecoder.decode(buffer);
        return output;
      }
      function parseJSONFromBytes(bytes) {
        return JSON.parse(utf8DecodeBytes(bytes));
      }
      function bodyMimeType(object) {
        const { headersList } = object[kState];
        const contentType = headersList.get("content-type");
        if (contentType === null) {
          return "failure";
        }
        return parseMIMEType(contentType);
      }
      module.exports = {
        extractBody,
        safelyExtractBody,
        cloneBody,
        mixinBody
      };
    }
  });

  // node_modules/undici/lib/core/request.js
  var require_request = __commonJS({
    "node_modules/undici/lib/core/request.js"(exports, module) {
      "use strict";
      var {
        InvalidArgumentError,
        NotSupportedError
      } = require_errors();
      var assert = __require("assert");
      var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
      var util = require_util();
      var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
      var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
      var invalidPathRegex = /[^\u0021-\u00ff]/;
      var kHandler = Symbol("handler");
      var channels = {};
      var extractBody;
      try {
        const diagnosticsChannel = __require("diagnostics_channel");
        channels.create = diagnosticsChannel.channel("undici:request:create");
        channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
        channels.headers = diagnosticsChannel.channel("undici:request:headers");
        channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
        channels.error = diagnosticsChannel.channel("undici:request:error");
      } catch {
        channels.create = { hasSubscribers: false };
        channels.bodySent = { hasSubscribers: false };
        channels.headers = { hasSubscribers: false };
        channels.trailers = { hasSubscribers: false };
        channels.error = { hasSubscribers: false };
      }
      var Request = class _Request {
        constructor(origin, {
          path,
          method,
          body,
          headers,
          query,
          idempotent,
          blocking,
          upgrade,
          headersTimeout,
          bodyTimeout,
          reset,
          throwOnError,
          expectContinue
        }, handler2) {
          if (typeof path !== "string") {
            throw new InvalidArgumentError("path must be a string");
          } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
            throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
          } else if (invalidPathRegex.exec(path) !== null) {
            throw new InvalidArgumentError("invalid request path");
          }
          if (typeof method !== "string") {
            throw new InvalidArgumentError("method must be a string");
          } else if (tokenRegExp.exec(method) === null) {
            throw new InvalidArgumentError("invalid request method");
          }
          if (upgrade && typeof upgrade !== "string") {
            throw new InvalidArgumentError("upgrade must be a string");
          }
          if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
            throw new InvalidArgumentError("invalid headersTimeout");
          }
          if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
            throw new InvalidArgumentError("invalid bodyTimeout");
          }
          if (reset != null && typeof reset !== "boolean") {
            throw new InvalidArgumentError("invalid reset");
          }
          if (expectContinue != null && typeof expectContinue !== "boolean") {
            throw new InvalidArgumentError("invalid expectContinue");
          }
          this.headersTimeout = headersTimeout;
          this.bodyTimeout = bodyTimeout;
          this.throwOnError = throwOnError === true;
          this.method = method;
          this.abort = null;
          if (body == null) {
            this.body = null;
          } else if (util.isStream(body)) {
            this.body = body;
            const rState = this.body._readableState;
            if (!rState || !rState.autoDestroy) {
              this.endHandler = function autoDestroy() {
                util.destroy(this);
              };
              this.body.on("end", this.endHandler);
            }
            this.errorHandler = (err) => {
              if (this.abort) {
                this.abort(err);
              } else {
                this.error = err;
              }
            };
            this.body.on("error", this.errorHandler);
          } else if (util.isBuffer(body)) {
            this.body = body.byteLength ? body : null;
          } else if (ArrayBuffer.isView(body)) {
            this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
          } else if (body instanceof ArrayBuffer) {
            this.body = body.byteLength ? Buffer.from(body) : null;
          } else if (typeof body === "string") {
            this.body = body.length ? Buffer.from(body) : null;
          } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
            this.body = body;
          } else {
            throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
          }
          this.completed = false;
          this.aborted = false;
          this.upgrade = upgrade || null;
          this.path = query ? util.buildURL(path, query) : path;
          this.origin = origin;
          this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
          this.blocking = blocking == null ? false : blocking;
          this.reset = reset == null ? null : reset;
          this.host = null;
          this.contentLength = null;
          this.contentType = null;
          this.headers = "";
          this.expectContinue = expectContinue != null ? expectContinue : false;
          if (Array.isArray(headers)) {
            if (headers.length % 2 !== 0) {
              throw new InvalidArgumentError("headers array must be even");
            }
            for (let i = 0; i < headers.length; i += 2) {
              processHeader(this, headers[i], headers[i + 1]);
            }
          } else if (headers && typeof headers === "object") {
            const keys = Object.keys(headers);
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              processHeader(this, key, headers[key]);
            }
          } else if (headers != null) {
            throw new InvalidArgumentError("headers must be an object or an array");
          }
          if (util.isFormDataLike(this.body)) {
            if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
              throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
            }
            if (!extractBody) {
              extractBody = require_body().extractBody;
            }
            const [bodyStream, contentType] = extractBody(body);
            if (this.contentType == null) {
              this.contentType = contentType;
              this.headers += `content-type: ${contentType}\r
`;
            }
            this.body = bodyStream.stream;
            this.contentLength = bodyStream.length;
          } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
            this.contentType = body.type;
            this.headers += `content-type: ${body.type}\r
`;
          }
          util.validateHandler(handler2, method, upgrade);
          this.servername = util.getServerName(this.host);
          this[kHandler] = handler2;
          if (channels.create.hasSubscribers) {
            channels.create.publish({ request: this });
          }
        }
        onBodySent(chunk) {
          if (this[kHandler].onBodySent) {
            try {
              return this[kHandler].onBodySent(chunk);
            } catch (err) {
              this.abort(err);
            }
          }
        }
        onRequestSent() {
          if (channels.bodySent.hasSubscribers) {
            channels.bodySent.publish({ request: this });
          }
          if (this[kHandler].onRequestSent) {
            try {
              return this[kHandler].onRequestSent();
            } catch (err) {
              this.abort(err);
            }
          }
        }
        onConnect(abort) {
          assert(!this.aborted);
          assert(!this.completed);
          if (this.error) {
            abort(this.error);
          } else {
            this.abort = abort;
            return this[kHandler].onConnect(abort);
          }
        }
        onHeaders(statusCode, headers, resume, statusText) {
          assert(!this.aborted);
          assert(!this.completed);
          if (channels.headers.hasSubscribers) {
            channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
          }
          try {
            return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
          } catch (err) {
            this.abort(err);
          }
        }
        onData(chunk) {
          assert(!this.aborted);
          assert(!this.completed);
          try {
            return this[kHandler].onData(chunk);
          } catch (err) {
            this.abort(err);
            return false;
          }
        }
        onUpgrade(statusCode, headers, socket) {
          assert(!this.aborted);
          assert(!this.completed);
          return this[kHandler].onUpgrade(statusCode, headers, socket);
        }
        onComplete(trailers) {
          this.onFinally();
          assert(!this.aborted);
          this.completed = true;
          if (channels.trailers.hasSubscribers) {
            channels.trailers.publish({ request: this, trailers });
          }
          try {
            return this[kHandler].onComplete(trailers);
          } catch (err) {
            this.onError(err);
          }
        }
        onError(error) {
          this.onFinally();
          if (channels.error.hasSubscribers) {
            channels.error.publish({ request: this, error });
          }
          if (this.aborted) {
            return;
          }
          this.aborted = true;
          return this[kHandler].onError(error);
        }
        onFinally() {
          if (this.errorHandler) {
            this.body.off("error", this.errorHandler);
            this.errorHandler = null;
          }
          if (this.endHandler) {
            this.body.off("end", this.endHandler);
            this.endHandler = null;
          }
        }
        // TODO: adjust to support H2
        addHeader(key, value) {
          processHeader(this, key, value);
          return this;
        }
        static [kHTTP1BuildRequest](origin, opts, handler2) {
          return new _Request(origin, opts, handler2);
        }
        static [kHTTP2BuildRequest](origin, opts, handler2) {
          const headers = opts.headers;
          opts = { ...opts, headers: null };
          const request2 = new _Request(origin, opts, handler2);
          request2.headers = {};
          if (Array.isArray(headers)) {
            if (headers.length % 2 !== 0) {
              throw new InvalidArgumentError("headers array must be even");
            }
            for (let i = 0; i < headers.length; i += 2) {
              processHeader(request2, headers[i], headers[i + 1], true);
            }
          } else if (headers && typeof headers === "object") {
            const keys = Object.keys(headers);
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              processHeader(request2, key, headers[key], true);
            }
          } else if (headers != null) {
            throw new InvalidArgumentError("headers must be an object or an array");
          }
          return request2;
        }
        static [kHTTP2CopyHeaders](raw) {
          const rawHeaders = raw.split("\r\n");
          const headers = {};
          for (const header of rawHeaders) {
            const [key, value] = header.split(": ");
            if (value == null || value.length === 0) continue;
            if (headers[key]) headers[key] += `,${value}`;
            else headers[key] = value;
          }
          return headers;
        }
      };
      function processHeaderValue(key, val, skipAppend) {
        if (val && typeof val === "object") {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        val = val != null ? `${val}` : "";
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        return skipAppend ? val : `${key}: ${val}\r
`;
      }
      function processHeader(request2, key, val, skipAppend = false) {
        if (val && (typeof val === "object" && !Array.isArray(val))) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        } else if (val === void 0) {
          return;
        }
        if (request2.host === null && key.length === 4 && key.toLowerCase() === "host") {
          if (headerCharRegex.exec(val) !== null) {
            throw new InvalidArgumentError(`invalid ${key} header`);
          }
          request2.host = val;
        } else if (request2.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
          request2.contentLength = parseInt(val, 10);
          if (!Number.isFinite(request2.contentLength)) {
            throw new InvalidArgumentError("invalid content-length header");
          }
        } else if (request2.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
          request2.contentType = val;
          if (skipAppend) request2.headers[key] = processHeaderValue(key, val, skipAppend);
          else request2.headers += processHeaderValue(key, val);
        } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
          throw new InvalidArgumentError("invalid transfer-encoding header");
        } else if (key.length === 10 && key.toLowerCase() === "connection") {
          const value = typeof val === "string" ? val.toLowerCase() : null;
          if (value !== "close" && value !== "keep-alive") {
            throw new InvalidArgumentError("invalid connection header");
          } else if (value === "close") {
            request2.reset = true;
          }
        } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
          throw new InvalidArgumentError("invalid keep-alive header");
        } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
          throw new InvalidArgumentError("invalid upgrade header");
        } else if (key.length === 6 && key.toLowerCase() === "expect") {
          throw new NotSupportedError("expect header not supported");
        } else if (tokenRegExp.exec(key) === null) {
          throw new InvalidArgumentError("invalid header key");
        } else {
          if (Array.isArray(val)) {
            for (let i = 0; i < val.length; i++) {
              if (skipAppend) {
                if (request2.headers[key]) request2.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
                else request2.headers[key] = processHeaderValue(key, val[i], skipAppend);
              } else {
                request2.headers += processHeaderValue(key, val[i]);
              }
            }
          } else {
            if (skipAppend) request2.headers[key] = processHeaderValue(key, val, skipAppend);
            else request2.headers += processHeaderValue(key, val);
          }
        }
      }
      module.exports = Request;
    }
  });

  // node_modules/undici/lib/dispatcher.js
  var require_dispatcher = __commonJS({
    "node_modules/undici/lib/dispatcher.js"(exports, module) {
      "use strict";
      var EventEmitter = __require("events");
      var Dispatcher = class extends EventEmitter {
        dispatch() {
          throw new Error("not implemented");
        }
        close() {
          throw new Error("not implemented");
        }
        destroy() {
          throw new Error("not implemented");
        }
      };
      module.exports = Dispatcher;
    }
  });

  // node_modules/undici/lib/dispatcher-base.js
  var require_dispatcher_base = __commonJS({
    "node_modules/undici/lib/dispatcher-base.js"(exports, module) {
      "use strict";
      var Dispatcher = require_dispatcher();
      var {
        ClientDestroyedError,
        ClientClosedError,
        InvalidArgumentError
      } = require_errors();
      var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
      var kDestroyed = Symbol("destroyed");
      var kClosed = Symbol("closed");
      var kOnDestroyed = Symbol("onDestroyed");
      var kOnClosed = Symbol("onClosed");
      var kInterceptedDispatch = Symbol("Intercepted Dispatch");
      var DispatcherBase = class extends Dispatcher {
        constructor() {
          super();
          this[kDestroyed] = false;
          this[kOnDestroyed] = null;
          this[kClosed] = false;
          this[kOnClosed] = [];
        }
        get destroyed() {
          return this[kDestroyed];
        }
        get closed() {
          return this[kClosed];
        }
        get interceptors() {
          return this[kInterceptors];
        }
        set interceptors(newInterceptors) {
          if (newInterceptors) {
            for (let i = newInterceptors.length - 1; i >= 0; i--) {
              const interceptor = this[kInterceptors][i];
              if (typeof interceptor !== "function") {
                throw new InvalidArgumentError("interceptor must be an function");
              }
            }
          }
          this[kInterceptors] = newInterceptors;
        }
        close(callback) {
          if (callback === void 0) {
            return new Promise((resolve, reject) => {
              this.close((err, data) => {
                return err ? reject(err) : resolve(data);
              });
            });
          }
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (this[kDestroyed]) {
            queueMicrotask(() => callback(new ClientDestroyedError(), null));
            return;
          }
          if (this[kClosed]) {
            if (this[kOnClosed]) {
              this[kOnClosed].push(callback);
            } else {
              queueMicrotask(() => callback(null, null));
            }
            return;
          }
          this[kClosed] = true;
          this[kOnClosed].push(callback);
          const onClosed = () => {
            const callbacks = this[kOnClosed];
            this[kOnClosed] = null;
            for (let i = 0; i < callbacks.length; i++) {
              callbacks[i](null, null);
            }
          };
          this[kClose]().then(() => this.destroy()).then(() => {
            queueMicrotask(onClosed);
          });
        }
        destroy(err, callback) {
          if (typeof err === "function") {
            callback = err;
            err = null;
          }
          if (callback === void 0) {
            return new Promise((resolve, reject) => {
              this.destroy(err, (err2, data) => {
                return err2 ? (
                  /* istanbul ignore next: should never error */
                  reject(err2)
                ) : resolve(data);
              });
            });
          }
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (this[kDestroyed]) {
            if (this[kOnDestroyed]) {
              this[kOnDestroyed].push(callback);
            } else {
              queueMicrotask(() => callback(null, null));
            }
            return;
          }
          if (!err) {
            err = new ClientDestroyedError();
          }
          this[kDestroyed] = true;
          this[kOnDestroyed] = this[kOnDestroyed] || [];
          this[kOnDestroyed].push(callback);
          const onDestroyed = () => {
            const callbacks = this[kOnDestroyed];
            this[kOnDestroyed] = null;
            for (let i = 0; i < callbacks.length; i++) {
              callbacks[i](null, null);
            }
          };
          this[kDestroy](err).then(() => {
            queueMicrotask(onDestroyed);
          });
        }
        [kInterceptedDispatch](opts, handler2) {
          if (!this[kInterceptors] || this[kInterceptors].length === 0) {
            this[kInterceptedDispatch] = this[kDispatch];
            return this[kDispatch](opts, handler2);
          }
          let dispatch = this[kDispatch].bind(this);
          for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
            dispatch = this[kInterceptors][i](dispatch);
          }
          this[kInterceptedDispatch] = dispatch;
          return dispatch(opts, handler2);
        }
        dispatch(opts, handler2) {
          if (!handler2 || typeof handler2 !== "object") {
            throw new InvalidArgumentError("handler must be an object");
          }
          try {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("opts must be an object.");
            }
            if (this[kDestroyed] || this[kOnDestroyed]) {
              throw new ClientDestroyedError();
            }
            if (this[kClosed]) {
              throw new ClientClosedError();
            }
            return this[kInterceptedDispatch](opts, handler2);
          } catch (err) {
            if (typeof handler2.onError !== "function") {
              throw new InvalidArgumentError("invalid onError method");
            }
            handler2.onError(err);
            return false;
          }
        }
      };
      module.exports = DispatcherBase;
    }
  });

  // node_modules/undici/lib/core/connect.js
  var require_connect = __commonJS({
    "node_modules/undici/lib/core/connect.js"(exports, module) {
      "use strict";
      var net = __require("net");
      var assert = __require("assert");
      var util = require_util();
      var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
      var tls;
      var SessionCache;
      if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
        SessionCache = class WeakSessionCache {
          constructor(maxCachedSessions) {
            this._maxCachedSessions = maxCachedSessions;
            this._sessionCache = /* @__PURE__ */ new Map();
            this._sessionRegistry = new global.FinalizationRegistry((key) => {
              if (this._sessionCache.size < this._maxCachedSessions) {
                return;
              }
              const ref = this._sessionCache.get(key);
              if (ref !== void 0 && ref.deref() === void 0) {
                this._sessionCache.delete(key);
              }
            });
          }
          get(sessionKey) {
            const ref = this._sessionCache.get(sessionKey);
            return ref ? ref.deref() : null;
          }
          set(sessionKey, session) {
            if (this._maxCachedSessions === 0) {
              return;
            }
            this._sessionCache.set(sessionKey, new WeakRef(session));
            this._sessionRegistry.register(session, sessionKey);
          }
        };
      } else {
        SessionCache = class SimpleSessionCache {
          constructor(maxCachedSessions) {
            this._maxCachedSessions = maxCachedSessions;
            this._sessionCache = /* @__PURE__ */ new Map();
          }
          get(sessionKey) {
            return this._sessionCache.get(sessionKey);
          }
          set(sessionKey, session) {
            if (this._maxCachedSessions === 0) {
              return;
            }
            if (this._sessionCache.size >= this._maxCachedSessions) {
              const { value: oldestKey } = this._sessionCache.keys().next();
              this._sessionCache.delete(oldestKey);
            }
            this._sessionCache.set(sessionKey, session);
          }
        };
      }
      function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
        if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
          throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
        }
        const options = { path: socketPath, ...opts };
        const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
        timeout = timeout == null ? 1e4 : timeout;
        allowH2 = allowH2 != null ? allowH2 : false;
        return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
          let socket;
          if (protocol === "https:") {
            if (!tls) {
              tls = __require("tls");
            }
            servername = servername || options.servername || util.getServerName(host) || null;
            const sessionKey = servername || hostname;
            const session = sessionCache.get(sessionKey) || null;
            assert(sessionKey);
            socket = tls.connect({
              highWaterMark: 16384,
              // TLS in node can't have bigger HWM anyway...
              ...options,
              servername,
              session,
              localAddress,
              // TODO(HTTP/2): Add support for h2c
              ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
              socket: httpSocket,
              // upgrade socket connection
              port: port || 443,
              host: hostname
            });
            socket.on("session", function(session2) {
              sessionCache.set(sessionKey, session2);
            });
          } else {
            assert(!httpSocket, "httpSocket can only be sent on TLS update");
            socket = net.connect({
              highWaterMark: 64 * 1024,
              // Same as nodejs fs streams.
              ...options,
              localAddress,
              port: port || 80,
              host: hostname
            });
          }
          if (options.keepAlive == null || options.keepAlive) {
            const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
            socket.setKeepAlive(true, keepAliveInitialDelay);
          }
          const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
          socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
            cancelTimeout();
            if (callback) {
              const cb = callback;
              callback = null;
              cb(null, this);
            }
          }).on("error", function(err) {
            cancelTimeout();
            if (callback) {
              const cb = callback;
              callback = null;
              cb(err);
            }
          });
          return socket;
        };
      }
      function setupTimeout(onConnectTimeout2, timeout) {
        if (!timeout) {
          return () => {
          };
        }
        let s1 = null;
        let s2 = null;
        const timeoutId = setTimeout(() => {
          s1 = setImmediate(() => {
            if (process.platform === "win32") {
              s2 = setImmediate(() => onConnectTimeout2());
            } else {
              onConnectTimeout2();
            }
          });
        }, timeout);
        return () => {
          clearTimeout(timeoutId);
          clearImmediate(s1);
          clearImmediate(s2);
        };
      }
      function onConnectTimeout(socket) {
        util.destroy(socket, new ConnectTimeoutError());
      }
      module.exports = buildConnector;
    }
  });

  // node_modules/undici/lib/llhttp/utils.js
  var require_utils2 = __commonJS({
    "node_modules/undici/lib/llhttp/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.enumToMap = void 0;
      function enumToMap(obj) {
        const res = {};
        Object.keys(obj).forEach((key) => {
          const value = obj[key];
          if (typeof value === "number") {
            res[key] = value;
          }
        });
        return res;
      }
      exports.enumToMap = enumToMap;
    }
  });

  // node_modules/undici/lib/llhttp/constants.js
  var require_constants3 = __commonJS({
    "node_modules/undici/lib/llhttp/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
      var utils_1 = require_utils2();
      var ERROR;
      (function(ERROR2) {
        ERROR2[ERROR2["OK"] = 0] = "OK";
        ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
        ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
        ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
        ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
        ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
        ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
        ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
        ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
        ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
        ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
        ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
        ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
        ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
        ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
        ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
        ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
        ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
        ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
        ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
        ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
        ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
        ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
        ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
        ERROR2[ERROR2["USER"] = 24] = "USER";
      })(ERROR = exports.ERROR || (exports.ERROR = {}));
      var TYPE;
      (function(TYPE2) {
        TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
        TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
        TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
      })(TYPE = exports.TYPE || (exports.TYPE = {}));
      var FLAGS;
      (function(FLAGS2) {
        FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
        FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
        FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
        FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
        FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
        FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
        FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
        FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
        FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
      })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
      var LENIENT_FLAGS;
      (function(LENIENT_FLAGS2) {
        LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
        LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
        LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
      })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
      var METHODS;
      (function(METHODS2) {
        METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
        METHODS2[METHODS2["GET"] = 1] = "GET";
        METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
        METHODS2[METHODS2["POST"] = 3] = "POST";
        METHODS2[METHODS2["PUT"] = 4] = "PUT";
        METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
        METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
        METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
        METHODS2[METHODS2["COPY"] = 8] = "COPY";
        METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
        METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
        METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
        METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
        METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
        METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
        METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
        METHODS2[METHODS2["BIND"] = 16] = "BIND";
        METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
        METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
        METHODS2[METHODS2["ACL"] = 19] = "ACL";
        METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
        METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
        METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
        METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
        METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
        METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
        METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
        METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
        METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
        METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
        METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
        METHODS2[METHODS2["LINK"] = 31] = "LINK";
        METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
        METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
        METHODS2[METHODS2["PRI"] = 34] = "PRI";
        METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
        METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
        METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
        METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
        METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
        METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
        METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
        METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
        METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
        METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
        METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
      })(METHODS = exports.METHODS || (exports.METHODS = {}));
      exports.METHODS_HTTP = [
        METHODS.DELETE,
        METHODS.GET,
        METHODS.HEAD,
        METHODS.POST,
        METHODS.PUT,
        METHODS.CONNECT,
        METHODS.OPTIONS,
        METHODS.TRACE,
        METHODS.COPY,
        METHODS.LOCK,
        METHODS.MKCOL,
        METHODS.MOVE,
        METHODS.PROPFIND,
        METHODS.PROPPATCH,
        METHODS.SEARCH,
        METHODS.UNLOCK,
        METHODS.BIND,
        METHODS.REBIND,
        METHODS.UNBIND,
        METHODS.ACL,
        METHODS.REPORT,
        METHODS.MKACTIVITY,
        METHODS.CHECKOUT,
        METHODS.MERGE,
        METHODS["M-SEARCH"],
        METHODS.NOTIFY,
        METHODS.SUBSCRIBE,
        METHODS.UNSUBSCRIBE,
        METHODS.PATCH,
        METHODS.PURGE,
        METHODS.MKCALENDAR,
        METHODS.LINK,
        METHODS.UNLINK,
        METHODS.PRI,
        // TODO(indutny): should we allow it with HTTP?
        METHODS.SOURCE
      ];
      exports.METHODS_ICE = [
        METHODS.SOURCE
      ];
      exports.METHODS_RTSP = [
        METHODS.OPTIONS,
        METHODS.DESCRIBE,
        METHODS.ANNOUNCE,
        METHODS.SETUP,
        METHODS.PLAY,
        METHODS.PAUSE,
        METHODS.TEARDOWN,
        METHODS.GET_PARAMETER,
        METHODS.SET_PARAMETER,
        METHODS.REDIRECT,
        METHODS.RECORD,
        METHODS.FLUSH,
        // For AirPlay
        METHODS.GET,
        METHODS.POST
      ];
      exports.METHOD_MAP = utils_1.enumToMap(METHODS);
      exports.H_METHOD_MAP = {};
      Object.keys(exports.METHOD_MAP).forEach((key) => {
        if (/^H/.test(key)) {
          exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
        }
      });
      var FINISH;
      (function(FINISH2) {
        FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
        FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
        FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
      })(FINISH = exports.FINISH || (exports.FINISH = {}));
      exports.ALPHA = [];
      for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
        exports.ALPHA.push(String.fromCharCode(i));
        exports.ALPHA.push(String.fromCharCode(i + 32));
      }
      exports.NUM_MAP = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9
      };
      exports.HEX_MAP = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15
      };
      exports.NUM = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9"
      ];
      exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
      exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
      exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
      exports.STRICT_URL_CHAR = [
        "!",
        '"',
        "$",
        "%",
        "&",
        "'",
        "(",
        ")",
        "*",
        "+",
        ",",
        "-",
        ".",
        "/",
        ":",
        ";",
        "<",
        "=",
        ">",
        "@",
        "[",
        "\\",
        "]",
        "^",
        "_",
        "`",
        "{",
        "|",
        "}",
        "~"
      ].concat(exports.ALPHANUM);
      exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
      for (let i = 128; i <= 255; i++) {
        exports.URL_CHAR.push(i);
      }
      exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
      exports.STRICT_TOKEN = [
        "!",
        "#",
        "$",
        "%",
        "&",
        "'",
        "*",
        "+",
        "-",
        ".",
        "^",
        "_",
        "`",
        "|",
        "~"
      ].concat(exports.ALPHANUM);
      exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
      exports.HEADER_CHARS = ["	"];
      for (let i = 32; i <= 255; i++) {
        if (i !== 127) {
          exports.HEADER_CHARS.push(i);
        }
      }
      exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
      exports.MAJOR = exports.NUM_MAP;
      exports.MINOR = exports.MAJOR;
      var HEADER_STATE;
      (function(HEADER_STATE2) {
        HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
        HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
        HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
        HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
        HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
        HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
        HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
        HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
        HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
      })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
      exports.SPECIAL_HEADERS = {
        "connection": HEADER_STATE.CONNECTION,
        "content-length": HEADER_STATE.CONTENT_LENGTH,
        "proxy-connection": HEADER_STATE.CONNECTION,
        "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
        "upgrade": HEADER_STATE.UPGRADE
      };
    }
  });

  // node_modules/undici/lib/handler/RedirectHandler.js
  var require_RedirectHandler = __commonJS({
    "node_modules/undici/lib/handler/RedirectHandler.js"(exports, module) {
      "use strict";
      var util = require_util();
      var { kBodyUsed } = require_symbols();
      var assert = __require("assert");
      var { InvalidArgumentError } = require_errors();
      var EE = __require("events");
      var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
      var kBody = Symbol("body");
      var BodyAsyncIterable = class {
        constructor(body) {
          this[kBody] = body;
          this[kBodyUsed] = false;
        }
        async *[Symbol.asyncIterator]() {
          assert(!this[kBodyUsed], "disturbed");
          this[kBodyUsed] = true;
          yield* this[kBody];
        }
      };
      var RedirectHandler = class {
        constructor(dispatch, maxRedirections, opts, handler2) {
          if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
            throw new InvalidArgumentError("maxRedirections must be a positive number");
          }
          util.validateHandler(handler2, opts.method, opts.upgrade);
          this.dispatch = dispatch;
          this.location = null;
          this.abort = null;
          this.opts = { ...opts, maxRedirections: 0 };
          this.maxRedirections = maxRedirections;
          this.handler = handler2;
          this.history = [];
          if (util.isStream(this.opts.body)) {
            if (util.bodyLength(this.opts.body) === 0) {
              this.opts.body.on("data", function() {
                assert(false);
              });
            }
            if (typeof this.opts.body.readableDidRead !== "boolean") {
              this.opts.body[kBodyUsed] = false;
              EE.prototype.on.call(this.opts.body, "data", function() {
                this[kBodyUsed] = true;
              });
            }
          } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
            this.opts.body = new BodyAsyncIterable(this.opts.body);
          } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
            this.opts.body = new BodyAsyncIterable(this.opts.body);
          }
        }
        onConnect(abort) {
          this.abort = abort;
          this.handler.onConnect(abort, { history: this.history });
        }
        onUpgrade(statusCode, headers, socket) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
        onError(error) {
          this.handler.onError(error);
        }
        onHeaders(statusCode, headers, resume, statusText) {
          this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
          if (this.opts.origin) {
            this.history.push(new URL(this.opts.path, this.opts.origin));
          }
          if (!this.location) {
            return this.handler.onHeaders(statusCode, headers, resume, statusText);
          }
          const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
          const path = search ? `${pathname}${search}` : pathname;
          this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
          this.opts.path = path;
          this.opts.origin = origin;
          this.opts.maxRedirections = 0;
          this.opts.query = null;
          if (statusCode === 303 && this.opts.method !== "HEAD") {
            this.opts.method = "GET";
            this.opts.body = null;
          }
        }
        onData(chunk) {
          if (this.location) {
          } else {
            return this.handler.onData(chunk);
          }
        }
        onComplete(trailers) {
          if (this.location) {
            this.location = null;
            this.abort = null;
            this.dispatch(this.opts, this);
          } else {
            this.handler.onComplete(trailers);
          }
        }
        onBodySent(chunk) {
          if (this.handler.onBodySent) {
            this.handler.onBodySent(chunk);
          }
        }
      };
      function parseLocation(statusCode, headers) {
        if (redirectableStatusCodes.indexOf(statusCode) === -1) {
          return null;
        }
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toString().toLowerCase() === "location") {
            return headers[i + 1];
          }
        }
      }
      function shouldRemoveHeader(header, removeContent, unknownOrigin) {
        if (header.length === 4) {
          return util.headerNameToString(header) === "host";
        }
        if (removeContent && util.headerNameToString(header).startsWith("content-")) {
          return true;
        }
        if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
          const name = util.headerNameToString(header);
          return name === "authorization" || name === "cookie" || name === "proxy-authorization";
        }
        return false;
      }
      function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
        const ret = [];
        if (Array.isArray(headers)) {
          for (let i = 0; i < headers.length; i += 2) {
            if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
              ret.push(headers[i], headers[i + 1]);
            }
          }
        } else if (headers && typeof headers === "object") {
          for (const key of Object.keys(headers)) {
            if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
              ret.push(key, headers[key]);
            }
          }
        } else {
          assert(headers == null, "headers must be an object or an array");
        }
        return ret;
      }
      module.exports = RedirectHandler;
    }
  });

  // node_modules/undici/lib/interceptor/redirectInterceptor.js
  var require_redirectInterceptor = __commonJS({
    "node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports, module) {
      "use strict";
      var RedirectHandler = require_RedirectHandler();
      function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
        return (dispatch) => {
          return function Intercept(opts, handler2) {
            const { maxRedirections = defaultMaxRedirections } = opts;
            if (!maxRedirections) {
              return dispatch(opts, handler2);
            }
            const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler2);
            opts = { ...opts, maxRedirections: 0 };
            return dispatch(opts, redirectHandler);
          };
        };
      }
      module.exports = createRedirectInterceptor;
    }
  });

  // node_modules/undici/lib/llhttp/llhttp-wasm.js
  var require_llhttp_wasm = __commonJS({
    "node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports, module) {
      module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
    }
  });

  // node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
  var require_llhttp_simd_wasm = __commonJS({
    "node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports, module) {
      module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB4fICEjJSg/QEFERUZHSElKS0xNT1BRUlPeA1dZW1xdYGJlZmdoaWprbG1vcHFyc3R1dnd4eXp7fH1+gAGCAYUBhgGHAYkBiwGMAY0BjgGPAZABkQGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMBmQKkArAC/gL+AgsgASIEIAJHDfMBQd0BIRAM/wMLIAEiECACRw3dAUHDASEQDP4DCyABIgEgAkcNkAFB9wAhEAz9AwsgASIBIAJHDYYBQe8AIRAM/AMLIAEiASACRw1/QeoAIRAM+wMLIAEiASACRw17QegAIRAM+gMLIAEiASACRw14QeYAIRAM+QMLIAEiASACRw0aQRghEAz4AwsgASIBIAJHDRRBEiEQDPcDCyABIgEgAkcNWUHFACEQDPYDCyABIgEgAkcNSkE/IRAM9QMLIAEiASACRw1IQTwhEAz0AwsgASIBIAJHDUFBMSEQDPMDCyAALQAuQQFGDesDDIcCCyAAIAEiASACEMCAgIAAQQFHDeYBIABCADcDIAznAQsgACABIgEgAhC0gICAACIQDecBIAEhAQz1AgsCQCABIgEgAkcNAEEGIRAM8AMLIAAgAUEBaiIBIAIQu4CAgAAiEA3oASABIQEMMQsgAEIANwMgQRIhEAzVAwsgASIQIAJHDStBHSEQDO0DCwJAIAEiASACRg0AIAFBAWohAUEQIRAM1AMLQQchEAzsAwsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3lAUEIIRAM6wMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRQhEAzSAwtBCSEQDOoDCyABIQEgACkDIFAN5AEgASEBDPICCwJAIAEiASACRw0AQQshEAzpAwsgACABQQFqIgEgAhC2gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeYBIAEhAQwNCyAAIAEiASACELqAgIAAIhAN5wEgASEBDPACCwJAIAEiASACRw0AQQ8hEAzlAwsgAS0AACIQQTtGDQggEEENRw3oASABQQFqIQEM7wILIAAgASIBIAIQuoCAgAAiEA3oASABIQEM8gILA0ACQCABLQAAQfC1gIAAai0AACIQQQFGDQAgEEECRw3rASAAKAIEIRAgAEEANgIEIAAgECABQQFqIgEQuYCAgAAiEA3qASABIQEM9AILIAFBAWoiASACRw0AC0ESIRAM4gMLIAAgASIBIAIQuoCAgAAiEA3pASABIQEMCgsgASIBIAJHDQZBGyEQDOADCwJAIAEiASACRw0AQRYhEAzgAwsgAEGKgICAADYCCCAAIAE2AgQgACABIAIQuICAgAAiEA3qASABIQFBICEQDMYDCwJAIAEiASACRg0AA0ACQCABLQAAQfC3gIAAai0AACIQQQJGDQACQCAQQX9qDgTlAewBAOsB7AELIAFBAWohAUEIIRAMyAMLIAFBAWoiASACRw0AC0EVIRAM3wMLQRUhEAzeAwsDQAJAIAEtAABB8LmAgABqLQAAIhBBAkYNACAQQX9qDgTeAewB4AHrAewBCyABQQFqIgEgAkcNAAtBGCEQDN0DCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUEHIRAMxAMLQRkhEAzcAwsgAUEBaiEBDAILAkAgASIUIAJHDQBBGiEQDNsDCyAUIQECQCAULQAAQXNqDhTdAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAgDuAgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQM2gMLAkAgAS0AACIQQTtGDQAgEEENRw3oASABQQFqIQEM5QILIAFBAWohAQtBIiEQDL8DCwJAIAEiECACRw0AQRwhEAzYAwtCACERIBAhASAQLQAAQVBqDjfnAeYBAQIDBAUGBwgAAAAAAAAACQoLDA0OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEBESExQAC0EeIRAMvQMLQgIhEQzlAQtCAyERDOQBC0IEIREM4wELQgUhEQziAQtCBiERDOEBC0IHIREM4AELQgghEQzfAQtCCSERDN4BC0IKIREM3QELQgshEQzcAQtCDCERDNsBC0INIREM2gELQg4hEQzZAQtCDyERDNgBC0IKIREM1wELQgshEQzWAQtCDCERDNUBC0INIREM1AELQg4hEQzTAQtCDyERDNIBC0IAIRECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAtAABBUGoON+UB5AEAAQIDBAUGB+YB5gHmAeYB5gHmAeYBCAkKCwwN5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAQ4PEBESE+YBC0ICIREM5AELQgMhEQzjAQtCBCERDOIBC0IFIREM4QELQgYhEQzgAQtCByERDN8BC0IIIREM3gELQgkhEQzdAQtCCiERDNwBC0ILIREM2wELQgwhEQzaAQtCDSERDNkBC0IOIREM2AELQg8hEQzXAQtCCiERDNYBC0ILIREM1QELQgwhEQzUAQtCDSERDNMBC0IOIREM0gELQg8hEQzRAQsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3SAUEfIRAMwAMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQSQhEAynAwtBICEQDL8DCyAAIAEiECACEL6AgIAAQX9qDgW2AQDFAgHRAdIBC0ERIRAMpAMLIABBAToALyAQIQEMuwMLIAEiASACRw3SAUEkIRAMuwMLIAEiDSACRw0eQcYAIRAMugMLIAAgASIBIAIQsoCAgAAiEA3UASABIQEMtQELIAEiECACRw0mQdAAIRAMuAMLAkAgASIBIAJHDQBBKCEQDLgDCyAAQQA2AgQgAEGMgICAADYCCCAAIAEgARCxgICAACIQDdMBIAEhAQzYAQsCQCABIhAgAkcNAEEpIRAMtwMLIBAtAAAiAUEgRg0UIAFBCUcN0wEgEEEBaiEBDBULAkAgASIBIAJGDQAgAUEBaiEBDBcLQSohEAy1AwsCQCABIhAgAkcNAEErIRAMtQMLAkAgEC0AACIBQQlGDQAgAUEgRw3VAQsgAC0ALEEIRg3TASAQIQEMkQMLAkAgASIBIAJHDQBBLCEQDLQDCyABLQAAQQpHDdUBIAFBAWohAQzJAgsgASIOIAJHDdUBQS8hEAyyAwsDQAJAIAEtAAAiEEEgRg0AAkAgEEF2ag4EANwB3AEA2gELIAEhAQzgAQsgAUEBaiIBIAJHDQALQTEhEAyxAwtBMiEQIAEiFCACRg2wAyACIBRrIAAoAgAiAWohFSAUIAFrQQNqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BAkAgAUEDRw0AQQYhAQyWAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMsQMLIABBADYCACAUIQEM2QELQTMhECABIhQgAkYNrwMgAiAUayAAKAIAIgFqIRUgFCABa0EIaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNAQJAIAFBCEcNAEEFIQEMlQMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLADCyAAQQA2AgAgFCEBDNgBC0E0IRAgASIUIAJGDa4DIAIgFGsgACgCACIBaiEVIBQgAWtBBWohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUHQwoCAAGotAABHDQECQCABQQVHDQBBByEBDJQDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAyvAwsgAEEANgIAIBQhAQzXAQsCQCABIgEgAkYNAANAAkAgAS0AAEGAvoCAAGotAAAiEEEBRg0AIBBBAkYNCiABIQEM3QELIAFBAWoiASACRw0AC0EwIRAMrgMLQTAhEAytAwsCQCABIgEgAkYNAANAAkAgAS0AACIQQSBGDQAgEEF2ag4E2QHaAdoB2QHaAQsgAUEBaiIBIAJHDQALQTghEAytAwtBOCEQDKwDCwNAAkAgAS0AACIQQSBGDQAgEEEJRw0DCyABQQFqIgEgAkcNAAtBPCEQDKsDCwNAAkAgAS0AACIQQSBGDQACQAJAIBBBdmoOBNoBAQHaAQALIBBBLEYN2wELIAEhAQwECyABQQFqIgEgAkcNAAtBPyEQDKoDCyABIQEM2wELQcAAIRAgASIUIAJGDagDIAIgFGsgACgCACIBaiEWIBQgAWtBBmohFwJAA0AgFC0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDY4DIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADKkDCyAAQQA2AgAgFCEBC0E2IRAMjgMLAkAgASIPIAJHDQBBwQAhEAynAwsgAEGMgICAADYCCCAAIA82AgQgDyEBIAAtACxBf2oOBM0B1QHXAdkBhwMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIQQSByIBAgEEG/f2pB/wFxQRpJG0H/AXEiEEEJRg0AIBBBIEYNAAJAAkACQAJAIBBBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhEAyRAwsgAUEBaiEBQTIhEAyQAwsgAUEBaiEBQTMhEAyPAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEQDKUDC0E1IRAMpAMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNMBCyABQQFqIgEgAkcNAAtBPSEQDKQDC0E9IRAMowMLIAAgASIBIAIQsICAgAAiEA3WASABIQEMAQsgEEEBaiEBC0E8IRAMhwMLAkAgASIBIAJHDQBBwgAhEAygAwsCQANAAkAgAS0AAEF3ag4YAAL+Av4ChAP+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gIA/gILIAFBAWoiASACRw0AC0HCACEQDKADCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsIRAMhQMLIAEiASACRw3TAUHEACEQDJ0DCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMtwILIAFBAWoiASACRw0AC0HFACEQDJwDCyANLQAAIhBBIEYNswEgEEE6Rw2BAyAAKAIEIQEgAEEANgIEIAAgASANEK+AgIAAIgEN0AEgDUEBaiEBDLMCC0HHACEQIAEiDSACRg2aAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNgAMgAUEFRg30AiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyaAwtByAAhECABIg0gAkYNmQMgAiANayAAKAIAIgFqIRYgDSABa0EJaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDf8CAkAgAUEJRw0AQQIhAQz1AgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmQMLAkAgASINIAJHDQBByQAhEAyZAwsCQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIADgAOAA4ADgAMBgAMLIA1BAWohAUE+IRAMgAMLIA1BAWohAUE/IRAM/wILQcoAIRAgASINIAJGDZcDIAIgDWsgACgCACIBaiEWIA0gAWtBAWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw39AiABQQFGDfACIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJcDC0HLACEQIAEiDSACRg2WAyACIA1rIAAoAgAiAWohFiANIAFrQQ5qIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcN/AIgAUEORg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyWAwtBzAAhECABIg0gAkYNlQMgAiANayAAKAIAIgFqIRYgDSABa0EPaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDfsCAkAgAUEPRw0AQQMhAQzxAgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlQMLQc0AIRAgASINIAJGDZQDIAIgDWsgACgCACIBaiEWIA0gAWtBBWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw36AgJAIAFBBUcNAEEEIQEM8AILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJQDCwJAIAEiDSACRw0AQc4AIRAMlAMLAkACQAJAAkAgDS0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMA/QL9Av0C/QL9Av0C/QL9Av0C/QL9Av0CAf0C/QL9AgID/QILIA1BAWohAUHBACEQDP0CCyANQQFqIQFBwgAhEAz8AgsgDUEBaiEBQcMAIRAM+wILIA1BAWohAUHEACEQDPoCCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEQDPoCC0HPACEQDJIDCyAQIQECQAJAIBAtAABBdmoOBAGoAqgCAKgCCyAQQQFqIQELQSchEAz4AgsCQCABIgEgAkcNAEHRACEQDJEDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3HASABIQEMjAELIAEiFyACRw3IAUHSACEQDI8DC0HTACEQIAEiFCACRg2OAyACIBRrIAAoAgAiAWohFiAUIAFrQQFqIRcDQCAULQAAIAFB1sKAgABqLQAARw3MASABQQFGDccBIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADI4DCwJAIAEiASACRw0AQdUAIRAMjgMLIAEtAABBCkcNzAEgAUEBaiEBDMcBCwJAIAEiASACRw0AQdYAIRAMjQMLAkACQCABLQAAQXZqDgQAzQHNAQHNAQsgAUEBaiEBDMcBCyABQQFqIQFBygAhEAzzAgsgACABIgEgAhCugICAACIQDcsBIAEhAUHNACEQDPICCyAALQApQSJGDYUDDKYCCwJAIAEiASACRw0AQdsAIRAMigMLQQAhFEEBIRdBASEWQQAhEAJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrUAdMBAAECAwQFBgjVAQtBAiEQDAYLQQMhEAwFC0EEIRAMBAtBBSEQDAMLQQYhEAwCC0EHIRAMAQtBCCEQC0EAIRdBACEWQQAhFAzMAQtBCSEQQQEhFEEAIRdBACEWDMsBCwJAIAEiASACRw0AQd0AIRAMiQMLIAEtAABBLkcNzAEgAUEBaiEBDKYCCyABIgEgAkcNzAFB3wAhEAyHAwsCQCABIgEgAkYNACAAQY6AgIAANgIIIAAgATYCBCABIQFB0AAhEAzuAgtB4AAhEAyGAwtB4QAhECABIgEgAkYNhQMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQeLCgIAAai0AAEcNzQEgFEEDRg3MASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyFAwtB4gAhECABIgEgAkYNhAMgAiABayAAKAIAIhRqIRYgASAUa0ECaiEXA0AgAS0AACAUQebCgIAAai0AAEcNzAEgFEECRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyEAwtB4wAhECABIgEgAkYNgwMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQenCgIAAai0AAEcNywEgFEEDRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyDAwsCQCABIgEgAkcNAEHlACEQDIMDCyAAIAFBAWoiASACEKiAgIAAIhANzQEgASEBQdYAIRAM6QILAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AAkACQAJAIBBBuH9qDgsAAc8BzwHPAc8BzwHPAc8BzwECzwELIAFBAWohAUHSACEQDO0CCyABQQFqIQFB0wAhEAzsAgsgAUEBaiEBQdQAIRAM6wILIAFBAWoiASACRw0AC0HkACEQDIIDC0HkACEQDIEDCwNAAkAgAS0AAEHwwoCAAGotAAAiEEEBRg0AIBBBfmoOA88B0AHRAdIBCyABQQFqIgEgAkcNAAtB5gAhEAyAAwsCQCABIgEgAkYNACABQQFqIQEMAwtB5wAhEAz/AgsDQAJAIAEtAABB8MSAgABqLQAAIhBBAUYNAAJAIBBBfmoOBNIB0wHUAQDVAQsgASEBQdcAIRAM5wILIAFBAWoiASACRw0AC0HoACEQDP4CCwJAIAEiASACRw0AQekAIRAM/gILAkAgAS0AACIQQXZqDhq6AdUB1QG8AdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAcoB1QHVAQDTAQsgAUEBaiEBC0EGIRAM4wILA0ACQCABLQAAQfDGgIAAai0AAEEBRg0AIAEhAQyeAgsgAUEBaiIBIAJHDQALQeoAIRAM+wILAkAgASIBIAJGDQAgAUEBaiEBDAMLQesAIRAM+gILAkAgASIBIAJHDQBB7AAhEAz6AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB7QAhEAz5AgsgAUEBaiEBC0EEIRAM3gILAkAgASIUIAJHDQBB7gAhEAz3AgsgFCEBAkACQAJAIBQtAABB8MiAgABqLQAAQX9qDgfUAdUB1gEAnAIBAtcBCyAUQQFqIQEMCgsgFEEBaiEBDM0BC0EAIRAgAEEANgIcIABBm5KAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAz2AgsCQANAAkAgAS0AAEHwyICAAGotAAAiEEEERg0AAkACQCAQQX9qDgfSAdMB1AHZAQAEAdkBCyABIQFB2gAhEAzgAgsgAUEBaiEBQdwAIRAM3wILIAFBAWoiASACRw0AC0HvACEQDPYCCyABQQFqIQEMywELAkAgASIUIAJHDQBB8AAhEAz1AgsgFC0AAEEvRw3UASAUQQFqIQEMBgsCQCABIhQgAkcNAEHxACEQDPQCCwJAIBQtAAAiAUEvRw0AIBRBAWohAUHdACEQDNsCCyABQXZqIgRBFksN0wFBASAEdEGJgIACcUUN0wEMygILAkAgASIBIAJGDQAgAUEBaiEBQd4AIRAM2gILQfIAIRAM8gILAkAgASIUIAJHDQBB9AAhEAzyAgsgFCEBAkAgFC0AAEHwzICAAGotAABBf2oOA8kClAIA1AELQeEAIRAM2AILAkAgASIUIAJGDQADQAJAIBQtAABB8MqAgABqLQAAIgFBA0YNAAJAIAFBf2oOAssCANUBCyAUIQFB3wAhEAzaAgsgFEEBaiIUIAJHDQALQfMAIRAM8QILQfMAIRAM8AILAkAgASIBIAJGDQAgAEGPgICAADYCCCAAIAE2AgQgASEBQeAAIRAM1wILQfUAIRAM7wILAkAgASIBIAJHDQBB9gAhEAzvAgsgAEGPgICAADYCCCAAIAE2AgQgASEBC0EDIRAM1AILA0AgAS0AAEEgRw3DAiABQQFqIgEgAkcNAAtB9wAhEAzsAgsCQCABIgEgAkcNAEH4ACEQDOwCCyABLQAAQSBHDc4BIAFBAWohAQzvAQsgACABIgEgAhCsgICAACIQDc4BIAEhAQyOAgsCQCABIgQgAkcNAEH6ACEQDOoCCyAELQAAQcwARw3RASAEQQFqIQFBEyEQDM8BCwJAIAEiBCACRw0AQfsAIRAM6QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEANAIAQtAAAgAUHwzoCAAGotAABHDdABIAFBBUYNzgEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBB+wAhEAzoAgsCQCABIgQgAkcNAEH8ACEQDOgCCwJAAkAgBC0AAEG9f2oODADRAdEB0QHRAdEB0QHRAdEB0QHRAQHRAQsgBEEBaiEBQeYAIRAMzwILIARBAWohAUHnACEQDM4CCwJAIAEiBCACRw0AQf0AIRAM5wILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNzwEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf0AIRAM5wILIABBADYCACAQQQFqIQFBECEQDMwBCwJAIAEiBCACRw0AQf4AIRAM5gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQfbOgIAAai0AAEcNzgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf4AIRAM5gILIABBADYCACAQQQFqIQFBFiEQDMsBCwJAIAEiBCACRw0AQf8AIRAM5QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQfzOgIAAai0AAEcNzQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf8AIRAM5QILIABBADYCACAQQQFqIQFBBSEQDMoBCwJAIAEiBCACRw0AQYABIRAM5AILIAQtAABB2QBHDcsBIARBAWohAUEIIRAMyQELAkAgASIEIAJHDQBBgQEhEAzjAgsCQAJAIAQtAABBsn9qDgMAzAEBzAELIARBAWohAUHrACEQDMoCCyAEQQFqIQFB7AAhEAzJAgsCQCABIgQgAkcNAEGCASEQDOICCwJAAkAgBC0AAEG4f2oOCADLAcsBywHLAcsBywEBywELIARBAWohAUHqACEQDMkCCyAEQQFqIQFB7QAhEAzIAgsCQCABIgQgAkcNAEGDASEQDOECCyACIARrIAAoAgAiAWohECAEIAFrQQJqIRQCQANAIAQtAAAgAUGAz4CAAGotAABHDckBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgEDYCAEGDASEQDOECC0EAIRAgAEEANgIAIBRBAWohAQzGAQsCQCABIgQgAkcNAEGEASEQDOACCyACIARrIAAoAgAiAWohFCAEIAFrQQRqIRACQANAIAQtAAAgAUGDz4CAAGotAABHDcgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGEASEQDOACCyAAQQA2AgAgEEEBaiEBQSMhEAzFAQsCQCABIgQgAkcNAEGFASEQDN8CCwJAAkAgBC0AAEG0f2oOCADIAcgByAHIAcgByAEByAELIARBAWohAUHvACEQDMYCCyAEQQFqIQFB8AAhEAzFAgsCQCABIgQgAkcNAEGGASEQDN4CCyAELQAAQcUARw3FASAEQQFqIQEMgwILAkAgASIEIAJHDQBBhwEhEAzdAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBiM+AgABqLQAARw3FASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhwEhEAzdAgsgAEEANgIAIBBBAWohAUEtIRAMwgELAkAgASIEIAJHDQBBiAEhEAzcAgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw3EASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiAEhEAzcAgsgAEEANgIAIBBBAWohAUEpIRAMwQELAkAgASIBIAJHDQBBiQEhEAzbAgtBASEQIAEtAABB3wBHDcABIAFBAWohAQyBAgsCQCABIgQgAkcNAEGKASEQDNoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRADQCAELQAAIAFBjM+AgABqLQAARw3BASABQQFGDa8CIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYoBIRAM2QILAkAgASIEIAJHDQBBiwEhEAzZAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBjs+AgABqLQAARw3BASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiwEhEAzZAgsgAEEANgIAIBBBAWohAUECIRAMvgELAkAgASIEIAJHDQBBjAEhEAzYAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw3AASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjAEhEAzYAgsgAEEANgIAIBBBAWohAUEfIRAMvQELAkAgASIEIAJHDQBBjQEhEAzXAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8s+AgABqLQAARw2/ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjQEhEAzXAgsgAEEANgIAIBBBAWohAUEJIRAMvAELAkAgASIEIAJHDQBBjgEhEAzWAgsCQAJAIAQtAABBt39qDgcAvwG/Ab8BvwG/AQG/AQsgBEEBaiEBQfgAIRAMvQILIARBAWohAUH5ACEQDLwCCwJAIAEiBCACRw0AQY8BIRAM1QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQZHPgIAAai0AAEcNvQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY8BIRAM1QILIABBADYCACAQQQFqIQFBGCEQDLoBCwJAIAEiBCACRw0AQZABIRAM1AILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQZfPgIAAai0AAEcNvAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZABIRAM1AILIABBADYCACAQQQFqIQFBFyEQDLkBCwJAIAEiBCACRw0AQZEBIRAM0wILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQZrPgIAAai0AAEcNuwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZEBIRAM0wILIABBADYCACAQQQFqIQFBFSEQDLgBCwJAIAEiBCACRw0AQZIBIRAM0gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQaHPgIAAai0AAEcNugEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZIBIRAM0gILIABBADYCACAQQQFqIQFBHiEQDLcBCwJAIAEiBCACRw0AQZMBIRAM0QILIAQtAABBzABHDbgBIARBAWohAUEKIRAMtgELAkAgBCACRw0AQZQBIRAM0AILAkACQCAELQAAQb9/ag4PALkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB/gAhEAy3AgsgBEEBaiEBQf8AIRAMtgILAkAgBCACRw0AQZUBIRAMzwILAkACQCAELQAAQb9/ag4DALgBAbgBCyAEQQFqIQFB/QAhEAy2AgsgBEEBaiEEQYABIRAMtQILAkAgBCACRw0AQZYBIRAMzgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQafPgIAAai0AAEcNtgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZYBIRAMzgILIABBADYCACAQQQFqIQFBCyEQDLMBCwJAIAQgAkcNAEGXASEQDM0CCwJAAkACQAJAIAQtAABBU2oOIwC4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBAbgBuAG4AbgBuAECuAG4AbgBA7gBCyAEQQFqIQFB+wAhEAy2AgsgBEEBaiEBQfwAIRAMtQILIARBAWohBEGBASEQDLQCCyAEQQFqIQRBggEhEAyzAgsCQCAEIAJHDQBBmAEhEAzMAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBqc+AgABqLQAARw20ASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmAEhEAzMAgsgAEEANgIAIBBBAWohAUEZIRAMsQELAkAgBCACRw0AQZkBIRAMywILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQa7PgIAAai0AAEcNswEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZkBIRAMywILIABBADYCACAQQQFqIQFBBiEQDLABCwJAIAQgAkcNAEGaASEQDMoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG0z4CAAGotAABHDbIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGaASEQDMoCCyAAQQA2AgAgEEEBaiEBQRwhEAyvAQsCQCAEIAJHDQBBmwEhEAzJAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBts+AgABqLQAARw2xASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmwEhEAzJAgsgAEEANgIAIBBBAWohAUEnIRAMrgELAkAgBCACRw0AQZwBIRAMyAILAkACQCAELQAAQax/ag4CAAGxAQsgBEEBaiEEQYYBIRAMrwILIARBAWohBEGHASEQDK4CCwJAIAQgAkcNAEGdASEQDMcCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG4z4CAAGotAABHDa8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGdASEQDMcCCyAAQQA2AgAgEEEBaiEBQSYhEAysAQsCQCAEIAJHDQBBngEhEAzGAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBus+AgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBngEhEAzGAgsgAEEANgIAIBBBAWohAUEDIRAMqwELAkAgBCACRw0AQZ8BIRAMxQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNrQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ8BIRAMxQILIABBADYCACAQQQFqIQFBDCEQDKoBCwJAIAQgAkcNAEGgASEQDMQCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUG8z4CAAGotAABHDawBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGgASEQDMQCCyAAQQA2AgAgEEEBaiEBQQ0hEAypAQsCQCAEIAJHDQBBoQEhEAzDAgsCQAJAIAQtAABBun9qDgsArAGsAawBrAGsAawBrAGsAawBAawBCyAEQQFqIQRBiwEhEAyqAgsgBEEBaiEEQYwBIRAMqQILAkAgBCACRw0AQaIBIRAMwgILIAQtAABB0ABHDakBIARBAWohBAzpAQsCQCAEIAJHDQBBowEhEAzBAgsCQAJAIAQtAABBt39qDgcBqgGqAaoBqgGqAQCqAQsgBEEBaiEEQY4BIRAMqAILIARBAWohAUEiIRAMpgELAkAgBCACRw0AQaQBIRAMwAILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQcDPgIAAai0AAEcNqAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaQBIRAMwAILIABBADYCACAQQQFqIQFBHSEQDKUBCwJAIAQgAkcNAEGlASEQDL8CCwJAAkAgBC0AAEGuf2oOAwCoAQGoAQsgBEEBaiEEQZABIRAMpgILIARBAWohAUEEIRAMpAELAkAgBCACRw0AQaYBIRAMvgILAkACQAJAAkACQCAELQAAQb9/ag4VAKoBqgGqAaoBqgGqAaoBqgGqAaoBAaoBqgECqgGqAQOqAaoBBKoBCyAEQQFqIQRBiAEhEAyoAgsgBEEBaiEEQYkBIRAMpwILIARBAWohBEGKASEQDKYCCyAEQQFqIQRBjwEhEAylAgsgBEEBaiEEQZEBIRAMpAILAkAgBCACRw0AQacBIRAMvQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNpQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQacBIRAMvQILIABBADYCACAQQQFqIQFBESEQDKIBCwJAIAQgAkcNAEGoASEQDLwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHCz4CAAGotAABHDaQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGoASEQDLwCCyAAQQA2AgAgEEEBaiEBQSwhEAyhAQsCQCAEIAJHDQBBqQEhEAy7AgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBxc+AgABqLQAARw2jASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqQEhEAy7AgsgAEEANgIAIBBBAWohAUErIRAMoAELAkAgBCACRw0AQaoBIRAMugILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQcrPgIAAai0AAEcNogEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaoBIRAMugILIABBADYCACAQQQFqIQFBFCEQDJ8BCwJAIAQgAkcNAEGrASEQDLkCCwJAAkACQAJAIAQtAABBvn9qDg8AAQKkAaQBpAGkAaQBpAGkAaQBpAGkAaQBA6QBCyAEQQFqIQRBkwEhEAyiAgsgBEEBaiEEQZQBIRAMoQILIARBAWohBEGVASEQDKACCyAEQQFqIQRBlgEhEAyfAgsCQCAEIAJHDQBBrAEhEAy4AgsgBC0AAEHFAEcNnwEgBEEBaiEEDOABCwJAIAQgAkcNAEGtASEQDLcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHNz4CAAGotAABHDZ8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGtASEQDLcCCyAAQQA2AgAgEEEBaiEBQQ4hEAycAQsCQCAEIAJHDQBBrgEhEAy2AgsgBC0AAEHQAEcNnQEgBEEBaiEBQSUhEAybAQsCQCAEIAJHDQBBrwEhEAy1AgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw2dASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrwEhEAy1AgsgAEEANgIAIBBBAWohAUEqIRAMmgELAkAgBCACRw0AQbABIRAMtAILAkACQCAELQAAQat/ag4LAJ0BnQGdAZ0BnQGdAZ0BnQGdAQGdAQsgBEEBaiEEQZoBIRAMmwILIARBAWohBEGbASEQDJoCCwJAIAQgAkcNAEGxASEQDLMCCwJAAkAgBC0AAEG/f2oOFACcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAEBnAELIARBAWohBEGZASEQDJoCCyAEQQFqIQRBnAEhEAyZAgsCQCAEIAJHDQBBsgEhEAyyAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFB2c+AgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBsgEhEAyyAgsgAEEANgIAIBBBAWohAUEhIRAMlwELAkAgBCACRw0AQbMBIRAMsQILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQd3PgIAAai0AAEcNmQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbMBIRAMsQILIABBADYCACAQQQFqIQFBGiEQDJYBCwJAIAQgAkcNAEG0ASEQDLACCwJAAkACQCAELQAAQbt/ag4RAJoBmgGaAZoBmgGaAZoBmgGaAQGaAZoBmgGaAZoBApoBCyAEQQFqIQRBnQEhEAyYAgsgBEEBaiEEQZ4BIRAMlwILIARBAWohBEGfASEQDJYCCwJAIAQgAkcNAEG1ASEQDK8CCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUHkz4CAAGotAABHDZcBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG1ASEQDK8CCyAAQQA2AgAgEEEBaiEBQSghEAyUAQsCQCAEIAJHDQBBtgEhEAyuAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB6s+AgABqLQAARw2WASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtgEhEAyuAgsgAEEANgIAIBBBAWohAUEHIRAMkwELAkAgBCACRw0AQbcBIRAMrQILAkACQCAELQAAQbt/ag4OAJYBlgGWAZYBlgGWAZYBlgGWAZYBlgGWAQGWAQsgBEEBaiEEQaEBIRAMlAILIARBAWohBEGiASEQDJMCCwJAIAQgAkcNAEG4ASEQDKwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDZQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG4ASEQDKwCCyAAQQA2AgAgEEEBaiEBQRIhEAyRAQsCQCAEIAJHDQBBuQEhEAyrAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw2TASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuQEhEAyrAgsgAEEANgIAIBBBAWohAUEgIRAMkAELAkAgBCACRw0AQboBIRAMqgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQboBIRAMqgILIABBADYCACAQQQFqIQFBDyEQDI8BCwJAIAQgAkcNAEG7ASEQDKkCCwJAAkAgBC0AAEG3f2oOBwCSAZIBkgGSAZIBAZIBCyAEQQFqIQRBpQEhEAyQAgsgBEEBaiEEQaYBIRAMjwILAkAgBCACRw0AQbwBIRAMqAILIAIgBGsgACgCACIBaiEUIAQgAWtBB2ohEAJAA0AgBC0AACABQfTPgIAAai0AAEcNkAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbwBIRAMqAILIABBADYCACAQQQFqIQFBGyEQDI0BCwJAIAQgAkcNAEG9ASEQDKcCCwJAAkACQCAELQAAQb5/ag4SAJEBkQGRAZEBkQGRAZEBkQGRAQGRAZEBkQGRAZEBkQECkQELIARBAWohBEGkASEQDI8CCyAEQQFqIQRBpwEhEAyOAgsgBEEBaiEEQagBIRAMjQILAkAgBCACRw0AQb4BIRAMpgILIAQtAABBzgBHDY0BIARBAWohBAzPAQsCQCAEIAJHDQBBvwEhEAylAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA5wBBAUGnAGcAZwBBwgJCgucAQwNDg+cAQsgBEEBaiEBQegAIRAMmgILIARBAWohAUHpACEQDJkCCyAEQQFqIQFB7gAhEAyYAgsgBEEBaiEBQfIAIRAMlwILIARBAWohAUHzACEQDJYCCyAEQQFqIQFB9gAhEAyVAgsgBEEBaiEBQfcAIRAMlAILIARBAWohAUH6ACEQDJMCCyAEQQFqIQRBgwEhEAySAgsgBEEBaiEEQYQBIRAMkQILIARBAWohBEGFASEQDJACCyAEQQFqIQRBkgEhEAyPAgsgBEEBaiEEQZgBIRAMjgILIARBAWohBEGgASEQDI0CCyAEQQFqIQRBowEhEAyMAgsgBEEBaiEEQaoBIRAMiwILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBIRAMiwILQcABIRAMowILIAAgBSACEKqAgIAAIgENiwEgBSEBDFwLAkAgBiACRg0AIAZBAWohBQyNAQtBwgEhEAyhAgsDQAJAIBAtAABBdmoOBIwBAACPAQALIBBBAWoiECACRw0AC0HDASEQDKACCwJAIAcgAkYNACAAQZGAgIAANgIIIAAgBzYCBCAHIQFBASEQDIcCC0HEASEQDJ8CCwJAIAcgAkcNAEHFASEQDJ8CCwJAAkAgBy0AAEF2ag4EAc4BzgEAzgELIAdBAWohBgyNAQsgB0EBaiEFDIkBCwJAIAcgAkcNAEHGASEQDJ4CCwJAAkAgBy0AAEF2ag4XAY8BjwEBjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAI8BCyAHQQFqIQcLQbABIRAMhAILAkAgCCACRw0AQcgBIRAMnQILIAgtAABBIEcNjQEgAEEAOwEyIAhBAWohAUGzASEQDIMCCyABIRcCQANAIBciByACRg0BIActAABBUGpB/wFxIhBBCk8NzAECQCAALwEyIhRBmTNLDQAgACAUQQpsIhQ7ATIgEEH//wNzIBRB/v8DcUkNACAHQQFqIRcgACAUIBBqIhA7ATIgEEH//wNxQegHSQ0BCwtBACEQIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIAdBAWo2AhQMnAILQccBIRAMmwILIAAgCCACEK6AgIAAIhBFDcoBIBBBFUcNjAEgAEHIATYCHCAAIAg2AhQgAEHJl4CAADYCECAAQRU2AgxBACEQDJoCCwJAIAkgAkcNAEHMASEQDJoCC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgCS0AAEFQag4KlgGVAQABAgMEBQYIlwELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMjgELQQkhEEEBIRRBACEXQQAhFgyNAQsCQCAKIAJHDQBBzgEhEAyZAgsgCi0AAEEuRw2OASAKQQFqIQkMygELIAsgAkcNjgFB0AEhEAyXAgsCQCALIAJGDQAgAEGOgICAADYCCCAAIAs2AgRBtwEhEAz+AQtB0QEhEAyWAgsCQCAEIAJHDQBB0gEhEAyWAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EEaiELA0AgBC0AACAQQfzPgIAAai0AAEcNjgEgEEEERg3pASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHSASEQDJUCCyAAIAwgAhCsgICAACIBDY0BIAwhAQy4AQsCQCAEIAJHDQBB1AEhEAyUAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EBaiEMA0AgBC0AACAQQYHQgIAAai0AAEcNjwEgEEEBRg2OASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHUASEQDJMCCwJAIAQgAkcNAEHWASEQDJMCCyACIARrIAAoAgAiEGohFCAEIBBrQQJqIQsDQCAELQAAIBBBg9CAgABqLQAARw2OASAQQQJGDZABIBBBAWohECAEQQFqIgQgAkcNAAsgACAUNgIAQdYBIRAMkgILAkAgBCACRw0AQdcBIRAMkgILAkACQCAELQAAQbt/ag4QAI8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwEBjwELIARBAWohBEG7ASEQDPkBCyAEQQFqIQRBvAEhEAz4AQsCQCAEIAJHDQBB2AEhEAyRAgsgBC0AAEHIAEcNjAEgBEEBaiEEDMQBCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEG+ASEQDPcBC0HZASEQDI8CCwJAIAQgAkcNAEHaASEQDI8CCyAELQAAQcgARg3DASAAQQE6ACgMuQELIABBAjoALyAAIAQgAhCmgICAACIQDY0BQcIBIRAM9AELIAAtAChBf2oOArcBuQG4AQsDQAJAIAQtAABBdmoOBACOAY4BAI4BCyAEQQFqIgQgAkcNAAtB3QEhEAyLAgsgAEEAOgAvIAAtAC1BBHFFDYQCCyAAQQA6AC8gAEEBOgA0IAEhAQyMAQsgEEEVRg3aASAAQQA2AhwgACABNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAyIAgsCQCAAIBAgAhC0gICAACIEDQAgECEBDIECCwJAIARBFUcNACAAQQM2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAyIAgsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMhwILIBBBFUYN1gEgAEEANgIcIAAgATYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMhgILIAAoAgQhFyAAQQA2AgQgECARp2oiFiEBIAAgFyAQIBYgFBsiEBC1gICAACIURQ2NASAAQQc2AhwgACAQNgIUIAAgFDYCDEEAIRAMhQILIAAgAC8BMEGAAXI7ATAgASEBC0EqIRAM6gELIBBBFUYN0QEgAEEANgIcIAAgATYCFCAAQYOMgIAANgIQIABBEzYCDEEAIRAMggILIBBBFUYNzwEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAMgQILIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDI0BCyAAQQw2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMgAILIBBBFUYNzAEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM/wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIwBCyAAQQ02AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/gELIBBBFUYNyQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM/QELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIsBCyAAQQ42AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/AELIABBADYCHCAAIAE2AhQgAEHAlYCAADYCECAAQQI2AgxBACEQDPsBCyAQQRVGDcUBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPoBCyAAQRA2AhwgACABNgIUIAAgEDYCDEEAIRAM+QELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDPEBCyAAQRE2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM+AELIBBBFUYNwQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM9wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIgBCyAAQRM2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM9gELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDO0BCyAAQRQ2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM9QELIBBBFUYNvQEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM9AELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIYBCyAAQRY2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM8wELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC3gICAACIEDQAgAUEBaiEBDOkBCyAAQRc2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM8gELIABBADYCHCAAIAE2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDPEBC0IBIRELIBBBAWohAQJAIAApAyAiEkL//////////w9WDQAgACASQgSGIBGENwMgIAEhAQyEAQsgAEEANgIcIAAgATYCFCAAQa2JgIAANgIQIABBDDYCDEEAIRAM7wELIABBADYCHCAAIBA2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDO4BCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNcyAAQQU2AhwgACAQNgIUIAAgFDYCDEEAIRAM7QELIABBADYCHCAAIBA2AhQgAEGqnICAADYCECAAQQ82AgxBACEQDOwBCyAAIBAgAhC0gICAACIBDQEgECEBC0EOIRAM0QELAkAgAUEVRw0AIABBAjYCHCAAIBA2AhQgAEGwmICAADYCECAAQRU2AgxBACEQDOoBCyAAQQA2AhwgACAQNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAzpAQsgAUEBaiEQAkAgAC8BMCIBQYABcUUNAAJAIAAgECACELuAgIAAIgENACAQIQEMcAsgAUEVRw26ASAAQQU2AhwgACAQNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAzpAQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgEDYCFCAAQZaTgIAANgIQIABBBDYCDEEAIRAM6QELIAAgECACEL2AgIAAGiAQIQECQAJAAkACQAJAIAAgECACELOAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBAhAQtBJiEQDNEBCyAAQSM2AhwgACAQNgIUIABBpZaAgAA2AhAgAEEVNgIMQQAhEAzpAQsgAEEANgIcIAAgEDYCFCAAQdWLgIAANgIQIABBETYCDEEAIRAM6AELIAAtAC1BAXFFDQFBwwEhEAzOAQsCQCANIAJGDQADQAJAIA0tAABBIEYNACANIQEMxAELIA1BAWoiDSACRw0AC0ElIRAM5wELQSUhEAzmAQsgACgCBCEEIABBADYCBCAAIAQgDRCvgICAACIERQ2tASAAQSY2AhwgACAENgIMIAAgDUEBajYCFEEAIRAM5QELIBBBFUYNqwEgAEEANgIcIAAgATYCFCAAQf2NgIAANgIQIABBHTYCDEEAIRAM5AELIABBJzYCHCAAIAE2AhQgACAQNgIMQQAhEAzjAQsgECEBQQEhFAJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0ErIRAMygELIABBADYCHCAAIBA2AhQgAEGrkoCAADYCECAAQQs2AgxBACEQDOIBCyAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMQQAhEAzhAQsgAEEAOgAsIBAhAQy9AQsgECEBQQEhFAJAAkACQAJAAkAgAC0ALEF7ag4EAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIRQMAQtBBCEUCyAAQQE6ACwgACAALwEwIBRyOwEwCyAQIQELQSkhEAzFAQsgAEEANgIcIAAgATYCFCAAQfCUgIAANgIQIABBAzYCDEEAIRAM3QELAkAgDi0AAEENRw0AIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHULIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzdAQsgAC0ALUEBcUUNAUHEASEQDMMBCwJAIA4gAkcNAEEtIRAM3AELAkACQANAAkAgDi0AAEF2ag4EAgAAAwALIA5BAWoiDiACRw0AC0EtIRAM3QELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDiEBDHQLIABBLDYCHCAAIA42AhQgACABNgIMQQAhEAzcAQsgACgCBCEBIABBADYCBAJAIAAgASAOELGAgIAAIgENACAOQQFqIQEMcwsgAEEsNgIcIAAgATYCDCAAIA5BAWo2AhRBACEQDNsBCyAAKAIEIQQgAEEANgIEIAAgBCAOELGAgIAAIgQNoAEgDiEBDM4BCyAQQSxHDQEgAUEBaiEQQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBAhAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBAhAQwBCyAAIAAvATBBCHI7ATAgECEBC0E5IRAMvwELIABBADoALCABIQELQTQhEAy9AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzHAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEQDNQBCyAAQQg6ACwgASEBC0EwIRAMuQELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2TASABIQEMAwsgAC0AMEEgcQ2UAUHFASEQDLcBCwJAIA8gAkYNAAJAA0ACQCAPLQAAQVBqIgFB/wFxQQpJDQAgDyEBQTUhEAy6AQsgACkDICIRQpmz5syZs+bMGVYNASAAIBFCCn4iETcDICARIAGtQv8BgyISQn+FVg0BIAAgESASfDcDICAPQQFqIg8gAkcNAAtBOSEQDNEBCyAAKAIEIQIgAEEANgIEIAAgAiAPQQFqIgQQsYCAgAAiAg2VASAEIQEMwwELQTkhEAzPAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDZABCyAAIAFB9/sDcUGABHI7ATAgDyEBC0E3IRAMtAELIAAgAC8BMEEQcjsBMAyrAQsgEEEVRg2LASAAQQA2AhwgACABNgIUIABB8I6AgAA2AhAgAEEcNgIMQQAhEAzLAQsgAEHDADYCHCAAIAE2AgwgACANQQFqNgIUQQAhEAzKAQsCQCABLQAAQTpHDQAgACgCBCEQIABBADYCBAJAIAAgECABEK+AgIAAIhANACABQQFqIQEMYwsgAEHDADYCHCAAIBA2AgwgACABQQFqNgIUQQAhEAzKAQsgAEEANgIcIAAgATYCFCAAQbGRgIAANgIQIABBCjYCDEEAIRAMyQELIABBADYCHCAAIAE2AhQgAEGgmYCAADYCECAAQR42AgxBACEQDMgBCyAAQQA2AgALIABBgBI7ASogACAXQQFqIgEgAhCogICAACIQDQEgASEBC0HHACEQDKwBCyAQQRVHDYMBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAzEAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAzDAQsgAEEANgIcIAAgFDYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEQDMIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxdCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDMEBC0EAIRAgAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzAAQsgEEEVRg19IABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEQDL8BC0EBIRZBACEXQQAhFEEBIRALIAAgEDoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAWRQ0DDAILIBQNAQwCCyAXRQ0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQrYCAgAAiEA0AIAEhAQxcCyAAQdgANgIcIAAgATYCFCAAIBA2AgxBACEQDL4BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQytAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhEAy9AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqwELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAIRAMvAELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKkBCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEQDLsBCwJAIAEtAABBUGoiEEH/AXFBCk8NACAAIBA6ACogAUEBaiEBQc8AIRAMogELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKcBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEQDLoBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKUEjTw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhEAy5AQsgAEEANgIAC0EAIRAgAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy3AQsgAEEANgIAIBdBAWohAQJAIAAtAClBIUcNACABIQEMVgsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAIRAMtgELIABBADYCACAXQQFqIQECQCAALQApIhBBXWpBC08NACABIQEMVQsCQCAQQQZLDQBBASAQdEHKAHFFDQAgASEBDFULQQAhECAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLUBCyAQQRVGDXEgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMtAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMswELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMsgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMsQELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFELIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMsAELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEQDK8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDK4BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDK0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDKwBCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhEAyrAQsgEEE/Rw0BIAFBAWohAQtBBSEQDJABC0EAIRAgAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyoAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAynAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAymAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMRgsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAylAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHSADYCHCAAIBQ2AhQgACABNgIMQQAhEAykAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHTADYCHCAAIBQ2AhQgACABNgIMQQAhEAyjAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMQwsgAEHlADYCHCAAIBQ2AhQgACABNgIMQQAhEAyiAQsgAEEANgIcIAAgFDYCFCAAQcOPgIAANgIQIABBBzYCDEEAIRAMoQELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKABC0EAIRAgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDAyfAQsgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDEEAIRAMngELIABBADYCHCAAIBQ2AhQgAEH+kYCAADYCECAAQQc2AgxBACEQDJ0BCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhEAycAQsgEEEVRg1XIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDJsBCyAAQQA2AgAgEEEBaiEBQSQhEAsgACAQOgApIAAoAgQhECAAQQA2AgQgACAQIAEQq4CAgAAiEA1UIAEhAQw+CyAAQQA2AgALQQAhECAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJcBCyABQRVGDVAgAEEANgIcIAAgBTYCFCAAQfCMgIAANgIQIABBGzYCDEEAIRAMlgELIAAoAgQhBSAAQQA2AgQgACAFIBAQqYCAgAAiBQ0BIBBBAWohBQtBrQEhEAx7CyAAQcEBNgIcIAAgBTYCDCAAIBBBAWo2AhRBACEQDJMBCyAAKAIEIQYgAEEANgIEIAAgBiAQEKmAgIAAIgYNASAQQQFqIQYLQa4BIRAMeAsgAEHCATYCHCAAIAY2AgwgACAQQQFqNgIUQQAhEAyQAQsgAEEANgIcIAAgBzYCFCAAQZeLgIAANgIQIABBDTYCDEEAIRAMjwELIABBADYCHCAAIAg2AhQgAEHjkICAADYCECAAQQk2AgxBACEQDI4BCyAAQQA2AhwgACAINgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAyNAQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgCUEBaiEIAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBCAAIBAgCBCtgICAACIQRQ09IABByQE2AhwgACAINgIUIAAgEDYCDEEAIRAMjAELIAAoAgQhBCAAQQA2AgQgACAEIAgQrYCAgAAiBEUNdiAAQcoBNgIcIAAgCDYCFCAAIAQ2AgxBACEQDIsBCyAAKAIEIQQgAEEANgIEIAAgBCAJEK2AgIAAIgRFDXQgAEHLATYCHCAAIAk2AhQgACAENgIMQQAhEAyKAQsgACgCBCEEIABBADYCBCAAIAQgChCtgICAACIERQ1yIABBzQE2AhwgACAKNgIUIAAgBDYCDEEAIRAMiQELAkAgCy0AAEFQaiIQQf8BcUEKTw0AIAAgEDoAKiALQQFqIQpBtgEhEAxwCyAAKAIEIQQgAEEANgIEIAAgBCALEK2AgIAAIgRFDXAgAEHPATYCHCAAIAs2AhQgACAENgIMQQAhEAyIAQsgAEEANgIcIAAgBDYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEQDIcBCyABQRVGDT8gAEEANgIcIAAgDDYCFCAAQcyOgIAANgIQIABBIDYCDEEAIRAMhgELIABBgQQ7ASggACgCBCEQIABCADcDACAAIBAgDEEBaiIMEKuAgIAAIhBFDTggAEHTATYCHCAAIAw2AhQgACAQNgIMQQAhEAyFAQsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyDAQsgACgCBCEQIABCADcDACAAIBAgC0EBaiILEKuAgIAAIhANAUHGASEQDGkLIABBAjoAKAxVCyAAQdUBNgIcIAAgCzYCFCAAIBA2AgxBACEQDIABCyAQQRVGDTcgAEEANgIcIAAgBDYCFCAAQaSMgIAANgIQIABBEDYCDEEAIRAMfwsgAC0ANEEBRw00IAAgBCACELyAgIAAIhBFDTQgEEEVRw01IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhEAx+C0EAIRAgAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgFEEBajYCFAx9C0EAIRAMYwtBAiEQDGILQQ0hEAxhC0EPIRAMYAtBJSEQDF8LQRMhEAxeC0EVIRAMXQtBFiEQDFwLQRchEAxbC0EYIRAMWgtBGSEQDFkLQRohEAxYC0EbIRAMVwtBHCEQDFYLQR0hEAxVC0EfIRAMVAtBISEQDFMLQSMhEAxSC0HGACEQDFELQS4hEAxQC0EvIRAMTwtBOyEQDE4LQT0hEAxNC0HIACEQDEwLQckAIRAMSwtBywAhEAxKC0HMACEQDEkLQc4AIRAMSAtB0QAhEAxHC0HVACEQDEYLQdgAIRAMRQtB2QAhEAxEC0HbACEQDEMLQeQAIRAMQgtB5QAhEAxBC0HxACEQDEALQfQAIRAMPwtBjQEhEAw+C0GXASEQDD0LQakBIRAMPAtBrAEhEAw7C0HAASEQDDoLQbkBIRAMOQtBrwEhEAw4C0GxASEQDDcLQbIBIRAMNgtBtAEhEAw1C0G1ASEQDDQLQboBIRAMMwtBvQEhEAwyC0G/ASEQDDELQcEBIRAMMAsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAIRAMSAsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEQDEcLIABB+AA2AhwgACAMNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhEAxGCyAAQdEANgIcIAAgBTYCFCAAQbCXgIAANgIQIABBFTYCDEEAIRAMRQsgAEH5ADYCHCAAIAE2AhQgACAQNgIMQQAhEAxECyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMQwsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEQDEILIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAxBCyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhEAxACyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAIRAMPwsgAEEANgIEIAAgDyAPELGAgIAAIgRFDQEgAEE6NgIcIAAgBDYCDCAAIA9BAWo2AhRBACEQDD4LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhEAw+CyABQQFqIQEMLQsgD0EBaiEBDC0LIABBADYCHCAAIA82AhQgAEHkkoCAADYCECAAQQQ2AgxBACEQDDsLIABBNjYCHCAAIAQ2AhQgACACNgIMQQAhEAw6CyAAQS42AhwgACAONgIUIAAgBDYCDEEAIRAMOQsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEQDDgLIA1BAWohAQwsCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAw2CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw1CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw0CyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAwzCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwyCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwxCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhEAwwCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAwvCyAAQQA2AhwgACAQNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhEAwuCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAwtCyAAQQA2AgAgC0EBaiELC0G4ASEQDBILIABBADYCACAQQQFqIQFB9QAhEAwRCyABIQECQCAALQApQQVHDQBB4wAhEAwRC0HiACEQDBALQQAhECAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAUQQFqNgIUDCgLIABBADYCACAXQQFqIQFBwAAhEAwOC0EBIQELIAAgAToALCAAQQA2AgAgF0EBaiEBC0EoIRAMCwsgASEBC0E4IRAMCQsCQCABIg8gAkYNAANAAkAgDy0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyAPQQFqIQEMBAsgD0EBaiIPIAJHDQALQT4hEAwiC0E+IRAMIQsgAEEAOgAsIA8hAQwBC0ELIRAMBgtBOiEQDAULIAFBAWohAUEtIRAMBAsgACABOgAsIABBADYCACAWQQFqIQFBDCEQDAMLIABBADYCACAXQQFqIQFBCiEQDAILIABBADYCAAsgAEEAOgAsIA0hAUEJIRAMAAsLQQAhECAAQQA2AhwgACALNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhECAAQQA2AhwgACAKNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhECAAQQA2AhwgACAJNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhECAAQQA2AhwgACAINgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhECAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhECAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhECAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhECAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhECAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhECAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhECAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhECAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhECAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhECAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhECAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEQDAYLQQEhEAwFC0HUACEQIAEiBCACRg0EIANBCGogACAEIAJB2MKAgABBChDFgICAACADKAIMIQQgAygCCA4DAQQCAAsQyoCAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhEAwCCyAAQQA2AhwgACAENgIUIABBypqAgAA2AhAgAEEJNgIMQQAhEAwBCwJAIAEiBCACRw0AQSIhEAwBCyAAQYmAgIAANgIIIAAgBDYCBEEhIRALIANBEGokgICAgAAgEAuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC/I2AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQy4CAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACQUhqIgUgA2siA0EBcjYCAEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgABBgNSEgAAgBWpBODYCBAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAojQgIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNAAJAAkAgA0EBcSAEckEBcyIFQQN0IgRBsNCAgABqIgMgBEG40ICAAGooAgAiBCgCCCICRw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgAyACNgIIIAIgAzYCDAsgBEEIaiEDIAQgBUEDdCIFQQNyNgIEIAQgBWoiBCAEKAIEQQFyNgIEDAwLIAJBACgCkNCAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBEEDdCIDQbDQgIAAaiIFIANBuNCAgABqKAIAIgMoAggiAEcNAEEAIAZBfiAEd3EiBjYCiNCAgAAMAQsgBSAANgIIIAAgBTYCDAsgAyACQQNyNgIEIAMgBEEDdCIEaiAEIAJrIgU2AgAgAyACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhBAJAAkAgBkEBIAdBA3Z0IghxDQBBACAGIAhyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLIANBCGohA0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNACAAKAIIIgNBACgCmNCAgABJGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AIAgoAggiA0EAKAKY0ICAAEkaIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgBCADaiIDIAMoAgRBAXI2AgRBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQy4CAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQy4CAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMuAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDLgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDLgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDLgICAACEAQQAQy4CAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGQUhqIgUgA2siA0EBcjYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgAAgACAFakE4NgIEDAILIAMtAAxBCHENACAEIAVJDQAgBCAATw0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClNCAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAU2ApTQgIAAQQAgADYCoNCAgAAgBCALakE4NgIEDAELAkAgAEEAKAKY0ICAACIITw0AQQAgADYCmNCAgAAgACEICyAAIAZqIQVByNOAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAFRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HI04CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiILIAJBA3I2AgQgBUF4IAVrQQ9xQQAgBUEIakEPcRtqIgYgCyACaiICayEDAkAgBiAERw0AQQAgAjYCoNCAgABBAEEAKAKU0ICAACADaiIDNgKU0ICAACACIANBAXI2AgQMAwsCQCAGQQAoApzQgIAARw0AQQAgAjYCnNCAgABBAEEAKAKQ0ICAACADaiIDNgKQ0ICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgBigCBCIEQQNxQQFHDQAgBEF4cSEHAkACQCAEQf8BSw0AIAYoAggiBSAEQQN2IghBA3RBsNCAgABqIgBGGgJAIAYoAgwiBCAFRw0AQQBBACgCiNCAgABBfiAId3E2AojQgIAADAILIAQgAEYaIAQgBTYCCCAFIAQ2AgwMAQsgBigCGCEJAkACQCAGKAIMIgAgBkYNACAGKAIIIgQgCEkaIAAgBDYCCCAEIAA2AgwMAQsCQCAGQRRqIgQoAgAiBQ0AIAZBEGoiBCgCACIFDQBBACEADAELA0AgBCEIIAUiAEEUaiIEKAIAIgUNACAAQRBqIQQgACgCECIFDQALIAhBADYCAAsgCUUNAAJAAkAgBiAGKAIcIgVBAnRBuNKAgABqIgQoAgBHDQAgBCAANgIAIAANAUEAQQAoAozQgIAAQX4gBXdxNgKM0ICAAAwCCyAJQRBBFCAJKAIQIAZGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAGKAIQIgRFDQAgACAENgIQIAQgADYCGAsgBigCFCIERQ0AIABBFGogBDYCACAEIAA2AhgLIAcgA2ohAyAGIAdqIgYoAgQhBAsgBiAEQX5xNgIEIAIgA2ogAzYCACACIANBAXI2AgQCQCADQf8BSw0AIANBeHFBsNCAgABqIQQCQAJAQQAoAojQgIAAIgVBASADQQN2dCIDcQ0AQQAgBSADcjYCiNCAgAAgBCEDDAELIAQoAgghAwsgAyACNgIMIAQgAjYCCCACIAQ2AgwgAiADNgIIDAMLQR8hBAJAIANB////B0sNACADQQh2IgQgBEGA/j9qQRB2QQhxIgR0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAQgBXIgAHJrIgRBAXQgAyAEQRVqdkEBcXJBHGohBAsgAiAENgIcIAJCADcCECAEQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiAEEBIAR0IghxDQAgBSACNgIAQQAgACAIcjYCjNCAgAAgAiAFNgIYIAIgAjYCCCACIAI2AgwMAwsgA0EAQRkgBEEBdmsgBEEfRht0IQQgBSgCACEAA0AgACIFKAIEQXhxIANGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAFNgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGQUhqIgggA2siA0EBcjYCBCAAIAhqQTg2AgQgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAs2AqDQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACADQQRqIgMgBUkNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiADYCACAEIABBAXI2AgQCQCAAQf8BSw0AIABBeHFBsNCAgABqIQMCQAJAQQAoAojQgIAAIgVBASAAQQN2dCIAcQ0AQQAgBSAAcjYCiNCAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIABB////B0sNACAAQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgggCEGAgA9qQRB2QQJxIgh0QQ92IAMgBXIgCHJrIgNBAXQgACADQRVqdkEBcXJBHGohAwsgBCADNgIcIARCADcCECADQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiCEEBIAN0IgZxDQAgBSAENgIAQQAgCCAGcjYCjNCAgAAgBCAFNgIYIAQgBDYCCCAEIAQ2AgwMBAsgAEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEIA0AgCCIFKAIEQXhxIABGDQMgA0EddiEIIANBAXQhAyAFIAhBBHFqQRBqIgYoAgAiCA0ACyAGIAQ2AgAgBCAFNgIYIAQgBDYCDCAEIAQ2AggMAwsgBSgCCCIDIAI2AgwgBSACNgIIIAJBADYCGCACIAU2AgwgAiADNgIICyALQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBADYCGCAEIAU2AgwgBCADNgIIC0EAKAKU0ICAACIDIAJNDQBBACgCoNCAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApTQgIAAQQAgBTYCoNCAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL404CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0QbjSgIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2AozQgIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCAIIANqIgMgAygCBEEBcjYCBAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBEEDdnQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAAgA2oiAyADKAIEQQFyNgIEDAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAHQQN2dCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAviDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQCABQQAoApzQgIAARg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgASgCCCICIARJGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEgASgCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyABIANPDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQCADQQAoAqDQgIAARw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAIANBACgCnNCAgABHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AIAMoAggiAkEAKAKY0ICAAEkaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAyADKAIcIgRBAnRBuNKAgABqIgIoAgBHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQXhxQbDQgIAAaiECAkACQEEAKAKI0ICAACIEQQEgAEEDdnQiAHENAEEAIAQgAHI2AojQgIAAIAIhAAwBCyACKAIIIQALIAAgATYCDCACIAE2AgggASACNgIMIAEgADYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgASACNgIcIAFCADcCECACQQJ0QbjSgIAAaiEEAkACQEEAKAKM0ICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKM0ICAACABIAQ2AhggASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAEgBDYCGCABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQQA2AhggASAENgIMIAEgADYCCAtBAEEAKAKo0ICAAEF/aiIBQX8gARs2AqjQgIAACwsEAAAAC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMqAgIAAAAvyAgIDfwF+AkAgAkUNACAAIAE6AAAgAiAAaiIDQX9qIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0F9aiABOgAAIANBfmogAToAACACQQdJDQAgACABOgADIANBfGogAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrUKBgICAEH4hBiADIAVqIQEDQCABIAY3AxggASAGNwMQIAEgBjcDCCABIAY3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAsLjkgBAEGACAuGSAEAAAACAAAAAwAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
    }
  });

  // node_modules/undici/lib/client.js
  var require_client = __commonJS({
    "node_modules/undici/lib/client.js"(exports, module) {
      "use strict";
      var assert = __require("assert");
      var net = __require("net");
      var http = __require("http");
      var { pipeline } = __require("stream");
      var util = require_util();
      var timers = require_timers();
      var Request = require_request();
      var DispatcherBase = require_dispatcher_base();
      var {
        RequestContentLengthMismatchError,
        ResponseContentLengthMismatchError,
        InvalidArgumentError,
        RequestAbortedError,
        HeadersTimeoutError,
        HeadersOverflowError,
        SocketError,
        InformationalError,
        BodyTimeoutError,
        HTTPParserError,
        ResponseExceededMaxSizeError,
        ClientDestroyedError
      } = require_errors();
      var buildConnector = require_connect();
      var {
        kUrl,
        kReset,
        kServerName,
        kClient,
        kBusy,
        kParser,
        kConnect,
        kBlocking,
        kResuming,
        kRunning,
        kPending,
        kSize,
        kWriting,
        kQueue,
        kConnected,
        kConnecting,
        kNeedDrain,
        kNoRef,
        kKeepAliveDefaultTimeout,
        kHostHeader,
        kPendingIdx,
        kRunningIdx,
        kError,
        kPipelining,
        kSocket,
        kKeepAliveTimeoutValue,
        kMaxHeadersSize,
        kKeepAliveMaxTimeout,
        kKeepAliveTimeoutThreshold,
        kHeadersTimeout,
        kBodyTimeout,
        kStrictContentLength,
        kConnector,
        kMaxRedirections,
        kMaxRequests,
        kCounter,
        kClose,
        kDestroy,
        kDispatch,
        kInterceptors,
        kLocalAddress,
        kMaxResponseSize,
        kHTTPConnVersion,
        // HTTP2
        kHost,
        kHTTP2Session,
        kHTTP2SessionState,
        kHTTP2BuildRequest,
        kHTTP2CopyHeaders,
        kHTTP1BuildRequest
      } = require_symbols();
      var http2;
      try {
        http2 = __require("http2");
      } catch {
        http2 = { constants: {} };
      }
      var {
        constants: {
          HTTP2_HEADER_AUTHORITY,
          HTTP2_HEADER_METHOD,
          HTTP2_HEADER_PATH,
          HTTP2_HEADER_SCHEME,
          HTTP2_HEADER_CONTENT_LENGTH,
          HTTP2_HEADER_EXPECT,
          HTTP2_HEADER_STATUS
        }
      } = http2;
      var h2ExperimentalWarned = false;
      var FastBuffer = Buffer[Symbol.species];
      var kClosedResolve = Symbol("kClosedResolve");
      var channels = {};
      try {
        const diagnosticsChannel = __require("diagnostics_channel");
        channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
        channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
        channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
        channels.connected = diagnosticsChannel.channel("undici:client:connected");
      } catch {
        channels.sendHeaders = { hasSubscribers: false };
        channels.beforeConnect = { hasSubscribers: false };
        channels.connectError = { hasSubscribers: false };
        channels.connected = { hasSubscribers: false };
      }
      var Client = class extends DispatcherBase {
        /**
         *
         * @param {string|URL} url
         * @param {import('../types/client').Client.Options} options
         */
        constructor(url, {
          interceptors,
          maxHeaderSize,
          headersTimeout,
          socketTimeout,
          requestTimeout,
          connectTimeout,
          bodyTimeout,
          idleTimeout,
          keepAlive,
          keepAliveTimeout,
          maxKeepAliveTimeout,
          keepAliveMaxTimeout,
          keepAliveTimeoutThreshold,
          socketPath,
          pipelining,
          tls,
          strictContentLength,
          maxCachedSessions,
          maxRedirections,
          connect: connect2,
          maxRequestsPerClient,
          localAddress,
          maxResponseSize,
          autoSelectFamily,
          autoSelectFamilyAttemptTimeout,
          // h2
          allowH2,
          maxConcurrentStreams
        } = {}) {
          super();
          if (keepAlive !== void 0) {
            throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
          }
          if (socketTimeout !== void 0) {
            throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
          }
          if (requestTimeout !== void 0) {
            throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
          }
          if (idleTimeout !== void 0) {
            throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
          }
          if (maxKeepAliveTimeout !== void 0) {
            throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
          }
          if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
            throw new InvalidArgumentError("invalid maxHeaderSize");
          }
          if (socketPath != null && typeof socketPath !== "string") {
            throw new InvalidArgumentError("invalid socketPath");
          }
          if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
            throw new InvalidArgumentError("invalid connectTimeout");
          }
          if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
            throw new InvalidArgumentError("invalid keepAliveTimeout");
          }
          if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
            throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
          }
          if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
            throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
          }
          if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
            throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
          }
          if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
            throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
          }
          if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
            throw new InvalidArgumentError("connect must be a function or an object");
          }
          if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
            throw new InvalidArgumentError("maxRedirections must be a positive number");
          }
          if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
            throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
          }
          if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
            throw new InvalidArgumentError("localAddress must be valid string IP address");
          }
          if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
            throw new InvalidArgumentError("maxResponseSize must be a positive number");
          }
          if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
            throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
          }
          if (allowH2 != null && typeof allowH2 !== "boolean") {
            throw new InvalidArgumentError("allowH2 must be a valid boolean value");
          }
          if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
            throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
          }
          if (typeof connect2 !== "function") {
            connect2 = buildConnector({
              ...tls,
              maxCachedSessions,
              allowH2,
              socketPath,
              timeout: connectTimeout,
              ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
              ...connect2
            });
          }
          this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
          this[kUrl] = util.parseOrigin(url);
          this[kConnector] = connect2;
          this[kSocket] = null;
          this[kPipelining] = pipelining != null ? pipelining : 1;
          this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
          this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
          this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
          this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
          this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
          this[kServerName] = null;
          this[kLocalAddress] = localAddress != null ? localAddress : null;
          this[kResuming] = 0;
          this[kNeedDrain] = 0;
          this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
          this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
          this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
          this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
          this[kMaxRedirections] = maxRedirections;
          this[kMaxRequests] = maxRequestsPerClient;
          this[kClosedResolve] = null;
          this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
          this[kHTTPConnVersion] = "h1";
          this[kHTTP2Session] = null;
          this[kHTTP2SessionState] = !allowH2 ? null : {
            // streams: null, // Fixed queue of streams - For future support of `push`
            openStreams: 0,
            // Keep track of them to decide wether or not unref the session
            maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
            // Max peerConcurrentStreams for a Node h2 server
          };
          this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
          this[kQueue] = [];
          this[kRunningIdx] = 0;
          this[kPendingIdx] = 0;
        }
        get pipelining() {
          return this[kPipelining];
        }
        set pipelining(value) {
          this[kPipelining] = value;
          resume(this, true);
        }
        get [kPending]() {
          return this[kQueue].length - this[kPendingIdx];
        }
        get [kRunning]() {
          return this[kPendingIdx] - this[kRunningIdx];
        }
        get [kSize]() {
          return this[kQueue].length - this[kRunningIdx];
        }
        get [kConnected]() {
          return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
        }
        get [kBusy]() {
          const socket = this[kSocket];
          return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
        }
        /* istanbul ignore: only used for test */
        [kConnect](cb) {
          connect(this);
          this.once("connect", cb);
        }
        [kDispatch](opts, handler2) {
          const origin = opts.origin || this[kUrl].origin;
          const request2 = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler2) : Request[kHTTP1BuildRequest](origin, opts, handler2);
          this[kQueue].push(request2);
          if (this[kResuming]) {
          } else if (util.bodyLength(request2.body) == null && util.isIterable(request2.body)) {
            this[kResuming] = 1;
            process.nextTick(resume, this);
          } else {
            resume(this, true);
          }
          if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
            this[kNeedDrain] = 2;
          }
          return this[kNeedDrain] < 2;
        }
        async [kClose]() {
          return new Promise((resolve) => {
            if (!this[kSize]) {
              resolve(null);
            } else {
              this[kClosedResolve] = resolve;
            }
          });
        }
        async [kDestroy](err) {
          return new Promise((resolve) => {
            const requests = this[kQueue].splice(this[kPendingIdx]);
            for (let i = 0; i < requests.length; i++) {
              const request2 = requests[i];
              errorRequest(this, request2, err);
            }
            const callback = () => {
              if (this[kClosedResolve]) {
                this[kClosedResolve]();
                this[kClosedResolve] = null;
              }
              resolve();
            };
            if (this[kHTTP2Session] != null) {
              util.destroy(this[kHTTP2Session], err);
              this[kHTTP2Session] = null;
              this[kHTTP2SessionState] = null;
            }
            if (!this[kSocket]) {
              queueMicrotask(callback);
            } else {
              util.destroy(this[kSocket].on("close", callback), err);
            }
            resume(this);
          });
        }
      };
      function onHttp2SessionError(err) {
        assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
      function onHttp2FrameError(type, code, id) {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        if (id === 0) {
          this[kSocket][kError] = err;
          onError(this[kClient], err);
        }
      }
      function onHttp2SessionEnd() {
        util.destroy(this, new SocketError("other side closed"));
        util.destroy(this[kSocket], new SocketError("other side closed"));
      }
      function onHTTP2GoAway(code) {
        const client = this[kClient];
        const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
        client[kSocket] = null;
        client[kHTTP2Session] = null;
        if (client.destroyed) {
          assert(this[kPending] === 0);
          const requests = client[kQueue].splice(client[kRunningIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request2 = requests[i];
            errorRequest(this, request2, err);
          }
        } else if (client[kRunning] > 0) {
          const request2 = client[kQueue][client[kRunningIdx]];
          client[kQueue][client[kRunningIdx]++] = null;
          errorRequest(client, request2, err);
        }
        client[kPendingIdx] = client[kRunningIdx];
        assert(client[kRunning] === 0);
        client.emit(
          "disconnect",
          client[kUrl],
          [client],
          err
        );
        resume(client);
      }
      var constants = require_constants3();
      var createRedirectInterceptor = require_redirectInterceptor();
      var EMPTY_BUF = Buffer.alloc(0);
      async function lazyllhttp() {
        const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
        let mod;
        try {
          mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
        } catch (e) {
          mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
        }
        return await WebAssembly.instantiate(mod, {
          env: {
            /* eslint-disable camelcase */
            wasm_on_url: (p, at, len) => {
              return 0;
            },
            wasm_on_status: (p, at, len) => {
              assert.strictEqual(currentParser.ptr, p);
              const start = at - currentBufferPtr + currentBufferRef.byteOffset;
              return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
            },
            wasm_on_message_begin: (p) => {
              assert.strictEqual(currentParser.ptr, p);
              return currentParser.onMessageBegin() || 0;
            },
            wasm_on_header_field: (p, at, len) => {
              assert.strictEqual(currentParser.ptr, p);
              const start = at - currentBufferPtr + currentBufferRef.byteOffset;
              return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
            },
            wasm_on_header_value: (p, at, len) => {
              assert.strictEqual(currentParser.ptr, p);
              const start = at - currentBufferPtr + currentBufferRef.byteOffset;
              return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
            },
            wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
              assert.strictEqual(currentParser.ptr, p);
              return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
            },
            wasm_on_body: (p, at, len) => {
              assert.strictEqual(currentParser.ptr, p);
              const start = at - currentBufferPtr + currentBufferRef.byteOffset;
              return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
            },
            wasm_on_message_complete: (p) => {
              assert.strictEqual(currentParser.ptr, p);
              return currentParser.onMessageComplete() || 0;
            }
            /* eslint-enable camelcase */
          }
        });
      }
      var llhttpInstance = null;
      var llhttpPromise = lazyllhttp();
      llhttpPromise.catch();
      var currentParser = null;
      var currentBufferRef = null;
      var currentBufferSize = 0;
      var currentBufferPtr = null;
      var TIMEOUT_HEADERS = 1;
      var TIMEOUT_BODY = 2;
      var TIMEOUT_IDLE = 3;
      var Parser = class {
        constructor(client, socket, { exports: exports2 }) {
          assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
          this.llhttp = exports2;
          this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
          this.client = client;
          this.socket = socket;
          this.timeout = null;
          this.timeoutValue = null;
          this.timeoutType = null;
          this.statusCode = null;
          this.statusText = "";
          this.upgrade = false;
          this.headers = [];
          this.headersSize = 0;
          this.headersMaxSize = client[kMaxHeadersSize];
          this.shouldKeepAlive = false;
          this.paused = false;
          this.resume = this.resume.bind(this);
          this.bytesRead = 0;
          this.keepAlive = "";
          this.contentLength = "";
          this.connection = "";
          this.maxResponseSize = client[kMaxResponseSize];
        }
        setTimeout(value, type) {
          this.timeoutType = type;
          if (value !== this.timeoutValue) {
            timers.clearTimeout(this.timeout);
            if (value) {
              this.timeout = timers.setTimeout(onParserTimeout, value, this);
              if (this.timeout.unref) {
                this.timeout.unref();
              }
            } else {
              this.timeout = null;
            }
            this.timeoutValue = value;
          } else if (this.timeout) {
            if (this.timeout.refresh) {
              this.timeout.refresh();
            }
          }
        }
        resume() {
          if (this.socket.destroyed || !this.paused) {
            return;
          }
          assert(this.ptr != null);
          assert(currentParser == null);
          this.llhttp.llhttp_resume(this.ptr);
          assert(this.timeoutType === TIMEOUT_BODY);
          if (this.timeout) {
            if (this.timeout.refresh) {
              this.timeout.refresh();
            }
          }
          this.paused = false;
          this.execute(this.socket.read() || EMPTY_BUF);
          this.readMore();
        }
        readMore() {
          while (!this.paused && this.ptr) {
            const chunk = this.socket.read();
            if (chunk === null) {
              break;
            }
            this.execute(chunk);
          }
        }
        execute(data) {
          assert(this.ptr != null);
          assert(currentParser == null);
          assert(!this.paused);
          const { socket, llhttp } = this;
          if (data.length > currentBufferSize) {
            if (currentBufferPtr) {
              llhttp.free(currentBufferPtr);
            }
            currentBufferSize = Math.ceil(data.length / 4096) * 4096;
            currentBufferPtr = llhttp.malloc(currentBufferSize);
          }
          new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
          try {
            let ret;
            try {
              currentBufferRef = data;
              currentParser = this;
              ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
            } catch (err) {
              throw err;
            } finally {
              currentParser = null;
              currentBufferRef = null;
            }
            const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
            if (ret === constants.ERROR.PAUSED_UPGRADE) {
              this.onUpgrade(data.slice(offset));
            } else if (ret === constants.ERROR.PAUSED) {
              this.paused = true;
              socket.unshift(data.slice(offset));
            } else if (ret !== constants.ERROR.OK) {
              const ptr = llhttp.llhttp_get_error_reason(this.ptr);
              let message = "";
              if (ptr) {
                const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
                message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
              }
              throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
            }
          } catch (err) {
            util.destroy(socket, err);
          }
        }
        destroy() {
          assert(this.ptr != null);
          assert(currentParser == null);
          this.llhttp.llhttp_free(this.ptr);
          this.ptr = null;
          timers.clearTimeout(this.timeout);
          this.timeout = null;
          this.timeoutValue = null;
          this.timeoutType = null;
          this.paused = false;
        }
        onStatus(buf) {
          this.statusText = buf.toString();
        }
        onMessageBegin() {
          const { socket, client } = this;
          if (socket.destroyed) {
            return -1;
          }
          const request2 = client[kQueue][client[kRunningIdx]];
          if (!request2) {
            return -1;
          }
        }
        onHeaderField(buf) {
          const len = this.headers.length;
          if ((len & 1) === 0) {
            this.headers.push(buf);
          } else {
            this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
          }
          this.trackHeader(buf.length);
        }
        onHeaderValue(buf) {
          let len = this.headers.length;
          if ((len & 1) === 1) {
            this.headers.push(buf);
            len += 1;
          } else {
            this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
          }
          const key = this.headers[len - 2];
          if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
            this.keepAlive += buf.toString();
          } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
            this.connection += buf.toString();
          } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
            this.contentLength += buf.toString();
          }
          this.trackHeader(buf.length);
        }
        trackHeader(len) {
          this.headersSize += len;
          if (this.headersSize >= this.headersMaxSize) {
            util.destroy(this.socket, new HeadersOverflowError());
          }
        }
        onUpgrade(head) {
          const { upgrade, client, socket, headers, statusCode } = this;
          assert(upgrade);
          const request2 = client[kQueue][client[kRunningIdx]];
          assert(request2);
          assert(!socket.destroyed);
          assert(socket === client[kSocket]);
          assert(!this.paused);
          assert(request2.upgrade || request2.method === "CONNECT");
          this.statusCode = null;
          this.statusText = "";
          this.shouldKeepAlive = null;
          assert(this.headers.length % 2 === 0);
          this.headers = [];
          this.headersSize = 0;
          socket.unshift(head);
          socket[kParser].destroy();
          socket[kParser] = null;
          socket[kClient] = null;
          socket[kError] = null;
          socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
          client[kSocket] = null;
          client[kQueue][client[kRunningIdx]++] = null;
          client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
          try {
            request2.onUpgrade(statusCode, headers, socket);
          } catch (err) {
            util.destroy(socket, err);
          }
          resume(client);
        }
        onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
          const { client, socket, headers, statusText } = this;
          if (socket.destroyed) {
            return -1;
          }
          const request2 = client[kQueue][client[kRunningIdx]];
          if (!request2) {
            return -1;
          }
          assert(!this.upgrade);
          assert(this.statusCode < 200);
          if (statusCode === 100) {
            util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
            return -1;
          }
          if (upgrade && !request2.upgrade) {
            util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
            return -1;
          }
          assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
          this.statusCode = statusCode;
          this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
          request2.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
          if (this.statusCode >= 200) {
            const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client[kBodyTimeout];
            this.setTimeout(bodyTimeout, TIMEOUT_BODY);
          } else if (this.timeout) {
            if (this.timeout.refresh) {
              this.timeout.refresh();
            }
          }
          if (request2.method === "CONNECT") {
            assert(client[kRunning] === 1);
            this.upgrade = true;
            return 2;
          }
          if (upgrade) {
            assert(client[kRunning] === 1);
            this.upgrade = true;
            return 2;
          }
          assert(this.headers.length % 2 === 0);
          this.headers = [];
          this.headersSize = 0;
          if (this.shouldKeepAlive && client[kPipelining]) {
            const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
            if (keepAliveTimeout != null) {
              const timeout = Math.min(
                keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
                client[kKeepAliveMaxTimeout]
              );
              if (timeout <= 0) {
                socket[kReset] = true;
              } else {
                client[kKeepAliveTimeoutValue] = timeout;
              }
            } else {
              client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
            }
          } else {
            socket[kReset] = true;
          }
          const pause = request2.onHeaders(statusCode, headers, this.resume, statusText) === false;
          if (request2.aborted) {
            return -1;
          }
          if (request2.method === "HEAD") {
            return 1;
          }
          if (statusCode < 200) {
            return 1;
          }
          if (socket[kBlocking]) {
            socket[kBlocking] = false;
            resume(client);
          }
          return pause ? constants.ERROR.PAUSED : 0;
        }
        onBody(buf) {
          const { client, socket, statusCode, maxResponseSize } = this;
          if (socket.destroyed) {
            return -1;
          }
          const request2 = client[kQueue][client[kRunningIdx]];
          assert(request2);
          assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
          if (this.timeout) {
            if (this.timeout.refresh) {
              this.timeout.refresh();
            }
          }
          assert(statusCode >= 200);
          if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
            util.destroy(socket, new ResponseExceededMaxSizeError());
            return -1;
          }
          this.bytesRead += buf.length;
          if (request2.onData(buf) === false) {
            return constants.ERROR.PAUSED;
          }
        }
        onMessageComplete() {
          const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
          if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
            return -1;
          }
          if (upgrade) {
            return;
          }
          const request2 = client[kQueue][client[kRunningIdx]];
          assert(request2);
          assert(statusCode >= 100);
          this.statusCode = null;
          this.statusText = "";
          this.bytesRead = 0;
          this.contentLength = "";
          this.keepAlive = "";
          this.connection = "";
          assert(this.headers.length % 2 === 0);
          this.headers = [];
          this.headersSize = 0;
          if (statusCode < 200) {
            return;
          }
          if (request2.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
            util.destroy(socket, new ResponseContentLengthMismatchError());
            return -1;
          }
          request2.onComplete(headers);
          client[kQueue][client[kRunningIdx]++] = null;
          if (socket[kWriting]) {
            assert.strictEqual(client[kRunning], 0);
            util.destroy(socket, new InformationalError("reset"));
            return constants.ERROR.PAUSED;
          } else if (!shouldKeepAlive) {
            util.destroy(socket, new InformationalError("reset"));
            return constants.ERROR.PAUSED;
          } else if (socket[kReset] && client[kRunning] === 0) {
            util.destroy(socket, new InformationalError("reset"));
            return constants.ERROR.PAUSED;
          } else if (client[kPipelining] === 1) {
            setImmediate(resume, client);
          } else {
            resume(client);
          }
        }
      };
      function onParserTimeout(parser) {
        const { socket, timeoutType, client } = parser;
        if (timeoutType === TIMEOUT_HEADERS) {
          if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
            assert(!parser.paused, "cannot be paused while waiting for headers");
            util.destroy(socket, new HeadersTimeoutError());
          }
        } else if (timeoutType === TIMEOUT_BODY) {
          if (!parser.paused) {
            util.destroy(socket, new BodyTimeoutError());
          }
        } else if (timeoutType === TIMEOUT_IDLE) {
          assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
          util.destroy(socket, new InformationalError("socket idle timeout"));
        }
      }
      function onSocketReadable() {
        const { [kParser]: parser } = this;
        if (parser) {
          parser.readMore();
        }
      }
      function onSocketError(err) {
        const { [kClient]: client, [kParser]: parser } = this;
        assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
        if (client[kHTTPConnVersion] !== "h2") {
          if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
            parser.onMessageComplete();
            return;
          }
        }
        this[kError] = err;
        onError(this[kClient], err);
      }
      function onError(client, err) {
        if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
          assert(client[kPendingIdx] === client[kRunningIdx]);
          const requests = client[kQueue].splice(client[kRunningIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request2 = requests[i];
            errorRequest(client, request2, err);
          }
          assert(client[kSize] === 0);
        }
      }
      function onSocketEnd() {
        const { [kParser]: parser, [kClient]: client } = this;
        if (client[kHTTPConnVersion] !== "h2") {
          if (parser.statusCode && !parser.shouldKeepAlive) {
            parser.onMessageComplete();
            return;
          }
        }
        util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
      }
      function onSocketClose() {
        const { [kClient]: client, [kParser]: parser } = this;
        if (client[kHTTPConnVersion] === "h1" && parser) {
          if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
            parser.onMessageComplete();
          }
          this[kParser].destroy();
          this[kParser] = null;
        }
        const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
        client[kSocket] = null;
        if (client.destroyed) {
          assert(client[kPending] === 0);
          const requests = client[kQueue].splice(client[kRunningIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request2 = requests[i];
            errorRequest(client, request2, err);
          }
        } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
          const request2 = client[kQueue][client[kRunningIdx]];
          client[kQueue][client[kRunningIdx]++] = null;
          errorRequest(client, request2, err);
        }
        client[kPendingIdx] = client[kRunningIdx];
        assert(client[kRunning] === 0);
        client.emit("disconnect", client[kUrl], [client], err);
        resume(client);
      }
      async function connect(client) {
        assert(!client[kConnecting]);
        assert(!client[kSocket]);
        let { host, hostname, protocol, port } = client[kUrl];
        if (hostname[0] === "[") {
          const idx = hostname.indexOf("]");
          assert(idx !== -1);
          const ip = hostname.substring(1, idx);
          assert(net.isIP(ip));
          hostname = ip;
        }
        client[kConnecting] = true;
        if (channels.beforeConnect.hasSubscribers) {
          channels.beforeConnect.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector]
          });
        }
        try {
          const socket = await new Promise((resolve, reject) => {
            client[kConnector]({
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            }, (err, socket2) => {
              if (err) {
                reject(err);
              } else {
                resolve(socket2);
              }
            });
          });
          if (client.destroyed) {
            util.destroy(socket.on("error", () => {
            }), new ClientDestroyedError());
            return;
          }
          client[kConnecting] = false;
          assert(socket);
          const isH2 = socket.alpnProtocol === "h2";
          if (isH2) {
            if (!h2ExperimentalWarned) {
              h2ExperimentalWarned = true;
              process.emitWarning("H2 support is experimental, expect them to change at any time.", {
                code: "UNDICI-H2"
              });
            }
            const session = http2.connect(client[kUrl], {
              createConnection: () => socket,
              peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
            });
            client[kHTTPConnVersion] = "h2";
            session[kClient] = client;
            session[kSocket] = socket;
            session.on("error", onHttp2SessionError);
            session.on("frameError", onHttp2FrameError);
            session.on("end", onHttp2SessionEnd);
            session.on("goaway", onHTTP2GoAway);
            session.on("close", onSocketClose);
            session.unref();
            client[kHTTP2Session] = session;
            socket[kHTTP2Session] = session;
          } else {
            if (!llhttpInstance) {
              llhttpInstance = await llhttpPromise;
              llhttpPromise = null;
            }
            socket[kNoRef] = false;
            socket[kWriting] = false;
            socket[kReset] = false;
            socket[kBlocking] = false;
            socket[kParser] = new Parser(client, socket, llhttpInstance);
          }
          socket[kCounter] = 0;
          socket[kMaxRequests] = client[kMaxRequests];
          socket[kClient] = client;
          socket[kError] = null;
          socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
          client[kSocket] = socket;
          if (channels.connected.hasSubscribers) {
            channels.connected.publish({
              connectParams: {
                host,
                hostname,
                protocol,
                port,
                servername: client[kServerName],
                localAddress: client[kLocalAddress]
              },
              connector: client[kConnector],
              socket
            });
          }
          client.emit("connect", client[kUrl], [client]);
        } catch (err) {
          if (client.destroyed) {
            return;
          }
          client[kConnecting] = false;
          if (channels.connectError.hasSubscribers) {
            channels.connectError.publish({
              connectParams: {
                host,
                hostname,
                protocol,
                port,
                servername: client[kServerName],
                localAddress: client[kLocalAddress]
              },
              connector: client[kConnector],
              error: err
            });
          }
          if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
            assert(client[kRunning] === 0);
            while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
              const request2 = client[kQueue][client[kPendingIdx]++];
              errorRequest(client, request2, err);
            }
          } else {
            onError(client, err);
          }
          client.emit("connectionError", client[kUrl], [client], err);
        }
        resume(client);
      }
      function emitDrain(client) {
        client[kNeedDrain] = 0;
        client.emit("drain", client[kUrl], [client]);
      }
      function resume(client, sync) {
        if (client[kResuming] === 2) {
          return;
        }
        client[kResuming] = 2;
        _resume(client, sync);
        client[kResuming] = 0;
        if (client[kRunningIdx] > 256) {
          client[kQueue].splice(0, client[kRunningIdx]);
          client[kPendingIdx] -= client[kRunningIdx];
          client[kRunningIdx] = 0;
        }
      }
      function _resume(client, sync) {
        while (true) {
          if (client.destroyed) {
            assert(client[kPending] === 0);
            return;
          }
          if (client[kClosedResolve] && !client[kSize]) {
            client[kClosedResolve]();
            client[kClosedResolve] = null;
            return;
          }
          const socket = client[kSocket];
          if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
            if (client[kSize] === 0) {
              if (!socket[kNoRef] && socket.unref) {
                socket.unref();
                socket[kNoRef] = true;
              }
            } else if (socket[kNoRef] && socket.ref) {
              socket.ref();
              socket[kNoRef] = false;
            }
            if (client[kSize] === 0) {
              if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
                socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
              }
            } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
              if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
                const request3 = client[kQueue][client[kRunningIdx]];
                const headersTimeout = request3.headersTimeout != null ? request3.headersTimeout : client[kHeadersTimeout];
                socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
              }
            }
          }
          if (client[kBusy]) {
            client[kNeedDrain] = 2;
          } else if (client[kNeedDrain] === 2) {
            if (sync) {
              client[kNeedDrain] = 1;
              process.nextTick(emitDrain, client);
            } else {
              emitDrain(client);
            }
            continue;
          }
          if (client[kPending] === 0) {
            return;
          }
          if (client[kRunning] >= (client[kPipelining] || 1)) {
            return;
          }
          const request2 = client[kQueue][client[kPendingIdx]];
          if (client[kUrl].protocol === "https:" && client[kServerName] !== request2.servername) {
            if (client[kRunning] > 0) {
              return;
            }
            client[kServerName] = request2.servername;
            if (socket && socket.servername !== request2.servername) {
              util.destroy(socket, new InformationalError("servername changed"));
              return;
            }
          }
          if (client[kConnecting]) {
            return;
          }
          if (!socket && !client[kHTTP2Session]) {
            connect(client);
            return;
          }
          if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
            return;
          }
          if (client[kRunning] > 0 && !request2.idempotent) {
            return;
          }
          if (client[kRunning] > 0 && (request2.upgrade || request2.method === "CONNECT")) {
            return;
          }
          if (client[kRunning] > 0 && util.bodyLength(request2.body) !== 0 && (util.isStream(request2.body) || util.isAsyncIterable(request2.body))) {
            return;
          }
          if (!request2.aborted && write(client, request2)) {
            client[kPendingIdx]++;
          } else {
            client[kQueue].splice(client[kPendingIdx], 1);
          }
        }
      }
      function shouldSendContentLength(method) {
        return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
      }
      function write(client, request2) {
        if (client[kHTTPConnVersion] === "h2") {
          writeH2(client, client[kHTTP2Session], request2);
          return;
        }
        const { body, method, path, host, upgrade, headers, blocking, reset } = request2;
        const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
        if (body && typeof body.read === "function") {
          body.read(0);
        }
        const bodyLength = util.bodyLength(body);
        let contentLength = bodyLength;
        if (contentLength === null) {
          contentLength = request2.contentLength;
        }
        if (contentLength === 0 && !expectsPayload) {
          contentLength = null;
        }
        if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength !== null && request2.contentLength !== contentLength) {
          if (client[kStrictContentLength]) {
            errorRequest(client, request2, new RequestContentLengthMismatchError());
            return false;
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        const socket = client[kSocket];
        try {
          request2.onConnect((err) => {
            if (request2.aborted || request2.completed) {
              return;
            }
            errorRequest(client, request2, err || new RequestAbortedError());
            util.destroy(socket, new InformationalError("aborted"));
          });
        } catch (err) {
          errorRequest(client, request2, err);
        }
        if (request2.aborted) {
          return false;
        }
        if (method === "HEAD") {
          socket[kReset] = true;
        }
        if (upgrade || method === "CONNECT") {
          socket[kReset] = true;
        }
        if (reset != null) {
          socket[kReset] = reset;
        }
        if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
          socket[kReset] = true;
        }
        if (blocking) {
          socket[kBlocking] = true;
        }
        let header = `${method} ${path} HTTP/1.1\r
`;
        if (typeof host === "string") {
          header += `host: ${host}\r
`;
        } else {
          header += client[kHostHeader];
        }
        if (upgrade) {
          header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
        } else if (client[kPipelining] && !socket[kReset]) {
          header += "connection: keep-alive\r\n";
        } else {
          header += "connection: close\r\n";
        }
        if (headers) {
          header += headers;
        }
        if (channels.sendHeaders.hasSubscribers) {
          channels.sendHeaders.publish({ request: request2, headers: header, socket });
        }
        if (!body || bodyLength === 0) {
          if (contentLength === 0) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            assert(contentLength === null, "no body must not have content length");
            socket.write(`${header}\r
`, "latin1");
          }
          request2.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(body);
          socket.uncork();
          request2.onBodySent(body);
          request2.onRequestSent();
          if (!expectsPayload) {
            socket[kReset] = true;
          }
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({ body: body.stream(), client, request: request2, socket, contentLength, header, expectsPayload });
          } else {
            writeBlob({ body, client, request: request2, socket, contentLength, header, expectsPayload });
          }
        } else if (util.isStream(body)) {
          writeStream({ body, client, request: request2, socket, contentLength, header, expectsPayload });
        } else if (util.isIterable(body)) {
          writeIterable({ body, client, request: request2, socket, contentLength, header, expectsPayload });
        } else {
          assert(false);
        }
        return true;
      }
      function writeH2(client, session, request2) {
        const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request2;
        let headers;
        if (typeof reqHeaders === "string") headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
        else headers = reqHeaders;
        if (upgrade) {
          errorRequest(client, request2, new Error("Upgrade not supported for H2"));
          return false;
        }
        try {
          request2.onConnect((err) => {
            if (request2.aborted || request2.completed) {
              return;
            }
            errorRequest(client, request2, err || new RequestAbortedError());
          });
        } catch (err) {
          errorRequest(client, request2, err);
        }
        if (request2.aborted) {
          return false;
        }
        let stream;
        const h2State = client[kHTTP2SessionState];
        headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
        headers[HTTP2_HEADER_METHOD] = method;
        if (method === "CONNECT") {
          session.ref();
          stream = session.request(headers, { endStream: false, signal });
          if (stream.id && !stream.pending) {
            request2.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          } else {
            stream.once("ready", () => {
              request2.onUpgrade(null, null, stream);
              ++h2State.openStreams;
            });
          }
          stream.once("close", () => {
            h2State.openStreams -= 1;
            if (h2State.openStreams === 0) session.unref();
          });
          return true;
        }
        headers[HTTP2_HEADER_PATH] = path;
        headers[HTTP2_HEADER_SCHEME] = "https";
        const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
        if (body && typeof body.read === "function") {
          body.read(0);
        }
        let contentLength = util.bodyLength(body);
        if (contentLength == null) {
          contentLength = request2.contentLength;
        }
        if (contentLength === 0 || !expectsPayload) {
          contentLength = null;
        }
        if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength != null && request2.contentLength !== contentLength) {
          if (client[kStrictContentLength]) {
            errorRequest(client, request2, new RequestContentLengthMismatchError());
            return false;
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        if (contentLength != null) {
          assert(body, "no body must not have content length");
          headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
        }
        session.ref();
        const shouldEndStream = method === "GET" || method === "HEAD";
        if (expectContinue) {
          headers[HTTP2_HEADER_EXPECT] = "100-continue";
          stream = session.request(headers, { endStream: shouldEndStream, signal });
          stream.once("continue", writeBodyH2);
        } else {
          stream = session.request(headers, {
            endStream: shouldEndStream,
            signal
          });
          writeBodyH2();
        }
        ++h2State.openStreams;
        stream.once("response", (headers2) => {
          const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
          if (request2.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === false) {
            stream.pause();
          }
        });
        stream.once("end", () => {
          request2.onComplete([]);
        });
        stream.on("data", (chunk) => {
          if (request2.onData(chunk) === false) {
            stream.pause();
          }
        });
        stream.once("close", () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0) {
            session.unref();
          }
        });
        stream.once("error", function(err) {
          if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
            h2State.streams -= 1;
            util.destroy(stream, err);
          }
        });
        stream.once("frameError", (type, code) => {
          const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
          errorRequest(client, request2, err);
          if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
            h2State.streams -= 1;
            util.destroy(stream, err);
          }
        });
        return true;
        function writeBodyH2() {
          if (!body) {
            request2.onRequestSent();
          } else if (util.isBuffer(body)) {
            assert(contentLength === body.byteLength, "buffer body must have content length");
            stream.cork();
            stream.write(body);
            stream.uncork();
            stream.end();
            request2.onBodySent(body);
            request2.onRequestSent();
          } else if (util.isBlobLike(body)) {
            if (typeof body.stream === "function") {
              writeIterable({
                client,
                request: request2,
                contentLength,
                h2stream: stream,
                expectsPayload,
                body: body.stream(),
                socket: client[kSocket],
                header: ""
              });
            } else {
              writeBlob({
                body,
                client,
                request: request2,
                contentLength,
                expectsPayload,
                h2stream: stream,
                header: "",
                socket: client[kSocket]
              });
            }
          } else if (util.isStream(body)) {
            writeStream({
              body,
              client,
              request: request2,
              contentLength,
              expectsPayload,
              socket: client[kSocket],
              h2stream: stream,
              header: ""
            });
          } else if (util.isIterable(body)) {
            writeIterable({
              body,
              client,
              request: request2,
              contentLength,
              expectsPayload,
              header: "",
              h2stream: stream,
              socket: client[kSocket]
            });
          } else {
            assert(false);
          }
        }
      }
      function writeStream({ h2stream, body, client, request: request2, socket, contentLength, header, expectsPayload }) {
        assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
        if (client[kHTTPConnVersion] === "h2") {
          let onPipeData = function(chunk) {
            request2.onBodySent(chunk);
          };
          const pipe = pipeline(
            body,
            h2stream,
            (err) => {
              if (err) {
                util.destroy(body, err);
                util.destroy(h2stream, err);
              } else {
                request2.onRequestSent();
              }
            }
          );
          pipe.on("data", onPipeData);
          pipe.once("end", () => {
            pipe.removeListener("data", onPipeData);
            util.destroy(pipe);
          });
          return;
        }
        let finished = false;
        const writer = new AsyncWriter({ socket, request: request2, contentLength, client, expectsPayload, header });
        const onData = function(chunk) {
          if (finished) {
            return;
          }
          try {
            if (!writer.write(chunk) && this.pause) {
              this.pause();
            }
          } catch (err) {
            util.destroy(this, err);
          }
        };
        const onDrain = function() {
          if (finished) {
            return;
          }
          if (body.resume) {
            body.resume();
          }
        };
        const onAbort = function() {
          if (finished) {
            return;
          }
          const err = new RequestAbortedError();
          queueMicrotask(() => onFinished(err));
        };
        const onFinished = function(err) {
          if (finished) {
            return;
          }
          finished = true;
          assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
          socket.off("drain", onDrain).off("error", onFinished);
          body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
          if (!err) {
            try {
              writer.end();
            } catch (er) {
              err = er;
            }
          }
          writer.destroy(err);
          if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
            util.destroy(body, err);
          } else {
            util.destroy(body);
          }
        };
        body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
        if (body.resume) {
          body.resume();
        }
        socket.on("drain", onDrain).on("error", onFinished);
      }
      async function writeBlob({ h2stream, body, client, request: request2, socket, contentLength, header, expectsPayload }) {
        assert(contentLength === body.size, "blob body must have content length");
        const isH2 = client[kHTTPConnVersion] === "h2";
        try {
          if (contentLength != null && contentLength !== body.size) {
            throw new RequestContentLengthMismatchError();
          }
          const buffer = Buffer.from(await body.arrayBuffer());
          if (isH2) {
            h2stream.cork();
            h2stream.write(buffer);
            h2stream.uncork();
          } else {
            socket.cork();
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
            socket.write(buffer);
            socket.uncork();
          }
          request2.onBodySent(buffer);
          request2.onRequestSent();
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          resume(client);
        } catch (err) {
          util.destroy(isH2 ? h2stream : socket, err);
        }
      }
      async function writeIterable({ h2stream, body, client, request: request2, socket, contentLength, header, expectsPayload }) {
        assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
        let callback = null;
        function onDrain() {
          if (callback) {
            const cb = callback;
            callback = null;
            cb();
          }
        }
        const waitForDrain = () => new Promise((resolve, reject) => {
          assert(callback === null);
          if (socket[kError]) {
            reject(socket[kError]);
          } else {
            callback = resolve;
          }
        });
        if (client[kHTTPConnVersion] === "h2") {
          h2stream.on("close", onDrain).on("drain", onDrain);
          try {
            for await (const chunk of body) {
              if (socket[kError]) {
                throw socket[kError];
              }
              const res = h2stream.write(chunk);
              request2.onBodySent(chunk);
              if (!res) {
                await waitForDrain();
              }
            }
          } catch (err) {
            h2stream.destroy(err);
          } finally {
            request2.onRequestSent();
            h2stream.end();
            h2stream.off("close", onDrain).off("drain", onDrain);
          }
          return;
        }
        socket.on("close", onDrain).on("drain", onDrain);
        const writer = new AsyncWriter({ socket, request: request2, contentLength, client, expectsPayload, header });
        try {
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            if (!writer.write(chunk)) {
              await waitForDrain();
            }
          }
          writer.end();
        } catch (err) {
          writer.destroy(err);
        } finally {
          socket.off("close", onDrain).off("drain", onDrain);
        }
      }
      var AsyncWriter = class {
        constructor({ socket, request: request2, contentLength, client, expectsPayload, header }) {
          this.socket = socket;
          this.request = request2;
          this.contentLength = contentLength;
          this.client = client;
          this.bytesWritten = 0;
          this.expectsPayload = expectsPayload;
          this.header = header;
          socket[kWriting] = true;
        }
        write(chunk) {
          const { socket, request: request2, contentLength, client, bytesWritten, expectsPayload, header } = this;
          if (socket[kError]) {
            throw socket[kError];
          }
          if (socket.destroyed) {
            return false;
          }
          const len = Buffer.byteLength(chunk);
          if (!len) {
            return true;
          }
          if (contentLength !== null && bytesWritten + len > contentLength) {
            if (client[kStrictContentLength]) {
              throw new RequestContentLengthMismatchError();
            }
            process.emitWarning(new RequestContentLengthMismatchError());
          }
          socket.cork();
          if (bytesWritten === 0) {
            if (!expectsPayload) {
              socket[kReset] = true;
            }
            if (contentLength === null) {
              socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
            } else {
              socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
            }
          }
          if (contentLength === null) {
            socket.write(`\r
${len.toString(16)}\r
`, "latin1");
          }
          this.bytesWritten += len;
          const ret = socket.write(chunk);
          socket.uncork();
          request2.onBodySent(chunk);
          if (!ret) {
            if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
              if (socket[kParser].timeout.refresh) {
                socket[kParser].timeout.refresh();
              }
            }
          }
          return ret;
        }
        end() {
          const { socket, contentLength, client, bytesWritten, expectsPayload, header, request: request2 } = this;
          request2.onRequestSent();
          socket[kWriting] = false;
          if (socket[kError]) {
            throw socket[kError];
          }
          if (socket.destroyed) {
            return;
          }
          if (bytesWritten === 0) {
            if (expectsPayload) {
              socket.write(`${header}content-length: 0\r
\r
`, "latin1");
            } else {
              socket.write(`${header}\r
`, "latin1");
            }
          } else if (contentLength === null) {
            socket.write("\r\n0\r\n\r\n", "latin1");
          }
          if (contentLength !== null && bytesWritten !== contentLength) {
            if (client[kStrictContentLength]) {
              throw new RequestContentLengthMismatchError();
            } else {
              process.emitWarning(new RequestContentLengthMismatchError());
            }
          }
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
          resume(client);
        }
        destroy(err) {
          const { socket, client } = this;
          socket[kWriting] = false;
          if (err) {
            assert(client[kRunning] <= 1, "pipeline should only contain this request");
            util.destroy(socket, err);
          }
        }
      };
      function errorRequest(client, request2, err) {
        try {
          request2.onError(err);
          assert(request2.aborted);
        } catch (err2) {
          client.emit("error", err2);
        }
      }
      module.exports = Client;
    }
  });

  // node_modules/undici/lib/node/fixed-queue.js
  var require_fixed_queue = __commonJS({
    "node_modules/undici/lib/node/fixed-queue.js"(exports, module) {
      "use strict";
      var kSize = 2048;
      var kMask = kSize - 1;
      var FixedCircularBuffer = class {
        constructor() {
          this.bottom = 0;
          this.top = 0;
          this.list = new Array(kSize);
          this.next = null;
        }
        isEmpty() {
          return this.top === this.bottom;
        }
        isFull() {
          return (this.top + 1 & kMask) === this.bottom;
        }
        push(data) {
          this.list[this.top] = data;
          this.top = this.top + 1 & kMask;
        }
        shift() {
          const nextItem = this.list[this.bottom];
          if (nextItem === void 0)
            return null;
          this.list[this.bottom] = void 0;
          this.bottom = this.bottom + 1 & kMask;
          return nextItem;
        }
      };
      module.exports = class FixedQueue {
        constructor() {
          this.head = this.tail = new FixedCircularBuffer();
        }
        isEmpty() {
          return this.head.isEmpty();
        }
        push(data) {
          if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
          }
          this.head.push(data);
        }
        shift() {
          const tail = this.tail;
          const next = tail.shift();
          if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
          }
          return next;
        }
      };
    }
  });

  // node_modules/undici/lib/pool-stats.js
  var require_pool_stats = __commonJS({
    "node_modules/undici/lib/pool-stats.js"(exports, module) {
      var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
      var kPool = Symbol("pool");
      var PoolStats = class {
        constructor(pool) {
          this[kPool] = pool;
        }
        get connected() {
          return this[kPool][kConnected];
        }
        get free() {
          return this[kPool][kFree];
        }
        get pending() {
          return this[kPool][kPending];
        }
        get queued() {
          return this[kPool][kQueued];
        }
        get running() {
          return this[kPool][kRunning];
        }
        get size() {
          return this[kPool][kSize];
        }
      };
      module.exports = PoolStats;
    }
  });

  // node_modules/undici/lib/pool-base.js
  var require_pool_base = __commonJS({
    "node_modules/undici/lib/pool-base.js"(exports, module) {
      "use strict";
      var DispatcherBase = require_dispatcher_base();
      var FixedQueue = require_fixed_queue();
      var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
      var PoolStats = require_pool_stats();
      var kClients = Symbol("clients");
      var kNeedDrain = Symbol("needDrain");
      var kQueue = Symbol("queue");
      var kClosedResolve = Symbol("closed resolve");
      var kOnDrain = Symbol("onDrain");
      var kOnConnect = Symbol("onConnect");
      var kOnDisconnect = Symbol("onDisconnect");
      var kOnConnectionError = Symbol("onConnectionError");
      var kGetDispatcher = Symbol("get dispatcher");
      var kAddClient = Symbol("add client");
      var kRemoveClient = Symbol("remove client");
      var kStats = Symbol("stats");
      var PoolBase = class extends DispatcherBase {
        constructor() {
          super();
          this[kQueue] = new FixedQueue();
          this[kClients] = [];
          this[kQueued] = 0;
          const pool = this;
          this[kOnDrain] = function onDrain(origin, targets) {
            const queue = pool[kQueue];
            let needDrain = false;
            while (!needDrain) {
              const item = queue.shift();
              if (!item) {
                break;
              }
              pool[kQueued]--;
              needDrain = !this.dispatch(item.opts, item.handler);
            }
            this[kNeedDrain] = needDrain;
            if (!this[kNeedDrain] && pool[kNeedDrain]) {
              pool[kNeedDrain] = false;
              pool.emit("drain", origin, [pool, ...targets]);
            }
            if (pool[kClosedResolve] && queue.isEmpty()) {
              Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
            }
          };
          this[kOnConnect] = (origin, targets) => {
            pool.emit("connect", origin, [pool, ...targets]);
          };
          this[kOnDisconnect] = (origin, targets, err) => {
            pool.emit("disconnect", origin, [pool, ...targets], err);
          };
          this[kOnConnectionError] = (origin, targets, err) => {
            pool.emit("connectionError", origin, [pool, ...targets], err);
          };
          this[kStats] = new PoolStats(this);
        }
        get [kBusy]() {
          return this[kNeedDrain];
        }
        get [kConnected]() {
          return this[kClients].filter((client) => client[kConnected]).length;
        }
        get [kFree]() {
          return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
        }
        get [kPending]() {
          let ret = this[kQueued];
          for (const { [kPending]: pending } of this[kClients]) {
            ret += pending;
          }
          return ret;
        }
        get [kRunning]() {
          let ret = 0;
          for (const { [kRunning]: running } of this[kClients]) {
            ret += running;
          }
          return ret;
        }
        get [kSize]() {
          let ret = this[kQueued];
          for (const { [kSize]: size } of this[kClients]) {
            ret += size;
          }
          return ret;
        }
        get stats() {
          return this[kStats];
        }
        async [kClose]() {
          if (this[kQueue].isEmpty()) {
            return Promise.all(this[kClients].map((c) => c.close()));
          } else {
            return new Promise((resolve) => {
              this[kClosedResolve] = resolve;
            });
          }
        }
        async [kDestroy](err) {
          while (true) {
            const item = this[kQueue].shift();
            if (!item) {
              break;
            }
            item.handler.onError(err);
          }
          return Promise.all(this[kClients].map((c) => c.destroy(err)));
        }
        [kDispatch](opts, handler2) {
          const dispatcher = this[kGetDispatcher]();
          if (!dispatcher) {
            this[kNeedDrain] = true;
            this[kQueue].push({ opts, handler: handler2 });
            this[kQueued]++;
          } else if (!dispatcher.dispatch(opts, handler2)) {
            dispatcher[kNeedDrain] = true;
            this[kNeedDrain] = !this[kGetDispatcher]();
          }
          return !this[kNeedDrain];
        }
        [kAddClient](client) {
          client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].push(client);
          if (this[kNeedDrain]) {
            process.nextTick(() => {
              if (this[kNeedDrain]) {
                this[kOnDrain](client[kUrl], [this, client]);
              }
            });
          }
          return this;
        }
        [kRemoveClient](client) {
          client.close(() => {
            const idx = this[kClients].indexOf(client);
            if (idx !== -1) {
              this[kClients].splice(idx, 1);
            }
          });
          this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
        }
      };
      module.exports = {
        PoolBase,
        kClients,
        kNeedDrain,
        kAddClient,
        kRemoveClient,
        kGetDispatcher
      };
    }
  });

  // node_modules/undici/lib/pool.js
  var require_pool = __commonJS({
    "node_modules/undici/lib/pool.js"(exports, module) {
      "use strict";
      var {
        PoolBase,
        kClients,
        kNeedDrain,
        kAddClient,
        kGetDispatcher
      } = require_pool_base();
      var Client = require_client();
      var {
        InvalidArgumentError
      } = require_errors();
      var util = require_util();
      var { kUrl, kInterceptors } = require_symbols();
      var buildConnector = require_connect();
      var kOptions = Symbol("options");
      var kConnections = Symbol("connections");
      var kFactory = Symbol("factory");
      function defaultFactory(origin, opts) {
        return new Client(origin, opts);
      }
      var Pool = class extends PoolBase {
        constructor(origin, {
          connections,
          factory = defaultFactory,
          connect,
          connectTimeout,
          tls,
          maxCachedSessions,
          socketPath,
          autoSelectFamily,
          autoSelectFamilyAttemptTimeout,
          allowH2,
          ...options
        } = {}) {
          super();
          if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
            throw new InvalidArgumentError("invalid connections");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("factory must be a function.");
          }
          if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
            throw new InvalidArgumentError("connect must be a function or an object");
          }
          if (typeof connect !== "function") {
            connect = buildConnector({
              ...tls,
              maxCachedSessions,
              allowH2,
              socketPath,
              timeout: connectTimeout,
              ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
              ...connect
            });
          }
          this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
          this[kConnections] = connections || null;
          this[kUrl] = util.parseOrigin(origin);
          this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
          this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
          this[kFactory] = factory;
        }
        [kGetDispatcher]() {
          let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
          if (dispatcher) {
            return dispatcher;
          }
          if (!this[kConnections] || this[kClients].length < this[kConnections]) {
            dispatcher = this[kFactory](this[kUrl], this[kOptions]);
            this[kAddClient](dispatcher);
          }
          return dispatcher;
        }
      };
      module.exports = Pool;
    }
  });

  // node_modules/undici/lib/balanced-pool.js
  var require_balanced_pool = __commonJS({
    "node_modules/undici/lib/balanced-pool.js"(exports, module) {
      "use strict";
      var {
        BalancedPoolMissingUpstreamError,
        InvalidArgumentError
      } = require_errors();
      var {
        PoolBase,
        kClients,
        kNeedDrain,
        kAddClient,
        kRemoveClient,
        kGetDispatcher
      } = require_pool_base();
      var Pool = require_pool();
      var { kUrl, kInterceptors } = require_symbols();
      var { parseOrigin } = require_util();
      var kFactory = Symbol("factory");
      var kOptions = Symbol("options");
      var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
      var kCurrentWeight = Symbol("kCurrentWeight");
      var kIndex = Symbol("kIndex");
      var kWeight = Symbol("kWeight");
      var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
      var kErrorPenalty = Symbol("kErrorPenalty");
      function getGreatestCommonDivisor(a, b) {
        if (b === 0) return a;
        return getGreatestCommonDivisor(b, a % b);
      }
      function defaultFactory(origin, opts) {
        return new Pool(origin, opts);
      }
      var BalancedPool = class extends PoolBase {
        constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
          super();
          this[kOptions] = opts;
          this[kIndex] = -1;
          this[kCurrentWeight] = 0;
          this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
          this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
          if (!Array.isArray(upstreams)) {
            upstreams = [upstreams];
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("factory must be a function.");
          }
          this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
          this[kFactory] = factory;
          for (const upstream of upstreams) {
            this.addUpstream(upstream);
          }
          this._updateBalancedPoolStats();
        }
        addUpstream(upstream) {
          const upstreamOrigin = parseOrigin(upstream).origin;
          if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
            return this;
          }
          const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
          this[kAddClient](pool);
          pool.on("connect", () => {
            pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
          });
          pool.on("connectionError", () => {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          });
          pool.on("disconnect", (...args) => {
            const err = args[2];
            if (err && err.code === "UND_ERR_SOCKET") {
              pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
              this._updateBalancedPoolStats();
            }
          });
          for (const client of this[kClients]) {
            client[kWeight] = this[kMaxWeightPerServer];
          }
          this._updateBalancedPoolStats();
          return this;
        }
        _updateBalancedPoolStats() {
          this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
        }
        removeUpstream(upstream) {
          const upstreamOrigin = parseOrigin(upstream).origin;
          const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
          if (pool) {
            this[kRemoveClient](pool);
          }
          return this;
        }
        get upstreams() {
          return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
        }
        [kGetDispatcher]() {
          if (this[kClients].length === 0) {
            throw new BalancedPoolMissingUpstreamError();
          }
          const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
          if (!dispatcher) {
            return;
          }
          const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
          if (allClientsBusy) {
            return;
          }
          let counter = 0;
          let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
          while (counter++ < this[kClients].length) {
            this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
            const pool = this[kClients][this[kIndex]];
            if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
              maxWeightIndex = this[kIndex];
            }
            if (this[kIndex] === 0) {
              this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
              if (this[kCurrentWeight] <= 0) {
                this[kCurrentWeight] = this[kMaxWeightPerServer];
              }
            }
            if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
              return pool;
            }
          }
          this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
          this[kIndex] = maxWeightIndex;
          return this[kClients][maxWeightIndex];
        }
      };
      module.exports = BalancedPool;
    }
  });

  // node_modules/undici/lib/compat/dispatcher-weakref.js
  var require_dispatcher_weakref = __commonJS({
    "node_modules/undici/lib/compat/dispatcher-weakref.js"(exports, module) {
      "use strict";
      var { kConnected, kSize } = require_symbols();
      var CompatWeakRef = class {
        constructor(value) {
          this.value = value;
        }
        deref() {
          return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
        }
      };
      var CompatFinalizer = class {
        constructor(finalizer) {
          this.finalizer = finalizer;
        }
        register(dispatcher, key) {
          if (dispatcher.on) {
            dispatcher.on("disconnect", () => {
              if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
                this.finalizer(key);
              }
            });
          }
        }
      };
      module.exports = function() {
        if (process.env.NODE_V8_COVERAGE) {
          return {
            WeakRef: CompatWeakRef,
            FinalizationRegistry: CompatFinalizer
          };
        }
        return {
          WeakRef: global.WeakRef || CompatWeakRef,
          FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
        };
      };
    }
  });

  // node_modules/undici/lib/agent.js
  var require_agent = __commonJS({
    "node_modules/undici/lib/agent.js"(exports, module) {
      "use strict";
      var { InvalidArgumentError } = require_errors();
      var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
      var DispatcherBase = require_dispatcher_base();
      var Pool = require_pool();
      var Client = require_client();
      var util = require_util();
      var createRedirectInterceptor = require_redirectInterceptor();
      var { WeakRef: WeakRef2, FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
      var kOnConnect = Symbol("onConnect");
      var kOnDisconnect = Symbol("onDisconnect");
      var kOnConnectionError = Symbol("onConnectionError");
      var kMaxRedirections = Symbol("maxRedirections");
      var kOnDrain = Symbol("onDrain");
      var kFactory = Symbol("factory");
      var kFinalizer = Symbol("finalizer");
      var kOptions = Symbol("options");
      function defaultFactory(origin, opts) {
        return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
      }
      var Agent = class extends DispatcherBase {
        constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
          super();
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("factory must be a function.");
          }
          if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
            throw new InvalidArgumentError("connect must be a function or an object");
          }
          if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
            throw new InvalidArgumentError("maxRedirections must be a positive number");
          }
          if (connect && typeof connect !== "function") {
            connect = { ...connect };
          }
          this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
          this[kOptions] = { ...util.deepClone(options), connect };
          this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
          this[kMaxRedirections] = maxRedirections;
          this[kFactory] = factory;
          this[kClients] = /* @__PURE__ */ new Map();
          this[kFinalizer] = new FinalizationRegistry2(
            /* istanbul ignore next: gc is undeterministic */
            (key) => {
              const ref = this[kClients].get(key);
              if (ref !== void 0 && ref.deref() === void 0) {
                this[kClients].delete(key);
              }
            }
          );
          const agent = this;
          this[kOnDrain] = (origin, targets) => {
            agent.emit("drain", origin, [agent, ...targets]);
          };
          this[kOnConnect] = (origin, targets) => {
            agent.emit("connect", origin, [agent, ...targets]);
          };
          this[kOnDisconnect] = (origin, targets, err) => {
            agent.emit("disconnect", origin, [agent, ...targets], err);
          };
          this[kOnConnectionError] = (origin, targets, err) => {
            agent.emit("connectionError", origin, [agent, ...targets], err);
          };
        }
        get [kRunning]() {
          let ret = 0;
          for (const ref of this[kClients].values()) {
            const client = ref.deref();
            if (client) {
              ret += client[kRunning];
            }
          }
          return ret;
        }
        [kDispatch](opts, handler2) {
          let key;
          if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
            key = String(opts.origin);
          } else {
            throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
          }
          const ref = this[kClients].get(key);
          let dispatcher = ref ? ref.deref() : null;
          if (!dispatcher) {
            dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
            this[kClients].set(key, new WeakRef2(dispatcher));
            this[kFinalizer].register(dispatcher, key);
          }
          return dispatcher.dispatch(opts, handler2);
        }
        async [kClose]() {
          const closePromises = [];
          for (const ref of this[kClients].values()) {
            const client = ref.deref();
            if (client) {
              closePromises.push(client.close());
            }
          }
          await Promise.all(closePromises);
        }
        async [kDestroy](err) {
          const destroyPromises = [];
          for (const ref of this[kClients].values()) {
            const client = ref.deref();
            if (client) {
              destroyPromises.push(client.destroy(err));
            }
          }
          await Promise.all(destroyPromises);
        }
      };
      module.exports = Agent;
    }
  });

  // node_modules/undici/lib/api/readable.js
  var require_readable = __commonJS({
    "node_modules/undici/lib/api/readable.js"(exports, module) {
      "use strict";
      var assert = __require("assert");
      var { Readable } = __require("stream");
      var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
      var util = require_util();
      var { ReadableStreamFrom, toUSVString } = require_util();
      var Blob2;
      var kConsume = Symbol("kConsume");
      var kReading = Symbol("kReading");
      var kBody = Symbol("kBody");
      var kAbort = Symbol("abort");
      var kContentType = Symbol("kContentType");
      var noop = () => {
      };
      module.exports = class BodyReadable extends Readable {
        constructor({
          resume,
          abort,
          contentType = "",
          highWaterMark = 64 * 1024
          // Same as nodejs fs streams.
        }) {
          super({
            autoDestroy: true,
            read: resume,
            highWaterMark
          });
          this._readableState.dataEmitted = false;
          this[kAbort] = abort;
          this[kConsume] = null;
          this[kBody] = null;
          this[kContentType] = contentType;
          this[kReading] = false;
        }
        destroy(err) {
          if (this.destroyed) {
            return this;
          }
          if (!err && !this._readableState.endEmitted) {
            err = new RequestAbortedError();
          }
          if (err) {
            this[kAbort]();
          }
          return super.destroy(err);
        }
        emit(ev, ...args) {
          if (ev === "data") {
            this._readableState.dataEmitted = true;
          } else if (ev === "error") {
            this._readableState.errorEmitted = true;
          }
          return super.emit(ev, ...args);
        }
        on(ev, ...args) {
          if (ev === "data" || ev === "readable") {
            this[kReading] = true;
          }
          return super.on(ev, ...args);
        }
        addListener(ev, ...args) {
          return this.on(ev, ...args);
        }
        off(ev, ...args) {
          const ret = super.off(ev, ...args);
          if (ev === "data" || ev === "readable") {
            this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
          }
          return ret;
        }
        removeListener(ev, ...args) {
          return this.off(ev, ...args);
        }
        push(chunk) {
          if (this[kConsume] && chunk !== null && this.readableLength === 0) {
            consumePush(this[kConsume], chunk);
            return this[kReading] ? super.push(chunk) : true;
          }
          return super.push(chunk);
        }
        // https://fetch.spec.whatwg.org/#dom-body-text
        async text() {
          return consume(this, "text");
        }
        // https://fetch.spec.whatwg.org/#dom-body-json
        async json() {
          return consume(this, "json");
        }
        // https://fetch.spec.whatwg.org/#dom-body-blob
        async blob() {
          return consume(this, "blob");
        }
        // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
        async arrayBuffer() {
          return consume(this, "arrayBuffer");
        }
        // https://fetch.spec.whatwg.org/#dom-body-formdata
        async formData() {
          throw new NotSupportedError();
        }
        // https://fetch.spec.whatwg.org/#dom-body-bodyused
        get bodyUsed() {
          return util.isDisturbed(this);
        }
        // https://fetch.spec.whatwg.org/#dom-body-body
        get body() {
          if (!this[kBody]) {
            this[kBody] = ReadableStreamFrom(this);
            if (this[kConsume]) {
              this[kBody].getReader();
              assert(this[kBody].locked);
            }
          }
          return this[kBody];
        }
        dump(opts) {
          let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
          const signal = opts && opts.signal;
          if (signal) {
            try {
              if (typeof signal !== "object" || !("aborted" in signal)) {
                throw new InvalidArgumentError("signal must be an AbortSignal");
              }
              util.throwIfAborted(signal);
            } catch (err) {
              return Promise.reject(err);
            }
          }
          if (this.closed) {
            return Promise.resolve(null);
          }
          return new Promise((resolve, reject) => {
            const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
              this.destroy();
            }) : noop;
            this.on("close", function() {
              signalListenerCleanup();
              if (signal && signal.aborted) {
                reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
              } else {
                resolve(null);
              }
            }).on("error", noop).on("data", function(chunk) {
              limit -= chunk.length;
              if (limit <= 0) {
                this.destroy();
              }
            }).resume();
          });
        }
      };
      function isLocked(self2) {
        return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
      }
      function isUnusable(self2) {
        return util.isDisturbed(self2) || isLocked(self2);
      }
      async function consume(stream, type) {
        if (isUnusable(stream)) {
          throw new TypeError("unusable");
        }
        assert(!stream[kConsume]);
        return new Promise((resolve, reject) => {
          stream[kConsume] = {
            type,
            stream,
            resolve,
            reject,
            length: 0,
            body: []
          };
          stream.on("error", function(err) {
            consumeFinish(this[kConsume], err);
          }).on("close", function() {
            if (this[kConsume].body !== null) {
              consumeFinish(this[kConsume], new RequestAbortedError());
            }
          });
          process.nextTick(consumeStart, stream[kConsume]);
        });
      }
      function consumeStart(consume2) {
        if (consume2.body === null) {
          return;
        }
        const { _readableState: state } = consume2.stream;
        for (const chunk of state.buffer) {
          consumePush(consume2, chunk);
        }
        if (state.endEmitted) {
          consumeEnd(this[kConsume]);
        } else {
          consume2.stream.on("end", function() {
            consumeEnd(this[kConsume]);
          });
        }
        consume2.stream.resume();
        while (consume2.stream.read() != null) {
        }
      }
      function consumeEnd(consume2) {
        const { type, body, resolve, stream, length } = consume2;
        try {
          if (type === "text") {
            resolve(toUSVString(Buffer.concat(body)));
          } else if (type === "json") {
            resolve(JSON.parse(Buffer.concat(body)));
          } else if (type === "arrayBuffer") {
            const dst = new Uint8Array(length);
            let pos = 0;
            for (const buf of body) {
              dst.set(buf, pos);
              pos += buf.byteLength;
            }
            resolve(dst.buffer);
          } else if (type === "blob") {
            if (!Blob2) {
              Blob2 = __require("buffer").Blob;
            }
            resolve(new Blob2(body, { type: stream[kContentType] }));
          }
          consumeFinish(consume2);
        } catch (err) {
          stream.destroy(err);
        }
      }
      function consumePush(consume2, chunk) {
        consume2.length += chunk.length;
        consume2.body.push(chunk);
      }
      function consumeFinish(consume2, err) {
        if (consume2.body === null) {
          return;
        }
        if (err) {
          consume2.reject(err);
        } else {
          consume2.resolve();
        }
        consume2.type = null;
        consume2.stream = null;
        consume2.resolve = null;
        consume2.reject = null;
        consume2.length = 0;
        consume2.body = null;
      }
    }
  });

  // node_modules/undici/lib/api/util.js
  var require_util3 = __commonJS({
    "node_modules/undici/lib/api/util.js"(exports, module) {
      var assert = __require("assert");
      var {
        ResponseStatusCodeError
      } = require_errors();
      var { toUSVString } = require_util();
      async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
        assert(body);
        let chunks = [];
        let limit = 0;
        for await (const chunk of body) {
          chunks.push(chunk);
          limit += chunk.length;
          if (limit > 128 * 1024) {
            chunks = null;
            break;
          }
        }
        if (statusCode === 204 || !contentType || !chunks) {
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
          return;
        }
        try {
          if (contentType.startsWith("application/json")) {
            const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
            return;
          }
          if (contentType.startsWith("text/")) {
            const payload = toUSVString(Buffer.concat(chunks));
            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
            return;
          }
        } catch (err) {
        }
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
      }
      module.exports = { getResolveErrorBodyCallback };
    }
  });

  // node_modules/undici/lib/api/abort-signal.js
  var require_abort_signal = __commonJS({
    "node_modules/undici/lib/api/abort-signal.js"(exports, module) {
      var { addAbortListener } = require_util();
      var { RequestAbortedError } = require_errors();
      var kListener = Symbol("kListener");
      var kSignal = Symbol("kSignal");
      function abort(self2) {
        if (self2.abort) {
          self2.abort();
        } else {
          self2.onError(new RequestAbortedError());
        }
      }
      function addSignal(self2, signal) {
        self2[kSignal] = null;
        self2[kListener] = null;
        if (!signal) {
          return;
        }
        if (signal.aborted) {
          abort(self2);
          return;
        }
        self2[kSignal] = signal;
        self2[kListener] = () => {
          abort(self2);
        };
        addAbortListener(self2[kSignal], self2[kListener]);
      }
      function removeSignal(self2) {
        if (!self2[kSignal]) {
          return;
        }
        if ("removeEventListener" in self2[kSignal]) {
          self2[kSignal].removeEventListener("abort", self2[kListener]);
        } else {
          self2[kSignal].removeListener("abort", self2[kListener]);
        }
        self2[kSignal] = null;
        self2[kListener] = null;
      }
      module.exports = {
        addSignal,
        removeSignal
      };
    }
  });

  // node_modules/undici/lib/api/api-request.js
  var require_api_request = __commonJS({
    "node_modules/undici/lib/api/api-request.js"(exports, module) {
      "use strict";
      var Readable = require_readable();
      var {
        InvalidArgumentError,
        RequestAbortedError
      } = require_errors();
      var util = require_util();
      var { getResolveErrorBodyCallback } = require_util3();
      var { AsyncResource } = __require("async_hooks");
      var { addSignal, removeSignal } = require_abort_signal();
      var RequestHandler = class extends AsyncResource {
        constructor(opts, callback) {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("invalid opts");
          }
          const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
          try {
            if (typeof callback !== "function") {
              throw new InvalidArgumentError("invalid callback");
            }
            if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
              throw new InvalidArgumentError("invalid highWaterMark");
            }
            if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
              throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
            }
            if (method === "CONNECT") {
              throw new InvalidArgumentError("invalid method");
            }
            if (onInfo && typeof onInfo !== "function") {
              throw new InvalidArgumentError("invalid onInfo callback");
            }
            super("UNDICI_REQUEST");
          } catch (err) {
            if (util.isStream(body)) {
              util.destroy(body.on("error", util.nop), err);
            }
            throw err;
          }
          this.responseHeaders = responseHeaders || null;
          this.opaque = opaque || null;
          this.callback = callback;
          this.res = null;
          this.abort = null;
          this.body = body;
          this.trailers = {};
          this.context = null;
          this.onInfo = onInfo || null;
          this.throwOnError = throwOnError;
          this.highWaterMark = highWaterMark;
          if (util.isStream(body)) {
            body.on("error", (err) => {
              this.onError(err);
            });
          }
          addSignal(this, signal);
        }
        onConnect(abort, context2) {
          if (!this.callback) {
            throw new RequestAbortedError();
          }
          this.abort = abort;
          this.context = context2;
        }
        onHeaders(statusCode, rawHeaders, resume, statusMessage) {
          const { callback, opaque, abort, context: context2, responseHeaders, highWaterMark } = this;
          const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          if (statusCode < 200) {
            if (this.onInfo) {
              this.onInfo({ statusCode, headers });
            }
            return;
          }
          const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          const body = new Readable({ resume, abort, contentType, highWaterMark });
          this.callback = null;
          this.res = body;
          if (callback !== null) {
            if (this.throwOnError && statusCode >= 400) {
              this.runInAsyncScope(
                getResolveErrorBodyCallback,
                null,
                { callback, body, contentType, statusCode, statusMessage, headers }
              );
            } else {
              this.runInAsyncScope(callback, null, null, {
                statusCode,
                headers,
                trailers: this.trailers,
                opaque,
                body,
                context: context2
              });
            }
          }
        }
        onData(chunk) {
          const { res } = this;
          return res.push(chunk);
        }
        onComplete(trailers) {
          const { res } = this;
          removeSignal(this);
          util.parseHeaders(trailers, this.trailers);
          res.push(null);
        }
        onError(err) {
          const { res, callback, body, opaque } = this;
          removeSignal(this);
          if (callback) {
            this.callback = null;
            queueMicrotask(() => {
              this.runInAsyncScope(callback, null, err, { opaque });
            });
          }
          if (res) {
            this.res = null;
            queueMicrotask(() => {
              util.destroy(res, err);
            });
          }
          if (body) {
            this.body = null;
            util.destroy(body, err);
          }
        }
      };
      function request2(opts, callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            request2.call(this, opts, (err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        try {
          this.dispatch(opts, new RequestHandler(opts, callback));
        } catch (err) {
          if (typeof callback !== "function") {
            throw err;
          }
          const opaque = opts && opts.opaque;
          queueMicrotask(() => callback(err, { opaque }));
        }
      }
      module.exports = request2;
      module.exports.RequestHandler = RequestHandler;
    }
  });

  // node_modules/undici/lib/api/api-stream.js
  var require_api_stream = __commonJS({
    "node_modules/undici/lib/api/api-stream.js"(exports, module) {
      "use strict";
      var { finished, PassThrough } = __require("stream");
      var {
        InvalidArgumentError,
        InvalidReturnValueError,
        RequestAbortedError
      } = require_errors();
      var util = require_util();
      var { getResolveErrorBodyCallback } = require_util3();
      var { AsyncResource } = __require("async_hooks");
      var { addSignal, removeSignal } = require_abort_signal();
      var StreamHandler = class extends AsyncResource {
        constructor(opts, factory, callback) {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("invalid opts");
          }
          const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
          try {
            if (typeof callback !== "function") {
              throw new InvalidArgumentError("invalid callback");
            }
            if (typeof factory !== "function") {
              throw new InvalidArgumentError("invalid factory");
            }
            if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
              throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
            }
            if (method === "CONNECT") {
              throw new InvalidArgumentError("invalid method");
            }
            if (onInfo && typeof onInfo !== "function") {
              throw new InvalidArgumentError("invalid onInfo callback");
            }
            super("UNDICI_STREAM");
          } catch (err) {
            if (util.isStream(body)) {
              util.destroy(body.on("error", util.nop), err);
            }
            throw err;
          }
          this.responseHeaders = responseHeaders || null;
          this.opaque = opaque || null;
          this.factory = factory;
          this.callback = callback;
          this.res = null;
          this.abort = null;
          this.context = null;
          this.trailers = null;
          this.body = body;
          this.onInfo = onInfo || null;
          this.throwOnError = throwOnError || false;
          if (util.isStream(body)) {
            body.on("error", (err) => {
              this.onError(err);
            });
          }
          addSignal(this, signal);
        }
        onConnect(abort, context2) {
          if (!this.callback) {
            throw new RequestAbortedError();
          }
          this.abort = abort;
          this.context = context2;
        }
        onHeaders(statusCode, rawHeaders, resume, statusMessage) {
          const { factory, opaque, context: context2, callback, responseHeaders } = this;
          const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          if (statusCode < 200) {
            if (this.onInfo) {
              this.onInfo({ statusCode, headers });
            }
            return;
          }
          this.factory = null;
          let res;
          if (this.throwOnError && statusCode >= 400) {
            const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
            const contentType = parsedHeaders["content-type"];
            res = new PassThrough();
            this.callback = null;
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body: res, contentType, statusCode, statusMessage, headers }
            );
          } else {
            if (factory === null) {
              return;
            }
            res = this.runInAsyncScope(factory, null, {
              statusCode,
              headers,
              opaque,
              context: context2
            });
            if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
              throw new InvalidReturnValueError("expected Writable");
            }
            finished(res, { readable: false }, (err) => {
              const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
              this.res = null;
              if (err || !res2.readable) {
                util.destroy(res2, err);
              }
              this.callback = null;
              this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
              if (err) {
                abort();
              }
            });
          }
          res.on("drain", resume);
          this.res = res;
          const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
          return needDrain !== true;
        }
        onData(chunk) {
          const { res } = this;
          return res ? res.write(chunk) : true;
        }
        onComplete(trailers) {
          const { res } = this;
          removeSignal(this);
          if (!res) {
            return;
          }
          this.trailers = util.parseHeaders(trailers);
          res.end();
        }
        onError(err) {
          const { res, callback, opaque, body } = this;
          removeSignal(this);
          this.factory = null;
          if (res) {
            this.res = null;
            util.destroy(res, err);
          } else if (callback) {
            this.callback = null;
            queueMicrotask(() => {
              this.runInAsyncScope(callback, null, err, { opaque });
            });
          }
          if (body) {
            this.body = null;
            util.destroy(body, err);
          }
        }
      };
      function stream(opts, factory, callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            stream.call(this, opts, factory, (err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        try {
          this.dispatch(opts, new StreamHandler(opts, factory, callback));
        } catch (err) {
          if (typeof callback !== "function") {
            throw err;
          }
          const opaque = opts && opts.opaque;
          queueMicrotask(() => callback(err, { opaque }));
        }
      }
      module.exports = stream;
    }
  });

  // node_modules/undici/lib/api/api-pipeline.js
  var require_api_pipeline = __commonJS({
    "node_modules/undici/lib/api/api-pipeline.js"(exports, module) {
      "use strict";
      var {
        Readable,
        Duplex,
        PassThrough
      } = __require("stream");
      var {
        InvalidArgumentError,
        InvalidReturnValueError,
        RequestAbortedError
      } = require_errors();
      var util = require_util();
      var { AsyncResource } = __require("async_hooks");
      var { addSignal, removeSignal } = require_abort_signal();
      var assert = __require("assert");
      var kResume = Symbol("resume");
      var PipelineRequest = class extends Readable {
        constructor() {
          super({ autoDestroy: true });
          this[kResume] = null;
        }
        _read() {
          const { [kResume]: resume } = this;
          if (resume) {
            this[kResume] = null;
            resume();
          }
        }
        _destroy(err, callback) {
          this._read();
          callback(err);
        }
      };
      var PipelineResponse = class extends Readable {
        constructor(resume) {
          super({ autoDestroy: true });
          this[kResume] = resume;
        }
        _read() {
          this[kResume]();
        }
        _destroy(err, callback) {
          if (!err && !this._readableState.endEmitted) {
            err = new RequestAbortedError();
          }
          callback(err);
        }
      };
      var PipelineHandler = class extends AsyncResource {
        constructor(opts, handler2) {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("invalid opts");
          }
          if (typeof handler2 !== "function") {
            throw new InvalidArgumentError("invalid handler");
          }
          const { signal, method, opaque, onInfo, responseHeaders } = opts;
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_PIPELINE");
          this.opaque = opaque || null;
          this.responseHeaders = responseHeaders || null;
          this.handler = handler2;
          this.abort = null;
          this.context = null;
          this.onInfo = onInfo || null;
          this.req = new PipelineRequest().on("error", util.nop);
          this.ret = new Duplex({
            readableObjectMode: opts.objectMode,
            autoDestroy: true,
            read: () => {
              const { body } = this;
              if (body && body.resume) {
                body.resume();
              }
            },
            write: (chunk, encoding, callback) => {
              const { req } = this;
              if (req.push(chunk, encoding) || req._readableState.destroyed) {
                callback();
              } else {
                req[kResume] = callback;
              }
            },
            destroy: (err, callback) => {
              const { body, req, res, ret, abort } = this;
              if (!err && !ret._readableState.endEmitted) {
                err = new RequestAbortedError();
              }
              if (abort && err) {
                abort();
              }
              util.destroy(body, err);
              util.destroy(req, err);
              util.destroy(res, err);
              removeSignal(this);
              callback(err);
            }
          }).on("prefinish", () => {
            const { req } = this;
            req.push(null);
          });
          this.res = null;
          addSignal(this, signal);
        }
        onConnect(abort, context2) {
          const { ret, res } = this;
          assert(!res, "pipeline cannot be retried");
          if (ret.destroyed) {
            throw new RequestAbortedError();
          }
          this.abort = abort;
          this.context = context2;
        }
        onHeaders(statusCode, rawHeaders, resume) {
          const { opaque, handler: handler2, context: context2 } = this;
          if (statusCode < 200) {
            if (this.onInfo) {
              const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
              this.onInfo({ statusCode, headers });
            }
            return;
          }
          this.res = new PipelineResponse(resume);
          let body;
          try {
            this.handler = null;
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            body = this.runInAsyncScope(handler2, null, {
              statusCode,
              headers,
              opaque,
              body: this.res,
              context: context2
            });
          } catch (err) {
            this.res.on("error", util.nop);
            throw err;
          }
          if (!body || typeof body.on !== "function") {
            throw new InvalidReturnValueError("expected Readable");
          }
          body.on("data", (chunk) => {
            const { ret, body: body2 } = this;
            if (!ret.push(chunk) && body2.pause) {
              body2.pause();
            }
          }).on("error", (err) => {
            const { ret } = this;
            util.destroy(ret, err);
          }).on("end", () => {
            const { ret } = this;
            ret.push(null);
          }).on("close", () => {
            const { ret } = this;
            if (!ret._readableState.ended) {
              util.destroy(ret, new RequestAbortedError());
            }
          });
          this.body = body;
        }
        onData(chunk) {
          const { res } = this;
          return res.push(chunk);
        }
        onComplete(trailers) {
          const { res } = this;
          res.push(null);
        }
        onError(err) {
          const { ret } = this;
          this.handler = null;
          util.destroy(ret, err);
        }
      };
      function pipeline(opts, handler2) {
        try {
          const pipelineHandler = new PipelineHandler(opts, handler2);
          this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
          return pipelineHandler.ret;
        } catch (err) {
          return new PassThrough().destroy(err);
        }
      }
      module.exports = pipeline;
    }
  });

  // node_modules/undici/lib/api/api-upgrade.js
  var require_api_upgrade = __commonJS({
    "node_modules/undici/lib/api/api-upgrade.js"(exports, module) {
      "use strict";
      var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
      var { AsyncResource } = __require("async_hooks");
      var util = require_util();
      var { addSignal, removeSignal } = require_abort_signal();
      var assert = __require("assert");
      var UpgradeHandler = class extends AsyncResource {
        constructor(opts, callback) {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("invalid opts");
          }
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          const { signal, opaque, responseHeaders } = opts;
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          super("UNDICI_UPGRADE");
          this.responseHeaders = responseHeaders || null;
          this.opaque = opaque || null;
          this.callback = callback;
          this.abort = null;
          this.context = null;
          addSignal(this, signal);
        }
        onConnect(abort, context2) {
          if (!this.callback) {
            throw new RequestAbortedError();
          }
          this.abort = abort;
          this.context = null;
        }
        onHeaders() {
          throw new SocketError("bad upgrade", null);
        }
        onUpgrade(statusCode, rawHeaders, socket) {
          const { callback, opaque, context: context2 } = this;
          assert.strictEqual(statusCode, 101);
          removeSignal(this);
          this.callback = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          this.runInAsyncScope(callback, null, null, {
            headers,
            socket,
            opaque,
            context: context2
          });
        }
        onError(err) {
          const { callback, opaque } = this;
          removeSignal(this);
          if (callback) {
            this.callback = null;
            queueMicrotask(() => {
              this.runInAsyncScope(callback, null, err, { opaque });
            });
          }
        }
      };
      function upgrade(opts, callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            upgrade.call(this, opts, (err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        try {
          const upgradeHandler = new UpgradeHandler(opts, callback);
          this.dispatch({
            ...opts,
            method: opts.method || "GET",
            upgrade: opts.protocol || "Websocket"
          }, upgradeHandler);
        } catch (err) {
          if (typeof callback !== "function") {
            throw err;
          }
          const opaque = opts && opts.opaque;
          queueMicrotask(() => callback(err, { opaque }));
        }
      }
      module.exports = upgrade;
    }
  });

  // node_modules/undici/lib/api/api-connect.js
  var require_api_connect = __commonJS({
    "node_modules/undici/lib/api/api-connect.js"(exports, module) {
      "use strict";
      var { AsyncResource } = __require("async_hooks");
      var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
      var util = require_util();
      var { addSignal, removeSignal } = require_abort_signal();
      var ConnectHandler = class extends AsyncResource {
        constructor(opts, callback) {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("invalid opts");
          }
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          const { signal, opaque, responseHeaders } = opts;
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          super("UNDICI_CONNECT");
          this.opaque = opaque || null;
          this.responseHeaders = responseHeaders || null;
          this.callback = callback;
          this.abort = null;
          addSignal(this, signal);
        }
        onConnect(abort, context2) {
          if (!this.callback) {
            throw new RequestAbortedError();
          }
          this.abort = abort;
          this.context = context2;
        }
        onHeaders() {
          throw new SocketError("bad connect", null);
        }
        onUpgrade(statusCode, rawHeaders, socket) {
          const { callback, opaque, context: context2 } = this;
          removeSignal(this);
          this.callback = null;
          let headers = rawHeaders;
          if (headers != null) {
            headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          }
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            socket,
            opaque,
            context: context2
          });
        }
        onError(err) {
          const { callback, opaque } = this;
          removeSignal(this);
          if (callback) {
            this.callback = null;
            queueMicrotask(() => {
              this.runInAsyncScope(callback, null, err, { opaque });
            });
          }
        }
      };
      function connect(opts, callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            connect.call(this, opts, (err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        try {
          const connectHandler = new ConnectHandler(opts, callback);
          this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
        } catch (err) {
          if (typeof callback !== "function") {
            throw err;
          }
          const opaque = opts && opts.opaque;
          queueMicrotask(() => callback(err, { opaque }));
        }
      }
      module.exports = connect;
    }
  });

  // node_modules/undici/lib/api/index.js
  var require_api = __commonJS({
    "node_modules/undici/lib/api/index.js"(exports, module) {
      "use strict";
      module.exports.request = require_api_request();
      module.exports.stream = require_api_stream();
      module.exports.pipeline = require_api_pipeline();
      module.exports.upgrade = require_api_upgrade();
      module.exports.connect = require_api_connect();
    }
  });

  // node_modules/undici/lib/mock/mock-errors.js
  var require_mock_errors = __commonJS({
    "node_modules/undici/lib/mock/mock-errors.js"(exports, module) {
      "use strict";
      var { UndiciError } = require_errors();
      var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
        constructor(message) {
          super(message);
          Error.captureStackTrace(this, _MockNotMatchedError);
          this.name = "MockNotMatchedError";
          this.message = message || "The request does not match any registered mock dispatches";
          this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
        }
      };
      module.exports = {
        MockNotMatchedError
      };
    }
  });

  // node_modules/undici/lib/mock/mock-symbols.js
  var require_mock_symbols = __commonJS({
    "node_modules/undici/lib/mock/mock-symbols.js"(exports, module) {
      "use strict";
      module.exports = {
        kAgent: Symbol("agent"),
        kOptions: Symbol("options"),
        kFactory: Symbol("factory"),
        kDispatches: Symbol("dispatches"),
        kDispatchKey: Symbol("dispatch key"),
        kDefaultHeaders: Symbol("default headers"),
        kDefaultTrailers: Symbol("default trailers"),
        kContentLength: Symbol("content length"),
        kMockAgent: Symbol("mock agent"),
        kMockAgentSet: Symbol("mock agent set"),
        kMockAgentGet: Symbol("mock agent get"),
        kMockDispatch: Symbol("mock dispatch"),
        kClose: Symbol("close"),
        kOriginalClose: Symbol("original agent close"),
        kOrigin: Symbol("origin"),
        kIsMockActive: Symbol("is mock active"),
        kNetConnect: Symbol("net connect"),
        kGetNetConnect: Symbol("get net connect"),
        kConnected: Symbol("connected")
      };
    }
  });

  // node_modules/undici/lib/mock/mock-utils.js
  var require_mock_utils = __commonJS({
    "node_modules/undici/lib/mock/mock-utils.js"(exports, module) {
      "use strict";
      var { MockNotMatchedError } = require_mock_errors();
      var {
        kDispatches,
        kMockAgent,
        kOriginalDispatch,
        kOrigin,
        kGetNetConnect
      } = require_mock_symbols();
      var { buildURL, nop } = require_util();
      var { STATUS_CODES } = __require("http");
      var {
        types: {
          isPromise
        }
      } = __require("util");
      function matchValue(match, value) {
        if (typeof match === "string") {
          return match === value;
        }
        if (match instanceof RegExp) {
          return match.test(value);
        }
        if (typeof match === "function") {
          return match(value) === true;
        }
        return false;
      }
      function lowerCaseEntries(headers) {
        return Object.fromEntries(
          Object.entries(headers).map(([headerName, headerValue]) => {
            return [headerName.toLocaleLowerCase(), headerValue];
          })
        );
      }
      function getHeaderByName(headers, key) {
        if (Array.isArray(headers)) {
          for (let i = 0; i < headers.length; i += 2) {
            if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
              return headers[i + 1];
            }
          }
          return void 0;
        } else if (typeof headers.get === "function") {
          return headers.get(key);
        } else {
          return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
        }
      }
      function buildHeadersFromArray(headers) {
        const clone = headers.slice();
        const entries = [];
        for (let index = 0; index < clone.length; index += 2) {
          entries.push([clone[index], clone[index + 1]]);
        }
        return Object.fromEntries(entries);
      }
      function matchHeaders(mockDispatch2, headers) {
        if (typeof mockDispatch2.headers === "function") {
          if (Array.isArray(headers)) {
            headers = buildHeadersFromArray(headers);
          }
          return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
        }
        if (typeof mockDispatch2.headers === "undefined") {
          return true;
        }
        if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
          return false;
        }
        for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
          const headerValue = getHeaderByName(headers, matchHeaderName);
          if (!matchValue(matchHeaderValue, headerValue)) {
            return false;
          }
        }
        return true;
      }
      function safeUrl(path) {
        if (typeof path !== "string") {
          return path;
        }
        const pathSegments = path.split("?");
        if (pathSegments.length !== 2) {
          return path;
        }
        const qp = new URLSearchParams(pathSegments.pop());
        qp.sort();
        return [...pathSegments, qp.toString()].join("?");
      }
      function matchKey(mockDispatch2, { path, method, body, headers }) {
        const pathMatch = matchValue(mockDispatch2.path, path);
        const methodMatch = matchValue(mockDispatch2.method, method);
        const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
        const headersMatch = matchHeaders(mockDispatch2, headers);
        return pathMatch && methodMatch && bodyMatch && headersMatch;
      }
      function getResponseData2(data) {
        if (Buffer.isBuffer(data)) {
          return data;
        } else if (typeof data === "object") {
          return JSON.stringify(data);
        } else {
          return data.toString();
        }
      }
      function getMockDispatch(mockDispatches, key) {
        const basePath = key.query ? buildURL(key.path, key.query) : key.path;
        const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
        let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
        if (matchedMockDispatches.length === 0) {
          throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
        }
        matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
        if (matchedMockDispatches.length === 0) {
          throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
        }
        matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
        if (matchedMockDispatches.length === 0) {
          throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
        }
        matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
        if (matchedMockDispatches.length === 0) {
          throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
        }
        return matchedMockDispatches[0];
      }
      function addMockDispatch(mockDispatches, key, data) {
        const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
        const replyData = typeof data === "function" ? { callback: data } : { ...data };
        const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
        mockDispatches.push(newMockDispatch);
        return newMockDispatch;
      }
      function deleteMockDispatch(mockDispatches, key) {
        const index = mockDispatches.findIndex((dispatch) => {
          if (!dispatch.consumed) {
            return false;
          }
          return matchKey(dispatch, key);
        });
        if (index !== -1) {
          mockDispatches.splice(index, 1);
        }
      }
      function buildKey(opts) {
        const { path, method, body, headers, query } = opts;
        return {
          path,
          method,
          body,
          headers,
          query
        };
      }
      function generateKeyValues(data) {
        return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
          ...keyValuePairs,
          Buffer.from(`${key}`),
          Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
        ], []);
      }
      function getStatusText(statusCode) {
        return STATUS_CODES[statusCode] || "unknown";
      }
      async function getResponse(body) {
        const buffers = [];
        for await (const data of body) {
          buffers.push(data);
        }
        return Buffer.concat(buffers).toString("utf8");
      }
      function mockDispatch(opts, handler2) {
        const key = buildKey(opts);
        const mockDispatch2 = getMockDispatch(this[kDispatches], key);
        mockDispatch2.timesInvoked++;
        if (mockDispatch2.data.callback) {
          mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
        }
        const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
        const { timesInvoked, times } = mockDispatch2;
        mockDispatch2.consumed = !persist && timesInvoked >= times;
        mockDispatch2.pending = timesInvoked < times;
        if (error !== null) {
          deleteMockDispatch(this[kDispatches], key);
          handler2.onError(error);
          return true;
        }
        if (typeof delay === "number" && delay > 0) {
          setTimeout(() => {
            handleReply(this[kDispatches]);
          }, delay);
        } else {
          handleReply(this[kDispatches]);
        }
        function handleReply(mockDispatches, _data = data) {
          const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
          const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
          if (isPromise(body)) {
            body.then((newData) => handleReply(mockDispatches, newData));
            return;
          }
          const responseData = getResponseData2(body);
          const responseHeaders = generateKeyValues(headers);
          const responseTrailers = generateKeyValues(trailers);
          handler2.abort = nop;
          handler2.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
          handler2.onData(Buffer.from(responseData));
          handler2.onComplete(responseTrailers);
          deleteMockDispatch(mockDispatches, key);
        }
        function resume() {
        }
        return true;
      }
      function buildMockDispatch() {
        const agent = this[kMockAgent];
        const origin = this[kOrigin];
        const originalDispatch = this[kOriginalDispatch];
        return function dispatch(opts, handler2) {
          if (agent.isMockActive) {
            try {
              mockDispatch.call(this, opts, handler2);
            } catch (error) {
              if (error instanceof MockNotMatchedError) {
                const netConnect = agent[kGetNetConnect]();
                if (netConnect === false) {
                  throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
                }
                if (checkNetConnect(netConnect, origin)) {
                  originalDispatch.call(this, opts, handler2);
                } else {
                  throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
                }
              } else {
                throw error;
              }
            }
          } else {
            originalDispatch.call(this, opts, handler2);
          }
        };
      }
      function checkNetConnect(netConnect, origin) {
        const url = new URL(origin);
        if (netConnect === true) {
          return true;
        } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
          return true;
        }
        return false;
      }
      function buildMockOptions(opts) {
        if (opts) {
          const { agent, ...mockOptions } = opts;
          return mockOptions;
        }
      }
      module.exports = {
        getResponseData: getResponseData2,
        getMockDispatch,
        addMockDispatch,
        deleteMockDispatch,
        buildKey,
        generateKeyValues,
        matchValue,
        getResponse,
        getStatusText,
        mockDispatch,
        buildMockDispatch,
        checkNetConnect,
        buildMockOptions,
        getHeaderByName
      };
    }
  });

  // node_modules/undici/lib/mock/mock-interceptor.js
  var require_mock_interceptor = __commonJS({
    "node_modules/undici/lib/mock/mock-interceptor.js"(exports, module) {
      "use strict";
      var { getResponseData: getResponseData2, buildKey, addMockDispatch } = require_mock_utils();
      var {
        kDispatches,
        kDispatchKey,
        kDefaultHeaders,
        kDefaultTrailers,
        kContentLength,
        kMockDispatch
      } = require_mock_symbols();
      var { InvalidArgumentError } = require_errors();
      var { buildURL } = require_util();
      var MockScope = class {
        constructor(mockDispatch) {
          this[kMockDispatch] = mockDispatch;
        }
        /**
         * Delay a reply by a set amount in ms.
         */
        delay(waitInMs) {
          if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
            throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
          }
          this[kMockDispatch].delay = waitInMs;
          return this;
        }
        /**
         * For a defined reply, never mark as consumed.
         */
        persist() {
          this[kMockDispatch].persist = true;
          return this;
        }
        /**
         * Allow one to define a reply for a set amount of matching requests.
         */
        times(repeatTimes) {
          if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
            throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
          }
          this[kMockDispatch].times = repeatTimes;
          return this;
        }
      };
      var MockInterceptor = class {
        constructor(opts, mockDispatches) {
          if (typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object");
          }
          if (typeof opts.path === "undefined") {
            throw new InvalidArgumentError("opts.path must be defined");
          }
          if (typeof opts.method === "undefined") {
            opts.method = "GET";
          }
          if (typeof opts.path === "string") {
            if (opts.query) {
              opts.path = buildURL(opts.path, opts.query);
            } else {
              const parsedURL = new URL(opts.path, "data://");
              opts.path = parsedURL.pathname + parsedURL.search;
            }
          }
          if (typeof opts.method === "string") {
            opts.method = opts.method.toUpperCase();
          }
          this[kDispatchKey] = buildKey(opts);
          this[kDispatches] = mockDispatches;
          this[kDefaultHeaders] = {};
          this[kDefaultTrailers] = {};
          this[kContentLength] = false;
        }
        createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
          const responseData = getResponseData2(data);
          const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
          const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
          const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
          return { statusCode, data, headers, trailers };
        }
        validateReplyParameters(statusCode, data, responseOptions) {
          if (typeof statusCode === "undefined") {
            throw new InvalidArgumentError("statusCode must be defined");
          }
          if (typeof data === "undefined") {
            throw new InvalidArgumentError("data must be defined");
          }
          if (typeof responseOptions !== "object") {
            throw new InvalidArgumentError("responseOptions must be an object");
          }
        }
        /**
         * Mock an undici request with a defined reply.
         */
        reply(replyData) {
          if (typeof replyData === "function") {
            const wrappedDefaultsCallback = (opts) => {
              const resolvedData = replyData(opts);
              if (typeof resolvedData !== "object") {
                throw new InvalidArgumentError("reply options callback must return an object");
              }
              const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
              this.validateReplyParameters(statusCode2, data2, responseOptions2);
              return {
                ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
              };
            };
            const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
            return new MockScope(newMockDispatch2);
          }
          const [statusCode, data = "", responseOptions = {}] = [...arguments];
          this.validateReplyParameters(statusCode, data, responseOptions);
          const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
          const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
          return new MockScope(newMockDispatch);
        }
        /**
         * Mock an undici request with a defined error.
         */
        replyWithError(error) {
          if (typeof error === "undefined") {
            throw new InvalidArgumentError("error must be defined");
          }
          const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
          return new MockScope(newMockDispatch);
        }
        /**
         * Set default reply headers on the interceptor for subsequent replies
         */
        defaultReplyHeaders(headers) {
          if (typeof headers === "undefined") {
            throw new InvalidArgumentError("headers must be defined");
          }
          this[kDefaultHeaders] = headers;
          return this;
        }
        /**
         * Set default reply trailers on the interceptor for subsequent replies
         */
        defaultReplyTrailers(trailers) {
          if (typeof trailers === "undefined") {
            throw new InvalidArgumentError("trailers must be defined");
          }
          this[kDefaultTrailers] = trailers;
          return this;
        }
        /**
         * Set reply content length header for replies on the interceptor
         */
        replyContentLength() {
          this[kContentLength] = true;
          return this;
        }
      };
      module.exports.MockInterceptor = MockInterceptor;
      module.exports.MockScope = MockScope;
    }
  });

  // node_modules/undici/lib/mock/mock-client.js
  var require_mock_client = __commonJS({
    "node_modules/undici/lib/mock/mock-client.js"(exports, module) {
      "use strict";
      var { promisify } = __require("util");
      var Client = require_client();
      var { buildMockDispatch } = require_mock_utils();
      var {
        kDispatches,
        kMockAgent,
        kClose,
        kOriginalClose,
        kOrigin,
        kOriginalDispatch,
        kConnected
      } = require_mock_symbols();
      var { MockInterceptor } = require_mock_interceptor();
      var Symbols = require_symbols();
      var { InvalidArgumentError } = require_errors();
      var MockClient = class extends Client {
        constructor(origin, opts) {
          super(origin, opts);
          if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
            throw new InvalidArgumentError("Argument opts.agent must implement Agent");
          }
          this[kMockAgent] = opts.agent;
          this[kOrigin] = origin;
          this[kDispatches] = [];
          this[kConnected] = 1;
          this[kOriginalDispatch] = this.dispatch;
          this[kOriginalClose] = this.close.bind(this);
          this.dispatch = buildMockDispatch.call(this);
          this.close = this[kClose];
        }
        get [Symbols.kConnected]() {
          return this[kConnected];
        }
        /**
         * Sets up the base interceptor for mocking replies from undici.
         */
        intercept(opts) {
          return new MockInterceptor(opts, this[kDispatches]);
        }
        async [kClose]() {
          await promisify(this[kOriginalClose])();
          this[kConnected] = 0;
          this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
        }
      };
      module.exports = MockClient;
    }
  });

  // node_modules/undici/lib/mock/mock-pool.js
  var require_mock_pool = __commonJS({
    "node_modules/undici/lib/mock/mock-pool.js"(exports, module) {
      "use strict";
      var { promisify } = __require("util");
      var Pool = require_pool();
      var { buildMockDispatch } = require_mock_utils();
      var {
        kDispatches,
        kMockAgent,
        kClose,
        kOriginalClose,
        kOrigin,
        kOriginalDispatch,
        kConnected
      } = require_mock_symbols();
      var { MockInterceptor } = require_mock_interceptor();
      var Symbols = require_symbols();
      var { InvalidArgumentError } = require_errors();
      var MockPool = class extends Pool {
        constructor(origin, opts) {
          super(origin, opts);
          if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
            throw new InvalidArgumentError("Argument opts.agent must implement Agent");
          }
          this[kMockAgent] = opts.agent;
          this[kOrigin] = origin;
          this[kDispatches] = [];
          this[kConnected] = 1;
          this[kOriginalDispatch] = this.dispatch;
          this[kOriginalClose] = this.close.bind(this);
          this.dispatch = buildMockDispatch.call(this);
          this.close = this[kClose];
        }
        get [Symbols.kConnected]() {
          return this[kConnected];
        }
        /**
         * Sets up the base interceptor for mocking replies from undici.
         */
        intercept(opts) {
          return new MockInterceptor(opts, this[kDispatches]);
        }
        async [kClose]() {
          await promisify(this[kOriginalClose])();
          this[kConnected] = 0;
          this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
        }
      };
      module.exports = MockPool;
    }
  });

  // node_modules/undici/lib/mock/pluralizer.js
  var require_pluralizer = __commonJS({
    "node_modules/undici/lib/mock/pluralizer.js"(exports, module) {
      "use strict";
      var singulars = {
        pronoun: "it",
        is: "is",
        was: "was",
        this: "this"
      };
      var plurals = {
        pronoun: "they",
        is: "are",
        was: "were",
        this: "these"
      };
      module.exports = class Pluralizer {
        constructor(singular, plural) {
          this.singular = singular;
          this.plural = plural;
        }
        pluralize(count) {
          const one = count === 1;
          const keys = one ? singulars : plurals;
          const noun = one ? this.singular : this.plural;
          return { ...keys, count, noun };
        }
      };
    }
  });

  // node_modules/undici/lib/mock/pending-interceptors-formatter.js
  var require_pending_interceptors_formatter = __commonJS({
    "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports, module) {
      "use strict";
      var { Transform } = __require("stream");
      var { Console } = __require("console");
      module.exports = class PendingInterceptorsFormatter {
        constructor({ disableColors } = {}) {
          this.transform = new Transform({
            transform(chunk, _enc, cb) {
              cb(null, chunk);
            }
          });
          this.logger = new Console({
            stdout: this.transform,
            inspectOptions: {
              colors: !disableColors && !process.env.CI
            }
          });
        }
        format(pendingInterceptors) {
          const withPrettyHeaders = pendingInterceptors.map(
            ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
              Method: method,
              Origin: origin,
              Path: path,
              "Status code": statusCode,
              Persistent: persist ? "\u2705" : "\u274C",
              Invocations: timesInvoked,
              Remaining: persist ? Infinity : times - timesInvoked
            })
          );
          this.logger.table(withPrettyHeaders);
          return this.transform.read().toString();
        }
      };
    }
  });

  // node_modules/undici/lib/mock/mock-agent.js
  var require_mock_agent = __commonJS({
    "node_modules/undici/lib/mock/mock-agent.js"(exports, module) {
      "use strict";
      var { kClients } = require_symbols();
      var Agent = require_agent();
      var {
        kAgent,
        kMockAgentSet,
        kMockAgentGet,
        kDispatches,
        kIsMockActive,
        kNetConnect,
        kGetNetConnect,
        kOptions,
        kFactory
      } = require_mock_symbols();
      var MockClient = require_mock_client();
      var MockPool = require_mock_pool();
      var { matchValue, buildMockOptions } = require_mock_utils();
      var { InvalidArgumentError, UndiciError } = require_errors();
      var Dispatcher = require_dispatcher();
      var Pluralizer = require_pluralizer();
      var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
      var FakeWeakRef = class {
        constructor(value) {
          this.value = value;
        }
        deref() {
          return this.value;
        }
      };
      var MockAgent = class extends Dispatcher {
        constructor(opts) {
          super(opts);
          this[kNetConnect] = true;
          this[kIsMockActive] = true;
          if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
            throw new InvalidArgumentError("Argument opts.agent must implement Agent");
          }
          const agent = opts && opts.agent ? opts.agent : new Agent(opts);
          this[kAgent] = agent;
          this[kClients] = agent[kClients];
          this[kOptions] = buildMockOptions(opts);
        }
        get(origin) {
          let dispatcher = this[kMockAgentGet](origin);
          if (!dispatcher) {
            dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
          }
          return dispatcher;
        }
        dispatch(opts, handler2) {
          this.get(opts.origin);
          return this[kAgent].dispatch(opts, handler2);
        }
        async close() {
          await this[kAgent].close();
          this[kClients].clear();
        }
        deactivate() {
          this[kIsMockActive] = false;
        }
        activate() {
          this[kIsMockActive] = true;
        }
        enableNetConnect(matcher) {
          if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
            if (Array.isArray(this[kNetConnect])) {
              this[kNetConnect].push(matcher);
            } else {
              this[kNetConnect] = [matcher];
            }
          } else if (typeof matcher === "undefined") {
            this[kNetConnect] = true;
          } else {
            throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
          }
        }
        disableNetConnect() {
          this[kNetConnect] = false;
        }
        // This is required to bypass issues caused by using global symbols - see:
        // https://github.com/nodejs/undici/issues/1447
        get isMockActive() {
          return this[kIsMockActive];
        }
        [kMockAgentSet](origin, dispatcher) {
          this[kClients].set(origin, new FakeWeakRef(dispatcher));
        }
        [kFactory](origin) {
          const mockOptions = Object.assign({ agent: this }, this[kOptions]);
          return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
        }
        [kMockAgentGet](origin) {
          const ref = this[kClients].get(origin);
          if (ref) {
            return ref.deref();
          }
          if (typeof origin !== "string") {
            const dispatcher = this[kFactory]("http://localhost:9999");
            this[kMockAgentSet](origin, dispatcher);
            return dispatcher;
          }
          for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
            const nonExplicitDispatcher = nonExplicitRef.deref();
            if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
              const dispatcher = this[kFactory](origin);
              this[kMockAgentSet](origin, dispatcher);
              dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
              return dispatcher;
            }
          }
        }
        [kGetNetConnect]() {
          return this[kNetConnect];
        }
        pendingInterceptors() {
          const mockAgentClients = this[kClients];
          return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
        }
        assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
          const pending = this.pendingInterceptors();
          if (pending.length === 0) {
            return;
          }
          const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
          throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
        }
      };
      module.exports = MockAgent;
    }
  });

  // node_modules/undici/lib/proxy-agent.js
  var require_proxy_agent = __commonJS({
    "node_modules/undici/lib/proxy-agent.js"(exports, module) {
      "use strict";
      var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
      var { URL: URL2 } = __require("url");
      var Agent = require_agent();
      var Pool = require_pool();
      var DispatcherBase = require_dispatcher_base();
      var { InvalidArgumentError, RequestAbortedError } = require_errors();
      var buildConnector = require_connect();
      var kAgent = Symbol("proxy agent");
      var kClient = Symbol("proxy client");
      var kProxyHeaders = Symbol("proxy headers");
      var kRequestTls = Symbol("request tls settings");
      var kProxyTls = Symbol("proxy tls settings");
      var kConnectEndpoint = Symbol("connect endpoint function");
      function defaultProtocolPort(protocol) {
        return protocol === "https:" ? 443 : 80;
      }
      function buildProxyOptions(opts) {
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        return {
          uri: opts.uri,
          protocol: opts.protocol || "https"
        };
      }
      function defaultFactory(origin, opts) {
        return new Pool(origin, opts);
      }
      var ProxyAgent = class extends DispatcherBase {
        constructor(opts) {
          super(opts);
          this[kProxy] = buildProxyOptions(opts);
          this[kAgent] = new Agent(opts);
          this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
          if (typeof opts === "string") {
            opts = { uri: opts };
          }
          if (!opts || !opts.uri) {
            throw new InvalidArgumentError("Proxy opts.uri is mandatory");
          }
          const { clientFactory = defaultFactory } = opts;
          if (typeof clientFactory !== "function") {
            throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
          }
          this[kRequestTls] = opts.requestTls;
          this[kProxyTls] = opts.proxyTls;
          this[kProxyHeaders] = opts.headers || {};
          const resolvedUrl = new URL2(opts.uri);
          const { origin, port, host, username, password } = resolvedUrl;
          if (opts.auth && opts.token) {
            throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
          } else if (opts.auth) {
            this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
          } else if (opts.token) {
            this[kProxyHeaders]["proxy-authorization"] = opts.token;
          } else if (username && password) {
            this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
          }
          const connect = buildConnector({ ...opts.proxyTls });
          this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
          this[kClient] = clientFactory(resolvedUrl, { connect });
          this[kAgent] = new Agent({
            ...opts,
            connect: async (opts2, callback) => {
              let requestedHost = opts2.host;
              if (!opts2.port) {
                requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
              }
              try {
                const { socket, statusCode } = await this[kClient].connect({
                  origin,
                  port,
                  path: requestedHost,
                  signal: opts2.signal,
                  headers: {
                    ...this[kProxyHeaders],
                    host
                  }
                });
                if (statusCode !== 200) {
                  socket.on("error", () => {
                  }).destroy();
                  callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
                }
                if (opts2.protocol !== "https:") {
                  callback(null, socket);
                  return;
                }
                let servername;
                if (this[kRequestTls]) {
                  servername = this[kRequestTls].servername;
                } else {
                  servername = opts2.servername;
                }
                this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
              } catch (err) {
                callback(err);
              }
            }
          });
        }
        dispatch(opts, handler2) {
          const { host } = new URL2(opts.origin);
          const headers = buildHeaders(opts.headers);
          throwIfProxyAuthIsSent(headers);
          return this[kAgent].dispatch(
            {
              ...opts,
              headers: {
                ...headers,
                host
              }
            },
            handler2
          );
        }
        async [kClose]() {
          await this[kAgent].close();
          await this[kClient].close();
        }
        async [kDestroy]() {
          await this[kAgent].destroy();
          await this[kClient].destroy();
        }
      };
      function buildHeaders(headers) {
        if (Array.isArray(headers)) {
          const headersPair = {};
          for (let i = 0; i < headers.length; i += 2) {
            headersPair[headers[i]] = headers[i + 1];
          }
          return headersPair;
        }
        return headers;
      }
      function throwIfProxyAuthIsSent(headers) {
        const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
        if (existProxyAuth) {
          throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
        }
      }
      module.exports = ProxyAgent;
    }
  });

  // node_modules/undici/lib/handler/RetryHandler.js
  var require_RetryHandler = __commonJS({
    "node_modules/undici/lib/handler/RetryHandler.js"(exports, module) {
      var assert = __require("assert");
      var { kRetryHandlerDefaultRetry } = require_symbols();
      var { RequestRetryError } = require_errors();
      var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
      function calculateRetryAfterHeader(retryAfter) {
        const current = Date.now();
        const diff = new Date(retryAfter).getTime() - current;
        return diff;
      }
      var RetryHandler = class _RetryHandler {
        constructor(opts, handlers) {
          const { retryOptions, ...dispatchOpts } = opts;
          const {
            // Retry scoped
            retry: retryFn,
            maxRetries,
            maxTimeout,
            minTimeout,
            timeoutFactor,
            // Response scoped
            methods,
            errorCodes,
            retryAfter,
            statusCodes
          } = retryOptions ?? {};
          this.dispatch = handlers.dispatch;
          this.handler = handlers.handler;
          this.opts = dispatchOpts;
          this.abort = null;
          this.aborted = false;
          this.retryOpts = {
            retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
            retryAfter: retryAfter ?? true,
            maxTimeout: maxTimeout ?? 30 * 1e3,
            // 30s,
            timeout: minTimeout ?? 500,
            // .5s
            timeoutFactor: timeoutFactor ?? 2,
            maxRetries: maxRetries ?? 5,
            // What errors we should retry
            methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
            // Indicates which errors to retry
            statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
            // List of errors to retry
            errorCodes: errorCodes ?? [
              "ECONNRESET",
              "ECONNREFUSED",
              "ENOTFOUND",
              "ENETDOWN",
              "ENETUNREACH",
              "EHOSTDOWN",
              "EHOSTUNREACH",
              "EPIPE"
            ]
          };
          this.retryCount = 0;
          this.start = 0;
          this.end = null;
          this.etag = null;
          this.resume = null;
          this.handler.onConnect((reason) => {
            this.aborted = true;
            if (this.abort) {
              this.abort(reason);
            } else {
              this.reason = reason;
            }
          });
        }
        onRequestSent() {
          if (this.handler.onRequestSent) {
            this.handler.onRequestSent();
          }
        }
        onUpgrade(statusCode, headers, socket) {
          if (this.handler.onUpgrade) {
            this.handler.onUpgrade(statusCode, headers, socket);
          }
        }
        onConnect(abort) {
          if (this.aborted) {
            abort(this.reason);
          } else {
            this.abort = abort;
          }
        }
        onBodySent(chunk) {
          if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
        }
        static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
          const { statusCode, code, headers } = err;
          const { method, retryOptions } = opts;
          const {
            maxRetries,
            timeout,
            maxTimeout,
            timeoutFactor,
            statusCodes,
            errorCodes,
            methods
          } = retryOptions;
          let { counter, currentTimeout } = state;
          currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
          if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
            cb(err);
            return;
          }
          if (Array.isArray(methods) && !methods.includes(method)) {
            cb(err);
            return;
          }
          if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
            cb(err);
            return;
          }
          if (counter > maxRetries) {
            cb(err);
            return;
          }
          let retryAfterHeader = headers != null && headers["retry-after"];
          if (retryAfterHeader) {
            retryAfterHeader = Number(retryAfterHeader);
            retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
          }
          const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
          state.currentTimeout = retryTimeout;
          setTimeout(() => cb(null), retryTimeout);
        }
        onHeaders(statusCode, rawHeaders, resume, statusMessage) {
          const headers = parseHeaders(rawHeaders);
          this.retryCount += 1;
          if (statusCode >= 300) {
            this.abort(
              new RequestRetryError("Request failed", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          if (this.resume != null) {
            this.resume = null;
            if (statusCode !== 206) {
              return true;
            }
            const contentRange = parseRangeHeader(headers["content-range"]);
            if (!contentRange) {
              this.abort(
                new RequestRetryError("Content-Range mismatch", statusCode, {
                  headers,
                  count: this.retryCount
                })
              );
              return false;
            }
            if (this.etag != null && this.etag !== headers.etag) {
              this.abort(
                new RequestRetryError("ETag mismatch", statusCode, {
                  headers,
                  count: this.retryCount
                })
              );
              return false;
            }
            const { start, size, end = size } = contentRange;
            assert(this.start === start, "content-range mismatch");
            assert(this.end == null || this.end === end, "content-range mismatch");
            this.resume = resume;
            return true;
          }
          if (this.end == null) {
            if (statusCode === 206) {
              const range = parseRangeHeader(headers["content-range"]);
              if (range == null) {
                return this.handler.onHeaders(
                  statusCode,
                  rawHeaders,
                  resume,
                  statusMessage
                );
              }
              const { start, size, end = size } = range;
              assert(
                start != null && Number.isFinite(start) && this.start !== start,
                "content-range mismatch"
              );
              assert(Number.isFinite(start));
              assert(
                end != null && Number.isFinite(end) && this.end !== end,
                "invalid content-length"
              );
              this.start = start;
              this.end = end;
            }
            if (this.end == null) {
              const contentLength = headers["content-length"];
              this.end = contentLength != null ? Number(contentLength) : null;
            }
            assert(Number.isFinite(this.start));
            assert(
              this.end == null || Number.isFinite(this.end),
              "invalid content-length"
            );
            this.resume = resume;
            this.etag = headers.etag != null ? headers.etag : null;
            return this.handler.onHeaders(
              statusCode,
              rawHeaders,
              resume,
              statusMessage
            );
          }
          const err = new RequestRetryError("Request failed", statusCode, {
            headers,
            count: this.retryCount
          });
          this.abort(err);
          return false;
        }
        onData(chunk) {
          this.start += chunk.length;
          return this.handler.onData(chunk);
        }
        onComplete(rawTrailers) {
          this.retryCount = 0;
          return this.handler.onComplete(rawTrailers);
        }
        onError(err) {
          if (this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err);
          }
          this.retryOpts.retry(
            err,
            {
              state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
              opts: { retryOptions: this.retryOpts, ...this.opts }
            },
            onRetry.bind(this)
          );
          function onRetry(err2) {
            if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
              return this.handler.onError(err2);
            }
            if (this.start !== 0) {
              this.opts = {
                ...this.opts,
                headers: {
                  ...this.opts.headers,
                  range: `bytes=${this.start}-${this.end ?? ""}`
                }
              };
            }
            try {
              this.dispatch(this.opts, this);
            } catch (err3) {
              this.handler.onError(err3);
            }
          }
        }
      };
      module.exports = RetryHandler;
    }
  });

  // node_modules/undici/lib/global.js
  var require_global2 = __commonJS({
    "node_modules/undici/lib/global.js"(exports, module) {
      "use strict";
      var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
      var { InvalidArgumentError } = require_errors();
      var Agent = require_agent();
      if (getGlobalDispatcher() === void 0) {
        setGlobalDispatcher(new Agent());
      }
      function setGlobalDispatcher(agent) {
        if (!agent || typeof agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument agent must implement Agent");
        }
        Object.defineProperty(globalThis, globalDispatcher, {
          value: agent,
          writable: true,
          enumerable: false,
          configurable: false
        });
      }
      function getGlobalDispatcher() {
        return globalThis[globalDispatcher];
      }
      module.exports = {
        setGlobalDispatcher,
        getGlobalDispatcher
      };
    }
  });

  // node_modules/undici/lib/handler/DecoratorHandler.js
  var require_DecoratorHandler = __commonJS({
    "node_modules/undici/lib/handler/DecoratorHandler.js"(exports, module) {
      "use strict";
      module.exports = class DecoratorHandler {
        constructor(handler2) {
          this.handler = handler2;
        }
        onConnect(...args) {
          return this.handler.onConnect(...args);
        }
        onError(...args) {
          return this.handler.onError(...args);
        }
        onUpgrade(...args) {
          return this.handler.onUpgrade(...args);
        }
        onHeaders(...args) {
          return this.handler.onHeaders(...args);
        }
        onData(...args) {
          return this.handler.onData(...args);
        }
        onComplete(...args) {
          return this.handler.onComplete(...args);
        }
        onBodySent(...args) {
          return this.handler.onBodySent(...args);
        }
      };
    }
  });

  // node_modules/undici/lib/fetch/headers.js
  var require_headers = __commonJS({
    "node_modules/undici/lib/fetch/headers.js"(exports, module) {
      "use strict";
      var { kHeadersList, kConstruct } = require_symbols();
      var { kGuard } = require_symbols2();
      var { kEnumerableProperty } = require_util();
      var {
        makeIterator,
        isValidHeaderName,
        isValidHeaderValue
      } = require_util2();
      var { webidl } = require_webidl();
      var assert = __require("assert");
      var kHeadersMap = Symbol("headers map");
      var kHeadersSortedMap = Symbol("headers map sorted");
      function isHTTPWhiteSpaceCharCode(code) {
        return code === 10 || code === 13 || code === 9 || code === 32;
      }
      function headerValueNormalize(potentialValue) {
        let i = 0;
        let j = potentialValue.length;
        while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
        while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
        return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
      }
      function fill(headers, object) {
        if (Array.isArray(object)) {
          for (let i = 0; i < object.length; ++i) {
            const header = object[i];
            if (header.length !== 2) {
              throw webidl.errors.exception({
                header: "Headers constructor",
                message: `expected name/value pair to be length 2, found ${header.length}.`
              });
            }
            appendHeader(headers, header[0], header[1]);
          }
        } else if (typeof object === "object" && object !== null) {
          const keys = Object.keys(object);
          for (let i = 0; i < keys.length; ++i) {
            appendHeader(headers, keys[i], object[keys[i]]);
          }
        } else {
          throw webidl.errors.conversionFailed({
            prefix: "Headers constructor",
            argument: "Argument 1",
            types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
          });
        }
      }
      function appendHeader(headers, name, value) {
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.append",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.append",
            value,
            type: "header value"
          });
        }
        if (headers[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (headers[kGuard] === "request-no-cors") {
        }
        return headers[kHeadersList].append(name, value);
      }
      var HeadersList = class _HeadersList {
        /** @type {[string, string][]|null} */
        cookies = null;
        constructor(init) {
          if (init instanceof _HeadersList) {
            this[kHeadersMap] = new Map(init[kHeadersMap]);
            this[kHeadersSortedMap] = init[kHeadersSortedMap];
            this.cookies = init.cookies === null ? null : [...init.cookies];
          } else {
            this[kHeadersMap] = new Map(init);
            this[kHeadersSortedMap] = null;
          }
        }
        // https://fetch.spec.whatwg.org/#header-list-contains
        contains(name) {
          name = name.toLowerCase();
          return this[kHeadersMap].has(name);
        }
        clear() {
          this[kHeadersMap].clear();
          this[kHeadersSortedMap] = null;
          this.cookies = null;
        }
        // https://fetch.spec.whatwg.org/#concept-header-list-append
        append(name, value) {
          this[kHeadersSortedMap] = null;
          const lowercaseName = name.toLowerCase();
          const exists = this[kHeadersMap].get(lowercaseName);
          if (exists) {
            const delimiter = lowercaseName === "cookie" ? "; " : ", ";
            this[kHeadersMap].set(lowercaseName, {
              name: exists.name,
              value: `${exists.value}${delimiter}${value}`
            });
          } else {
            this[kHeadersMap].set(lowercaseName, { name, value });
          }
          if (lowercaseName === "set-cookie") {
            this.cookies ??= [];
            this.cookies.push(value);
          }
        }
        // https://fetch.spec.whatwg.org/#concept-header-list-set
        set(name, value) {
          this[kHeadersSortedMap] = null;
          const lowercaseName = name.toLowerCase();
          if (lowercaseName === "set-cookie") {
            this.cookies = [value];
          }
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        // https://fetch.spec.whatwg.org/#concept-header-list-delete
        delete(name) {
          this[kHeadersSortedMap] = null;
          name = name.toLowerCase();
          if (name === "set-cookie") {
            this.cookies = null;
          }
          this[kHeadersMap].delete(name);
        }
        // https://fetch.spec.whatwg.org/#concept-header-list-get
        get(name) {
          const value = this[kHeadersMap].get(name.toLowerCase());
          return value === void 0 ? null : value.value;
        }
        *[Symbol.iterator]() {
          for (const [name, { value }] of this[kHeadersMap]) {
            yield [name, value];
          }
        }
        get entries() {
          const headers = {};
          if (this[kHeadersMap].size) {
            for (const { name, value } of this[kHeadersMap].values()) {
              headers[name] = value;
            }
          }
          return headers;
        }
      };
      var Headers = class _Headers {
        constructor(init = void 0) {
          if (init === kConstruct) {
            return;
          }
          this[kHeadersList] = new HeadersList();
          this[kGuard] = "none";
          if (init !== void 0) {
            init = webidl.converters.HeadersInit(init);
            fill(this, init);
          }
        }
        // https://fetch.spec.whatwg.org/#dom-headers-append
        append(name, value) {
          webidl.brandCheck(this, _Headers);
          webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
          name = webidl.converters.ByteString(name);
          value = webidl.converters.ByteString(value);
          return appendHeader(this, name, value);
        }
        // https://fetch.spec.whatwg.org/#dom-headers-delete
        delete(name) {
          webidl.brandCheck(this, _Headers);
          webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
          name = webidl.converters.ByteString(name);
          if (!isValidHeaderName(name)) {
            throw webidl.errors.invalidArgument({
              prefix: "Headers.delete",
              value: name,
              type: "header name"
            });
          }
          if (this[kGuard] === "immutable") {
            throw new TypeError("immutable");
          } else if (this[kGuard] === "request-no-cors") {
          }
          if (!this[kHeadersList].contains(name)) {
            return;
          }
          this[kHeadersList].delete(name);
        }
        // https://fetch.spec.whatwg.org/#dom-headers-get
        get(name) {
          webidl.brandCheck(this, _Headers);
          webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
          name = webidl.converters.ByteString(name);
          if (!isValidHeaderName(name)) {
            throw webidl.errors.invalidArgument({
              prefix: "Headers.get",
              value: name,
              type: "header name"
            });
          }
          return this[kHeadersList].get(name);
        }
        // https://fetch.spec.whatwg.org/#dom-headers-has
        has(name) {
          webidl.brandCheck(this, _Headers);
          webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
          name = webidl.converters.ByteString(name);
          if (!isValidHeaderName(name)) {
            throw webidl.errors.invalidArgument({
              prefix: "Headers.has",
              value: name,
              type: "header name"
            });
          }
          return this[kHeadersList].contains(name);
        }
        // https://fetch.spec.whatwg.org/#dom-headers-set
        set(name, value) {
          webidl.brandCheck(this, _Headers);
          webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
          name = webidl.converters.ByteString(name);
          value = webidl.converters.ByteString(value);
          value = headerValueNormalize(value);
          if (!isValidHeaderName(name)) {
            throw webidl.errors.invalidArgument({
              prefix: "Headers.set",
              value: name,
              type: "header name"
            });
          } else if (!isValidHeaderValue(value)) {
            throw webidl.errors.invalidArgument({
              prefix: "Headers.set",
              value,
              type: "header value"
            });
          }
          if (this[kGuard] === "immutable") {
            throw new TypeError("immutable");
          } else if (this[kGuard] === "request-no-cors") {
          }
          this[kHeadersList].set(name, value);
        }
        // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
        getSetCookie() {
          webidl.brandCheck(this, _Headers);
          const list = this[kHeadersList].cookies;
          if (list) {
            return [...list];
          }
          return [];
        }
        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
        get [kHeadersSortedMap]() {
          if (this[kHeadersList][kHeadersSortedMap]) {
            return this[kHeadersList][kHeadersSortedMap];
          }
          const headers = [];
          const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
          const cookies = this[kHeadersList].cookies;
          for (let i = 0; i < names.length; ++i) {
            const [name, value] = names[i];
            if (name === "set-cookie") {
              for (let j = 0; j < cookies.length; ++j) {
                headers.push([name, cookies[j]]);
              }
            } else {
              assert(value !== null);
              headers.push([name, value]);
            }
          }
          this[kHeadersList][kHeadersSortedMap] = headers;
          return headers;
        }
        keys() {
          webidl.brandCheck(this, _Headers);
          if (this[kGuard] === "immutable") {
            const value = this[kHeadersSortedMap];
            return makeIterator(
              () => value,
              "Headers",
              "key"
            );
          }
          return makeIterator(
            () => [...this[kHeadersSortedMap].values()],
            "Headers",
            "key"
          );
        }
        values() {
          webidl.brandCheck(this, _Headers);
          if (this[kGuard] === "immutable") {
            const value = this[kHeadersSortedMap];
            return makeIterator(
              () => value,
              "Headers",
              "value"
            );
          }
          return makeIterator(
            () => [...this[kHeadersSortedMap].values()],
            "Headers",
            "value"
          );
        }
        entries() {
          webidl.brandCheck(this, _Headers);
          if (this[kGuard] === "immutable") {
            const value = this[kHeadersSortedMap];
            return makeIterator(
              () => value,
              "Headers",
              "key+value"
            );
          }
          return makeIterator(
            () => [...this[kHeadersSortedMap].values()],
            "Headers",
            "key+value"
          );
        }
        /**
         * @param {(value: string, key: string, self: Headers) => void} callbackFn
         * @param {unknown} thisArg
         */
        forEach(callbackFn, thisArg = globalThis) {
          webidl.brandCheck(this, _Headers);
          webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
          if (typeof callbackFn !== "function") {
            throw new TypeError(
              "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
            );
          }
          for (const [key, value] of this) {
            callbackFn.apply(thisArg, [value, key, this]);
          }
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          webidl.brandCheck(this, _Headers);
          return this[kHeadersList];
        }
      };
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      Object.defineProperties(Headers.prototype, {
        append: kEnumerableProperty,
        delete: kEnumerableProperty,
        get: kEnumerableProperty,
        has: kEnumerableProperty,
        set: kEnumerableProperty,
        getSetCookie: kEnumerableProperty,
        keys: kEnumerableProperty,
        values: kEnumerableProperty,
        entries: kEnumerableProperty,
        forEach: kEnumerableProperty,
        [Symbol.iterator]: { enumerable: false },
        [Symbol.toStringTag]: {
          value: "Headers",
          configurable: true
        }
      });
      webidl.converters.HeadersInit = function(V) {
        if (webidl.util.Type(V) === "Object") {
          if (V[Symbol.iterator]) {
            return webidl.converters["sequence<sequence<ByteString>>"](V);
          }
          return webidl.converters["record<ByteString, ByteString>"](V);
        }
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      };
      module.exports = {
        fill,
        Headers,
        HeadersList
      };
    }
  });

  // node_modules/undici/lib/fetch/response.js
  var require_response = __commonJS({
    "node_modules/undici/lib/fetch/response.js"(exports, module) {
      "use strict";
      var { Headers, HeadersList, fill } = require_headers();
      var { extractBody, cloneBody, mixinBody } = require_body();
      var util = require_util();
      var { kEnumerableProperty } = util;
      var {
        isValidReasonPhrase,
        isCancelled,
        isAborted,
        isBlobLike,
        serializeJavascriptValueToJSONString,
        isErrorLike,
        isomorphicEncode
      } = require_util2();
      var {
        redirectStatusSet,
        nullBodyStatus,
        DOMException: DOMException2
      } = require_constants2();
      var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
      var { webidl } = require_webidl();
      var { FormData } = require_formdata();
      var { getGlobalOrigin } = require_global();
      var { URLSerializer } = require_dataURL();
      var { kHeadersList, kConstruct } = require_symbols();
      var assert = __require("assert");
      var { types } = __require("util");
      var ReadableStream = globalThis.ReadableStream || __require("stream/web").ReadableStream;
      var textEncoder = new TextEncoder("utf-8");
      var Response = class _Response {
        // Creates network error Response.
        static error() {
          const relevantRealm = { settingsObject: {} };
          const responseObject = new _Response();
          responseObject[kState] = makeNetworkError();
          responseObject[kRealm] = relevantRealm;
          responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseObject[kHeaders][kRealm] = relevantRealm;
          return responseObject;
        }
        // https://fetch.spec.whatwg.org/#dom-response-json
        static json(data, init = {}) {
          webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
          if (init !== null) {
            init = webidl.converters.ResponseInit(init);
          }
          const bytes = textEncoder.encode(
            serializeJavascriptValueToJSONString(data)
          );
          const body = extractBody(bytes);
          const relevantRealm = { settingsObject: {} };
          const responseObject = new _Response();
          responseObject[kRealm] = relevantRealm;
          responseObject[kHeaders][kGuard] = "response";
          responseObject[kHeaders][kRealm] = relevantRealm;
          initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
          return responseObject;
        }
        // Creates a redirect Response that redirects to url with status status.
        static redirect(url, status = 302) {
          const relevantRealm = { settingsObject: {} };
          webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
          url = webidl.converters.USVString(url);
          status = webidl.converters["unsigned short"](status);
          let parsedURL;
          try {
            parsedURL = new URL(url, getGlobalOrigin());
          } catch (err) {
            throw Object.assign(new TypeError("Failed to parse URL from " + url), {
              cause: err
            });
          }
          if (!redirectStatusSet.has(status)) {
            throw new RangeError("Invalid status code " + status);
          }
          const responseObject = new _Response();
          responseObject[kRealm] = relevantRealm;
          responseObject[kHeaders][kGuard] = "immutable";
          responseObject[kHeaders][kRealm] = relevantRealm;
          responseObject[kState].status = status;
          const value = isomorphicEncode(URLSerializer(parsedURL));
          responseObject[kState].headersList.append("location", value);
          return responseObject;
        }
        // https://fetch.spec.whatwg.org/#dom-response
        constructor(body = null, init = {}) {
          if (body !== null) {
            body = webidl.converters.BodyInit(body);
          }
          init = webidl.converters.ResponseInit(init);
          this[kRealm] = { settingsObject: {} };
          this[kState] = makeResponse({});
          this[kHeaders] = new Headers(kConstruct);
          this[kHeaders][kGuard] = "response";
          this[kHeaders][kHeadersList] = this[kState].headersList;
          this[kHeaders][kRealm] = this[kRealm];
          let bodyWithType = null;
          if (body != null) {
            const [extractedBody, type] = extractBody(body);
            bodyWithType = { body: extractedBody, type };
          }
          initializeResponse(this, init, bodyWithType);
        }
        // Returns responses type, e.g., "cors".
        get type() {
          webidl.brandCheck(this, _Response);
          return this[kState].type;
        }
        // Returns responses URL, if it has one; otherwise the empty string.
        get url() {
          webidl.brandCheck(this, _Response);
          const urlList = this[kState].urlList;
          const url = urlList[urlList.length - 1] ?? null;
          if (url === null) {
            return "";
          }
          return URLSerializer(url, true);
        }
        // Returns whether response was obtained through a redirect.
        get redirected() {
          webidl.brandCheck(this, _Response);
          return this[kState].urlList.length > 1;
        }
        // Returns responses status.
        get status() {
          webidl.brandCheck(this, _Response);
          return this[kState].status;
        }
        // Returns whether responses status is an ok status.
        get ok() {
          webidl.brandCheck(this, _Response);
          return this[kState].status >= 200 && this[kState].status <= 299;
        }
        // Returns responses status message.
        get statusText() {
          webidl.brandCheck(this, _Response);
          return this[kState].statusText;
        }
        // Returns responses headers as Headers.
        get headers() {
          webidl.brandCheck(this, _Response);
          return this[kHeaders];
        }
        get body() {
          webidl.brandCheck(this, _Response);
          return this[kState].body ? this[kState].body.stream : null;
        }
        get bodyUsed() {
          webidl.brandCheck(this, _Response);
          return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
        }
        // Returns a clone of response.
        clone() {
          webidl.brandCheck(this, _Response);
          if (this.bodyUsed || this.body && this.body.locked) {
            throw webidl.errors.exception({
              header: "Response.clone",
              message: "Body has already been consumed."
            });
          }
          const clonedResponse = cloneResponse(this[kState]);
          const clonedResponseObject = new _Response();
          clonedResponseObject[kState] = clonedResponse;
          clonedResponseObject[kRealm] = this[kRealm];
          clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
          clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
          clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
          return clonedResponseObject;
        }
      };
      mixinBody(Response);
      Object.defineProperties(Response.prototype, {
        type: kEnumerableProperty,
        url: kEnumerableProperty,
        status: kEnumerableProperty,
        ok: kEnumerableProperty,
        redirected: kEnumerableProperty,
        statusText: kEnumerableProperty,
        headers: kEnumerableProperty,
        clone: kEnumerableProperty,
        body: kEnumerableProperty,
        bodyUsed: kEnumerableProperty,
        [Symbol.toStringTag]: {
          value: "Response",
          configurable: true
        }
      });
      Object.defineProperties(Response, {
        json: kEnumerableProperty,
        redirect: kEnumerableProperty,
        error: kEnumerableProperty
      });
      function cloneResponse(response) {
        if (response.internalResponse) {
          return filterResponse(
            cloneResponse(response.internalResponse),
            response.type
          );
        }
        const newResponse = makeResponse({ ...response, body: null });
        if (response.body != null) {
          newResponse.body = cloneBody(response.body);
        }
        return newResponse;
      }
      function makeResponse(init) {
        return {
          aborted: false,
          rangeRequested: false,
          timingAllowPassed: false,
          requestIncludesCredentials: false,
          type: "default",
          status: 200,
          timingInfo: null,
          cacheState: "",
          statusText: "",
          ...init,
          headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
          urlList: init.urlList ? [...init.urlList] : []
        };
      }
      function makeNetworkError(reason) {
        const isError = isErrorLike(reason);
        return makeResponse({
          type: "error",
          status: 0,
          error: isError ? reason : new Error(reason ? String(reason) : reason),
          aborted: reason && reason.name === "AbortError"
        });
      }
      function makeFilteredResponse(response, state) {
        state = {
          internalResponse: response,
          ...state
        };
        return new Proxy(response, {
          get(target, p) {
            return p in state ? state[p] : target[p];
          },
          set(target, p, value) {
            assert(!(p in state));
            target[p] = value;
            return true;
          }
        });
      }
      function filterResponse(response, type) {
        if (type === "basic") {
          return makeFilteredResponse(response, {
            type: "basic",
            headersList: response.headersList
          });
        } else if (type === "cors") {
          return makeFilteredResponse(response, {
            type: "cors",
            headersList: response.headersList
          });
        } else if (type === "opaque") {
          return makeFilteredResponse(response, {
            type: "opaque",
            urlList: Object.freeze([]),
            status: 0,
            statusText: "",
            body: null
          });
        } else if (type === "opaqueredirect") {
          return makeFilteredResponse(response, {
            type: "opaqueredirect",
            status: 0,
            statusText: "",
            headersList: [],
            body: null
          });
        } else {
          assert(false);
        }
      }
      function makeAppropriateNetworkError(fetchParams, err = null) {
        assert(isCancelled(fetchParams));
        return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
      }
      function initializeResponse(response, init, body) {
        if (init.status !== null && (init.status < 200 || init.status > 599)) {
          throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
        }
        if ("statusText" in init && init.statusText != null) {
          if (!isValidReasonPhrase(String(init.statusText))) {
            throw new TypeError("Invalid statusText");
          }
        }
        if ("status" in init && init.status != null) {
          response[kState].status = init.status;
        }
        if ("statusText" in init && init.statusText != null) {
          response[kState].statusText = init.statusText;
        }
        if ("headers" in init && init.headers != null) {
          fill(response[kHeaders], init.headers);
        }
        if (body) {
          if (nullBodyStatus.includes(response.status)) {
            throw webidl.errors.exception({
              header: "Response constructor",
              message: "Invalid response status code " + response.status
            });
          }
          response[kState].body = body.body;
          if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
            response[kState].headersList.append("content-type", body.type);
          }
        }
      }
      webidl.converters.ReadableStream = webidl.interfaceConverter(
        ReadableStream
      );
      webidl.converters.FormData = webidl.interfaceConverter(
        FormData
      );
      webidl.converters.URLSearchParams = webidl.interfaceConverter(
        URLSearchParams
      );
      webidl.converters.XMLHttpRequestBodyInit = function(V) {
        if (typeof V === "string") {
          return webidl.converters.USVString(V);
        }
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
          return webidl.converters.BufferSource(V);
        }
        if (util.isFormDataLike(V)) {
          return webidl.converters.FormData(V, { strict: false });
        }
        if (V instanceof URLSearchParams) {
          return webidl.converters.URLSearchParams(V);
        }
        return webidl.converters.DOMString(V);
      };
      webidl.converters.BodyInit = function(V) {
        if (V instanceof ReadableStream) {
          return webidl.converters.ReadableStream(V);
        }
        if (V?.[Symbol.asyncIterator]) {
          return V;
        }
        return webidl.converters.XMLHttpRequestBodyInit(V);
      };
      webidl.converters.ResponseInit = webidl.dictionaryConverter([
        {
          key: "status",
          converter: webidl.converters["unsigned short"],
          defaultValue: 200
        },
        {
          key: "statusText",
          converter: webidl.converters.ByteString,
          defaultValue: ""
        },
        {
          key: "headers",
          converter: webidl.converters.HeadersInit
        }
      ]);
      module.exports = {
        makeNetworkError,
        makeResponse,
        makeAppropriateNetworkError,
        filterResponse,
        Response,
        cloneResponse
      };
    }
  });

  // node_modules/undici/lib/fetch/request.js
  var require_request2 = __commonJS({
    "node_modules/undici/lib/fetch/request.js"(exports, module) {
      "use strict";
      var { extractBody, mixinBody, cloneBody } = require_body();
      var { Headers, fill: fillHeaders, HeadersList } = require_headers();
      var { FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
      var util = require_util();
      var {
        isValidHTTPToken,
        sameOrigin,
        normalizeMethod,
        makePolicyContainer,
        normalizeMethodRecord
      } = require_util2();
      var {
        forbiddenMethodsSet,
        corsSafeListedMethodsSet,
        referrerPolicy,
        requestRedirect,
        requestMode,
        requestCredentials,
        requestCache,
        requestDuplex
      } = require_constants2();
      var { kEnumerableProperty } = util;
      var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
      var { webidl } = require_webidl();
      var { getGlobalOrigin } = require_global();
      var { URLSerializer } = require_dataURL();
      var { kHeadersList, kConstruct } = require_symbols();
      var assert = __require("assert");
      var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events");
      var TransformStream = globalThis.TransformStream;
      var kAbortController = Symbol("abortController");
      var requestFinalizer = new FinalizationRegistry2(({ signal, abort }) => {
        signal.removeEventListener("abort", abort);
      });
      var Request = class _Request {
        // https://fetch.spec.whatwg.org/#dom-request
        constructor(input2, init = {}) {
          if (input2 === kConstruct) {
            return;
          }
          webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
          input2 = webidl.converters.RequestInfo(input2);
          init = webidl.converters.RequestInit(init);
          this[kRealm] = {
            settingsObject: {
              baseUrl: getGlobalOrigin(),
              get origin() {
                return this.baseUrl?.origin;
              },
              policyContainer: makePolicyContainer()
            }
          };
          let request2 = null;
          let fallbackMode = null;
          const baseUrl = this[kRealm].settingsObject.baseUrl;
          let signal = null;
          if (typeof input2 === "string") {
            let parsedURL;
            try {
              parsedURL = new URL(input2, baseUrl);
            } catch (err) {
              throw new TypeError("Failed to parse URL from " + input2, { cause: err });
            }
            if (parsedURL.username || parsedURL.password) {
              throw new TypeError(
                "Request cannot be constructed from a URL that includes credentials: " + input2
              );
            }
            request2 = makeRequest({ urlList: [parsedURL] });
            fallbackMode = "cors";
          } else {
            assert(input2 instanceof _Request);
            request2 = input2[kState];
            signal = input2[kSignal];
          }
          const origin = this[kRealm].settingsObject.origin;
          let window2 = "client";
          if (request2.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request2.window, origin)) {
            window2 = request2.window;
          }
          if (init.window != null) {
            throw new TypeError(`'window' option '${window2}' must be null`);
          }
          if ("window" in init) {
            window2 = "no-window";
          }
          request2 = makeRequest({
            // URL requests URL.
            // undici implementation note: this is set as the first item in request's urlList in makeRequest
            // method requests method.
            method: request2.method,
            // header list A copy of requests header list.
            // undici implementation note: headersList is cloned in makeRequest
            headersList: request2.headersList,
            // unsafe-request flag Set.
            unsafeRequest: request2.unsafeRequest,
            // client Thiss relevant settings object.
            client: this[kRealm].settingsObject,
            // window window.
            window: window2,
            // priority requests priority.
            priority: request2.priority,
            // origin requests origin. The propagation of the origin is only significant for navigation requests
            // being handled by a service worker. In this scenario a request can have an origin that is different
            // from the current client.
            origin: request2.origin,
            // referrer requests referrer.
            referrer: request2.referrer,
            // referrer policy requests referrer policy.
            referrerPolicy: request2.referrerPolicy,
            // mode requests mode.
            mode: request2.mode,
            // credentials mode requests credentials mode.
            credentials: request2.credentials,
            // cache mode requests cache mode.
            cache: request2.cache,
            // redirect mode requests redirect mode.
            redirect: request2.redirect,
            // integrity metadata requests integrity metadata.
            integrity: request2.integrity,
            // keepalive requests keepalive.
            keepalive: request2.keepalive,
            // reload-navigation flag requests reload-navigation flag.
            reloadNavigation: request2.reloadNavigation,
            // history-navigation flag requests history-navigation flag.
            historyNavigation: request2.historyNavigation,
            // URL list A clone of requests URL list.
            urlList: [...request2.urlList]
          });
          const initHasKey = Object.keys(init).length !== 0;
          if (initHasKey) {
            if (request2.mode === "navigate") {
              request2.mode = "same-origin";
            }
            request2.reloadNavigation = false;
            request2.historyNavigation = false;
            request2.origin = "client";
            request2.referrer = "client";
            request2.referrerPolicy = "";
            request2.url = request2.urlList[request2.urlList.length - 1];
            request2.urlList = [request2.url];
          }
          if (init.referrer !== void 0) {
            const referrer = init.referrer;
            if (referrer === "") {
              request2.referrer = "no-referrer";
            } else {
              let parsedReferrer;
              try {
                parsedReferrer = new URL(referrer, baseUrl);
              } catch (err) {
                throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
              }
              if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
                request2.referrer = "client";
              } else {
                request2.referrer = parsedReferrer;
              }
            }
          }
          if (init.referrerPolicy !== void 0) {
            request2.referrerPolicy = init.referrerPolicy;
          }
          let mode;
          if (init.mode !== void 0) {
            mode = init.mode;
          } else {
            mode = fallbackMode;
          }
          if (mode === "navigate") {
            throw webidl.errors.exception({
              header: "Request constructor",
              message: "invalid request mode navigate."
            });
          }
          if (mode != null) {
            request2.mode = mode;
          }
          if (init.credentials !== void 0) {
            request2.credentials = init.credentials;
          }
          if (init.cache !== void 0) {
            request2.cache = init.cache;
          }
          if (request2.cache === "only-if-cached" && request2.mode !== "same-origin") {
            throw new TypeError(
              "'only-if-cached' can be set only with 'same-origin' mode"
            );
          }
          if (init.redirect !== void 0) {
            request2.redirect = init.redirect;
          }
          if (init.integrity != null) {
            request2.integrity = String(init.integrity);
          }
          if (init.keepalive !== void 0) {
            request2.keepalive = Boolean(init.keepalive);
          }
          if (init.method !== void 0) {
            let method = init.method;
            if (!isValidHTTPToken(method)) {
              throw new TypeError(`'${method}' is not a valid HTTP method.`);
            }
            if (forbiddenMethodsSet.has(method.toUpperCase())) {
              throw new TypeError(`'${method}' HTTP method is unsupported.`);
            }
            method = normalizeMethodRecord[method] ?? normalizeMethod(method);
            request2.method = method;
          }
          if (init.signal !== void 0) {
            signal = init.signal;
          }
          this[kState] = request2;
          const ac = new AbortController();
          this[kSignal] = ac.signal;
          this[kSignal][kRealm] = this[kRealm];
          if (signal != null) {
            if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
              throw new TypeError(
                "Failed to construct 'Request': member signal is not of type AbortSignal."
              );
            }
            if (signal.aborted) {
              ac.abort(signal.reason);
            } else {
              this[kAbortController] = ac;
              const acRef = new WeakRef(ac);
              const abort = function() {
                const ac2 = acRef.deref();
                if (ac2 !== void 0) {
                  ac2.abort(this.reason);
                }
              };
              try {
                if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                  setMaxListeners(100, signal);
                } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                  setMaxListeners(100, signal);
                }
              } catch {
              }
              util.addAbortListener(signal, abort);
              requestFinalizer.register(ac, { signal, abort });
            }
          }
          this[kHeaders] = new Headers(kConstruct);
          this[kHeaders][kHeadersList] = request2.headersList;
          this[kHeaders][kGuard] = "request";
          this[kHeaders][kRealm] = this[kRealm];
          if (mode === "no-cors") {
            if (!corsSafeListedMethodsSet.has(request2.method)) {
              throw new TypeError(
                `'${request2.method} is unsupported in no-cors mode.`
              );
            }
            this[kHeaders][kGuard] = "request-no-cors";
          }
          if (initHasKey) {
            const headersList = this[kHeaders][kHeadersList];
            const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
            headersList.clear();
            if (headers instanceof HeadersList) {
              for (const [key, val] of headers) {
                headersList.append(key, val);
              }
              headersList.cookies = headers.cookies;
            } else {
              fillHeaders(this[kHeaders], headers);
            }
          }
          const inputBody = input2 instanceof _Request ? input2[kState].body : null;
          if ((init.body != null || inputBody != null) && (request2.method === "GET" || request2.method === "HEAD")) {
            throw new TypeError("Request with GET/HEAD method cannot have body.");
          }
          let initBody = null;
          if (init.body != null) {
            const [extractedBody, contentType] = extractBody(
              init.body,
              request2.keepalive
            );
            initBody = extractedBody;
            if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
              this[kHeaders].append("content-type", contentType);
            }
          }
          const inputOrInitBody = initBody ?? inputBody;
          if (inputOrInitBody != null && inputOrInitBody.source == null) {
            if (initBody != null && init.duplex == null) {
              throw new TypeError("RequestInit: duplex option is required when sending a body.");
            }
            if (request2.mode !== "same-origin" && request2.mode !== "cors") {
              throw new TypeError(
                'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
              );
            }
            request2.useCORSPreflightFlag = true;
          }
          let finalBody = inputOrInitBody;
          if (initBody == null && inputBody != null) {
            if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
              throw new TypeError(
                "Cannot construct a Request with a Request object that has already been used."
              );
            }
            if (!TransformStream) {
              TransformStream = __require("stream/web").TransformStream;
            }
            const identityTransform = new TransformStream();
            inputBody.stream.pipeThrough(identityTransform);
            finalBody = {
              source: inputBody.source,
              length: inputBody.length,
              stream: identityTransform.readable
            };
          }
          this[kState].body = finalBody;
        }
        // Returns requests HTTP method, which is "GET" by default.
        get method() {
          webidl.brandCheck(this, _Request);
          return this[kState].method;
        }
        // Returns the URL of request as a string.
        get url() {
          webidl.brandCheck(this, _Request);
          return URLSerializer(this[kState].url);
        }
        // Returns a Headers object consisting of the headers associated with request.
        // Note that headers added in the network layer by the user agent will not
        // be accounted for in this object, e.g., the "Host" header.
        get headers() {
          webidl.brandCheck(this, _Request);
          return this[kHeaders];
        }
        // Returns the kind of resource requested by request, e.g., "document"
        // or "script".
        get destination() {
          webidl.brandCheck(this, _Request);
          return this[kState].destination;
        }
        // Returns the referrer of request. Its value can be a same-origin URL if
        // explicitly set in init, the empty string to indicate no referrer, and
        // "about:client" when defaulting to the globals default. This is used
        // during fetching to determine the value of the `Referer` header of the
        // request being made.
        get referrer() {
          webidl.brandCheck(this, _Request);
          if (this[kState].referrer === "no-referrer") {
            return "";
          }
          if (this[kState].referrer === "client") {
            return "about:client";
          }
          return this[kState].referrer.toString();
        }
        // Returns the referrer policy associated with request.
        // This is used during fetching to compute the value of the requests
        // referrer.
        get referrerPolicy() {
          webidl.brandCheck(this, _Request);
          return this[kState].referrerPolicy;
        }
        // Returns the mode associated with request, which is a string indicating
        // whether the request will use CORS, or will be restricted to same-origin
        // URLs.
        get mode() {
          webidl.brandCheck(this, _Request);
          return this[kState].mode;
        }
        // Returns the credentials mode associated with request,
        // which is a string indicating whether credentials will be sent with the
        // request always, never, or only when sent to a same-origin URL.
        get credentials() {
          return this[kState].credentials;
        }
        // Returns the cache mode associated with request,
        // which is a string indicating how the request will
        // interact with the browsers cache when fetching.
        get cache() {
          webidl.brandCheck(this, _Request);
          return this[kState].cache;
        }
        // Returns the redirect mode associated with request,
        // which is a string indicating how redirects for the
        // request will be handled during fetching. A request
        // will follow redirects by default.
        get redirect() {
          webidl.brandCheck(this, _Request);
          return this[kState].redirect;
        }
        // Returns requests subresource integrity metadata, which is a
        // cryptographic hash of the resource being fetched. Its value
        // consists of multiple hashes separated by whitespace. [SRI]
        get integrity() {
          webidl.brandCheck(this, _Request);
          return this[kState].integrity;
        }
        // Returns a boolean indicating whether or not request can outlive the
        // global in which it was created.
        get keepalive() {
          webidl.brandCheck(this, _Request);
          return this[kState].keepalive;
        }
        // Returns a boolean indicating whether or not request is for a reload
        // navigation.
        get isReloadNavigation() {
          webidl.brandCheck(this, _Request);
          return this[kState].reloadNavigation;
        }
        // Returns a boolean indicating whether or not request is for a history
        // navigation (a.k.a. back-foward navigation).
        get isHistoryNavigation() {
          webidl.brandCheck(this, _Request);
          return this[kState].historyNavigation;
        }
        // Returns the signal associated with request, which is an AbortSignal
        // object indicating whether or not request has been aborted, and its
        // abort event handler.
        get signal() {
          webidl.brandCheck(this, _Request);
          return this[kSignal];
        }
        get body() {
          webidl.brandCheck(this, _Request);
          return this[kState].body ? this[kState].body.stream : null;
        }
        get bodyUsed() {
          webidl.brandCheck(this, _Request);
          return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
        }
        get duplex() {
          webidl.brandCheck(this, _Request);
          return "half";
        }
        // Returns a clone of request.
        clone() {
          webidl.brandCheck(this, _Request);
          if (this.bodyUsed || this.body?.locked) {
            throw new TypeError("unusable");
          }
          const clonedRequest = cloneRequest(this[kState]);
          const clonedRequestObject = new _Request(kConstruct);
          clonedRequestObject[kState] = clonedRequest;
          clonedRequestObject[kRealm] = this[kRealm];
          clonedRequestObject[kHeaders] = new Headers(kConstruct);
          clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
          clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
          clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
          const ac = new AbortController();
          if (this.signal.aborted) {
            ac.abort(this.signal.reason);
          } else {
            util.addAbortListener(
              this.signal,
              () => {
                ac.abort(this.signal.reason);
              }
            );
          }
          clonedRequestObject[kSignal] = ac.signal;
          return clonedRequestObject;
        }
      };
      mixinBody(Request);
      function makeRequest(init) {
        const request2 = {
          method: "GET",
          localURLsOnly: false,
          unsafeRequest: false,
          body: null,
          client: null,
          reservedClient: null,
          replacesClientId: "",
          window: "client",
          keepalive: false,
          serviceWorkers: "all",
          initiator: "",
          destination: "",
          priority: null,
          origin: "client",
          policyContainer: "client",
          referrer: "client",
          referrerPolicy: "",
          mode: "no-cors",
          useCORSPreflightFlag: false,
          credentials: "same-origin",
          useCredentials: false,
          cache: "default",
          redirect: "follow",
          integrity: "",
          cryptoGraphicsNonceMetadata: "",
          parserMetadata: "",
          reloadNavigation: false,
          historyNavigation: false,
          userActivation: false,
          taintedOrigin: false,
          redirectCount: 0,
          responseTainting: "basic",
          preventNoCacheCacheControlHeaderModification: false,
          done: false,
          timingAllowFailed: false,
          ...init,
          headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
        };
        request2.url = request2.urlList[0];
        return request2;
      }
      function cloneRequest(request2) {
        const newRequest = makeRequest({ ...request2, body: null });
        if (request2.body != null) {
          newRequest.body = cloneBody(request2.body);
        }
        return newRequest;
      }
      Object.defineProperties(Request.prototype, {
        method: kEnumerableProperty,
        url: kEnumerableProperty,
        headers: kEnumerableProperty,
        redirect: kEnumerableProperty,
        clone: kEnumerableProperty,
        signal: kEnumerableProperty,
        duplex: kEnumerableProperty,
        destination: kEnumerableProperty,
        body: kEnumerableProperty,
        bodyUsed: kEnumerableProperty,
        isHistoryNavigation: kEnumerableProperty,
        isReloadNavigation: kEnumerableProperty,
        keepalive: kEnumerableProperty,
        integrity: kEnumerableProperty,
        cache: kEnumerableProperty,
        credentials: kEnumerableProperty,
        attribute: kEnumerableProperty,
        referrerPolicy: kEnumerableProperty,
        referrer: kEnumerableProperty,
        mode: kEnumerableProperty,
        [Symbol.toStringTag]: {
          value: "Request",
          configurable: true
        }
      });
      webidl.converters.Request = webidl.interfaceConverter(
        Request
      );
      webidl.converters.RequestInfo = function(V) {
        if (typeof V === "string") {
          return webidl.converters.USVString(V);
        }
        if (V instanceof Request) {
          return webidl.converters.Request(V);
        }
        return webidl.converters.USVString(V);
      };
      webidl.converters.AbortSignal = webidl.interfaceConverter(
        AbortSignal
      );
      webidl.converters.RequestInit = webidl.dictionaryConverter([
        {
          key: "method",
          converter: webidl.converters.ByteString
        },
        {
          key: "headers",
          converter: webidl.converters.HeadersInit
        },
        {
          key: "body",
          converter: webidl.nullableConverter(
            webidl.converters.BodyInit
          )
        },
        {
          key: "referrer",
          converter: webidl.converters.USVString
        },
        {
          key: "referrerPolicy",
          converter: webidl.converters.DOMString,
          // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
          allowedValues: referrerPolicy
        },
        {
          key: "mode",
          converter: webidl.converters.DOMString,
          // https://fetch.spec.whatwg.org/#concept-request-mode
          allowedValues: requestMode
        },
        {
          key: "credentials",
          converter: webidl.converters.DOMString,
          // https://fetch.spec.whatwg.org/#requestcredentials
          allowedValues: requestCredentials
        },
        {
          key: "cache",
          converter: webidl.converters.DOMString,
          // https://fetch.spec.whatwg.org/#requestcache
          allowedValues: requestCache
        },
        {
          key: "redirect",
          converter: webidl.converters.DOMString,
          // https://fetch.spec.whatwg.org/#requestredirect
          allowedValues: requestRedirect
        },
        {
          key: "integrity",
          converter: webidl.converters.DOMString
        },
        {
          key: "keepalive",
          converter: webidl.converters.boolean
        },
        {
          key: "signal",
          converter: webidl.nullableConverter(
            (signal) => webidl.converters.AbortSignal(
              signal,
              { strict: false }
            )
          )
        },
        {
          key: "window",
          converter: webidl.converters.any
        },
        {
          key: "duplex",
          converter: webidl.converters.DOMString,
          allowedValues: requestDuplex
        }
      ]);
      module.exports = { Request, makeRequest };
    }
  });

  // node_modules/undici/lib/fetch/index.js
  var require_fetch = __commonJS({
    "node_modules/undici/lib/fetch/index.js"(exports, module) {
      "use strict";
      var {
        Response,
        makeNetworkError,
        makeAppropriateNetworkError,
        filterResponse,
        makeResponse
      } = require_response();
      var { Headers } = require_headers();
      var { Request, makeRequest } = require_request2();
      var zlib = __require("zlib");
      var {
        bytesMatch,
        makePolicyContainer,
        clonePolicyContainer,
        requestBadPort,
        TAOCheck,
        appendRequestOriginHeader,
        responseLocationURL,
        requestCurrentURL,
        setRequestReferrerPolicyOnRedirect,
        tryUpgradeRequestToAPotentiallyTrustworthyURL,
        createOpaqueTimingInfo,
        appendFetchMetadata,
        corsCheck,
        crossOriginResourcePolicyCheck,
        determineRequestsReferrer,
        coarsenedSharedCurrentTime,
        createDeferredPromise,
        isBlobLike,
        sameOrigin,
        isCancelled,
        isAborted,
        isErrorLike,
        fullyReadBody,
        readableStreamClose,
        isomorphicEncode,
        urlIsLocal,
        urlIsHttpHttpsScheme,
        urlHasHttpsScheme
      } = require_util2();
      var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
      var assert = __require("assert");
      var { safelyExtractBody } = require_body();
      var {
        redirectStatusSet,
        nullBodyStatus,
        safeMethodsSet,
        requestBodyHeader,
        subresourceSet,
        DOMException: DOMException2
      } = require_constants2();
      var { kHeadersList } = require_symbols();
      var EE = __require("events");
      var { Readable, pipeline } = __require("stream");
      var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
      var { dataURLProcessor, serializeAMimeType } = require_dataURL();
      var { TransformStream } = __require("stream/web");
      var { getGlobalDispatcher } = require_global2();
      var { webidl } = require_webidl();
      var { STATUS_CODES } = __require("http");
      var GET_OR_HEAD = ["GET", "HEAD"];
      var resolveObjectURL;
      var ReadableStream = globalThis.ReadableStream;
      var Fetch = class extends EE {
        constructor(dispatcher) {
          super();
          this.dispatcher = dispatcher;
          this.connection = null;
          this.dump = false;
          this.state = "ongoing";
          this.setMaxListeners(21);
        }
        terminate(reason) {
          if (this.state !== "ongoing") {
            return;
          }
          this.state = "terminated";
          this.connection?.destroy(reason);
          this.emit("terminated", reason);
        }
        // https://fetch.spec.whatwg.org/#fetch-controller-abort
        abort(error) {
          if (this.state !== "ongoing") {
            return;
          }
          this.state = "aborted";
          if (!error) {
            error = new DOMException2("The operation was aborted.", "AbortError");
          }
          this.serializedAbortReason = error;
          this.connection?.destroy(error);
          this.emit("terminated", error);
        }
      };
      function fetch2(input2, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
        const p = createDeferredPromise();
        let requestObject;
        try {
          requestObject = new Request(input2, init);
        } catch (e) {
          p.reject(e);
          return p.promise;
        }
        const request2 = requestObject[kState];
        if (requestObject.signal.aborted) {
          abortFetch(p, request2, null, requestObject.signal.reason);
          return p.promise;
        }
        const globalObject = request2.client.globalObject;
        if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
          request2.serviceWorkers = "none";
        }
        let responseObject = null;
        const relevantRealm = null;
        let locallyAborted = false;
        let controller = null;
        addAbortListener(
          requestObject.signal,
          () => {
            locallyAborted = true;
            assert(controller != null);
            controller.abort(requestObject.signal.reason);
            abortFetch(p, request2, responseObject, requestObject.signal.reason);
          }
        );
        const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
        const processResponse = (response) => {
          if (locallyAborted) {
            return Promise.resolve();
          }
          if (response.aborted) {
            abortFetch(p, request2, responseObject, controller.serializedAbortReason);
            return Promise.resolve();
          }
          if (response.type === "error") {
            p.reject(
              Object.assign(new TypeError("fetch failed"), { cause: response.error })
            );
            return Promise.resolve();
          }
          responseObject = new Response();
          responseObject[kState] = response;
          responseObject[kRealm] = relevantRealm;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseObject[kHeaders][kRealm] = relevantRealm;
          p.resolve(responseObject);
        };
        controller = fetching({
          request: request2,
          processResponseEndOfBody: handleFetchDone,
          processResponse,
          dispatcher: init.dispatcher ?? getGlobalDispatcher()
          // undici
        });
        return p.promise;
      }
      function finalizeAndReportTiming(response, initiatorType = "other") {
        if (response.type === "error" && response.aborted) {
          return;
        }
        if (!response.urlList?.length) {
          return;
        }
        const originalURL = response.urlList[0];
        let timingInfo = response.timingInfo;
        let cacheState = response.cacheState;
        if (!urlIsHttpHttpsScheme(originalURL)) {
          return;
        }
        if (timingInfo === null) {
          return;
        }
        if (!response.timingAllowPassed) {
          timingInfo = createOpaqueTimingInfo({
            startTime: timingInfo.startTime
          });
          cacheState = "";
        }
        timingInfo.endTime = coarsenedSharedCurrentTime();
        response.timingInfo = timingInfo;
        markResourceTiming(
          timingInfo,
          originalURL,
          initiatorType,
          globalThis,
          cacheState
        );
      }
      function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
        if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
          performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
        }
      }
      function abortFetch(p, request2, responseObject, error) {
        if (!error) {
          error = new DOMException2("The operation was aborted.", "AbortError");
        }
        p.reject(error);
        if (request2.body != null && isReadable(request2.body?.stream)) {
          request2.body.stream.cancel(error).catch((err) => {
            if (err.code === "ERR_INVALID_STATE") {
              return;
            }
            throw err;
          });
        }
        if (responseObject == null) {
          return;
        }
        const response = responseObject[kState];
        if (response.body != null && isReadable(response.body?.stream)) {
          response.body.stream.cancel(error).catch((err) => {
            if (err.code === "ERR_INVALID_STATE") {
              return;
            }
            throw err;
          });
        }
      }
      function fetching({
        request: request2,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseEndOfBody,
        processResponseConsumeBody,
        useParallelQueue = false,
        dispatcher
        // undici
      }) {
        let taskDestination = null;
        let crossOriginIsolatedCapability = false;
        if (request2.client != null) {
          taskDestination = request2.client.globalObject;
          crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;
        }
        const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
        const timingInfo = createOpaqueTimingInfo({
          startTime: currenTime
        });
        const fetchParams = {
          controller: new Fetch(dispatcher),
          request: request2,
          timingInfo,
          processRequestBodyChunkLength,
          processRequestEndOfBody,
          processResponse,
          processResponseConsumeBody,
          processResponseEndOfBody,
          taskDestination,
          crossOriginIsolatedCapability
        };
        assert(!request2.body || request2.body.stream);
        if (request2.window === "client") {
          request2.window = request2.client?.globalObject?.constructor?.name === "Window" ? request2.client : "no-window";
        }
        if (request2.origin === "client") {
          request2.origin = request2.client?.origin;
        }
        if (request2.policyContainer === "client") {
          if (request2.client != null) {
            request2.policyContainer = clonePolicyContainer(
              request2.client.policyContainer
            );
          } else {
            request2.policyContainer = makePolicyContainer();
          }
        }
        if (!request2.headersList.contains("accept")) {
          const value = "*/*";
          request2.headersList.append("accept", value);
        }
        if (!request2.headersList.contains("accept-language")) {
          request2.headersList.append("accept-language", "*");
        }
        if (request2.priority === null) {
        }
        if (subresourceSet.has(request2.destination)) {
        }
        mainFetch(fetchParams).catch((err) => {
          fetchParams.controller.terminate(err);
        });
        return fetchParams.controller;
      }
      async function mainFetch(fetchParams, recursive = false) {
        const request2 = fetchParams.request;
        let response = null;
        if (request2.localURLsOnly && !urlIsLocal(requestCurrentURL(request2))) {
          response = makeNetworkError("local URLs only");
        }
        tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);
        if (requestBadPort(request2) === "blocked") {
          response = makeNetworkError("bad port");
        }
        if (request2.referrerPolicy === "") {
          request2.referrerPolicy = request2.policyContainer.referrerPolicy;
        }
        if (request2.referrer !== "no-referrer") {
          request2.referrer = determineRequestsReferrer(request2);
        }
        if (response === null) {
          response = await (async () => {
            const currentURL = requestCurrentURL(request2);
            if (
              // - requests current URLs origin is same origin with requests origin,
              //   and requests response tainting is "basic"
              sameOrigin(currentURL, request2.url) && request2.responseTainting === "basic" || // requests current URLs scheme is "data"
              currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
              (request2.mode === "navigate" || request2.mode === "websocket")
            ) {
              request2.responseTainting = "basic";
              return await schemeFetch(fetchParams);
            }
            if (request2.mode === "same-origin") {
              return makeNetworkError('request mode cannot be "same-origin"');
            }
            if (request2.mode === "no-cors") {
              if (request2.redirect !== "follow") {
                return makeNetworkError(
                  'redirect mode cannot be "follow" for "no-cors" request'
                );
              }
              request2.responseTainting = "opaque";
              return await schemeFetch(fetchParams);
            }
            if (!urlIsHttpHttpsScheme(requestCurrentURL(request2))) {
              return makeNetworkError("URL scheme must be a HTTP(S) scheme");
            }
            request2.responseTainting = "cors";
            return await httpFetch(fetchParams);
          })();
        }
        if (recursive) {
          return response;
        }
        if (response.status !== 0 && !response.internalResponse) {
          if (request2.responseTainting === "cors") {
          }
          if (request2.responseTainting === "basic") {
            response = filterResponse(response, "basic");
          } else if (request2.responseTainting === "cors") {
            response = filterResponse(response, "cors");
          } else if (request2.responseTainting === "opaque") {
            response = filterResponse(response, "opaque");
          } else {
            assert(false);
          }
        }
        let internalResponse = response.status === 0 ? response : response.internalResponse;
        if (internalResponse.urlList.length === 0) {
          internalResponse.urlList.push(...request2.urlList);
        }
        if (!request2.timingAllowFailed) {
          response.timingAllowPassed = true;
        }
        if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.contains("range")) {
          response = internalResponse = makeNetworkError();
        }
        if (response.status !== 0 && (request2.method === "HEAD" || request2.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
          internalResponse.body = null;
          fetchParams.controller.dump = true;
        }
        if (request2.integrity) {
          const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
          if (request2.responseTainting === "opaque" || response.body == null) {
            processBodyError(response.error);
            return;
          }
          const processBody = (bytes) => {
            if (!bytesMatch(bytes, request2.integrity)) {
              processBodyError("integrity mismatch");
              return;
            }
            response.body = safelyExtractBody(bytes)[0];
            fetchFinale(fetchParams, response);
          };
          await fullyReadBody(response.body, processBody, processBodyError);
        } else {
          fetchFinale(fetchParams, response);
        }
      }
      function schemeFetch(fetchParams) {
        if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
          return Promise.resolve(makeAppropriateNetworkError(fetchParams));
        }
        const { request: request2 } = fetchParams;
        const { protocol: scheme } = requestCurrentURL(request2);
        switch (scheme) {
          case "about:": {
            return Promise.resolve(makeNetworkError("about scheme is not supported"));
          }
          case "blob:": {
            if (!resolveObjectURL) {
              resolveObjectURL = __require("buffer").resolveObjectURL;
            }
            const blobURLEntry = requestCurrentURL(request2);
            if (blobURLEntry.search.length !== 0) {
              return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
            }
            const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
            if (request2.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
              return Promise.resolve(makeNetworkError("invalid method"));
            }
            const bodyWithType = safelyExtractBody(blobURLEntryObject);
            const body = bodyWithType[0];
            const length = isomorphicEncode(`${body.length}`);
            const type = bodyWithType[1] ?? "";
            const response = makeResponse({
              statusText: "OK",
              headersList: [
                ["content-length", { name: "Content-Length", value: length }],
                ["content-type", { name: "Content-Type", value: type }]
              ]
            });
            response.body = body;
            return Promise.resolve(response);
          }
          case "data:": {
            const currentURL = requestCurrentURL(request2);
            const dataURLStruct = dataURLProcessor(currentURL);
            if (dataURLStruct === "failure") {
              return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
            }
            const mimeType = serializeAMimeType(dataURLStruct.mimeType);
            return Promise.resolve(makeResponse({
              statusText: "OK",
              headersList: [
                ["content-type", { name: "Content-Type", value: mimeType }]
              ],
              body: safelyExtractBody(dataURLStruct.body)[0]
            }));
          }
          case "file:": {
            return Promise.resolve(makeNetworkError("not implemented... yet..."));
          }
          case "http:":
          case "https:": {
            return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
          }
          default: {
            return Promise.resolve(makeNetworkError("unknown scheme"));
          }
        }
      }
      function finalizeResponse(fetchParams, response) {
        fetchParams.request.done = true;
        if (fetchParams.processResponseDone != null) {
          queueMicrotask(() => fetchParams.processResponseDone(response));
        }
      }
      function fetchFinale(fetchParams, response) {
        if (response.type === "error") {
          response.urlList = [fetchParams.request.urlList[0]];
          response.timingInfo = createOpaqueTimingInfo({
            startTime: fetchParams.timingInfo.startTime
          });
        }
        const processResponseEndOfBody = () => {
          fetchParams.request.done = true;
          if (fetchParams.processResponseEndOfBody != null) {
            queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
          }
        };
        if (fetchParams.processResponse != null) {
          queueMicrotask(() => fetchParams.processResponse(response));
        }
        if (response.body == null) {
          processResponseEndOfBody();
        } else {
          const identityTransformAlgorithm = (chunk, controller) => {
            controller.enqueue(chunk);
          };
          const transformStream = new TransformStream({
            start() {
            },
            transform: identityTransformAlgorithm,
            flush: processResponseEndOfBody
          }, {
            size() {
              return 1;
            }
          }, {
            size() {
              return 1;
            }
          });
          response.body = { stream: response.body.stream.pipeThrough(transformStream) };
        }
        if (fetchParams.processResponseConsumeBody != null) {
          const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
          const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
          if (response.body == null) {
            queueMicrotask(() => processBody(null));
          } else {
            return fullyReadBody(response.body, processBody, processBodyError);
          }
          return Promise.resolve();
        }
      }
      async function httpFetch(fetchParams) {
        const request2 = fetchParams.request;
        let response = null;
        let actualResponse = null;
        const timingInfo = fetchParams.timingInfo;
        if (request2.serviceWorkers === "all") {
        }
        if (response === null) {
          if (request2.redirect === "follow") {
            request2.serviceWorkers = "none";
          }
          actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
          if (request2.responseTainting === "cors" && corsCheck(request2, response) === "failure") {
            return makeNetworkError("cors failure");
          }
          if (TAOCheck(request2, response) === "failure") {
            request2.timingAllowFailed = true;
          }
        }
        if ((request2.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
          request2.origin,
          request2.client,
          request2.destination,
          actualResponse
        ) === "blocked") {
          return makeNetworkError("blocked");
        }
        if (redirectStatusSet.has(actualResponse.status)) {
          if (request2.redirect !== "manual") {
            fetchParams.controller.connection.destroy();
          }
          if (request2.redirect === "error") {
            response = makeNetworkError("unexpected redirect");
          } else if (request2.redirect === "manual") {
            response = actualResponse;
          } else if (request2.redirect === "follow") {
            response = await httpRedirectFetch(fetchParams, response);
          } else {
            assert(false);
          }
        }
        response.timingInfo = timingInfo;
        return response;
      }
      function httpRedirectFetch(fetchParams, response) {
        const request2 = fetchParams.request;
        const actualResponse = response.internalResponse ? response.internalResponse : response;
        let locationURL;
        try {
          locationURL = responseLocationURL(
            actualResponse,
            requestCurrentURL(request2).hash
          );
          if (locationURL == null) {
            return response;
          }
        } catch (err) {
          return Promise.resolve(makeNetworkError(err));
        }
        if (!urlIsHttpHttpsScheme(locationURL)) {
          return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
        }
        if (request2.redirectCount === 20) {
          return Promise.resolve(makeNetworkError("redirect count exceeded"));
        }
        request2.redirectCount += 1;
        if (request2.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {
          return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
        }
        if (request2.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
          return Promise.resolve(makeNetworkError(
            'URL cannot contain credentials for request mode "cors"'
          ));
        }
        if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {
          return Promise.resolve(makeNetworkError());
        }
        if ([301, 302].includes(actualResponse.status) && request2.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request2.method)) {
          request2.method = "GET";
          request2.body = null;
          for (const headerName of requestBodyHeader) {
            request2.headersList.delete(headerName);
          }
        }
        if (!sameOrigin(requestCurrentURL(request2), locationURL)) {
          request2.headersList.delete("authorization");
          request2.headersList.delete("proxy-authorization", true);
          request2.headersList.delete("cookie");
          request2.headersList.delete("host");
        }
        if (request2.body != null) {
          assert(request2.body.source != null);
          request2.body = safelyExtractBody(request2.body.source)[0];
        }
        const timingInfo = fetchParams.timingInfo;
        timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
        if (timingInfo.redirectStartTime === 0) {
          timingInfo.redirectStartTime = timingInfo.startTime;
        }
        request2.urlList.push(locationURL);
        setRequestReferrerPolicyOnRedirect(request2, actualResponse);
        return mainFetch(fetchParams, true);
      }
      async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
        const request2 = fetchParams.request;
        let httpFetchParams = null;
        let httpRequest = null;
        let response = null;
        const httpCache = null;
        const revalidatingFlag = false;
        if (request2.window === "no-window" && request2.redirect === "error") {
          httpFetchParams = fetchParams;
          httpRequest = request2;
        } else {
          httpRequest = makeRequest(request2);
          httpFetchParams = { ...fetchParams };
          httpFetchParams.request = httpRequest;
        }
        const includeCredentials = request2.credentials === "include" || request2.credentials === "same-origin" && request2.responseTainting === "basic";
        const contentLength = httpRequest.body ? httpRequest.body.length : null;
        let contentLengthHeaderValue = null;
        if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
          contentLengthHeaderValue = "0";
        }
        if (contentLength != null) {
          contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
        }
        if (contentLengthHeaderValue != null) {
          httpRequest.headersList.append("content-length", contentLengthHeaderValue);
        }
        if (contentLength != null && httpRequest.keepalive) {
        }
        if (httpRequest.referrer instanceof URL) {
          httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
        }
        appendRequestOriginHeader(httpRequest);
        appendFetchMetadata(httpRequest);
        if (!httpRequest.headersList.contains("user-agent")) {
          httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
        }
        if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
          httpRequest.cache = "no-store";
        }
        if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "max-age=0");
        }
        if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
          if (!httpRequest.headersList.contains("pragma")) {
            httpRequest.headersList.append("pragma", "no-cache");
          }
          if (!httpRequest.headersList.contains("cache-control")) {
            httpRequest.headersList.append("cache-control", "no-cache");
          }
        }
        if (httpRequest.headersList.contains("range")) {
          httpRequest.headersList.append("accept-encoding", "identity");
        }
        if (!httpRequest.headersList.contains("accept-encoding")) {
          if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
            httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
          } else {
            httpRequest.headersList.append("accept-encoding", "gzip, deflate");
          }
        }
        httpRequest.headersList.delete("host");
        if (includeCredentials) {
        }
        if (httpCache == null) {
          httpRequest.cache = "no-store";
        }
        if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
        }
        if (response == null) {
          if (httpRequest.mode === "only-if-cached") {
            return makeNetworkError("only if cached");
          }
          const forwardResponse = await httpNetworkFetch(
            httpFetchParams,
            includeCredentials,
            isNewConnectionFetch
          );
          if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
          }
          if (revalidatingFlag && forwardResponse.status === 304) {
          }
          if (response == null) {
            response = forwardResponse;
          }
        }
        response.urlList = [...httpRequest.urlList];
        if (httpRequest.headersList.contains("range")) {
          response.rangeRequested = true;
        }
        response.requestIncludesCredentials = includeCredentials;
        if (response.status === 407) {
          if (request2.window === "no-window") {
            return makeNetworkError();
          }
          if (isCancelled(fetchParams)) {
            return makeAppropriateNetworkError(fetchParams);
          }
          return makeNetworkError("proxy authentication required");
        }
        if (
          // responses status is 421
          response.status === 421 && // isNewConnectionFetch is false
          !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
          (request2.body == null || request2.body.source != null)
        ) {
          if (isCancelled(fetchParams)) {
            return makeAppropriateNetworkError(fetchParams);
          }
          fetchParams.controller.connection.destroy();
          response = await httpNetworkOrCacheFetch(
            fetchParams,
            isAuthenticationFetch,
            true
          );
        }
        if (isAuthenticationFetch) {
        }
        return response;
      }
      async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
        assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
        fetchParams.controller.connection = {
          abort: null,
          destroyed: false,
          destroy(err) {
            if (!this.destroyed) {
              this.destroyed = true;
              this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
            }
          }
        };
        const request2 = fetchParams.request;
        let response = null;
        const timingInfo = fetchParams.timingInfo;
        const httpCache = null;
        if (httpCache == null) {
          request2.cache = "no-store";
        }
        const newConnection = forceNewConnection ? "yes" : "no";
        if (request2.mode === "websocket") {
        } else {
        }
        let requestBody = null;
        if (request2.body == null && fetchParams.processRequestEndOfBody) {
          queueMicrotask(() => fetchParams.processRequestEndOfBody());
        } else if (request2.body != null) {
          const processBodyChunk = async function* (bytes) {
            if (isCancelled(fetchParams)) {
              return;
            }
            yield bytes;
            fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
          };
          const processEndOfBody = () => {
            if (isCancelled(fetchParams)) {
              return;
            }
            if (fetchParams.processRequestEndOfBody) {
              fetchParams.processRequestEndOfBody();
            }
          };
          const processBodyError = (e) => {
            if (isCancelled(fetchParams)) {
              return;
            }
            if (e.name === "AbortError") {
              fetchParams.controller.abort();
            } else {
              fetchParams.controller.terminate(e);
            }
          };
          requestBody = async function* () {
            try {
              for await (const bytes of request2.body.stream) {
                yield* processBodyChunk(bytes);
              }
              processEndOfBody();
            } catch (err) {
              processBodyError(err);
            }
          }();
        }
        try {
          const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
          if (socket) {
            response = makeResponse({ status, statusText, headersList, socket });
          } else {
            const iterator = body[Symbol.asyncIterator]();
            fetchParams.controller.next = () => iterator.next();
            response = makeResponse({ status, statusText, headersList });
          }
        } catch (err) {
          if (err.name === "AbortError") {
            fetchParams.controller.connection.destroy();
            return makeAppropriateNetworkError(fetchParams, err);
          }
          return makeNetworkError(err);
        }
        const pullAlgorithm = () => {
          fetchParams.controller.resume();
        };
        const cancelAlgorithm = (reason) => {
          fetchParams.controller.abort(reason);
        };
        if (!ReadableStream) {
          ReadableStream = __require("stream/web").ReadableStream;
        }
        const stream = new ReadableStream(
          {
            async start(controller) {
              fetchParams.controller.controller = controller;
            },
            async pull(controller) {
              await pullAlgorithm(controller);
            },
            async cancel(reason) {
              await cancelAlgorithm(reason);
            }
          },
          {
            highWaterMark: 0,
            size() {
              return 1;
            }
          }
        );
        response.body = { stream };
        fetchParams.controller.on("terminated", onAborted);
        fetchParams.controller.resume = async () => {
          while (true) {
            let bytes;
            let isFailure;
            try {
              const { done, value } = await fetchParams.controller.next();
              if (isAborted(fetchParams)) {
                break;
              }
              bytes = done ? void 0 : value;
            } catch (err) {
              if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
                bytes = void 0;
              } else {
                bytes = err;
                isFailure = true;
              }
            }
            if (bytes === void 0) {
              readableStreamClose(fetchParams.controller.controller);
              finalizeResponse(fetchParams, response);
              return;
            }
            timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
            if (isFailure) {
              fetchParams.controller.terminate(bytes);
              return;
            }
            fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
            if (isErrored(stream)) {
              fetchParams.controller.terminate();
              return;
            }
            if (!fetchParams.controller.controller.desiredSize) {
              return;
            }
          }
        };
        function onAborted(reason) {
          if (isAborted(fetchParams)) {
            response.aborted = true;
            if (isReadable(stream)) {
              fetchParams.controller.controller.error(
                fetchParams.controller.serializedAbortReason
              );
            }
          } else {
            if (isReadable(stream)) {
              fetchParams.controller.controller.error(new TypeError("terminated", {
                cause: isErrorLike(reason) ? reason : void 0
              }));
            }
          }
          fetchParams.controller.connection.destroy();
        }
        return response;
        async function dispatch({ body }) {
          const url = requestCurrentURL(request2);
          const agent = fetchParams.controller.dispatcher;
          return new Promise((resolve, reject) => agent.dispatch(
            {
              path: url.pathname + url.search,
              origin: url.origin,
              method: request2.method,
              body: fetchParams.controller.dispatcher.isMockActive ? request2.body && (request2.body.source || request2.body.stream) : body,
              headers: request2.headersList.entries,
              maxRedirections: 0,
              upgrade: request2.mode === "websocket" ? "websocket" : void 0
            },
            {
              body: null,
              abort: null,
              onConnect(abort) {
                const { connection } = fetchParams.controller;
                if (connection.destroyed) {
                  abort(new DOMException2("The operation was aborted.", "AbortError"));
                } else {
                  fetchParams.controller.on("terminated", abort);
                  this.abort = connection.abort = abort;
                }
              },
              onHeaders(status, headersList, resume, statusText) {
                if (status < 200) {
                  return;
                }
                let codings = [];
                let location = "";
                const headers = new Headers();
                if (Array.isArray(headersList)) {
                  for (let n = 0; n < headersList.length; n += 2) {
                    const key = headersList[n + 0].toString("latin1");
                    const val = headersList[n + 1].toString("latin1");
                    if (key.toLowerCase() === "content-encoding") {
                      codings = val.toLowerCase().split(",").map((x) => x.trim());
                    } else if (key.toLowerCase() === "location") {
                      location = val;
                    }
                    headers[kHeadersList].append(key, val);
                  }
                } else {
                  const keys = Object.keys(headersList);
                  for (const key of keys) {
                    const val = headersList[key];
                    if (key.toLowerCase() === "content-encoding") {
                      codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
                    } else if (key.toLowerCase() === "location") {
                      location = val;
                    }
                    headers[kHeadersList].append(key, val);
                  }
                }
                this.body = new Readable({ read: resume });
                const decoders = [];
                const willFollow = request2.redirect === "follow" && location && redirectStatusSet.has(status);
                if (request2.method !== "HEAD" && request2.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                  for (const coding of codings) {
                    if (coding === "x-gzip" || coding === "gzip") {
                      decoders.push(zlib.createGunzip({
                        // Be less strict when decoding compressed responses, since sometimes
                        // servers send slightly invalid responses that are still accepted
                        // by common browsers.
                        // Always using Z_SYNC_FLUSH is what cURL does.
                        flush: zlib.constants.Z_SYNC_FLUSH,
                        finishFlush: zlib.constants.Z_SYNC_FLUSH
                      }));
                    } else if (coding === "deflate") {
                      decoders.push(zlib.createInflate());
                    } else if (coding === "br") {
                      decoders.push(zlib.createBrotliDecompress());
                    } else {
                      decoders.length = 0;
                      break;
                    }
                  }
                }
                resolve({
                  status,
                  statusText,
                  headersList: headers[kHeadersList],
                  body: decoders.length ? pipeline(this.body, ...decoders, () => {
                  }) : this.body.on("error", () => {
                  })
                });
                return true;
              },
              onData(chunk) {
                if (fetchParams.controller.dump) {
                  return;
                }
                const bytes = chunk;
                timingInfo.encodedBodySize += bytes.byteLength;
                return this.body.push(bytes);
              },
              onComplete() {
                if (this.abort) {
                  fetchParams.controller.off("terminated", this.abort);
                }
                fetchParams.controller.ended = true;
                this.body.push(null);
              },
              onError(error) {
                if (this.abort) {
                  fetchParams.controller.off("terminated", this.abort);
                }
                this.body?.destroy(error);
                fetchParams.controller.terminate(error);
                reject(error);
              },
              onUpgrade(status, headersList, socket) {
                if (status !== 101) {
                  return;
                }
                const headers = new Headers();
                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString("latin1");
                  const val = headersList[n + 1].toString("latin1");
                  headers[kHeadersList].append(key, val);
                }
                resolve({
                  status,
                  statusText: STATUS_CODES[status],
                  headersList: headers[kHeadersList],
                  socket
                });
                return true;
              }
            }
          ));
        }
      }
      module.exports = {
        fetch: fetch2,
        Fetch,
        fetching,
        finalizeAndReportTiming
      };
    }
  });

  // node_modules/undici/lib/fileapi/symbols.js
  var require_symbols3 = __commonJS({
    "node_modules/undici/lib/fileapi/symbols.js"(exports, module) {
      "use strict";
      module.exports = {
        kState: Symbol("FileReader state"),
        kResult: Symbol("FileReader result"),
        kError: Symbol("FileReader error"),
        kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
        kEvents: Symbol("FileReader events"),
        kAborted: Symbol("FileReader aborted")
      };
    }
  });

  // node_modules/undici/lib/fileapi/progressevent.js
  var require_progressevent = __commonJS({
    "node_modules/undici/lib/fileapi/progressevent.js"(exports, module) {
      "use strict";
      var { webidl } = require_webidl();
      var kState = Symbol("ProgressEvent state");
      var ProgressEvent = class _ProgressEvent extends Event {
        constructor(type, eventInitDict = {}) {
          type = webidl.converters.DOMString(type);
          eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
          super(type, eventInitDict);
          this[kState] = {
            lengthComputable: eventInitDict.lengthComputable,
            loaded: eventInitDict.loaded,
            total: eventInitDict.total
          };
        }
        get lengthComputable() {
          webidl.brandCheck(this, _ProgressEvent);
          return this[kState].lengthComputable;
        }
        get loaded() {
          webidl.brandCheck(this, _ProgressEvent);
          return this[kState].loaded;
        }
        get total() {
          webidl.brandCheck(this, _ProgressEvent);
          return this[kState].total;
        }
      };
      webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
        {
          key: "lengthComputable",
          converter: webidl.converters.boolean,
          defaultValue: false
        },
        {
          key: "loaded",
          converter: webidl.converters["unsigned long long"],
          defaultValue: 0
        },
        {
          key: "total",
          converter: webidl.converters["unsigned long long"],
          defaultValue: 0
        },
        {
          key: "bubbles",
          converter: webidl.converters.boolean,
          defaultValue: false
        },
        {
          key: "cancelable",
          converter: webidl.converters.boolean,
          defaultValue: false
        },
        {
          key: "composed",
          converter: webidl.converters.boolean,
          defaultValue: false
        }
      ]);
      module.exports = {
        ProgressEvent
      };
    }
  });

  // node_modules/undici/lib/fileapi/encoding.js
  var require_encoding = __commonJS({
    "node_modules/undici/lib/fileapi/encoding.js"(exports, module) {
      "use strict";
      function getEncoding(label) {
        if (!label) {
          return "failure";
        }
        switch (label.trim().toLowerCase()) {
          case "unicode-1-1-utf-8":
          case "unicode11utf8":
          case "unicode20utf8":
          case "utf-8":
          case "utf8":
          case "x-unicode20utf8":
            return "UTF-8";
          case "866":
          case "cp866":
          case "csibm866":
          case "ibm866":
            return "IBM866";
          case "csisolatin2":
          case "iso-8859-2":
          case "iso-ir-101":
          case "iso8859-2":
          case "iso88592":
          case "iso_8859-2":
          case "iso_8859-2:1987":
          case "l2":
          case "latin2":
            return "ISO-8859-2";
          case "csisolatin3":
          case "iso-8859-3":
          case "iso-ir-109":
          case "iso8859-3":
          case "iso88593":
          case "iso_8859-3":
          case "iso_8859-3:1988":
          case "l3":
          case "latin3":
            return "ISO-8859-3";
          case "csisolatin4":
          case "iso-8859-4":
          case "iso-ir-110":
          case "iso8859-4":
          case "iso88594":
          case "iso_8859-4":
          case "iso_8859-4:1988":
          case "l4":
          case "latin4":
            return "ISO-8859-4";
          case "csisolatincyrillic":
          case "cyrillic":
          case "iso-8859-5":
          case "iso-ir-144":
          case "iso8859-5":
          case "iso88595":
          case "iso_8859-5":
          case "iso_8859-5:1988":
            return "ISO-8859-5";
          case "arabic":
          case "asmo-708":
          case "csiso88596e":
          case "csiso88596i":
          case "csisolatinarabic":
          case "ecma-114":
          case "iso-8859-6":
          case "iso-8859-6-e":
          case "iso-8859-6-i":
          case "iso-ir-127":
          case "iso8859-6":
          case "iso88596":
          case "iso_8859-6":
          case "iso_8859-6:1987":
            return "ISO-8859-6";
          case "csisolatingreek":
          case "ecma-118":
          case "elot_928":
          case "greek":
          case "greek8":
          case "iso-8859-7":
          case "iso-ir-126":
          case "iso8859-7":
          case "iso88597":
          case "iso_8859-7":
          case "iso_8859-7:1987":
          case "sun_eu_greek":
            return "ISO-8859-7";
          case "csiso88598e":
          case "csisolatinhebrew":
          case "hebrew":
          case "iso-8859-8":
          case "iso-8859-8-e":
          case "iso-ir-138":
          case "iso8859-8":
          case "iso88598":
          case "iso_8859-8":
          case "iso_8859-8:1988":
          case "visual":
            return "ISO-8859-8";
          case "csiso88598i":
          case "iso-8859-8-i":
          case "logical":
            return "ISO-8859-8-I";
          case "csisolatin6":
          case "iso-8859-10":
          case "iso-ir-157":
          case "iso8859-10":
          case "iso885910":
          case "l6":
          case "latin6":
            return "ISO-8859-10";
          case "iso-8859-13":
          case "iso8859-13":
          case "iso885913":
            return "ISO-8859-13";
          case "iso-8859-14":
          case "iso8859-14":
          case "iso885914":
            return "ISO-8859-14";
          case "csisolatin9":
          case "iso-8859-15":
          case "iso8859-15":
          case "iso885915":
          case "iso_8859-15":
          case "l9":
            return "ISO-8859-15";
          case "iso-8859-16":
            return "ISO-8859-16";
          case "cskoi8r":
          case "koi":
          case "koi8":
          case "koi8-r":
          case "koi8_r":
            return "KOI8-R";
          case "koi8-ru":
          case "koi8-u":
            return "KOI8-U";
          case "csmacintosh":
          case "mac":
          case "macintosh":
          case "x-mac-roman":
            return "macintosh";
          case "iso-8859-11":
          case "iso8859-11":
          case "iso885911":
          case "tis-620":
          case "windows-874":
            return "windows-874";
          case "cp1250":
          case "windows-1250":
          case "x-cp1250":
            return "windows-1250";
          case "cp1251":
          case "windows-1251":
          case "x-cp1251":
            return "windows-1251";
          case "ansi_x3.4-1968":
          case "ascii":
          case "cp1252":
          case "cp819":
          case "csisolatin1":
          case "ibm819":
          case "iso-8859-1":
          case "iso-ir-100":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "iso_8859-1:1987":
          case "l1":
          case "latin1":
          case "us-ascii":
          case "windows-1252":
          case "x-cp1252":
            return "windows-1252";
          case "cp1253":
          case "windows-1253":
          case "x-cp1253":
            return "windows-1253";
          case "cp1254":
          case "csisolatin5":
          case "iso-8859-9":
          case "iso-ir-148":
          case "iso8859-9":
          case "iso88599":
          case "iso_8859-9":
          case "iso_8859-9:1989":
          case "l5":
          case "latin5":
          case "windows-1254":
          case "x-cp1254":
            return "windows-1254";
          case "cp1255":
          case "windows-1255":
          case "x-cp1255":
            return "windows-1255";
          case "cp1256":
          case "windows-1256":
          case "x-cp1256":
            return "windows-1256";
          case "cp1257":
          case "windows-1257":
          case "x-cp1257":
            return "windows-1257";
          case "cp1258":
          case "windows-1258":
          case "x-cp1258":
            return "windows-1258";
          case "x-mac-cyrillic":
          case "x-mac-ukrainian":
            return "x-mac-cyrillic";
          case "chinese":
          case "csgb2312":
          case "csiso58gb231280":
          case "gb2312":
          case "gb_2312":
          case "gb_2312-80":
          case "gbk":
          case "iso-ir-58":
          case "x-gbk":
            return "GBK";
          case "gb18030":
            return "gb18030";
          case "big5":
          case "big5-hkscs":
          case "cn-big5":
          case "csbig5":
          case "x-x-big5":
            return "Big5";
          case "cseucpkdfmtjapanese":
          case "euc-jp":
          case "x-euc-jp":
            return "EUC-JP";
          case "csiso2022jp":
          case "iso-2022-jp":
            return "ISO-2022-JP";
          case "csshiftjis":
          case "ms932":
          case "ms_kanji":
          case "shift-jis":
          case "shift_jis":
          case "sjis":
          case "windows-31j":
          case "x-sjis":
            return "Shift_JIS";
          case "cseuckr":
          case "csksc56011987":
          case "euc-kr":
          case "iso-ir-149":
          case "korean":
          case "ks_c_5601-1987":
          case "ks_c_5601-1989":
          case "ksc5601":
          case "ksc_5601":
          case "windows-949":
            return "EUC-KR";
          case "csiso2022kr":
          case "hz-gb-2312":
          case "iso-2022-cn":
          case "iso-2022-cn-ext":
          case "iso-2022-kr":
          case "replacement":
            return "replacement";
          case "unicodefffe":
          case "utf-16be":
            return "UTF-16BE";
          case "csunicode":
          case "iso-10646-ucs-2":
          case "ucs-2":
          case "unicode":
          case "unicodefeff":
          case "utf-16":
          case "utf-16le":
            return "UTF-16LE";
          case "x-user-defined":
            return "x-user-defined";
          default:
            return "failure";
        }
      }
      module.exports = {
        getEncoding
      };
    }
  });

  // node_modules/undici/lib/fileapi/util.js
  var require_util4 = __commonJS({
    "node_modules/undici/lib/fileapi/util.js"(exports, module) {
      "use strict";
      var {
        kState,
        kError,
        kResult,
        kAborted,
        kLastProgressEventFired
      } = require_symbols3();
      var { ProgressEvent } = require_progressevent();
      var { getEncoding } = require_encoding();
      var { DOMException: DOMException2 } = require_constants2();
      var { serializeAMimeType, parseMIMEType } = require_dataURL();
      var { types } = __require("util");
      var { StringDecoder } = __require("string_decoder");
      var { btoa } = __require("buffer");
      var staticPropertyDescriptors = {
        enumerable: true,
        writable: false,
        configurable: false
      };
      function readOperation(fr, blob, type, encodingName) {
        if (fr[kState] === "loading") {
          throw new DOMException2("Invalid state", "InvalidStateError");
        }
        fr[kState] = "loading";
        fr[kResult] = null;
        fr[kError] = null;
        const stream = blob.stream();
        const reader = stream.getReader();
        const bytes = [];
        let chunkPromise = reader.read();
        let isFirstChunk = true;
        (async () => {
          while (!fr[kAborted]) {
            try {
              const { done, value } = await chunkPromise;
              if (isFirstChunk && !fr[kAborted]) {
                queueMicrotask(() => {
                  fireAProgressEvent("loadstart", fr);
                });
              }
              isFirstChunk = false;
              if (!done && types.isUint8Array(value)) {
                bytes.push(value);
                if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                  fr[kLastProgressEventFired] = Date.now();
                  queueMicrotask(() => {
                    fireAProgressEvent("progress", fr);
                  });
                }
                chunkPromise = reader.read();
              } else if (done) {
                queueMicrotask(() => {
                  fr[kState] = "done";
                  try {
                    const result = packageData(bytes, type, blob.type, encodingName);
                    if (fr[kAborted]) {
                      return;
                    }
                    fr[kResult] = result;
                    fireAProgressEvent("load", fr);
                  } catch (error) {
                    fr[kError] = error;
                    fireAProgressEvent("error", fr);
                  }
                  if (fr[kState] !== "loading") {
                    fireAProgressEvent("loadend", fr);
                  }
                });
                break;
              }
            } catch (error) {
              if (fr[kAborted]) {
                return;
              }
              queueMicrotask(() => {
                fr[kState] = "done";
                fr[kError] = error;
                fireAProgressEvent("error", fr);
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          }
        })();
      }
      function fireAProgressEvent(e, reader) {
        const event = new ProgressEvent(e, {
          bubbles: false,
          cancelable: false
        });
        reader.dispatchEvent(event);
      }
      function packageData(bytes, type, mimeType, encodingName) {
        switch (type) {
          case "DataURL": {
            let dataURL = "data:";
            const parsed = parseMIMEType(mimeType || "application/octet-stream");
            if (parsed !== "failure") {
              dataURL += serializeAMimeType(parsed);
            }
            dataURL += ";base64,";
            const decoder = new StringDecoder("latin1");
            for (const chunk of bytes) {
              dataURL += btoa(decoder.write(chunk));
            }
            dataURL += btoa(decoder.end());
            return dataURL;
          }
          case "Text": {
            let encoding = "failure";
            if (encodingName) {
              encoding = getEncoding(encodingName);
            }
            if (encoding === "failure" && mimeType) {
              const type2 = parseMIMEType(mimeType);
              if (type2 !== "failure") {
                encoding = getEncoding(type2.parameters.get("charset"));
              }
            }
            if (encoding === "failure") {
              encoding = "UTF-8";
            }
            return decode(bytes, encoding);
          }
          case "ArrayBuffer": {
            const sequence = combineByteSequences(bytes);
            return sequence.buffer;
          }
          case "BinaryString": {
            let binaryString = "";
            const decoder = new StringDecoder("latin1");
            for (const chunk of bytes) {
              binaryString += decoder.write(chunk);
            }
            binaryString += decoder.end();
            return binaryString;
          }
        }
      }
      function decode(ioQueue, encoding) {
        const bytes = combineByteSequences(ioQueue);
        const BOMEncoding = BOMSniffing(bytes);
        let slice = 0;
        if (BOMEncoding !== null) {
          encoding = BOMEncoding;
          slice = BOMEncoding === "UTF-8" ? 3 : 2;
        }
        const sliced = bytes.slice(slice);
        return new TextDecoder(encoding).decode(sliced);
      }
      function BOMSniffing(ioQueue) {
        const [a, b, c] = ioQueue;
        if (a === 239 && b === 187 && c === 191) {
          return "UTF-8";
        } else if (a === 254 && b === 255) {
          return "UTF-16BE";
        } else if (a === 255 && b === 254) {
          return "UTF-16LE";
        }
        return null;
      }
      function combineByteSequences(sequences) {
        const size = sequences.reduce((a, b) => {
          return a + b.byteLength;
        }, 0);
        let offset = 0;
        return sequences.reduce((a, b) => {
          a.set(b, offset);
          offset += b.byteLength;
          return a;
        }, new Uint8Array(size));
      }
      module.exports = {
        staticPropertyDescriptors,
        readOperation,
        fireAProgressEvent
      };
    }
  });

  // node_modules/undici/lib/fileapi/filereader.js
  var require_filereader = __commonJS({
    "node_modules/undici/lib/fileapi/filereader.js"(exports, module) {
      "use strict";
      var {
        staticPropertyDescriptors,
        readOperation,
        fireAProgressEvent
      } = require_util4();
      var {
        kState,
        kError,
        kResult,
        kEvents,
        kAborted
      } = require_symbols3();
      var { webidl } = require_webidl();
      var { kEnumerableProperty } = require_util();
      var FileReader = class _FileReader extends EventTarget {
        constructor() {
          super();
          this[kState] = "empty";
          this[kResult] = null;
          this[kError] = null;
          this[kEvents] = {
            loadend: null,
            error: null,
            abort: null,
            load: null,
            progress: null,
            loadstart: null
          };
        }
        /**
         * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
         * @param {import('buffer').Blob} blob
         */
        readAsArrayBuffer(blob) {
          webidl.brandCheck(this, _FileReader);
          webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
          blob = webidl.converters.Blob(blob, { strict: false });
          readOperation(this, blob, "ArrayBuffer");
        }
        /**
         * @see https://w3c.github.io/FileAPI/#readAsBinaryString
         * @param {import('buffer').Blob} blob
         */
        readAsBinaryString(blob) {
          webidl.brandCheck(this, _FileReader);
          webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
          blob = webidl.converters.Blob(blob, { strict: false });
          readOperation(this, blob, "BinaryString");
        }
        /**
         * @see https://w3c.github.io/FileAPI/#readAsDataText
         * @param {import('buffer').Blob} blob
         * @param {string?} encoding
         */
        readAsText(blob, encoding = void 0) {
          webidl.brandCheck(this, _FileReader);
          webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
          blob = webidl.converters.Blob(blob, { strict: false });
          if (encoding !== void 0) {
            encoding = webidl.converters.DOMString(encoding);
          }
          readOperation(this, blob, "Text", encoding);
        }
        /**
         * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
         * @param {import('buffer').Blob} blob
         */
        readAsDataURL(blob) {
          webidl.brandCheck(this, _FileReader);
          webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
          blob = webidl.converters.Blob(blob, { strict: false });
          readOperation(this, blob, "DataURL");
        }
        /**
         * @see https://w3c.github.io/FileAPI/#dfn-abort
         */
        abort() {
          if (this[kState] === "empty" || this[kState] === "done") {
            this[kResult] = null;
            return;
          }
          if (this[kState] === "loading") {
            this[kState] = "done";
            this[kResult] = null;
          }
          this[kAborted] = true;
          fireAProgressEvent("abort", this);
          if (this[kState] !== "loading") {
            fireAProgressEvent("loadend", this);
          }
        }
        /**
         * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
         */
        get readyState() {
          webidl.brandCheck(this, _FileReader);
          switch (this[kState]) {
            case "empty":
              return this.EMPTY;
            case "loading":
              return this.LOADING;
            case "done":
              return this.DONE;
          }
        }
        /**
         * @see https://w3c.github.io/FileAPI/#dom-filereader-result
         */
        get result() {
          webidl.brandCheck(this, _FileReader);
          return this[kResult];
        }
        /**
         * @see https://w3c.github.io/FileAPI/#dom-filereader-error
         */
        get error() {
          webidl.brandCheck(this, _FileReader);
          return this[kError];
        }
        get onloadend() {
          webidl.brandCheck(this, _FileReader);
          return this[kEvents].loadend;
        }
        set onloadend(fn) {
          webidl.brandCheck(this, _FileReader);
          if (this[kEvents].loadend) {
            this.removeEventListener("loadend", this[kEvents].loadend);
          }
          if (typeof fn === "function") {
            this[kEvents].loadend = fn;
            this.addEventListener("loadend", fn);
          } else {
            this[kEvents].loadend = null;
          }
        }
        get onerror() {
          webidl.brandCheck(this, _FileReader);
          return this[kEvents].error;
        }
        set onerror(fn) {
          webidl.brandCheck(this, _FileReader);
          if (this[kEvents].error) {
            this.removeEventListener("error", this[kEvents].error);
          }
          if (typeof fn === "function") {
            this[kEvents].error = fn;
            this.addEventListener("error", fn);
          } else {
            this[kEvents].error = null;
          }
        }
        get onloadstart() {
          webidl.brandCheck(this, _FileReader);
          return this[kEvents].loadstart;
        }
        set onloadstart(fn) {
          webidl.brandCheck(this, _FileReader);
          if (this[kEvents].loadstart) {
            this.removeEventListener("loadstart", this[kEvents].loadstart);
          }
          if (typeof fn === "function") {
            this[kEvents].loadstart = fn;
            this.addEventListener("loadstart", fn);
          } else {
            this[kEvents].loadstart = null;
          }
        }
        get onprogress() {
          webidl.brandCheck(this, _FileReader);
          return this[kEvents].progress;
        }
        set onprogress(fn) {
          webidl.brandCheck(this, _FileReader);
          if (this[kEvents].progress) {
            this.removeEventListener("progress", this[kEvents].progress);
          }
          if (typeof fn === "function") {
            this[kEvents].progress = fn;
            this.addEventListener("progress", fn);
          } else {
            this[kEvents].progress = null;
          }
        }
        get onload() {
          webidl.brandCheck(this, _FileReader);
          return this[kEvents].load;
        }
        set onload(fn) {
          webidl.brandCheck(this, _FileReader);
          if (this[kEvents].load) {
            this.removeEventListener("load", this[kEvents].load);
          }
          if (typeof fn === "function") {
            this[kEvents].load = fn;
            this.addEventListener("load", fn);
          } else {
            this[kEvents].load = null;
          }
        }
        get onabort() {
          webidl.brandCheck(this, _FileReader);
          return this[kEvents].abort;
        }
        set onabort(fn) {
          webidl.brandCheck(this, _FileReader);
          if (this[kEvents].abort) {
            this.removeEventListener("abort", this[kEvents].abort);
          }
          if (typeof fn === "function") {
            this[kEvents].abort = fn;
            this.addEventListener("abort", fn);
          } else {
            this[kEvents].abort = null;
          }
        }
      };
      FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
      FileReader.LOADING = FileReader.prototype.LOADING = 1;
      FileReader.DONE = FileReader.prototype.DONE = 2;
      Object.defineProperties(FileReader.prototype, {
        EMPTY: staticPropertyDescriptors,
        LOADING: staticPropertyDescriptors,
        DONE: staticPropertyDescriptors,
        readAsArrayBuffer: kEnumerableProperty,
        readAsBinaryString: kEnumerableProperty,
        readAsText: kEnumerableProperty,
        readAsDataURL: kEnumerableProperty,
        abort: kEnumerableProperty,
        readyState: kEnumerableProperty,
        result: kEnumerableProperty,
        error: kEnumerableProperty,
        onloadstart: kEnumerableProperty,
        onprogress: kEnumerableProperty,
        onload: kEnumerableProperty,
        onabort: kEnumerableProperty,
        onerror: kEnumerableProperty,
        onloadend: kEnumerableProperty,
        [Symbol.toStringTag]: {
          value: "FileReader",
          writable: false,
          enumerable: false,
          configurable: true
        }
      });
      Object.defineProperties(FileReader, {
        EMPTY: staticPropertyDescriptors,
        LOADING: staticPropertyDescriptors,
        DONE: staticPropertyDescriptors
      });
      module.exports = {
        FileReader
      };
    }
  });

  // node_modules/undici/lib/cache/symbols.js
  var require_symbols4 = __commonJS({
    "node_modules/undici/lib/cache/symbols.js"(exports, module) {
      "use strict";
      module.exports = {
        kConstruct: require_symbols().kConstruct
      };
    }
  });

  // node_modules/undici/lib/cache/util.js
  var require_util5 = __commonJS({
    "node_modules/undici/lib/cache/util.js"(exports, module) {
      "use strict";
      var assert = __require("assert");
      var { URLSerializer } = require_dataURL();
      var { isValidHeaderName } = require_util2();
      function urlEquals(A, B, excludeFragment = false) {
        const serializedA = URLSerializer(A, excludeFragment);
        const serializedB = URLSerializer(B, excludeFragment);
        return serializedA === serializedB;
      }
      function fieldValues(header) {
        assert(header !== null);
        const values = [];
        for (let value of header.split(",")) {
          value = value.trim();
          if (!value.length) {
            continue;
          } else if (!isValidHeaderName(value)) {
            continue;
          }
          values.push(value);
        }
        return values;
      }
      module.exports = {
        urlEquals,
        fieldValues
      };
    }
  });

  // node_modules/undici/lib/cache/cache.js
  var require_cache = __commonJS({
    "node_modules/undici/lib/cache/cache.js"(exports, module) {
      "use strict";
      var { kConstruct } = require_symbols4();
      var { urlEquals, fieldValues: getFieldValues } = require_util5();
      var { kEnumerableProperty, isDisturbed } = require_util();
      var { kHeadersList } = require_symbols();
      var { webidl } = require_webidl();
      var { Response, cloneResponse } = require_response();
      var { Request } = require_request2();
      var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
      var { fetching } = require_fetch();
      var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
      var assert = __require("assert");
      var { getGlobalDispatcher } = require_global2();
      var Cache = class _Cache {
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
         * @type {requestResponseList}
         */
        #relevantRequestResponseList;
        constructor() {
          if (arguments[0] !== kConstruct) {
            webidl.illegalConstructor();
          }
          this.#relevantRequestResponseList = arguments[1];
        }
        async match(request2, options = {}) {
          webidl.brandCheck(this, _Cache);
          webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
          request2 = webidl.converters.RequestInfo(request2);
          options = webidl.converters.CacheQueryOptions(options);
          const p = await this.matchAll(request2, options);
          if (p.length === 0) {
            return;
          }
          return p[0];
        }
        async matchAll(request2 = void 0, options = {}) {
          webidl.brandCheck(this, _Cache);
          if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2);
          options = webidl.converters.CacheQueryOptions(options);
          let r = null;
          if (request2 !== void 0) {
            if (request2 instanceof Request) {
              r = request2[kState];
              if (r.method !== "GET" && !options.ignoreMethod) {
                return [];
              }
            } else if (typeof request2 === "string") {
              r = new Request(request2)[kState];
            }
          }
          const responses = [];
          if (request2 === void 0) {
            for (const requestResponse of this.#relevantRequestResponseList) {
              responses.push(requestResponse[1]);
            }
          } else {
            const requestResponses = this.#queryCache(r, options);
            for (const requestResponse of requestResponses) {
              responses.push(requestResponse[1]);
            }
          }
          const responseList = [];
          for (const response of responses) {
            const responseObject = new Response(response.body?.source ?? null);
            const body = responseObject[kState].body;
            responseObject[kState] = response;
            responseObject[kState].body = body;
            responseObject[kHeaders][kHeadersList] = response.headersList;
            responseObject[kHeaders][kGuard] = "immutable";
            responseList.push(responseObject);
          }
          return Object.freeze(responseList);
        }
        async add(request2) {
          webidl.brandCheck(this, _Cache);
          webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
          request2 = webidl.converters.RequestInfo(request2);
          const requests = [request2];
          const responseArrayPromise = this.addAll(requests);
          return await responseArrayPromise;
        }
        async addAll(requests) {
          webidl.brandCheck(this, _Cache);
          webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
          requests = webidl.converters["sequence<RequestInfo>"](requests);
          const responsePromises = [];
          const requestList = [];
          for (const request2 of requests) {
            if (typeof request2 === "string") {
              continue;
            }
            const r = request2[kState];
            if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.addAll",
                message: "Expected http/s scheme when method is not GET."
              });
            }
          }
          const fetchControllers = [];
          for (const request2 of requests) {
            const r = new Request(request2)[kState];
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.addAll",
                message: "Expected http/s scheme."
              });
            }
            r.initiator = "fetch";
            r.destination = "subresource";
            requestList.push(r);
            const responsePromise = createDeferredPromise();
            fetchControllers.push(fetching({
              request: r,
              dispatcher: getGlobalDispatcher(),
              processResponse(response) {
                if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "Received an invalid status code or the request failed."
                  }));
                } else if (response.headersList.contains("vary")) {
                  const fieldValues = getFieldValues(response.headersList.get("vary"));
                  for (const fieldValue of fieldValues) {
                    if (fieldValue === "*") {
                      responsePromise.reject(webidl.errors.exception({
                        header: "Cache.addAll",
                        message: "invalid vary field value"
                      }));
                      for (const controller of fetchControllers) {
                        controller.abort();
                      }
                      return;
                    }
                  }
                }
              },
              processResponseEndOfBody(response) {
                if (response.aborted) {
                  responsePromise.reject(new DOMException("aborted", "AbortError"));
                  return;
                }
                responsePromise.resolve(response);
              }
            }));
            responsePromises.push(responsePromise.promise);
          }
          const p = Promise.all(responsePromises);
          const responses = await p;
          const operations = [];
          let index = 0;
          for (const response of responses) {
            const operation = {
              type: "put",
              // 7.3.2
              request: requestList[index],
              // 7.3.3
              response
              // 7.3.4
            };
            operations.push(operation);
            index++;
          }
          const cacheJobPromise = createDeferredPromise();
          let errorData = null;
          try {
            this.#batchCacheOperations(operations);
          } catch (e) {
            errorData = e;
          }
          queueMicrotask(() => {
            if (errorData === null) {
              cacheJobPromise.resolve(void 0);
            } else {
              cacheJobPromise.reject(errorData);
            }
          });
          return cacheJobPromise.promise;
        }
        async put(request2, response) {
          webidl.brandCheck(this, _Cache);
          webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
          request2 = webidl.converters.RequestInfo(request2);
          response = webidl.converters.Response(response);
          let innerRequest = null;
          if (request2 instanceof Request) {
            innerRequest = request2[kState];
          } else {
            innerRequest = new Request(request2)[kState];
          }
          if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.put",
              message: "Expected an http/s scheme when method is not GET"
            });
          }
          const innerResponse = response[kState];
          if (innerResponse.status === 206) {
            throw webidl.errors.exception({
              header: "Cache.put",
              message: "Got 206 status"
            });
          }
          if (innerResponse.headersList.contains("vary")) {
            const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
            for (const fieldValue of fieldValues) {
              if (fieldValue === "*") {
                throw webidl.errors.exception({
                  header: "Cache.put",
                  message: "Got * vary field value"
                });
              }
            }
          }
          if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
            throw webidl.errors.exception({
              header: "Cache.put",
              message: "Response body is locked or disturbed"
            });
          }
          const clonedResponse = cloneResponse(innerResponse);
          const bodyReadPromise = createDeferredPromise();
          if (innerResponse.body != null) {
            const stream = innerResponse.body.stream;
            const reader = stream.getReader();
            readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
          } else {
            bodyReadPromise.resolve(void 0);
          }
          const operations = [];
          const operation = {
            type: "put",
            // 14.
            request: innerRequest,
            // 15.
            response: clonedResponse
            // 16.
          };
          operations.push(operation);
          const bytes = await bodyReadPromise.promise;
          if (clonedResponse.body != null) {
            clonedResponse.body.source = bytes;
          }
          const cacheJobPromise = createDeferredPromise();
          let errorData = null;
          try {
            this.#batchCacheOperations(operations);
          } catch (e) {
            errorData = e;
          }
          queueMicrotask(() => {
            if (errorData === null) {
              cacheJobPromise.resolve();
            } else {
              cacheJobPromise.reject(errorData);
            }
          });
          return cacheJobPromise.promise;
        }
        async delete(request2, options = {}) {
          webidl.brandCheck(this, _Cache);
          webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
          request2 = webidl.converters.RequestInfo(request2);
          options = webidl.converters.CacheQueryOptions(options);
          let r = null;
          if (request2 instanceof Request) {
            r = request2[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return false;
            }
          } else {
            assert(typeof request2 === "string");
            r = new Request(request2)[kState];
          }
          const operations = [];
          const operation = {
            type: "delete",
            request: r,
            options
          };
          operations.push(operation);
          const cacheJobPromise = createDeferredPromise();
          let errorData = null;
          let requestResponses;
          try {
            requestResponses = this.#batchCacheOperations(operations);
          } catch (e) {
            errorData = e;
          }
          queueMicrotask(() => {
            if (errorData === null) {
              cacheJobPromise.resolve(!!requestResponses?.length);
            } else {
              cacheJobPromise.reject(errorData);
            }
          });
          return cacheJobPromise.promise;
        }
        /**
         * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
         * @param {any} request
         * @param {import('../../types/cache').CacheQueryOptions} options
         * @returns {readonly Request[]}
         */
        async keys(request2 = void 0, options = {}) {
          webidl.brandCheck(this, _Cache);
          if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2);
          options = webidl.converters.CacheQueryOptions(options);
          let r = null;
          if (request2 !== void 0) {
            if (request2 instanceof Request) {
              r = request2[kState];
              if (r.method !== "GET" && !options.ignoreMethod) {
                return [];
              }
            } else if (typeof request2 === "string") {
              r = new Request(request2)[kState];
            }
          }
          const promise = createDeferredPromise();
          const requests = [];
          if (request2 === void 0) {
            for (const requestResponse of this.#relevantRequestResponseList) {
              requests.push(requestResponse[0]);
            }
          } else {
            const requestResponses = this.#queryCache(r, options);
            for (const requestResponse of requestResponses) {
              requests.push(requestResponse[0]);
            }
          }
          queueMicrotask(() => {
            const requestList = [];
            for (const request3 of requests) {
              const requestObject = new Request("https://a");
              requestObject[kState] = request3;
              requestObject[kHeaders][kHeadersList] = request3.headersList;
              requestObject[kHeaders][kGuard] = "immutable";
              requestObject[kRealm] = request3.client;
              requestList.push(requestObject);
            }
            promise.resolve(Object.freeze(requestList));
          });
          return promise.promise;
        }
        /**
         * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
         * @param {CacheBatchOperation[]} operations
         * @returns {requestResponseList}
         */
        #batchCacheOperations(operations) {
          const cache = this.#relevantRequestResponseList;
          const backupCache = [...cache];
          const addedItems = [];
          const resultList = [];
          try {
            for (const operation of operations) {
              if (operation.type !== "delete" && operation.type !== "put") {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: 'operation type does not match "delete" or "put"'
                });
              }
              if (operation.type === "delete" && operation.response != null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "delete operation should not have an associated response"
                });
              }
              if (this.#queryCache(operation.request, operation.options, addedItems).length) {
                throw new DOMException("???", "InvalidStateError");
              }
              let requestResponses;
              if (operation.type === "delete") {
                requestResponses = this.#queryCache(operation.request, operation.options);
                if (requestResponses.length === 0) {
                  return [];
                }
                for (const requestResponse of requestResponses) {
                  const idx = cache.indexOf(requestResponse);
                  assert(idx !== -1);
                  cache.splice(idx, 1);
                }
              } else if (operation.type === "put") {
                if (operation.response == null) {
                  throw webidl.errors.exception({
                    header: "Cache.#batchCacheOperations",
                    message: "put operation should have an associated response"
                  });
                }
                const r = operation.request;
                if (!urlIsHttpHttpsScheme(r.url)) {
                  throw webidl.errors.exception({
                    header: "Cache.#batchCacheOperations",
                    message: "expected http or https scheme"
                  });
                }
                if (r.method !== "GET") {
                  throw webidl.errors.exception({
                    header: "Cache.#batchCacheOperations",
                    message: "not get method"
                  });
                }
                if (operation.options != null) {
                  throw webidl.errors.exception({
                    header: "Cache.#batchCacheOperations",
                    message: "options must not be defined"
                  });
                }
                requestResponses = this.#queryCache(operation.request);
                for (const requestResponse of requestResponses) {
                  const idx = cache.indexOf(requestResponse);
                  assert(idx !== -1);
                  cache.splice(idx, 1);
                }
                cache.push([operation.request, operation.response]);
                addedItems.push([operation.request, operation.response]);
              }
              resultList.push([operation.request, operation.response]);
            }
            return resultList;
          } catch (e) {
            this.#relevantRequestResponseList.length = 0;
            this.#relevantRequestResponseList = backupCache;
            throw e;
          }
        }
        /**
         * @see https://w3c.github.io/ServiceWorker/#query-cache
         * @param {any} requestQuery
         * @param {import('../../types/cache').CacheQueryOptions} options
         * @param {requestResponseList} targetStorage
         * @returns {requestResponseList}
         */
        #queryCache(requestQuery, options, targetStorage) {
          const resultList = [];
          const storage = targetStorage ?? this.#relevantRequestResponseList;
          for (const requestResponse of storage) {
            const [cachedRequest, cachedResponse] = requestResponse;
            if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
              resultList.push(requestResponse);
            }
          }
          return resultList;
        }
        /**
         * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
         * @param {any} requestQuery
         * @param {any} request
         * @param {any | null} response
         * @param {import('../../types/cache').CacheQueryOptions | undefined} options
         * @returns {boolean}
         */
        #requestMatchesCachedItem(requestQuery, request2, response = null, options) {
          const queryURL = new URL(requestQuery.url);
          const cachedURL = new URL(request2.url);
          if (options?.ignoreSearch) {
            cachedURL.search = "";
            queryURL.search = "";
          }
          if (!urlEquals(queryURL, cachedURL, true)) {
            return false;
          }
          if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
            return true;
          }
          const fieldValues = getFieldValues(response.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              return false;
            }
            const requestValue = request2.headersList.get(fieldValue);
            const queryValue = requestQuery.headersList.get(fieldValue);
            if (requestValue !== queryValue) {
              return false;
            }
          }
          return true;
        }
      };
      Object.defineProperties(Cache.prototype, {
        [Symbol.toStringTag]: {
          value: "Cache",
          configurable: true
        },
        match: kEnumerableProperty,
        matchAll: kEnumerableProperty,
        add: kEnumerableProperty,
        addAll: kEnumerableProperty,
        put: kEnumerableProperty,
        delete: kEnumerableProperty,
        keys: kEnumerableProperty
      });
      var cacheQueryOptionConverters = [
        {
          key: "ignoreSearch",
          converter: webidl.converters.boolean,
          defaultValue: false
        },
        {
          key: "ignoreMethod",
          converter: webidl.converters.boolean,
          defaultValue: false
        },
        {
          key: "ignoreVary",
          converter: webidl.converters.boolean,
          defaultValue: false
        }
      ];
      webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
      webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
        ...cacheQueryOptionConverters,
        {
          key: "cacheName",
          converter: webidl.converters.DOMString
        }
      ]);
      webidl.converters.Response = webidl.interfaceConverter(Response);
      webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
        webidl.converters.RequestInfo
      );
      module.exports = {
        Cache
      };
    }
  });

  // node_modules/undici/lib/cache/cachestorage.js
  var require_cachestorage = __commonJS({
    "node_modules/undici/lib/cache/cachestorage.js"(exports, module) {
      "use strict";
      var { kConstruct } = require_symbols4();
      var { Cache } = require_cache();
      var { webidl } = require_webidl();
      var { kEnumerableProperty } = require_util();
      var CacheStorage = class _CacheStorage {
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
         * @type {Map<string, import('./cache').requestResponseList}
         */
        #caches = /* @__PURE__ */ new Map();
        constructor() {
          if (arguments[0] !== kConstruct) {
            webidl.illegalConstructor();
          }
        }
        async match(request2, options = {}) {
          webidl.brandCheck(this, _CacheStorage);
          webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
          request2 = webidl.converters.RequestInfo(request2);
          options = webidl.converters.MultiCacheQueryOptions(options);
          if (options.cacheName != null) {
            if (this.#caches.has(options.cacheName)) {
              const cacheList = this.#caches.get(options.cacheName);
              const cache = new Cache(kConstruct, cacheList);
              return await cache.match(request2, options);
            }
          } else {
            for (const cacheList of this.#caches.values()) {
              const cache = new Cache(kConstruct, cacheList);
              const response = await cache.match(request2, options);
              if (response !== void 0) {
                return response;
              }
            }
          }
        }
        /**
         * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
         * @param {string} cacheName
         * @returns {Promise<boolean>}
         */
        async has(cacheName) {
          webidl.brandCheck(this, _CacheStorage);
          webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
          cacheName = webidl.converters.DOMString(cacheName);
          return this.#caches.has(cacheName);
        }
        /**
         * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
         * @param {string} cacheName
         * @returns {Promise<Cache>}
         */
        async open(cacheName) {
          webidl.brandCheck(this, _CacheStorage);
          webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
          cacheName = webidl.converters.DOMString(cacheName);
          if (this.#caches.has(cacheName)) {
            const cache2 = this.#caches.get(cacheName);
            return new Cache(kConstruct, cache2);
          }
          const cache = [];
          this.#caches.set(cacheName, cache);
          return new Cache(kConstruct, cache);
        }
        /**
         * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
         * @param {string} cacheName
         * @returns {Promise<boolean>}
         */
        async delete(cacheName) {
          webidl.brandCheck(this, _CacheStorage);
          webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
          cacheName = webidl.converters.DOMString(cacheName);
          return this.#caches.delete(cacheName);
        }
        /**
         * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
         * @returns {string[]}
         */
        async keys() {
          webidl.brandCheck(this, _CacheStorage);
          const keys = this.#caches.keys();
          return [...keys];
        }
      };
      Object.defineProperties(CacheStorage.prototype, {
        [Symbol.toStringTag]: {
          value: "CacheStorage",
          configurable: true
        },
        match: kEnumerableProperty,
        has: kEnumerableProperty,
        open: kEnumerableProperty,
        delete: kEnumerableProperty,
        keys: kEnumerableProperty
      });
      module.exports = {
        CacheStorage
      };
    }
  });

  // node_modules/undici/lib/cookies/constants.js
  var require_constants4 = __commonJS({
    "node_modules/undici/lib/cookies/constants.js"(exports, module) {
      "use strict";
      var maxAttributeValueSize = 1024;
      var maxNameValuePairSize = 4096;
      module.exports = {
        maxAttributeValueSize,
        maxNameValuePairSize
      };
    }
  });

  // node_modules/undici/lib/cookies/util.js
  var require_util6 = __commonJS({
    "node_modules/undici/lib/cookies/util.js"(exports, module) {
      "use strict";
      var assert = __require("assert");
      var { kHeadersList } = require_symbols();
      function isCTLExcludingHtab(value) {
        if (value.length === 0) {
          return false;
        }
        for (const char of value) {
          const code = char.charCodeAt(0);
          if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
            return false;
          }
        }
      }
      function validateCookieName(name) {
        for (const char of name) {
          const code = char.charCodeAt(0);
          if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
            throw new Error("Invalid cookie name");
          }
        }
      }
      function validateCookieValue(value) {
        for (const char of value) {
          const code = char.charCodeAt(0);
          if (code < 33 || // exclude CTLs (0-31)
          code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
            throw new Error("Invalid header value");
          }
        }
      }
      function validateCookiePath(path) {
        for (const char of path) {
          const code = char.charCodeAt(0);
          if (code < 33 || char === ";") {
            throw new Error("Invalid cookie path");
          }
        }
      }
      function validateCookieDomain(domain) {
        if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
          throw new Error("Invalid cookie domain");
        }
      }
      function toIMFDate(date) {
        if (typeof date === "number") {
          date = new Date(date);
        }
        const days = [
          "Sun",
          "Mon",
          "Tue",
          "Wed",
          "Thu",
          "Fri",
          "Sat"
        ];
        const months = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ];
        const dayName = days[date.getUTCDay()];
        const day = date.getUTCDate().toString().padStart(2, "0");
        const month = months[date.getUTCMonth()];
        const year = date.getUTCFullYear();
        const hour = date.getUTCHours().toString().padStart(2, "0");
        const minute = date.getUTCMinutes().toString().padStart(2, "0");
        const second = date.getUTCSeconds().toString().padStart(2, "0");
        return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
      }
      function validateCookieMaxAge(maxAge) {
        if (maxAge < 0) {
          throw new Error("Invalid cookie max-age");
        }
      }
      function stringify(cookie) {
        if (cookie.name.length === 0) {
          return null;
        }
        validateCookieName(cookie.name);
        validateCookieValue(cookie.value);
        const out = [`${cookie.name}=${cookie.value}`];
        if (cookie.name.startsWith("__Secure-")) {
          cookie.secure = true;
        }
        if (cookie.name.startsWith("__Host-")) {
          cookie.secure = true;
          cookie.domain = null;
          cookie.path = "/";
        }
        if (cookie.secure) {
          out.push("Secure");
        }
        if (cookie.httpOnly) {
          out.push("HttpOnly");
        }
        if (typeof cookie.maxAge === "number") {
          validateCookieMaxAge(cookie.maxAge);
          out.push(`Max-Age=${cookie.maxAge}`);
        }
        if (cookie.domain) {
          validateCookieDomain(cookie.domain);
          out.push(`Domain=${cookie.domain}`);
        }
        if (cookie.path) {
          validateCookiePath(cookie.path);
          out.push(`Path=${cookie.path}`);
        }
        if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
          out.push(`Expires=${toIMFDate(cookie.expires)}`);
        }
        if (cookie.sameSite) {
          out.push(`SameSite=${cookie.sameSite}`);
        }
        for (const part of cookie.unparsed) {
          if (!part.includes("=")) {
            throw new Error("Invalid unparsed");
          }
          const [key, ...value] = part.split("=");
          out.push(`${key.trim()}=${value.join("=")}`);
        }
        return out.join("; ");
      }
      var kHeadersListNode;
      function getHeadersList(headers) {
        if (headers[kHeadersList]) {
          return headers[kHeadersList];
        }
        if (!kHeadersListNode) {
          kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
            (symbol) => symbol.description === "headers list"
          );
          assert(kHeadersListNode, "Headers cannot be parsed");
        }
        const headersList = headers[kHeadersListNode];
        assert(headersList);
        return headersList;
      }
      module.exports = {
        isCTLExcludingHtab,
        stringify,
        getHeadersList
      };
    }
  });

  // node_modules/undici/lib/cookies/parse.js
  var require_parse = __commonJS({
    "node_modules/undici/lib/cookies/parse.js"(exports, module) {
      "use strict";
      var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
      var { isCTLExcludingHtab } = require_util6();
      var { collectASequenceOfCodePointsFast } = require_dataURL();
      var assert = __require("assert");
      function parseSetCookie(header) {
        if (isCTLExcludingHtab(header)) {
          return null;
        }
        let nameValuePair = "";
        let unparsedAttributes = "";
        let name = "";
        let value = "";
        if (header.includes(";")) {
          const position = { position: 0 };
          nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
          unparsedAttributes = header.slice(position.position);
        } else {
          nameValuePair = header;
        }
        if (!nameValuePair.includes("=")) {
          value = nameValuePair;
        } else {
          const position = { position: 0 };
          name = collectASequenceOfCodePointsFast(
            "=",
            nameValuePair,
            position
          );
          value = nameValuePair.slice(position.position + 1);
        }
        name = name.trim();
        value = value.trim();
        if (name.length + value.length > maxNameValuePairSize) {
          return null;
        }
        return {
          name,
          value,
          ...parseUnparsedAttributes(unparsedAttributes)
        };
      }
      function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
        if (unparsedAttributes.length === 0) {
          return cookieAttributeList;
        }
        assert(unparsedAttributes[0] === ";");
        unparsedAttributes = unparsedAttributes.slice(1);
        let cookieAv = "";
        if (unparsedAttributes.includes(";")) {
          cookieAv = collectASequenceOfCodePointsFast(
            ";",
            unparsedAttributes,
            { position: 0 }
          );
          unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
        } else {
          cookieAv = unparsedAttributes;
          unparsedAttributes = "";
        }
        let attributeName = "";
        let attributeValue = "";
        if (cookieAv.includes("=")) {
          const position = { position: 0 };
          attributeName = collectASequenceOfCodePointsFast(
            "=",
            cookieAv,
            position
          );
          attributeValue = cookieAv.slice(position.position + 1);
        } else {
          attributeName = cookieAv;
        }
        attributeName = attributeName.trim();
        attributeValue = attributeValue.trim();
        if (attributeValue.length > maxAttributeValueSize) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const attributeNameLowercase = attributeName.toLowerCase();
        if (attributeNameLowercase === "expires") {
          const expiryTime = new Date(attributeValue);
          cookieAttributeList.expires = expiryTime;
        } else if (attributeNameLowercase === "max-age") {
          const charCode = attributeValue.charCodeAt(0);
          if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
          }
          if (!/^\d+$/.test(attributeValue)) {
            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
          }
          const deltaSeconds = Number(attributeValue);
          cookieAttributeList.maxAge = deltaSeconds;
        } else if (attributeNameLowercase === "domain") {
          let cookieDomain = attributeValue;
          if (cookieDomain[0] === ".") {
            cookieDomain = cookieDomain.slice(1);
          }
          cookieDomain = cookieDomain.toLowerCase();
          cookieAttributeList.domain = cookieDomain;
        } else if (attributeNameLowercase === "path") {
          let cookiePath = "";
          if (attributeValue.length === 0 || attributeValue[0] !== "/") {
            cookiePath = "/";
          } else {
            cookiePath = attributeValue;
          }
          cookieAttributeList.path = cookiePath;
        } else if (attributeNameLowercase === "secure") {
          cookieAttributeList.secure = true;
        } else if (attributeNameLowercase === "httponly") {
          cookieAttributeList.httpOnly = true;
        } else if (attributeNameLowercase === "samesite") {
          let enforcement = "Default";
          const attributeValueLowercase = attributeValue.toLowerCase();
          if (attributeValueLowercase.includes("none")) {
            enforcement = "None";
          }
          if (attributeValueLowercase.includes("strict")) {
            enforcement = "Strict";
          }
          if (attributeValueLowercase.includes("lax")) {
            enforcement = "Lax";
          }
          cookieAttributeList.sameSite = enforcement;
        } else {
          cookieAttributeList.unparsed ??= [];
          cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
        }
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      module.exports = {
        parseSetCookie,
        parseUnparsedAttributes
      };
    }
  });

  // node_modules/undici/lib/cookies/index.js
  var require_cookies = __commonJS({
    "node_modules/undici/lib/cookies/index.js"(exports, module) {
      "use strict";
      var { parseSetCookie } = require_parse();
      var { stringify, getHeadersList } = require_util6();
      var { webidl } = require_webidl();
      var { Headers } = require_headers();
      function getCookies(headers) {
        webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
        webidl.brandCheck(headers, Headers, { strict: false });
        const cookie = headers.get("cookie");
        const out = {};
        if (!cookie) {
          return out;
        }
        for (const piece of cookie.split(";")) {
          const [name, ...value] = piece.split("=");
          out[name.trim()] = value.join("=");
        }
        return out;
      }
      function deleteCookie(headers, name, attributes) {
        webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
        webidl.brandCheck(headers, Headers, { strict: false });
        name = webidl.converters.DOMString(name);
        attributes = webidl.converters.DeleteCookieAttributes(attributes);
        setCookie(headers, {
          name,
          value: "",
          expires: /* @__PURE__ */ new Date(0),
          ...attributes
        });
      }
      function getSetCookies(headers) {
        webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
        webidl.brandCheck(headers, Headers, { strict: false });
        const cookies = getHeadersList(headers).cookies;
        if (!cookies) {
          return [];
        }
        return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
      }
      function setCookie(headers, cookie) {
        webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
        webidl.brandCheck(headers, Headers, { strict: false });
        cookie = webidl.converters.Cookie(cookie);
        const str = stringify(cookie);
        if (str) {
          headers.append("Set-Cookie", stringify(cookie));
        }
      }
      webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
        {
          converter: webidl.nullableConverter(webidl.converters.DOMString),
          key: "path",
          defaultValue: null
        },
        {
          converter: webidl.nullableConverter(webidl.converters.DOMString),
          key: "domain",
          defaultValue: null
        }
      ]);
      webidl.converters.Cookie = webidl.dictionaryConverter([
        {
          converter: webidl.converters.DOMString,
          key: "name"
        },
        {
          converter: webidl.converters.DOMString,
          key: "value"
        },
        {
          converter: webidl.nullableConverter((value) => {
            if (typeof value === "number") {
              return webidl.converters["unsigned long long"](value);
            }
            return new Date(value);
          }),
          key: "expires",
          defaultValue: null
        },
        {
          converter: webidl.nullableConverter(webidl.converters["long long"]),
          key: "maxAge",
          defaultValue: null
        },
        {
          converter: webidl.nullableConverter(webidl.converters.DOMString),
          key: "domain",
          defaultValue: null
        },
        {
          converter: webidl.nullableConverter(webidl.converters.DOMString),
          key: "path",
          defaultValue: null
        },
        {
          converter: webidl.nullableConverter(webidl.converters.boolean),
          key: "secure",
          defaultValue: null
        },
        {
          converter: webidl.nullableConverter(webidl.converters.boolean),
          key: "httpOnly",
          defaultValue: null
        },
        {
          converter: webidl.converters.USVString,
          key: "sameSite",
          allowedValues: ["Strict", "Lax", "None"]
        },
        {
          converter: webidl.sequenceConverter(webidl.converters.DOMString),
          key: "unparsed",
          defaultValue: []
        }
      ]);
      module.exports = {
        getCookies,
        deleteCookie,
        getSetCookies,
        setCookie
      };
    }
  });

  // node_modules/undici/lib/websocket/constants.js
  var require_constants5 = __commonJS({
    "node_modules/undici/lib/websocket/constants.js"(exports, module) {
      "use strict";
      var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
      var staticPropertyDescriptors = {
        enumerable: true,
        writable: false,
        configurable: false
      };
      var states = {
        CONNECTING: 0,
        OPEN: 1,
        CLOSING: 2,
        CLOSED: 3
      };
      var opcodes = {
        CONTINUATION: 0,
        TEXT: 1,
        BINARY: 2,
        CLOSE: 8,
        PING: 9,
        PONG: 10
      };
      var maxUnsigned16Bit = 2 ** 16 - 1;
      var parserStates = {
        INFO: 0,
        PAYLOADLENGTH_16: 2,
        PAYLOADLENGTH_64: 3,
        READ_DATA: 4
      };
      var emptyBuffer = Buffer.allocUnsafe(0);
      module.exports = {
        uid,
        staticPropertyDescriptors,
        states,
        opcodes,
        maxUnsigned16Bit,
        parserStates,
        emptyBuffer
      };
    }
  });

  // node_modules/undici/lib/websocket/symbols.js
  var require_symbols5 = __commonJS({
    "node_modules/undici/lib/websocket/symbols.js"(exports, module) {
      "use strict";
      module.exports = {
        kWebSocketURL: Symbol("url"),
        kReadyState: Symbol("ready state"),
        kController: Symbol("controller"),
        kResponse: Symbol("response"),
        kBinaryType: Symbol("binary type"),
        kSentClose: Symbol("sent close"),
        kReceivedClose: Symbol("received close"),
        kByteParser: Symbol("byte parser")
      };
    }
  });

  // node_modules/undici/lib/websocket/events.js
  var require_events = __commonJS({
    "node_modules/undici/lib/websocket/events.js"(exports, module) {
      "use strict";
      var { webidl } = require_webidl();
      var { kEnumerableProperty } = require_util();
      var { MessagePort } = __require("worker_threads");
      var MessageEvent = class _MessageEvent extends Event {
        #eventInit;
        constructor(type, eventInitDict = {}) {
          webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
          type = webidl.converters.DOMString(type);
          eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
          super(type, eventInitDict);
          this.#eventInit = eventInitDict;
        }
        get data() {
          webidl.brandCheck(this, _MessageEvent);
          return this.#eventInit.data;
        }
        get origin() {
          webidl.brandCheck(this, _MessageEvent);
          return this.#eventInit.origin;
        }
        get lastEventId() {
          webidl.brandCheck(this, _MessageEvent);
          return this.#eventInit.lastEventId;
        }
        get source() {
          webidl.brandCheck(this, _MessageEvent);
          return this.#eventInit.source;
        }
        get ports() {
          webidl.brandCheck(this, _MessageEvent);
          if (!Object.isFrozen(this.#eventInit.ports)) {
            Object.freeze(this.#eventInit.ports);
          }
          return this.#eventInit.ports;
        }
        initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
          webidl.brandCheck(this, _MessageEvent);
          webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
          return new _MessageEvent(type, {
            bubbles,
            cancelable,
            data,
            origin,
            lastEventId,
            source,
            ports
          });
        }
      };
      var CloseEvent = class _CloseEvent extends Event {
        #eventInit;
        constructor(type, eventInitDict = {}) {
          webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
          type = webidl.converters.DOMString(type);
          eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
          super(type, eventInitDict);
          this.#eventInit = eventInitDict;
        }
        get wasClean() {
          webidl.brandCheck(this, _CloseEvent);
          return this.#eventInit.wasClean;
        }
        get code() {
          webidl.brandCheck(this, _CloseEvent);
          return this.#eventInit.code;
        }
        get reason() {
          webidl.brandCheck(this, _CloseEvent);
          return this.#eventInit.reason;
        }
      };
      var ErrorEvent = class _ErrorEvent extends Event {
        #eventInit;
        constructor(type, eventInitDict) {
          webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
          super(type, eventInitDict);
          type = webidl.converters.DOMString(type);
          eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
          this.#eventInit = eventInitDict;
        }
        get message() {
          webidl.brandCheck(this, _ErrorEvent);
          return this.#eventInit.message;
        }
        get filename() {
          webidl.brandCheck(this, _ErrorEvent);
          return this.#eventInit.filename;
        }
        get lineno() {
          webidl.brandCheck(this, _ErrorEvent);
          return this.#eventInit.lineno;
        }
        get colno() {
          webidl.brandCheck(this, _ErrorEvent);
          return this.#eventInit.colno;
        }
        get error() {
          webidl.brandCheck(this, _ErrorEvent);
          return this.#eventInit.error;
        }
      };
      Object.defineProperties(MessageEvent.prototype, {
        [Symbol.toStringTag]: {
          value: "MessageEvent",
          configurable: true
        },
        data: kEnumerableProperty,
        origin: kEnumerableProperty,
        lastEventId: kEnumerableProperty,
        source: kEnumerableProperty,
        ports: kEnumerableProperty,
        initMessageEvent: kEnumerableProperty
      });
      Object.defineProperties(CloseEvent.prototype, {
        [Symbol.toStringTag]: {
          value: "CloseEvent",
          configurable: true
        },
        reason: kEnumerableProperty,
        code: kEnumerableProperty,
        wasClean: kEnumerableProperty
      });
      Object.defineProperties(ErrorEvent.prototype, {
        [Symbol.toStringTag]: {
          value: "ErrorEvent",
          configurable: true
        },
        message: kEnumerableProperty,
        filename: kEnumerableProperty,
        lineno: kEnumerableProperty,
        colno: kEnumerableProperty,
        error: kEnumerableProperty
      });
      webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
      webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
        webidl.converters.MessagePort
      );
      var eventInit = [
        {
          key: "bubbles",
          converter: webidl.converters.boolean,
          defaultValue: false
        },
        {
          key: "cancelable",
          converter: webidl.converters.boolean,
          defaultValue: false
        },
        {
          key: "composed",
          converter: webidl.converters.boolean,
          defaultValue: false
        }
      ];
      webidl.converters.MessageEventInit = webidl.dictionaryConverter([
        ...eventInit,
        {
          key: "data",
          converter: webidl.converters.any,
          defaultValue: null
        },
        {
          key: "origin",
          converter: webidl.converters.USVString,
          defaultValue: ""
        },
        {
          key: "lastEventId",
          converter: webidl.converters.DOMString,
          defaultValue: ""
        },
        {
          key: "source",
          // Node doesn't implement WindowProxy or ServiceWorker, so the only
          // valid value for source is a MessagePort.
          converter: webidl.nullableConverter(webidl.converters.MessagePort),
          defaultValue: null
        },
        {
          key: "ports",
          converter: webidl.converters["sequence<MessagePort>"],
          get defaultValue() {
            return [];
          }
        }
      ]);
      webidl.converters.CloseEventInit = webidl.dictionaryConverter([
        ...eventInit,
        {
          key: "wasClean",
          converter: webidl.converters.boolean,
          defaultValue: false
        },
        {
          key: "code",
          converter: webidl.converters["unsigned short"],
          defaultValue: 0
        },
        {
          key: "reason",
          converter: webidl.converters.USVString,
          defaultValue: ""
        }
      ]);
      webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
        ...eventInit,
        {
          key: "message",
          converter: webidl.converters.DOMString,
          defaultValue: ""
        },
        {
          key: "filename",
          converter: webidl.converters.USVString,
          defaultValue: ""
        },
        {
          key: "lineno",
          converter: webidl.converters["unsigned long"],
          defaultValue: 0
        },
        {
          key: "colno",
          converter: webidl.converters["unsigned long"],
          defaultValue: 0
        },
        {
          key: "error",
          converter: webidl.converters.any
        }
      ]);
      module.exports = {
        MessageEvent,
        CloseEvent,
        ErrorEvent
      };
    }
  });

  // node_modules/undici/lib/websocket/util.js
  var require_util7 = __commonJS({
    "node_modules/undici/lib/websocket/util.js"(exports, module) {
      "use strict";
      var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
      var { states, opcodes } = require_constants5();
      var { MessageEvent, ErrorEvent } = require_events();
      function isEstablished(ws) {
        return ws[kReadyState] === states.OPEN;
      }
      function isClosing(ws) {
        return ws[kReadyState] === states.CLOSING;
      }
      function isClosed(ws) {
        return ws[kReadyState] === states.CLOSED;
      }
      function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
        const event = new eventConstructor(e, eventInitDict);
        target.dispatchEvent(event);
      }
      function websocketMessageReceived(ws, type, data) {
        if (ws[kReadyState] !== states.OPEN) {
          return;
        }
        let dataForEvent;
        if (type === opcodes.TEXT) {
          try {
            dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
          } catch {
            failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
            return;
          }
        } else if (type === opcodes.BINARY) {
          if (ws[kBinaryType] === "blob") {
            dataForEvent = new Blob([data]);
          } else {
            dataForEvent = new Uint8Array(data).buffer;
          }
        }
        fireEvent("message", ws, MessageEvent, {
          origin: ws[kWebSocketURL].origin,
          data: dataForEvent
        });
      }
      function isValidSubprotocol(protocol) {
        if (protocol.length === 0) {
          return false;
        }
        for (const char of protocol) {
          const code = char.charCodeAt(0);
          if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
          code === 9) {
            return false;
          }
        }
        return true;
      }
      function isValidStatusCode(code) {
        if (code >= 1e3 && code < 1015) {
          return code !== 1004 && // reserved
          code !== 1005 && // "MUST NOT be set as a status code"
          code !== 1006;
        }
        return code >= 3e3 && code <= 4999;
      }
      function failWebsocketConnection(ws, reason) {
        const { [kController]: controller, [kResponse]: response } = ws;
        controller.abort();
        if (response?.socket && !response.socket.destroyed) {
          response.socket.destroy();
        }
        if (reason) {
          fireEvent("error", ws, ErrorEvent, {
            error: new Error(reason)
          });
        }
      }
      module.exports = {
        isEstablished,
        isClosing,
        isClosed,
        fireEvent,
        isValidSubprotocol,
        isValidStatusCode,
        failWebsocketConnection,
        websocketMessageReceived
      };
    }
  });

  // node_modules/undici/lib/websocket/connection.js
  var require_connection = __commonJS({
    "node_modules/undici/lib/websocket/connection.js"(exports, module) {
      "use strict";
      var diagnosticsChannel = __require("diagnostics_channel");
      var { uid, states } = require_constants5();
      var {
        kReadyState,
        kSentClose,
        kByteParser,
        kReceivedClose
      } = require_symbols5();
      var { fireEvent, failWebsocketConnection } = require_util7();
      var { CloseEvent } = require_events();
      var { makeRequest } = require_request2();
      var { fetching } = require_fetch();
      var { Headers } = require_headers();
      var { getGlobalDispatcher } = require_global2();
      var { kHeadersList } = require_symbols();
      var channels = {};
      channels.open = diagnosticsChannel.channel("undici:websocket:open");
      channels.close = diagnosticsChannel.channel("undici:websocket:close");
      channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
      var crypto;
      try {
        crypto = __require("crypto");
      } catch {
      }
      function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
        const requestURL = url;
        requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
        const request2 = makeRequest({
          urlList: [requestURL],
          serviceWorkers: "none",
          referrer: "no-referrer",
          mode: "websocket",
          credentials: "include",
          cache: "no-store",
          redirect: "error"
        });
        if (options.headers) {
          const headersList = new Headers(options.headers)[kHeadersList];
          request2.headersList = headersList;
        }
        const keyValue = crypto.randomBytes(16).toString("base64");
        request2.headersList.append("sec-websocket-key", keyValue);
        request2.headersList.append("sec-websocket-version", "13");
        for (const protocol of protocols) {
          request2.headersList.append("sec-websocket-protocol", protocol);
        }
        const permessageDeflate = "";
        const controller = fetching({
          request: request2,
          useParallelQueue: true,
          dispatcher: options.dispatcher ?? getGlobalDispatcher(),
          processResponse(response) {
            if (response.type === "error" || response.status !== 101) {
              failWebsocketConnection(ws, "Received network error or non-101 status code.");
              return;
            }
            if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
              failWebsocketConnection(ws, "Server did not respond with sent protocols.");
              return;
            }
            if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
              failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
              return;
            }
            if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
              failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
              return;
            }
            const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
            const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
            if (secWSAccept !== digest) {
              failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
              return;
            }
            const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
            if (secExtension !== null && secExtension !== permessageDeflate) {
              failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
              return;
            }
            const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
            if (secProtocol !== null && secProtocol !== request2.headersList.get("Sec-WebSocket-Protocol")) {
              failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
              return;
            }
            response.socket.on("data", onSocketData);
            response.socket.on("close", onSocketClose);
            response.socket.on("error", onSocketError);
            if (channels.open.hasSubscribers) {
              channels.open.publish({
                address: response.socket.address(),
                protocol: secProtocol,
                extensions: secExtension
              });
            }
            onEstablish(response);
          }
        });
        return controller;
      }
      function onSocketData(chunk) {
        if (!this.ws[kByteParser].write(chunk)) {
          this.pause();
        }
      }
      function onSocketClose() {
        const { ws } = this;
        const wasClean = ws[kSentClose] && ws[kReceivedClose];
        let code = 1005;
        let reason = "";
        const result = ws[kByteParser].closingInfo;
        if (result) {
          code = result.code ?? 1005;
          reason = result.reason;
        } else if (!ws[kSentClose]) {
          code = 1006;
        }
        ws[kReadyState] = states.CLOSED;
        fireEvent("close", ws, CloseEvent, {
          wasClean,
          code,
          reason
        });
        if (channels.close.hasSubscribers) {
          channels.close.publish({
            websocket: ws,
            code,
            reason
          });
        }
      }
      function onSocketError(error) {
        const { ws } = this;
        ws[kReadyState] = states.CLOSING;
        if (channels.socketError.hasSubscribers) {
          channels.socketError.publish(error);
        }
        this.destroy();
      }
      module.exports = {
        establishWebSocketConnection
      };
    }
  });

  // node_modules/undici/lib/websocket/frame.js
  var require_frame = __commonJS({
    "node_modules/undici/lib/websocket/frame.js"(exports, module) {
      "use strict";
      var { maxUnsigned16Bit } = require_constants5();
      var crypto;
      try {
        crypto = __require("crypto");
      } catch {
      }
      var WebsocketFrameSend = class {
        /**
         * @param {Buffer|undefined} data
         */
        constructor(data) {
          this.frameData = data;
          this.maskKey = crypto.randomBytes(4);
        }
        createFrame(opcode) {
          const bodyLength = this.frameData?.byteLength ?? 0;
          let payloadLength = bodyLength;
          let offset = 6;
          if (bodyLength > maxUnsigned16Bit) {
            offset += 8;
            payloadLength = 127;
          } else if (bodyLength > 125) {
            offset += 2;
            payloadLength = 126;
          }
          const buffer = Buffer.allocUnsafe(bodyLength + offset);
          buffer[0] = buffer[1] = 0;
          buffer[0] |= 128;
          buffer[0] = (buffer[0] & 240) + opcode;
          buffer[offset - 4] = this.maskKey[0];
          buffer[offset - 3] = this.maskKey[1];
          buffer[offset - 2] = this.maskKey[2];
          buffer[offset - 1] = this.maskKey[3];
          buffer[1] = payloadLength;
          if (payloadLength === 126) {
            buffer.writeUInt16BE(bodyLength, 2);
          } else if (payloadLength === 127) {
            buffer[2] = buffer[3] = 0;
            buffer.writeUIntBE(bodyLength, 4, 6);
          }
          buffer[1] |= 128;
          for (let i = 0; i < bodyLength; i++) {
            buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
          }
          return buffer;
        }
      };
      module.exports = {
        WebsocketFrameSend
      };
    }
  });

  // node_modules/undici/lib/websocket/receiver.js
  var require_receiver = __commonJS({
    "node_modules/undici/lib/websocket/receiver.js"(exports, module) {
      "use strict";
      var { Writable } = __require("stream");
      var diagnosticsChannel = __require("diagnostics_channel");
      var { parserStates, opcodes, states, emptyBuffer } = require_constants5();
      var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
      var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
      var { WebsocketFrameSend } = require_frame();
      var channels = {};
      channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
      channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
      var ByteParser = class extends Writable {
        #buffers = [];
        #byteOffset = 0;
        #state = parserStates.INFO;
        #info = {};
        #fragments = [];
        constructor(ws) {
          super();
          this.ws = ws;
        }
        /**
         * @param {Buffer} chunk
         * @param {() => void} callback
         */
        _write(chunk, _, callback) {
          this.#buffers.push(chunk);
          this.#byteOffset += chunk.length;
          this.run(callback);
        }
        /**
         * Runs whenever a new chunk is received.
         * Callback is called whenever there are no more chunks buffering,
         * or not enough bytes are buffered to parse.
         */
        run(callback) {
          while (true) {
            if (this.#state === parserStates.INFO) {
              if (this.#byteOffset < 2) {
                return callback();
              }
              const buffer = this.consume(2);
              this.#info.fin = (buffer[0] & 128) !== 0;
              this.#info.opcode = buffer[0] & 15;
              this.#info.originalOpcode ??= this.#info.opcode;
              this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
              if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
                failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
                return;
              }
              const payloadLength = buffer[1] & 127;
              if (payloadLength <= 125) {
                this.#info.payloadLength = payloadLength;
                this.#state = parserStates.READ_DATA;
              } else if (payloadLength === 126) {
                this.#state = parserStates.PAYLOADLENGTH_16;
              } else if (payloadLength === 127) {
                this.#state = parserStates.PAYLOADLENGTH_64;
              }
              if (this.#info.fragmented && payloadLength > 125) {
                failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
                return;
              } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
                failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
                return;
              } else if (this.#info.opcode === opcodes.CLOSE) {
                if (payloadLength === 1) {
                  failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                  return;
                }
                const body = this.consume(payloadLength);
                this.#info.closeInfo = this.parseCloseBody(false, body);
                if (!this.ws[kSentClose]) {
                  const body2 = Buffer.allocUnsafe(2);
                  body2.writeUInt16BE(this.#info.closeInfo.code, 0);
                  const closeFrame = new WebsocketFrameSend(body2);
                  this.ws[kResponse].socket.write(
                    closeFrame.createFrame(opcodes.CLOSE),
                    (err) => {
                      if (!err) {
                        this.ws[kSentClose] = true;
                      }
                    }
                  );
                }
                this.ws[kReadyState] = states.CLOSING;
                this.ws[kReceivedClose] = true;
                this.end();
                return;
              } else if (this.#info.opcode === opcodes.PING) {
                const body = this.consume(payloadLength);
                if (!this.ws[kReceivedClose]) {
                  const frame = new WebsocketFrameSend(body);
                  this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                  if (channels.ping.hasSubscribers) {
                    channels.ping.publish({
                      payload: body
                    });
                  }
                }
                this.#state = parserStates.INFO;
                if (this.#byteOffset > 0) {
                  continue;
                } else {
                  callback();
                  return;
                }
              } else if (this.#info.opcode === opcodes.PONG) {
                const body = this.consume(payloadLength);
                if (channels.pong.hasSubscribers) {
                  channels.pong.publish({
                    payload: body
                  });
                }
                if (this.#byteOffset > 0) {
                  continue;
                } else {
                  callback();
                  return;
                }
              }
            } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
              if (this.#byteOffset < 2) {
                return callback();
              }
              const buffer = this.consume(2);
              this.#info.payloadLength = buffer.readUInt16BE(0);
              this.#state = parserStates.READ_DATA;
            } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
              if (this.#byteOffset < 8) {
                return callback();
              }
              const buffer = this.consume(8);
              const upper = buffer.readUInt32BE(0);
              if (upper > 2 ** 31 - 1) {
                failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
                return;
              }
              const lower = buffer.readUInt32BE(4);
              this.#info.payloadLength = (upper << 8) + lower;
              this.#state = parserStates.READ_DATA;
            } else if (this.#state === parserStates.READ_DATA) {
              if (this.#byteOffset < this.#info.payloadLength) {
                return callback();
              } else if (this.#byteOffset >= this.#info.payloadLength) {
                const body = this.consume(this.#info.payloadLength);
                this.#fragments.push(body);
                if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
                  const fullMessage = Buffer.concat(this.#fragments);
                  websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
                  this.#info = {};
                  this.#fragments.length = 0;
                }
                this.#state = parserStates.INFO;
              }
            }
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              break;
            }
          }
        }
        /**
         * Take n bytes from the buffered Buffers
         * @param {number} n
         * @returns {Buffer|null}
         */
        consume(n) {
          if (n > this.#byteOffset) {
            return null;
          } else if (n === 0) {
            return emptyBuffer;
          }
          if (this.#buffers[0].length === n) {
            this.#byteOffset -= this.#buffers[0].length;
            return this.#buffers.shift();
          }
          const buffer = Buffer.allocUnsafe(n);
          let offset = 0;
          while (offset !== n) {
            const next = this.#buffers[0];
            const { length } = next;
            if (length + offset === n) {
              buffer.set(this.#buffers.shift(), offset);
              break;
            } else if (length + offset > n) {
              buffer.set(next.subarray(0, n - offset), offset);
              this.#buffers[0] = next.subarray(n - offset);
              break;
            } else {
              buffer.set(this.#buffers.shift(), offset);
              offset += next.length;
            }
          }
          this.#byteOffset -= n;
          return buffer;
        }
        parseCloseBody(onlyCode, data) {
          let code;
          if (data.length >= 2) {
            code = data.readUInt16BE(0);
          }
          if (onlyCode) {
            if (!isValidStatusCode(code)) {
              return null;
            }
            return { code };
          }
          let reason = data.subarray(2);
          if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
            reason = reason.subarray(3);
          }
          if (code !== void 0 && !isValidStatusCode(code)) {
            return null;
          }
          try {
            reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
          } catch {
            return null;
          }
          return { code, reason };
        }
        get closingInfo() {
          return this.#info.closeInfo;
        }
      };
      module.exports = {
        ByteParser
      };
    }
  });

  // node_modules/undici/lib/websocket/websocket.js
  var require_websocket = __commonJS({
    "node_modules/undici/lib/websocket/websocket.js"(exports, module) {
      "use strict";
      var { webidl } = require_webidl();
      var { DOMException: DOMException2 } = require_constants2();
      var { URLSerializer } = require_dataURL();
      var { getGlobalOrigin } = require_global();
      var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants5();
      var {
        kWebSocketURL,
        kReadyState,
        kController,
        kBinaryType,
        kResponse,
        kSentClose,
        kByteParser
      } = require_symbols5();
      var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
      var { establishWebSocketConnection } = require_connection();
      var { WebsocketFrameSend } = require_frame();
      var { ByteParser } = require_receiver();
      var { kEnumerableProperty, isBlobLike } = require_util();
      var { getGlobalDispatcher } = require_global2();
      var { types } = __require("util");
      var experimentalWarned = false;
      var WebSocket = class _WebSocket extends EventTarget {
        #events = {
          open: null,
          error: null,
          close: null,
          message: null
        };
        #bufferedAmount = 0;
        #protocol = "";
        #extensions = "";
        /**
         * @param {string} url
         * @param {string|string[]} protocols
         */
        constructor(url, protocols = []) {
          super();
          webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
          if (!experimentalWarned) {
            experimentalWarned = true;
            process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
              code: "UNDICI-WS"
            });
          }
          const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
          url = webidl.converters.USVString(url);
          protocols = options.protocols;
          const baseURL = getGlobalOrigin();
          let urlRecord;
          try {
            urlRecord = new URL(url, baseURL);
          } catch (e) {
            throw new DOMException2(e, "SyntaxError");
          }
          if (urlRecord.protocol === "http:") {
            urlRecord.protocol = "ws:";
          } else if (urlRecord.protocol === "https:") {
            urlRecord.protocol = "wss:";
          }
          if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
            throw new DOMException2(
              `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
              "SyntaxError"
            );
          }
          if (urlRecord.hash || urlRecord.href.endsWith("#")) {
            throw new DOMException2("Got fragment", "SyntaxError");
          }
          if (typeof protocols === "string") {
            protocols = [protocols];
          }
          if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
            throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          }
          if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
            throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          }
          this[kWebSocketURL] = new URL(urlRecord.href);
          this[kController] = establishWebSocketConnection(
            urlRecord,
            protocols,
            this,
            (response) => this.#onConnectionEstablished(response),
            options
          );
          this[kReadyState] = _WebSocket.CONNECTING;
          this[kBinaryType] = "blob";
        }
        /**
         * @see https://websockets.spec.whatwg.org/#dom-websocket-close
         * @param {number|undefined} code
         * @param {string|undefined} reason
         */
        close(code = void 0, reason = void 0) {
          webidl.brandCheck(this, _WebSocket);
          if (code !== void 0) {
            code = webidl.converters["unsigned short"](code, { clamp: true });
          }
          if (reason !== void 0) {
            reason = webidl.converters.USVString(reason);
          }
          if (code !== void 0) {
            if (code !== 1e3 && (code < 3e3 || code > 4999)) {
              throw new DOMException2("invalid code", "InvalidAccessError");
            }
          }
          let reasonByteLength = 0;
          if (reason !== void 0) {
            reasonByteLength = Buffer.byteLength(reason);
            if (reasonByteLength > 123) {
              throw new DOMException2(
                `Reason must be less than 123 bytes; received ${reasonByteLength}`,
                "SyntaxError"
              );
            }
          }
          if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) {
          } else if (!isEstablished(this)) {
            failWebsocketConnection(this, "Connection was closed before it was established.");
            this[kReadyState] = _WebSocket.CLOSING;
          } else if (!isClosing(this)) {
            const frame = new WebsocketFrameSend();
            if (code !== void 0 && reason === void 0) {
              frame.frameData = Buffer.allocUnsafe(2);
              frame.frameData.writeUInt16BE(code, 0);
            } else if (code !== void 0 && reason !== void 0) {
              frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
              frame.frameData.writeUInt16BE(code, 0);
              frame.frameData.write(reason, 2, "utf-8");
            } else {
              frame.frameData = emptyBuffer;
            }
            const socket = this[kResponse].socket;
            socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
              if (!err) {
                this[kSentClose] = true;
              }
            });
            this[kReadyState] = states.CLOSING;
          } else {
            this[kReadyState] = _WebSocket.CLOSING;
          }
        }
        /**
         * @see https://websockets.spec.whatwg.org/#dom-websocket-send
         * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
         */
        send(data) {
          webidl.brandCheck(this, _WebSocket);
          webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
          data = webidl.converters.WebSocketSendData(data);
          if (this[kReadyState] === _WebSocket.CONNECTING) {
            throw new DOMException2("Sent before connected.", "InvalidStateError");
          }
          if (!isEstablished(this) || isClosing(this)) {
            return;
          }
          const socket = this[kResponse].socket;
          if (typeof data === "string") {
            const value = Buffer.from(data);
            const frame = new WebsocketFrameSend(value);
            const buffer = frame.createFrame(opcodes.TEXT);
            this.#bufferedAmount += value.byteLength;
            socket.write(buffer, () => {
              this.#bufferedAmount -= value.byteLength;
            });
          } else if (types.isArrayBuffer(data)) {
            const value = Buffer.from(data);
            const frame = new WebsocketFrameSend(value);
            const buffer = frame.createFrame(opcodes.BINARY);
            this.#bufferedAmount += value.byteLength;
            socket.write(buffer, () => {
              this.#bufferedAmount -= value.byteLength;
            });
          } else if (ArrayBuffer.isView(data)) {
            const ab = Buffer.from(data, data.byteOffset, data.byteLength);
            const frame = new WebsocketFrameSend(ab);
            const buffer = frame.createFrame(opcodes.BINARY);
            this.#bufferedAmount += ab.byteLength;
            socket.write(buffer, () => {
              this.#bufferedAmount -= ab.byteLength;
            });
          } else if (isBlobLike(data)) {
            const frame = new WebsocketFrameSend();
            data.arrayBuffer().then((ab) => {
              const value = Buffer.from(ab);
              frame.frameData = value;
              const buffer = frame.createFrame(opcodes.BINARY);
              this.#bufferedAmount += value.byteLength;
              socket.write(buffer, () => {
                this.#bufferedAmount -= value.byteLength;
              });
            });
          }
        }
        get readyState() {
          webidl.brandCheck(this, _WebSocket);
          return this[kReadyState];
        }
        get bufferedAmount() {
          webidl.brandCheck(this, _WebSocket);
          return this.#bufferedAmount;
        }
        get url() {
          webidl.brandCheck(this, _WebSocket);
          return URLSerializer(this[kWebSocketURL]);
        }
        get extensions() {
          webidl.brandCheck(this, _WebSocket);
          return this.#extensions;
        }
        get protocol() {
          webidl.brandCheck(this, _WebSocket);
          return this.#protocol;
        }
        get onopen() {
          webidl.brandCheck(this, _WebSocket);
          return this.#events.open;
        }
        set onopen(fn) {
          webidl.brandCheck(this, _WebSocket);
          if (this.#events.open) {
            this.removeEventListener("open", this.#events.open);
          }
          if (typeof fn === "function") {
            this.#events.open = fn;
            this.addEventListener("open", fn);
          } else {
            this.#events.open = null;
          }
        }
        get onerror() {
          webidl.brandCheck(this, _WebSocket);
          return this.#events.error;
        }
        set onerror(fn) {
          webidl.brandCheck(this, _WebSocket);
          if (this.#events.error) {
            this.removeEventListener("error", this.#events.error);
          }
          if (typeof fn === "function") {
            this.#events.error = fn;
            this.addEventListener("error", fn);
          } else {
            this.#events.error = null;
          }
        }
        get onclose() {
          webidl.brandCheck(this, _WebSocket);
          return this.#events.close;
        }
        set onclose(fn) {
          webidl.brandCheck(this, _WebSocket);
          if (this.#events.close) {
            this.removeEventListener("close", this.#events.close);
          }
          if (typeof fn === "function") {
            this.#events.close = fn;
            this.addEventListener("close", fn);
          } else {
            this.#events.close = null;
          }
        }
        get onmessage() {
          webidl.brandCheck(this, _WebSocket);
          return this.#events.message;
        }
        set onmessage(fn) {
          webidl.brandCheck(this, _WebSocket);
          if (this.#events.message) {
            this.removeEventListener("message", this.#events.message);
          }
          if (typeof fn === "function") {
            this.#events.message = fn;
            this.addEventListener("message", fn);
          } else {
            this.#events.message = null;
          }
        }
        get binaryType() {
          webidl.brandCheck(this, _WebSocket);
          return this[kBinaryType];
        }
        set binaryType(type) {
          webidl.brandCheck(this, _WebSocket);
          if (type !== "blob" && type !== "arraybuffer") {
            this[kBinaryType] = "blob";
          } else {
            this[kBinaryType] = type;
          }
        }
        /**
         * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
         */
        #onConnectionEstablished(response) {
          this[kResponse] = response;
          const parser = new ByteParser(this);
          parser.on("drain", function onParserDrain() {
            this.ws[kResponse].socket.resume();
          });
          response.socket.ws = this;
          this[kByteParser] = parser;
          this[kReadyState] = states.OPEN;
          const extensions = response.headersList.get("sec-websocket-extensions");
          if (extensions !== null) {
            this.#extensions = extensions;
          }
          const protocol = response.headersList.get("sec-websocket-protocol");
          if (protocol !== null) {
            this.#protocol = protocol;
          }
          fireEvent("open", this);
        }
      };
      WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
      WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
      WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
      WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
      Object.defineProperties(WebSocket.prototype, {
        CONNECTING: staticPropertyDescriptors,
        OPEN: staticPropertyDescriptors,
        CLOSING: staticPropertyDescriptors,
        CLOSED: staticPropertyDescriptors,
        url: kEnumerableProperty,
        readyState: kEnumerableProperty,
        bufferedAmount: kEnumerableProperty,
        onopen: kEnumerableProperty,
        onerror: kEnumerableProperty,
        onclose: kEnumerableProperty,
        close: kEnumerableProperty,
        onmessage: kEnumerableProperty,
        binaryType: kEnumerableProperty,
        send: kEnumerableProperty,
        extensions: kEnumerableProperty,
        protocol: kEnumerableProperty,
        [Symbol.toStringTag]: {
          value: "WebSocket",
          writable: false,
          enumerable: false,
          configurable: true
        }
      });
      Object.defineProperties(WebSocket, {
        CONNECTING: staticPropertyDescriptors,
        OPEN: staticPropertyDescriptors,
        CLOSING: staticPropertyDescriptors,
        CLOSED: staticPropertyDescriptors
      });
      webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
        webidl.converters.DOMString
      );
      webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
        if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
          return webidl.converters["sequence<DOMString>"](V);
        }
        return webidl.converters.DOMString(V);
      };
      webidl.converters.WebSocketInit = webidl.dictionaryConverter([
        {
          key: "protocols",
          converter: webidl.converters["DOMString or sequence<DOMString>"],
          get defaultValue() {
            return [];
          }
        },
        {
          key: "dispatcher",
          converter: (V) => V,
          get defaultValue() {
            return getGlobalDispatcher();
          }
        },
        {
          key: "headers",
          converter: webidl.nullableConverter(webidl.converters.HeadersInit)
        }
      ]);
      webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
        if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
          return webidl.converters.WebSocketInit(V);
        }
        return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
      };
      webidl.converters.WebSocketSendData = function(V) {
        if (webidl.util.Type(V) === "Object") {
          if (isBlobLike(V)) {
            return webidl.converters.Blob(V, { strict: false });
          }
          if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
            return webidl.converters.BufferSource(V);
          }
        }
        return webidl.converters.USVString(V);
      };
      module.exports = {
        WebSocket
      };
    }
  });

  // node_modules/undici/index.js
  var require_undici = __commonJS({
    "node_modules/undici/index.js"(exports, module) {
      "use strict";
      var Client = require_client();
      var Dispatcher = require_dispatcher();
      var errors = require_errors();
      var Pool = require_pool();
      var BalancedPool = require_balanced_pool();
      var Agent = require_agent();
      var util = require_util();
      var { InvalidArgumentError } = errors;
      var api = require_api();
      var buildConnector = require_connect();
      var MockClient = require_mock_client();
      var MockAgent = require_mock_agent();
      var MockPool = require_mock_pool();
      var mockErrors = require_mock_errors();
      var ProxyAgent = require_proxy_agent();
      var RetryHandler = require_RetryHandler();
      var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
      var DecoratorHandler = require_DecoratorHandler();
      var RedirectHandler = require_RedirectHandler();
      var createRedirectInterceptor = require_redirectInterceptor();
      var hasCrypto;
      try {
        __require("crypto");
        hasCrypto = true;
      } catch {
        hasCrypto = false;
      }
      Object.assign(Dispatcher.prototype, api);
      module.exports.Dispatcher = Dispatcher;
      module.exports.Client = Client;
      module.exports.Pool = Pool;
      module.exports.BalancedPool = BalancedPool;
      module.exports.Agent = Agent;
      module.exports.ProxyAgent = ProxyAgent;
      module.exports.RetryHandler = RetryHandler;
      module.exports.DecoratorHandler = DecoratorHandler;
      module.exports.RedirectHandler = RedirectHandler;
      module.exports.createRedirectInterceptor = createRedirectInterceptor;
      module.exports.buildConnector = buildConnector;
      module.exports.errors = errors;
      function makeDispatcher(fn) {
        return (url, opts, handler2) => {
          if (typeof opts === "function") {
            handler2 = opts;
            opts = null;
          }
          if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
            throw new InvalidArgumentError("invalid url");
          }
          if (opts != null && typeof opts !== "object") {
            throw new InvalidArgumentError("invalid opts");
          }
          if (opts && opts.path != null) {
            if (typeof opts.path !== "string") {
              throw new InvalidArgumentError("invalid opts.path");
            }
            let path = opts.path;
            if (!opts.path.startsWith("/")) {
              path = `/${path}`;
            }
            url = new URL(util.parseOrigin(url).origin + path);
          } else {
            if (!opts) {
              opts = typeof url === "object" ? url : {};
            }
            url = util.parseURL(url);
          }
          const { agent, dispatcher = getGlobalDispatcher() } = opts;
          if (agent) {
            throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
          }
          return fn.call(dispatcher, {
            ...opts,
            origin: url.origin,
            path: url.search ? `${url.pathname}${url.search}` : url.pathname,
            method: opts.method || (opts.body ? "PUT" : "GET")
          }, handler2);
        };
      }
      module.exports.setGlobalDispatcher = setGlobalDispatcher;
      module.exports.getGlobalDispatcher = getGlobalDispatcher;
      if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
        let fetchImpl = null;
        module.exports.fetch = async function fetch2(resource) {
          if (!fetchImpl) {
            fetchImpl = require_fetch().fetch;
          }
          try {
            return await fetchImpl(...arguments);
          } catch (err) {
            if (typeof err === "object") {
              Error.captureStackTrace(err, this);
            }
            throw err;
          }
        };
        module.exports.Headers = require_headers().Headers;
        module.exports.Response = require_response().Response;
        module.exports.Request = require_request2().Request;
        module.exports.FormData = require_formdata().FormData;
        module.exports.File = require_file().File;
        module.exports.FileReader = require_filereader().FileReader;
        const { setGlobalOrigin, getGlobalOrigin } = require_global();
        module.exports.setGlobalOrigin = setGlobalOrigin;
        module.exports.getGlobalOrigin = getGlobalOrigin;
        const { CacheStorage } = require_cachestorage();
        const { kConstruct } = require_symbols4();
        module.exports.caches = new CacheStorage(kConstruct);
      }
      if (util.nodeMajor >= 16) {
        const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
        module.exports.deleteCookie = deleteCookie;
        module.exports.getCookies = getCookies;
        module.exports.getSetCookies = getSetCookies;
        module.exports.setCookie = setCookie;
        const { parseMIMEType, serializeAMimeType } = require_dataURL();
        module.exports.parseMIMEType = parseMIMEType;
        module.exports.serializeAMimeType = serializeAMimeType;
      }
      if (util.nodeMajor >= 18 && hasCrypto) {
        const { WebSocket } = require_websocket();
        module.exports.WebSocket = WebSocket;
      }
      module.exports.request = makeDispatcher(api.request);
      module.exports.stream = makeDispatcher(api.stream);
      module.exports.pipeline = makeDispatcher(api.pipeline);
      module.exports.connect = makeDispatcher(api.connect);
      module.exports.upgrade = makeDispatcher(api.upgrade);
      module.exports.MockClient = MockClient;
      module.exports.MockPool = MockPool;
      module.exports.MockAgent = MockAgent;
      module.exports.mockErrors = mockErrors;
    }
  });

  // node_modules/@actions/http-client/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@actions/http-client/lib/index.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
      var http = __importStar2(__require("http"));
      var https = __importStar2(__require("https"));
      var pm = __importStar2(require_proxy());
      var tunnel = __importStar2(require_tunnel2());
      var undici_1 = require_undici();
      var HttpCodes;
      (function(HttpCodes2) {
        HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
        HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
        HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
        HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
        HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
        HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
        HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
        HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
        HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
        HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
        HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
        HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
        HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
        HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
        HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
        HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
        HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
        HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
        HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
        HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
        HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
        HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
        HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
        HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
        HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
        HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
        HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
      })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
      var Headers;
      (function(Headers2) {
        Headers2["Accept"] = "accept";
        Headers2["ContentType"] = "content-type";
      })(Headers || (exports.Headers = Headers = {}));
      var MediaTypes;
      (function(MediaTypes2) {
        MediaTypes2["ApplicationJson"] = "application/json";
      })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
      function getProxyUrl(serverUrl) {
        const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
        return proxyUrl ? proxyUrl.href : "";
      }
      exports.getProxyUrl = getProxyUrl;
      var HttpRedirectCodes = [
        HttpCodes.MovedPermanently,
        HttpCodes.ResourceMoved,
        HttpCodes.SeeOther,
        HttpCodes.TemporaryRedirect,
        HttpCodes.PermanentRedirect
      ];
      var HttpResponseRetryCodes = [
        HttpCodes.BadGateway,
        HttpCodes.ServiceUnavailable,
        HttpCodes.GatewayTimeout
      ];
      var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
      var ExponentialBackoffCeiling = 10;
      var ExponentialBackoffTimeSlice = 5;
      var HttpClientError = class _HttpClientError extends Error {
        constructor(message, statusCode) {
          super(message);
          this.name = "HttpClientError";
          this.statusCode = statusCode;
          Object.setPrototypeOf(this, _HttpClientError.prototype);
        }
      };
      exports.HttpClientError = HttpClientError;
      var HttpClientResponse = class {
        constructor(message) {
          this.message = message;
        }
        readBody() {
          return __awaiter2(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter2(this, void 0, void 0, function* () {
              let output = Buffer.alloc(0);
              this.message.on("data", (chunk) => {
                output = Buffer.concat([output, chunk]);
              });
              this.message.on("end", () => {
                resolve(output.toString());
              });
            }));
          });
        }
        readBodyBuffer() {
          return __awaiter2(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter2(this, void 0, void 0, function* () {
              const chunks = [];
              this.message.on("data", (chunk) => {
                chunks.push(chunk);
              });
              this.message.on("end", () => {
                resolve(Buffer.concat(chunks));
              });
            }));
          });
        }
      };
      exports.HttpClientResponse = HttpClientResponse;
      function isHttps(requestUrl) {
        const parsedUrl = new URL(requestUrl);
        return parsedUrl.protocol === "https:";
      }
      exports.isHttps = isHttps;
      var HttpClient = class {
        constructor(userAgent2, handlers, requestOptions) {
          this._ignoreSslError = false;
          this._allowRedirects = true;
          this._allowRedirectDowngrade = false;
          this._maxRedirects = 50;
          this._allowRetries = false;
          this._maxRetries = 1;
          this._keepAlive = false;
          this._disposed = false;
          this.userAgent = userAgent2;
          this.handlers = handlers || [];
          this.requestOptions = requestOptions;
          if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
              this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
              this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
              this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
              this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
              this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
              this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
              this._maxRetries = requestOptions.maxRetries;
            }
          }
        }
        options(requestUrl, additionalHeaders) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
          });
        }
        get(requestUrl, additionalHeaders) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.request("GET", requestUrl, null, additionalHeaders || {});
          });
        }
        del(requestUrl, additionalHeaders) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.request("DELETE", requestUrl, null, additionalHeaders || {});
          });
        }
        post(requestUrl, data, additionalHeaders) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.request("POST", requestUrl, data, additionalHeaders || {});
          });
        }
        patch(requestUrl, data, additionalHeaders) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.request("PATCH", requestUrl, data, additionalHeaders || {});
          });
        }
        put(requestUrl, data, additionalHeaders) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.request("PUT", requestUrl, data, additionalHeaders || {});
          });
        }
        head(requestUrl, additionalHeaders) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.request("HEAD", requestUrl, null, additionalHeaders || {});
          });
        }
        sendStream(verb, requestUrl, stream, additionalHeaders) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
          });
        }
        /**
         * Gets a typed object from an endpoint
         * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
         */
        getJson(requestUrl, additionalHeaders = {}) {
          return __awaiter2(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
          });
        }
        postJson(requestUrl, obj, additionalHeaders = {}) {
          return __awaiter2(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
          });
        }
        putJson(requestUrl, obj, additionalHeaders = {}) {
          return __awaiter2(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
          });
        }
        patchJson(requestUrl, obj, additionalHeaders = {}) {
          return __awaiter2(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
          });
        }
        /**
         * Makes a raw http request.
         * All other methods such as get, post, patch, and request ultimately call this.
         * Prefer get, del, post and patch
         */
        request(verb, requestUrl, data, headers) {
          return __awaiter2(this, void 0, void 0, function* () {
            if (this._disposed) {
              throw new Error("Client has already been disposed.");
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
            let numTries = 0;
            let response;
            do {
              response = yield this.requestRaw(info, data);
              if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
                let authenticationHandler;
                for (const handler2 of this.handlers) {
                  if (handler2.canHandleAuthentication(response)) {
                    authenticationHandler = handler2;
                    break;
                  }
                }
                if (authenticationHandler) {
                  return authenticationHandler.handleAuthentication(this, info, data);
                } else {
                  return response;
                }
              }
              let redirectsRemaining = this._maxRedirects;
              while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
                const redirectUrl = response.message.headers["location"];
                if (!redirectUrl) {
                  break;
                }
                const parsedRedirectUrl = new URL(redirectUrl);
                if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                  throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
                }
                yield response.readBody();
                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                  for (const header in headers) {
                    if (header.toLowerCase() === "authorization") {
                      delete headers[header];
                    }
                  }
                }
                info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                response = yield this.requestRaw(info, data);
                redirectsRemaining--;
              }
              if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                return response;
              }
              numTries += 1;
              if (numTries < maxTries) {
                yield response.readBody();
                yield this._performExponentialBackoff(numTries);
              }
            } while (numTries < maxTries);
            return response;
          });
        }
        /**
         * Needs to be called if keepAlive is set to true in request options.
         */
        dispose() {
          if (this._agent) {
            this._agent.destroy();
          }
          this._disposed = true;
        }
        /**
         * Raw request.
         * @param info
         * @param data
         */
        requestRaw(info, data) {
          return __awaiter2(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
              function callbackForResult(err, res) {
                if (err) {
                  reject(err);
                } else if (!res) {
                  reject(new Error("Unknown error"));
                } else {
                  resolve(res);
                }
              }
              this.requestRawWithCallback(info, data, callbackForResult);
            });
          });
        }
        /**
         * Raw request with callback.
         * @param info
         * @param data
         * @param onResult
         */
        requestRawWithCallback(info, data, onResult) {
          if (typeof data === "string") {
            if (!info.options.headers) {
              info.options.headers = {};
            }
            info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
          }
          let callbackCalled = false;
          function handleResult(err, res) {
            if (!callbackCalled) {
              callbackCalled = true;
              onResult(err, res);
            }
          }
          const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(void 0, res);
          });
          let socket;
          req.on("socket", (sock) => {
            socket = sock;
          });
          req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
            if (socket) {
              socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
          });
          req.on("error", function(err) {
            handleResult(err);
          });
          if (data && typeof data === "string") {
            req.write(data, "utf8");
          }
          if (data && typeof data !== "string") {
            data.on("close", function() {
              req.end();
            });
            data.pipe(req);
          } else {
            req.end();
          }
        }
        /**
         * Gets an http agent. This function is useful when you need an http agent that handles
         * routing through a proxy server - depending upon the url and proxy environment variables.
         * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
         */
        getAgent(serverUrl) {
          const parsedUrl = new URL(serverUrl);
          return this._getAgent(parsedUrl);
        }
        getAgentDispatcher(serverUrl) {
          const parsedUrl = new URL(serverUrl);
          const proxyUrl = pm.getProxyUrl(parsedUrl);
          const useProxy = proxyUrl && proxyUrl.hostname;
          if (!useProxy) {
            return;
          }
          return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
        }
        _prepareRequest(method, requestUrl, headers) {
          const info = {};
          info.parsedUrl = requestUrl;
          const usingSsl = info.parsedUrl.protocol === "https:";
          info.httpModule = usingSsl ? https : http;
          const defaultPort = usingSsl ? 443 : 80;
          info.options = {};
          info.options.host = info.parsedUrl.hostname;
          info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
          info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
          info.options.method = method;
          info.options.headers = this._mergeHeaders(headers);
          if (this.userAgent != null) {
            info.options.headers["user-agent"] = this.userAgent;
          }
          info.options.agent = this._getAgent(info.parsedUrl);
          if (this.handlers) {
            for (const handler2 of this.handlers) {
              handler2.prepareRequest(info.options);
            }
          }
          return info;
        }
        _mergeHeaders(headers) {
          if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys2(this.requestOptions.headers), lowercaseKeys2(headers || {}));
          }
          return lowercaseKeys2(headers || {});
        }
        _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
          let clientHeader;
          if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys2(this.requestOptions.headers)[header];
          }
          return additionalHeaders[header] || clientHeader || _default;
        }
        _getAgent(parsedUrl) {
          let agent;
          const proxyUrl = pm.getProxyUrl(parsedUrl);
          const useProxy = proxyUrl && proxyUrl.hostname;
          if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
          }
          if (!useProxy) {
            agent = this._agent;
          }
          if (agent) {
            return agent;
          }
          const usingSsl = parsedUrl.protocol === "https:";
          let maxSockets = 100;
          if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
          }
          if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
              maxSockets,
              keepAlive: this._keepAlive,
              proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
                proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
              }), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === "https:";
            if (usingSsl) {
              tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            } else {
              tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
          }
          if (!agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
          }
          if (usingSsl && this._ignoreSslError) {
            agent.options = Object.assign(agent.options || {}, {
              rejectUnauthorized: false
            });
          }
          return agent;
        }
        _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
          let proxyAgent;
          if (this._keepAlive) {
            proxyAgent = this._proxyAgentDispatcher;
          }
          if (proxyAgent) {
            return proxyAgent;
          }
          const usingSsl = parsedUrl.protocol === "https:";
          proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
            token: `${proxyUrl.username}:${proxyUrl.password}`
          }));
          this._proxyAgentDispatcher = proxyAgent;
          if (usingSsl && this._ignoreSslError) {
            proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
              rejectUnauthorized: false
            });
          }
          return proxyAgent;
        }
        _performExponentialBackoff(retryNumber) {
          return __awaiter2(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise((resolve) => setTimeout(() => resolve(), ms));
          });
        }
        _processResponse(res, options) {
          return __awaiter2(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter2(this, void 0, void 0, function* () {
              const statusCode = res.message.statusCode || 0;
              const response = {
                statusCode,
                result: null,
                headers: {}
              };
              if (statusCode === HttpCodes.NotFound) {
                resolve(response);
              }
              function dateTimeDeserializer(key, value) {
                if (typeof value === "string") {
                  const a = new Date(value);
                  if (!isNaN(a.valueOf())) {
                    return a;
                  }
                }
                return value;
              }
              let obj;
              let contents;
              try {
                contents = yield res.readBody();
                if (contents && contents.length > 0) {
                  if (options && options.deserializeDates) {
                    obj = JSON.parse(contents, dateTimeDeserializer);
                  } else {
                    obj = JSON.parse(contents);
                  }
                  response.result = obj;
                }
                response.headers = res.message.headers;
              } catch (err) {
              }
              if (statusCode > 299) {
                let msg;
                if (obj && obj.message) {
                  msg = obj.message;
                } else if (contents && contents.length > 0) {
                  msg = contents;
                } else {
                  msg = `Failed request: (${statusCode})`;
                }
                const err = new HttpClientError(msg, statusCode);
                err.result = response.result;
                reject(err);
              } else {
                resolve(response);
              }
            }));
          });
        }
      };
      exports.HttpClient = HttpClient;
      var lowercaseKeys2 = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
    }
  });

  // node_modules/@actions/http-client/lib/auth.js
  var require_auth = __commonJS({
    "node_modules/@actions/http-client/lib/auth.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
      var BasicCredentialHandler = class {
        constructor(username, password) {
          this.username = username;
          this.password = password;
        }
        prepareRequest(options) {
          if (!options.headers) {
            throw Error("The request has no headers");
          }
          options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
        }
        // This handler cannot handle 401
        canHandleAuthentication() {
          return false;
        }
        handleAuthentication() {
          return __awaiter2(this, void 0, void 0, function* () {
            throw new Error("not implemented");
          });
        }
      };
      exports.BasicCredentialHandler = BasicCredentialHandler;
      var BearerCredentialHandler = class {
        constructor(token2) {
          this.token = token2;
        }
        // currently implements pre-authorization
        // TODO: support preAuth = false where it hooks on 401
        prepareRequest(options) {
          if (!options.headers) {
            throw Error("The request has no headers");
          }
          options.headers["Authorization"] = `Bearer ${this.token}`;
        }
        // This handler cannot handle 401
        canHandleAuthentication() {
          return false;
        }
        handleAuthentication() {
          return __awaiter2(this, void 0, void 0, function* () {
            throw new Error("not implemented");
          });
        }
      };
      exports.BearerCredentialHandler = BearerCredentialHandler;
      var PersonalAccessTokenCredentialHandler = class {
        constructor(token2) {
          this.token = token2;
        }
        // currently implements pre-authorization
        // TODO: support preAuth = false where it hooks on 401
        prepareRequest(options) {
          if (!options.headers) {
            throw Error("The request has no headers");
          }
          options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
        }
        // This handler cannot handle 401
        canHandleAuthentication() {
          return false;
        }
        handleAuthentication() {
          return __awaiter2(this, void 0, void 0, function* () {
            throw new Error("not implemented");
          });
        }
      };
      exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
    }
  });

  // node_modules/@actions/core/lib/oidc-utils.js
  var require_oidc_utils = __commonJS({
    "node_modules/@actions/core/lib/oidc-utils.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OidcClient = void 0;
      var http_client_1 = require_lib();
      var auth_1 = require_auth();
      var core_1 = require_core();
      var OidcClient = class _OidcClient {
        static createHttpClient(allowRetry = true, maxRetry = 10) {
          const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
          };
          return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
        }
        static getRequestToken() {
          const token2 = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
          if (!token2) {
            throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
          }
          return token2;
        }
        static getIDTokenUrl() {
          const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
          if (!runtimeUrl) {
            throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
          }
          return runtimeUrl;
        }
        static getCall(id_token_url) {
          var _a;
          return __awaiter2(this, void 0, void 0, function* () {
            const httpclient = _OidcClient.createHttpClient();
            const res = yield httpclient.getJson(id_token_url).catch((error) => {
              throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
              throw new Error("Response json body do not have ID Token field");
            }
            return id_token;
          });
        }
        static getIDToken(audience) {
          return __awaiter2(this, void 0, void 0, function* () {
            try {
              let id_token_url = _OidcClient.getIDTokenUrl();
              if (audience) {
                const encodedAudience = encodeURIComponent(audience);
                id_token_url = `${id_token_url}&audience=${encodedAudience}`;
              }
              (0, core_1.debug)(`ID token url is ${id_token_url}`);
              const id_token = yield _OidcClient.getCall(id_token_url);
              (0, core_1.setSecret)(id_token);
              return id_token;
            } catch (error) {
              throw new Error(`Error message: ${error.message}`);
            }
          });
        }
      };
      exports.OidcClient = OidcClient;
    }
  });

  // node_modules/@actions/core/lib/summary.js
  var require_summary = __commonJS({
    "node_modules/@actions/core/lib/summary.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
      var os_1 = __require("os");
      var fs_1 = __require("fs");
      var { access, appendFile, writeFile } = fs_1.promises;
      exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
      exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
      var Summary = class {
        constructor() {
          this._buffer = "";
        }
        /**
         * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
         * Also checks r/w permissions.
         *
         * @returns step summary file path
         */
        filePath() {
          return __awaiter2(this, void 0, void 0, function* () {
            if (this._filePath) {
              return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
              throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
              yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            } catch (_a) {
              throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
          });
        }
        /**
         * Wraps content in an HTML tag, adding any HTML attributes
         *
         * @param {string} tag HTML tag to wrap
         * @param {string | null} content content within the tag
         * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
         *
         * @returns {string} content wrapped in HTML element
         */
        wrap(tag, content, attrs = {}) {
          const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
          if (!content) {
            return `<${tag}${htmlAttrs}>`;
          }
          return `<${tag}${htmlAttrs}>${content}</${tag}>`;
        }
        /**
         * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
         *
         * @param {SummaryWriteOptions} [options] (optional) options for write operation
         *
         * @returns {Promise<Summary>} summary instance
         */
        write(options) {
          return __awaiter2(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
            return this.emptyBuffer();
          });
        }
        /**
         * Clears the summary buffer and wipes the summary file
         *
         * @returns {Summary} summary instance
         */
        clear() {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
          });
        }
        /**
         * Returns the current summary buffer as a string
         *
         * @returns {string} string of summary buffer
         */
        stringify() {
          return this._buffer;
        }
        /**
         * If the summary buffer is empty
         *
         * @returns {boolen} true if the buffer is empty
         */
        isEmptyBuffer() {
          return this._buffer.length === 0;
        }
        /**
         * Resets the summary buffer without writing to summary file
         *
         * @returns {Summary} summary instance
         */
        emptyBuffer() {
          this._buffer = "";
          return this;
        }
        /**
         * Adds raw text to the summary buffer
         *
         * @param {string} text content to add
         * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
         *
         * @returns {Summary} summary instance
         */
        addRaw(text, addEOL = false) {
          this._buffer += text;
          return addEOL ? this.addEOL() : this;
        }
        /**
         * Adds the operating system-specific end-of-line marker to the buffer
         *
         * @returns {Summary} summary instance
         */
        addEOL() {
          return this.addRaw(os_1.EOL);
        }
        /**
         * Adds an HTML codeblock to the summary buffer
         *
         * @param {string} code content to render within fenced code block
         * @param {string} lang (optional) language to syntax highlight code
         *
         * @returns {Summary} summary instance
         */
        addCodeBlock(code, lang) {
          const attrs = Object.assign({}, lang && { lang });
          const element = this.wrap("pre", this.wrap("code", code), attrs);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML list to the summary buffer
         *
         * @param {string[]} items list of items to render
         * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
         *
         * @returns {Summary} summary instance
         */
        addList(items, ordered = false) {
          const tag = ordered ? "ol" : "ul";
          const listItems = items.map((item) => this.wrap("li", item)).join("");
          const element = this.wrap(tag, listItems);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML table to the summary buffer
         *
         * @param {SummaryTableCell[]} rows table rows
         *
         * @returns {Summary} summary instance
         */
        addTable(rows) {
          const tableBody = rows.map((row) => {
            const cells = row.map((cell) => {
              if (typeof cell === "string") {
                return this.wrap("td", cell);
              }
              const { header, data, colspan, rowspan } = cell;
              const tag = header ? "th" : "td";
              const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
              return this.wrap(tag, data, attrs);
            }).join("");
            return this.wrap("tr", cells);
          }).join("");
          const element = this.wrap("table", tableBody);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds a collapsable HTML details element to the summary buffer
         *
         * @param {string} label text for the closed state
         * @param {string} content collapsable content
         *
         * @returns {Summary} summary instance
         */
        addDetails(label, content) {
          const element = this.wrap("details", this.wrap("summary", label) + content);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML image tag to the summary buffer
         *
         * @param {string} src path to the image you to embed
         * @param {string} alt text description of the image
         * @param {SummaryImageOptions} options (optional) addition image attributes
         *
         * @returns {Summary} summary instance
         */
        addImage(src, alt, options) {
          const { width, height } = options || {};
          const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
          const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML section heading element
         *
         * @param {string} text heading text
         * @param {number | string} [level=1] (optional) the heading level, default: 1
         *
         * @returns {Summary} summary instance
         */
        addHeading(text, level) {
          const tag = `h${level}`;
          const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
          const element = this.wrap(allowedTag, text);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML thematic break (<hr>) to the summary buffer
         *
         * @returns {Summary} summary instance
         */
        addSeparator() {
          const element = this.wrap("hr", null);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML line break (<br>) to the summary buffer
         *
         * @returns {Summary} summary instance
         */
        addBreak() {
          const element = this.wrap("br", null);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML blockquote to the summary buffer
         *
         * @param {string} text quote text
         * @param {string} cite (optional) citation url
         *
         * @returns {Summary} summary instance
         */
        addQuote(text, cite) {
          const attrs = Object.assign({}, cite && { cite });
          const element = this.wrap("blockquote", text, attrs);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML anchor tag to the summary buffer
         *
         * @param {string} text link text/content
         * @param {string} href hyperlink
         *
         * @returns {Summary} summary instance
         */
        addLink(text, href) {
          const element = this.wrap("a", text, { href });
          return this.addRaw(element).addEOL();
        }
      };
      var _summary = new Summary();
      exports.markdownSummary = _summary;
      exports.summary = _summary;
    }
  });

  // node_modules/@actions/core/lib/path-utils.js
  var require_path_utils = __commonJS({
    "node_modules/@actions/core/lib/path-utils.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
      var path = __importStar2(__require("path"));
      function toPosixPath(pth) {
        return pth.replace(/[\\]/g, "/");
      }
      exports.toPosixPath = toPosixPath;
      function toWin32Path(pth) {
        return pth.replace(/[/]/g, "\\");
      }
      exports.toWin32Path = toWin32Path;
      function toPlatformPath(pth) {
        return pth.replace(/[/\\]/g, path.sep);
      }
      exports.toPlatformPath = toPlatformPath;
    }
  });

  // node_modules/@actions/io/lib/io-util.js
  var require_io_util = __commonJS({
    "node_modules/@actions/io/lib/io-util.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
      var fs = __importStar2(__require("fs"));
      var path = __importStar2(__require("path"));
      _a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
      exports.IS_WINDOWS = process.platform === "win32";
      exports.UV_FS_O_EXLOCK = 268435456;
      exports.READONLY = fs.constants.O_RDONLY;
      function exists(fsPath) {
        return __awaiter2(this, void 0, void 0, function* () {
          try {
            yield exports.stat(fsPath);
          } catch (err) {
            if (err.code === "ENOENT") {
              return false;
            }
            throw err;
          }
          return true;
        });
      }
      exports.exists = exists;
      function isDirectory(fsPath, useStat = false) {
        return __awaiter2(this, void 0, void 0, function* () {
          const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
          return stats.isDirectory();
        });
      }
      exports.isDirectory = isDirectory;
      function isRooted(p) {
        p = normalizeSeparators(p);
        if (!p) {
          throw new Error('isRooted() parameter "p" cannot be empty');
        }
        if (exports.IS_WINDOWS) {
          return p.startsWith("\\") || /^[A-Z]:/i.test(p);
        }
        return p.startsWith("/");
      }
      exports.isRooted = isRooted;
      function tryGetExecutablePath(filePath, extensions) {
        return __awaiter2(this, void 0, void 0, function* () {
          let stats = void 0;
          try {
            stats = yield exports.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports.IS_WINDOWS) {
              const upperExt = path.extname(filePath).toUpperCase();
              if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
                return filePath;
              }
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
          const originalFilePath = filePath;
          for (const extension of extensions) {
            filePath = originalFilePath + extension;
            stats = void 0;
            try {
              stats = yield exports.stat(filePath);
            } catch (err) {
              if (err.code !== "ENOENT") {
                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
              }
            }
            if (stats && stats.isFile()) {
              if (exports.IS_WINDOWS) {
                try {
                  const directory = path.dirname(filePath);
                  const upperName = path.basename(filePath).toUpperCase();
                  for (const actualName of yield exports.readdir(directory)) {
                    if (upperName === actualName.toUpperCase()) {
                      filePath = path.join(directory, actualName);
                      break;
                    }
                  }
                } catch (err) {
                  console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
                }
                return filePath;
              } else {
                if (isUnixExecutable(stats)) {
                  return filePath;
                }
              }
            }
          }
          return "";
        });
      }
      exports.tryGetExecutablePath = tryGetExecutablePath;
      function normalizeSeparators(p) {
        p = p || "";
        if (exports.IS_WINDOWS) {
          p = p.replace(/\//g, "\\");
          return p.replace(/\\\\+/g, "\\");
        }
        return p.replace(/\/\/+/g, "/");
      }
      function isUnixExecutable(stats) {
        return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
      }
      function getCmdPath() {
        var _a2;
        return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
      }
      exports.getCmdPath = getCmdPath;
    }
  });

  // node_modules/@actions/io/lib/io.js
  var require_io = __commonJS({
    "node_modules/@actions/io/lib/io.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;
      var assert_1 = __require("assert");
      var path = __importStar2(__require("path"));
      var ioUtil = __importStar2(require_io_util());
      function cp(source, dest, options = {}) {
        return __awaiter2(this, void 0, void 0, function* () {
          const { force, recursive, copySourceDirectory } = readCopyOptions(options);
          const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
          if (destStat && destStat.isFile() && !force) {
            return;
          }
          const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
          if (!(yield ioUtil.exists(source))) {
            throw new Error(`no such file or directory: ${source}`);
          }
          const sourceStat = yield ioUtil.stat(source);
          if (sourceStat.isDirectory()) {
            if (!recursive) {
              throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
            } else {
              yield cpDirRecursive(source, newDest, 0, force);
            }
          } else {
            if (path.relative(source, newDest) === "") {
              throw new Error(`'${newDest}' and '${source}' are the same file`);
            }
            yield copyFile(source, newDest, force);
          }
        });
      }
      exports.cp = cp;
      function mv(source, dest, options = {}) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (yield ioUtil.exists(dest)) {
            let destExists = true;
            if (yield ioUtil.isDirectory(dest)) {
              dest = path.join(dest, path.basename(source));
              destExists = yield ioUtil.exists(dest);
            }
            if (destExists) {
              if (options.force == null || options.force) {
                yield rmRF(dest);
              } else {
                throw new Error("Destination already exists");
              }
            }
          }
          yield mkdirP(path.dirname(dest));
          yield ioUtil.rename(source, dest);
        });
      }
      exports.mv = mv;
      function rmRF(inputPath) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (ioUtil.IS_WINDOWS) {
            if (/[*"<>|]/.test(inputPath)) {
              throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
            }
          }
          try {
            yield ioUtil.rm(inputPath, {
              force: true,
              maxRetries: 3,
              recursive: true,
              retryDelay: 300
            });
          } catch (err) {
            throw new Error(`File was unable to be removed ${err}`);
          }
        });
      }
      exports.rmRF = rmRF;
      function mkdirP(fsPath) {
        return __awaiter2(this, void 0, void 0, function* () {
          assert_1.ok(fsPath, "a path argument must be provided");
          yield ioUtil.mkdir(fsPath, { recursive: true });
        });
      }
      exports.mkdirP = mkdirP;
      function which(tool, check) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!tool) {
            throw new Error("parameter 'tool' is required");
          }
          if (check) {
            const result = yield which(tool, false);
            if (!result) {
              if (ioUtil.IS_WINDOWS) {
                throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
              } else {
                throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
              }
            }
            return result;
          }
          const matches = yield findInPath(tool);
          if (matches && matches.length > 0) {
            return matches[0];
          }
          return "";
        });
      }
      exports.which = which;
      function findInPath(tool) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!tool) {
            throw new Error("parameter 'tool' is required");
          }
          const extensions = [];
          if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
            for (const extension of process.env["PATHEXT"].split(path.delimiter)) {
              if (extension) {
                extensions.push(extension);
              }
            }
          }
          if (ioUtil.isRooted(tool)) {
            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
            if (filePath) {
              return [filePath];
            }
            return [];
          }
          if (tool.includes(path.sep)) {
            return [];
          }
          const directories = [];
          if (process.env.PATH) {
            for (const p of process.env.PATH.split(path.delimiter)) {
              if (p) {
                directories.push(p);
              }
            }
          }
          const matches = [];
          for (const directory of directories) {
            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
            if (filePath) {
              matches.push(filePath);
            }
          }
          return matches;
        });
      }
      exports.findInPath = findInPath;
      function readCopyOptions(options) {
        const force = options.force == null ? true : options.force;
        const recursive = Boolean(options.recursive);
        const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
        return { force, recursive, copySourceDirectory };
      }
      function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (currentDepth >= 255)
            return;
          currentDepth++;
          yield mkdirP(destDir);
          const files = yield ioUtil.readdir(sourceDir);
          for (const fileName of files) {
            const srcFile = `${sourceDir}/${fileName}`;
            const destFile = `${destDir}/${fileName}`;
            const srcFileStat = yield ioUtil.lstat(srcFile);
            if (srcFileStat.isDirectory()) {
              yield cpDirRecursive(srcFile, destFile, currentDepth, force);
            } else {
              yield copyFile(srcFile, destFile, force);
            }
          }
          yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
        });
      }
      function copyFile(srcFile, destFile, force) {
        return __awaiter2(this, void 0, void 0, function* () {
          if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
            try {
              yield ioUtil.lstat(destFile);
              yield ioUtil.unlink(destFile);
            } catch (e) {
              if (e.code === "EPERM") {
                yield ioUtil.chmod(destFile, "0666");
                yield ioUtil.unlink(destFile);
              }
            }
            const symlinkFull = yield ioUtil.readlink(srcFile);
            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
          } else if (!(yield ioUtil.exists(destFile)) || force) {
            yield ioUtil.copyFile(srcFile, destFile);
          }
        });
      }
    }
  });

  // node_modules/@actions/exec/lib/toolrunner.js
  var require_toolrunner = __commonJS({
    "node_modules/@actions/exec/lib/toolrunner.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.argStringToArray = exports.ToolRunner = void 0;
      var os = __importStar2(__require("os"));
      var events = __importStar2(__require("events"));
      var child = __importStar2(__require("child_process"));
      var path = __importStar2(__require("path"));
      var io = __importStar2(require_io());
      var ioUtil = __importStar2(require_io_util());
      var timers_1 = __require("timers");
      var IS_WINDOWS = process.platform === "win32";
      var ToolRunner = class extends events.EventEmitter {
        constructor(toolPath, args, options) {
          super();
          if (!toolPath) {
            throw new Error("Parameter 'toolPath' cannot be null or empty.");
          }
          this.toolPath = toolPath;
          this.args = args || [];
          this.options = options || {};
        }
        _debug(message) {
          if (this.options.listeners && this.options.listeners.debug) {
            this.options.listeners.debug(message);
          }
        }
        _getCommandString(options, noPrefix) {
          const toolPath = this._getSpawnFileName();
          const args = this._getSpawnArgs(options);
          let cmd = noPrefix ? "" : "[command]";
          if (IS_WINDOWS) {
            if (this._isCmdFile()) {
              cmd += toolPath;
              for (const a of args) {
                cmd += ` ${a}`;
              }
            } else if (options.windowsVerbatimArguments) {
              cmd += `"${toolPath}"`;
              for (const a of args) {
                cmd += ` ${a}`;
              }
            } else {
              cmd += this._windowsQuoteCmdArg(toolPath);
              for (const a of args) {
                cmd += ` ${this._windowsQuoteCmdArg(a)}`;
              }
            }
          } else {
            cmd += toolPath;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          }
          return cmd;
        }
        _processLineBuffer(data, strBuffer, onLine) {
          try {
            let s = strBuffer + data.toString();
            let n = s.indexOf(os.EOL);
            while (n > -1) {
              const line = s.substring(0, n);
              onLine(line);
              s = s.substring(n + os.EOL.length);
              n = s.indexOf(os.EOL);
            }
            return s;
          } catch (err) {
            this._debug(`error processing line. Failed with error ${err}`);
            return "";
          }
        }
        _getSpawnFileName() {
          if (IS_WINDOWS) {
            if (this._isCmdFile()) {
              return process.env["COMSPEC"] || "cmd.exe";
            }
          }
          return this.toolPath;
        }
        _getSpawnArgs(options) {
          if (IS_WINDOWS) {
            if (this._isCmdFile()) {
              let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
              for (const a of this.args) {
                argline += " ";
                argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
              }
              argline += '"';
              return [argline];
            }
          }
          return this.args;
        }
        _endsWith(str, end) {
          return str.endsWith(end);
        }
        _isCmdFile() {
          const upperToolPath = this.toolPath.toUpperCase();
          return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
        }
        _windowsQuoteCmdArg(arg) {
          if (!this._isCmdFile()) {
            return this._uvQuoteCmdArg(arg);
          }
          if (!arg) {
            return '""';
          }
          const cmdSpecialChars = [
            " ",
            "	",
            "&",
            "(",
            ")",
            "[",
            "]",
            "{",
            "}",
            "^",
            "=",
            ";",
            "!",
            "'",
            "+",
            ",",
            "`",
            "~",
            "|",
            "<",
            ">",
            '"'
          ];
          let needsQuotes = false;
          for (const char of arg) {
            if (cmdSpecialChars.some((x) => x === char)) {
              needsQuotes = true;
              break;
            }
          }
          if (!needsQuotes) {
            return arg;
          }
          let reverse = '"';
          let quoteHit = true;
          for (let i = arg.length; i > 0; i--) {
            reverse += arg[i - 1];
            if (quoteHit && arg[i - 1] === "\\") {
              reverse += "\\";
            } else if (arg[i - 1] === '"') {
              quoteHit = true;
              reverse += '"';
            } else {
              quoteHit = false;
            }
          }
          reverse += '"';
          return reverse.split("").reverse().join("");
        }
        _uvQuoteCmdArg(arg) {
          if (!arg) {
            return '""';
          }
          if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
            return arg;
          }
          if (!arg.includes('"') && !arg.includes("\\")) {
            return `"${arg}"`;
          }
          let reverse = '"';
          let quoteHit = true;
          for (let i = arg.length; i > 0; i--) {
            reverse += arg[i - 1];
            if (quoteHit && arg[i - 1] === "\\") {
              reverse += "\\";
            } else if (arg[i - 1] === '"') {
              quoteHit = true;
              reverse += "\\";
            } else {
              quoteHit = false;
            }
          }
          reverse += '"';
          return reverse.split("").reverse().join("");
        }
        _cloneExecOptions(options) {
          options = options || {};
          const result = {
            cwd: options.cwd || process.cwd(),
            env: options.env || process.env,
            silent: options.silent || false,
            windowsVerbatimArguments: options.windowsVerbatimArguments || false,
            failOnStdErr: options.failOnStdErr || false,
            ignoreReturnCode: options.ignoreReturnCode || false,
            delay: options.delay || 1e4
          };
          result.outStream = options.outStream || process.stdout;
          result.errStream = options.errStream || process.stderr;
          return result;
        }
        _getSpawnOptions(options, toolPath) {
          options = options || {};
          const result = {};
          result.cwd = options.cwd;
          result.env = options.env;
          result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
          if (options.windowsVerbatimArguments) {
            result.argv0 = `"${toolPath}"`;
          }
          return result;
        }
        /**
         * Exec a tool.
         * Output will be streamed to the live console.
         * Returns promise with return code
         *
         * @param     tool     path to tool to exec
         * @param     options  optional exec options.  See ExecOptions
         * @returns   number
         */
        exec() {
          return __awaiter2(this, void 0, void 0, function* () {
            if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
              this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
            }
            this.toolPath = yield io.which(this.toolPath, true);
            return new Promise((resolve, reject) => __awaiter2(this, void 0, void 0, function* () {
              this._debug(`exec tool: ${this.toolPath}`);
              this._debug("arguments:");
              for (const arg of this.args) {
                this._debug(`   ${arg}`);
              }
              const optionsNonNull = this._cloneExecOptions(this.options);
              if (!optionsNonNull.silent && optionsNonNull.outStream) {
                optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
              }
              const state = new ExecState(optionsNonNull, this.toolPath);
              state.on("debug", (message) => {
                this._debug(message);
              });
              if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
                return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
              }
              const fileName = this._getSpawnFileName();
              const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
              let stdbuffer = "";
              if (cp.stdout) {
                cp.stdout.on("data", (data) => {
                  if (this.options.listeners && this.options.listeners.stdout) {
                    this.options.listeners.stdout(data);
                  }
                  if (!optionsNonNull.silent && optionsNonNull.outStream) {
                    optionsNonNull.outStream.write(data);
                  }
                  stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                    if (this.options.listeners && this.options.listeners.stdline) {
                      this.options.listeners.stdline(line);
                    }
                  });
                });
              }
              let errbuffer = "";
              if (cp.stderr) {
                cp.stderr.on("data", (data) => {
                  state.processStderr = true;
                  if (this.options.listeners && this.options.listeners.stderr) {
                    this.options.listeners.stderr(data);
                  }
                  if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                    const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                    s.write(data);
                  }
                  errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                    if (this.options.listeners && this.options.listeners.errline) {
                      this.options.listeners.errline(line);
                    }
                  });
                });
              }
              cp.on("error", (err) => {
                state.processError = err.message;
                state.processExited = true;
                state.processClosed = true;
                state.CheckComplete();
              });
              cp.on("exit", (code) => {
                state.processExitCode = code;
                state.processExited = true;
                this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
                state.CheckComplete();
              });
              cp.on("close", (code) => {
                state.processExitCode = code;
                state.processExited = true;
                state.processClosed = true;
                this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
                state.CheckComplete();
              });
              state.on("done", (error, exitCode) => {
                if (stdbuffer.length > 0) {
                  this.emit("stdline", stdbuffer);
                }
                if (errbuffer.length > 0) {
                  this.emit("errline", errbuffer);
                }
                cp.removeAllListeners();
                if (error) {
                  reject(error);
                } else {
                  resolve(exitCode);
                }
              });
              if (this.options.input) {
                if (!cp.stdin) {
                  throw new Error("child process missing stdin");
                }
                cp.stdin.end(this.options.input);
              }
            }));
          });
        }
      };
      exports.ToolRunner = ToolRunner;
      function argStringToArray(argString) {
        const args = [];
        let inQuotes = false;
        let escaped = false;
        let arg = "";
        function append(c) {
          if (escaped && c !== '"') {
            arg += "\\";
          }
          arg += c;
          escaped = false;
        }
        for (let i = 0; i < argString.length; i++) {
          const c = argString.charAt(i);
          if (c === '"') {
            if (!escaped) {
              inQuotes = !inQuotes;
            } else {
              append(c);
            }
            continue;
          }
          if (c === "\\" && escaped) {
            append(c);
            continue;
          }
          if (c === "\\" && inQuotes) {
            escaped = true;
            continue;
          }
          if (c === " " && !inQuotes) {
            if (arg.length > 0) {
              args.push(arg);
              arg = "";
            }
            continue;
          }
          append(c);
        }
        if (arg.length > 0) {
          args.push(arg.trim());
        }
        return args;
      }
      exports.argStringToArray = argStringToArray;
      var ExecState = class _ExecState extends events.EventEmitter {
        constructor(options, toolPath) {
          super();
          this.processClosed = false;
          this.processError = "";
          this.processExitCode = 0;
          this.processExited = false;
          this.processStderr = false;
          this.delay = 1e4;
          this.done = false;
          this.timeout = null;
          if (!toolPath) {
            throw new Error("toolPath must not be empty");
          }
          this.options = options;
          this.toolPath = toolPath;
          if (options.delay) {
            this.delay = options.delay;
          }
        }
        CheckComplete() {
          if (this.done) {
            return;
          }
          if (this.processClosed) {
            this._setResult();
          } else if (this.processExited) {
            this.timeout = timers_1.setTimeout(_ExecState.HandleTimeout, this.delay, this);
          }
        }
        _debug(message) {
          this.emit("debug", message);
        }
        _setResult() {
          let error;
          if (this.processExited) {
            if (this.processError) {
              error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
            } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
              error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
            } else if (this.processStderr && this.options.failOnStdErr) {
              error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
            }
          }
          if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }
          this.done = true;
          this.emit("done", error, this.processExitCode);
        }
        static HandleTimeout(state) {
          if (state.done) {
            return;
          }
          if (!state.processClosed && state.processExited) {
            const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
            state._debug(message);
          }
          state._setResult();
        }
      };
    }
  });

  // node_modules/@actions/exec/lib/exec.js
  var require_exec = __commonJS({
    "node_modules/@actions/exec/lib/exec.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getExecOutput = exports.exec = void 0;
      var string_decoder_1 = __require("string_decoder");
      var tr = __importStar2(require_toolrunner());
      function exec(commandLine, args, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          const commandArgs = tr.argStringToArray(commandLine);
          if (commandArgs.length === 0) {
            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
          }
          const toolPath = commandArgs[0];
          args = commandArgs.slice(1).concat(args || []);
          const runner = new tr.ToolRunner(toolPath, args, options);
          return runner.exec();
        });
      }
      exports.exec = exec;
      function getExecOutput(commandLine, args, options) {
        var _a, _b;
        return __awaiter2(this, void 0, void 0, function* () {
          let stdout = "";
          let stderr = "";
          const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
          const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
          const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
          const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
          const stdErrListener = (data) => {
            stderr += stderrDecoder.write(data);
            if (originalStdErrListener) {
              originalStdErrListener(data);
            }
          };
          const stdOutListener = (data) => {
            stdout += stdoutDecoder.write(data);
            if (originalStdoutListener) {
              originalStdoutListener(data);
            }
          };
          const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
          const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
          stdout += stdoutDecoder.end();
          stderr += stderrDecoder.end();
          return {
            exitCode,
            stdout,
            stderr
          };
        });
      }
      exports.getExecOutput = getExecOutput;
    }
  });

  // node_modules/@actions/core/lib/platform.js
  var require_platform = __commonJS({
    "node_modules/@actions/core/lib/platform.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
      var os_1 = __importDefault2(__require("os"));
      var exec = __importStar2(require_exec());
      var getWindowsInfo = () => __awaiter2(void 0, void 0, void 0, function* () {
        const { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
          silent: true
        });
        const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
          silent: true
        });
        return {
          name: name.trim(),
          version: version.trim()
        };
      });
      var getMacOsInfo = () => __awaiter2(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        const { stdout } = yield exec.getExecOutput("sw_vers", void 0, {
          silent: true
        });
        const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
        const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "";
        return {
          name,
          version
        };
      });
      var getLinuxInfo = () => __awaiter2(void 0, void 0, void 0, function* () {
        const { stdout } = yield exec.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
          silent: true
        });
        const [name, version] = stdout.trim().split("\n");
        return {
          name,
          version
        };
      });
      exports.platform = os_1.default.platform();
      exports.arch = os_1.default.arch();
      exports.isWindows = exports.platform === "win32";
      exports.isMacOS = exports.platform === "darwin";
      exports.isLinux = exports.platform === "linux";
      function getDetails() {
        return __awaiter2(this, void 0, void 0, function* () {
          return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
            platform: exports.platform,
            arch: exports.arch,
            isWindows: exports.isWindows,
            isMacOS: exports.isMacOS,
            isLinux: exports.isLinux
          });
        });
      }
      exports.getDetails = getDetails;
    }
  });

  // node_modules/@actions/core/lib/core.js
  var require_core = __commonJS({
    "node_modules/@actions/core/lib/core.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
      var command_1 = require_command();
      var file_command_1 = require_file_command();
      var utils_1 = require_utils();
      var os = __importStar2(__require("os"));
      var path = __importStar2(__require("path"));
      var oidc_utils_1 = require_oidc_utils();
      var ExitCode;
      (function(ExitCode2) {
        ExitCode2[ExitCode2["Success"] = 0] = "Success";
        ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
      })(ExitCode || (exports.ExitCode = ExitCode = {}));
      function exportVariable(name, val) {
        const convertedVal = (0, utils_1.toCommandValue)(val);
        process.env[name] = convertedVal;
        const filePath = process.env["GITHUB_ENV"] || "";
        if (filePath) {
          return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
        }
        (0, command_1.issueCommand)("set-env", { name }, convertedVal);
      }
      exports.exportVariable = exportVariable;
      function setSecret(secret) {
        (0, command_1.issueCommand)("add-mask", {}, secret);
      }
      exports.setSecret = setSecret;
      function addPath(inputPath) {
        const filePath = process.env["GITHUB_PATH"] || "";
        if (filePath) {
          (0, file_command_1.issueFileCommand)("PATH", inputPath);
        } else {
          (0, command_1.issueCommand)("add-path", {}, inputPath);
        }
        process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
      }
      exports.addPath = addPath;
      function getInput2(name, options) {
        const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
        if (options && options.required && !val) {
          throw new Error(`Input required and not supplied: ${name}`);
        }
        if (options && options.trimWhitespace === false) {
          return val;
        }
        return val.trim();
      }
      exports.getInput = getInput2;
      function getMultilineInput(name, options) {
        const inputs = getInput2(name, options).split("\n").filter((x) => x !== "");
        if (options && options.trimWhitespace === false) {
          return inputs;
        }
        return inputs.map((input2) => input2.trim());
      }
      exports.getMultilineInput = getMultilineInput;
      function getBooleanInput(name, options) {
        const trueValue = ["true", "True", "TRUE"];
        const falseValue = ["false", "False", "FALSE"];
        const val = getInput2(name, options);
        if (trueValue.includes(val))
          return true;
        if (falseValue.includes(val))
          return false;
        throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
      }
      exports.getBooleanInput = getBooleanInput;
      function setOutput(name, value) {
        const filePath = process.env["GITHUB_OUTPUT"] || "";
        if (filePath) {
          return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
        }
        process.stdout.write(os.EOL);
        (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
      }
      exports.setOutput = setOutput;
      function setCommandEcho(enabled) {
        (0, command_1.issue)("echo", enabled ? "on" : "off");
      }
      exports.setCommandEcho = setCommandEcho;
      function setFailed(message) {
        process.exitCode = ExitCode.Failure;
        error(message);
      }
      exports.setFailed = setFailed;
      function isDebug() {
        return process.env["RUNNER_DEBUG"] === "1";
      }
      exports.isDebug = isDebug;
      function debug(message) {
        (0, command_1.issueCommand)("debug", {}, message);
      }
      exports.debug = debug;
      function error(message, properties = {}) {
        (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
      }
      exports.error = error;
      function warning(message, properties = {}) {
        (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
      }
      exports.warning = warning;
      function notice(message, properties = {}) {
        (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
      }
      exports.notice = notice;
      function info(message) {
        process.stdout.write(message + os.EOL);
      }
      exports.info = info;
      function startGroup(name) {
        (0, command_1.issue)("group", name);
      }
      exports.startGroup = startGroup;
      function endGroup() {
        (0, command_1.issue)("endgroup");
      }
      exports.endGroup = endGroup;
      function group(name, fn) {
        return __awaiter2(this, void 0, void 0, function* () {
          startGroup(name);
          let result;
          try {
            result = yield fn();
          } finally {
            endGroup();
          }
          return result;
        });
      }
      exports.group = group;
      function saveState(name, value) {
        const filePath = process.env["GITHUB_STATE"] || "";
        if (filePath) {
          return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
        }
        (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
      }
      exports.saveState = saveState;
      function getState2(name) {
        return process.env[`STATE_${name}`] || "";
      }
      exports.getState = getState2;
      function getIDToken(aud) {
        return __awaiter2(this, void 0, void 0, function* () {
          return yield oidc_utils_1.OidcClient.getIDToken(aud);
        });
      }
      exports.getIDToken = getIDToken;
      var summary_1 = require_summary();
      Object.defineProperty(exports, "summary", { enumerable: true, get: function() {
        return summary_1.summary;
      } });
      var summary_2 = require_summary();
      Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function() {
        return summary_2.markdownSummary;
      } });
      var path_utils_1 = require_path_utils();
      Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function() {
        return path_utils_1.toPosixPath;
      } });
      Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function() {
        return path_utils_1.toWin32Path;
      } });
      Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function() {
        return path_utils_1.toPlatformPath;
      } });
      exports.platform = __importStar2(require_platform());
    }
  });

  // node_modules/@actions/github/lib/context.js
  var require_context = __commonJS({
    "node_modules/@actions/github/lib/context.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Context = void 0;
      var fs_1 = __require("fs");
      var os_1 = __require("os");
      var Context = class {
        /**
         * Hydrate the context from the environment
         */
        constructor() {
          var _a, _b, _c;
          this.payload = {};
          if (process.env.GITHUB_EVENT_PATH) {
            if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH)) {
              this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
            } else {
              const path = process.env.GITHUB_EVENT_PATH;
              process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
            }
          }
          this.eventName = process.env.GITHUB_EVENT_NAME;
          this.sha = process.env.GITHUB_SHA;
          this.ref = process.env.GITHUB_REF;
          this.workflow = process.env.GITHUB_WORKFLOW;
          this.action = process.env.GITHUB_ACTION;
          this.actor = process.env.GITHUB_ACTOR;
          this.job = process.env.GITHUB_JOB;
          this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
          this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
          this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
          this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
          this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
        }
        get issue() {
          const payload = this.payload;
          return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
        }
        get repo() {
          if (process.env.GITHUB_REPOSITORY) {
            const [owner2, repo2] = process.env.GITHUB_REPOSITORY.split("/");
            return { owner: owner2, repo: repo2 };
          }
          if (this.payload.repository) {
            return {
              owner: this.payload.repository.owner.login,
              repo: this.payload.repository.name
            };
          }
          throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
        }
      };
      exports.Context = Context;
    }
  });

  // node_modules/@actions/github/lib/internal/utils.js
  var require_utils3 = __commonJS({
    "node_modules/@actions/github/lib/internal/utils.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getApiBaseUrl = exports.getProxyFetch = exports.getProxyAgentDispatcher = exports.getProxyAgent = exports.getAuthString = void 0;
      var httpClient = __importStar2(require_lib());
      var undici_1 = require_undici();
      function getAuthString(token2, options) {
        if (!token2 && !options.auth) {
          throw new Error("Parameter token or opts.auth is required");
        } else if (token2 && options.auth) {
          throw new Error("Parameters token and opts.auth may not both be specified");
        }
        return typeof options.auth === "string" ? options.auth : `token ${token2}`;
      }
      exports.getAuthString = getAuthString;
      function getProxyAgent(destinationUrl) {
        const hc = new httpClient.HttpClient();
        return hc.getAgent(destinationUrl);
      }
      exports.getProxyAgent = getProxyAgent;
      function getProxyAgentDispatcher(destinationUrl) {
        const hc = new httpClient.HttpClient();
        return hc.getAgentDispatcher(destinationUrl);
      }
      exports.getProxyAgentDispatcher = getProxyAgentDispatcher;
      function getProxyFetch(destinationUrl) {
        const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
        const proxyFetch = (url, opts) => __awaiter2(this, void 0, void 0, function* () {
          return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
        });
        return proxyFetch;
      }
      exports.getProxyFetch = getProxyFetch;
      function getApiBaseUrl() {
        return process.env["GITHUB_API_URL"] || "https://api.github.com";
      }
      exports.getApiBaseUrl = getApiBaseUrl;
    }
  });

  // node_modules/universal-user-agent/dist-node/index.js
  var require_dist_node = __commonJS({
    "node_modules/universal-user-agent/dist-node/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function getUserAgent3() {
        if (typeof navigator === "object" && "userAgent" in navigator) {
          return navigator.userAgent;
        }
        if (typeof process === "object" && process.version !== void 0) {
          return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
        }
        return "<environment undetectable>";
      }
      exports.getUserAgent = getUserAgent3;
    }
  });

  // node_modules/before-after-hook/lib/register.js
  var require_register = __commonJS({
    "node_modules/before-after-hook/lib/register.js"(exports, module) {
      module.exports = register;
      function register(state, name, method, options) {
        if (typeof method !== "function") {
          throw new Error("method for before hook must be a function");
        }
        if (!options) {
          options = {};
        }
        if (Array.isArray(name)) {
          return name.reverse().reduce(function(callback, name2) {
            return register.bind(null, state, name2, callback, options);
          }, method)();
        }
        return Promise.resolve().then(function() {
          if (!state.registry[name]) {
            return method(options);
          }
          return state.registry[name].reduce(function(method2, registered) {
            return registered.hook.bind(null, method2, options);
          }, method)();
        });
      }
    }
  });

  // node_modules/before-after-hook/lib/add.js
  var require_add = __commonJS({
    "node_modules/before-after-hook/lib/add.js"(exports, module) {
      module.exports = addHook;
      function addHook(state, kind, name, hook2) {
        var orig = hook2;
        if (!state.registry[name]) {
          state.registry[name] = [];
        }
        if (kind === "before") {
          hook2 = function(method, options) {
            return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
          };
        }
        if (kind === "after") {
          hook2 = function(method, options) {
            var result;
            return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
              result = result_;
              return orig(result, options);
            }).then(function() {
              return result;
            });
          };
        }
        if (kind === "error") {
          hook2 = function(method, options) {
            return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
              return orig(error, options);
            });
          };
        }
        state.registry[name].push({
          hook: hook2,
          orig
        });
      }
    }
  });

  // node_modules/before-after-hook/lib/remove.js
  var require_remove = __commonJS({
    "node_modules/before-after-hook/lib/remove.js"(exports, module) {
      module.exports = removeHook;
      function removeHook(state, name, method) {
        if (!state.registry[name]) {
          return;
        }
        var index = state.registry[name].map(function(registered) {
          return registered.orig;
        }).indexOf(method);
        if (index === -1) {
          return;
        }
        state.registry[name].splice(index, 1);
      }
    }
  });

  // node_modules/before-after-hook/index.js
  var require_before_after_hook = __commonJS({
    "node_modules/before-after-hook/index.js"(exports, module) {
      var register = require_register();
      var addHook = require_add();
      var removeHook = require_remove();
      var bind = Function.bind;
      var bindable = bind.bind(bind);
      function bindApi(hook2, state, name) {
        var removeHookRef = bindable(removeHook, null).apply(
          null,
          name ? [state, name] : [state]
        );
        hook2.api = { remove: removeHookRef };
        hook2.remove = removeHookRef;
        ["before", "error", "after", "wrap"].forEach(function(kind) {
          var args = name ? [state, kind, name] : [state, kind];
          hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
        });
      }
      function HookSingular() {
        var singularHookName = "h";
        var singularHookState = {
          registry: {}
        };
        var singularHook = register.bind(null, singularHookState, singularHookName);
        bindApi(singularHook, singularHookState, singularHookName);
        return singularHook;
      }
      function HookCollection() {
        var state = {
          registry: {}
        };
        var hook2 = register.bind(null, state);
        bindApi(hook2, state);
        return hook2;
      }
      var collectionHookDeprecationMessageDisplayed = false;
      function Hook() {
        if (!collectionHookDeprecationMessageDisplayed) {
          console.warn(
            '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
          );
          collectionHookDeprecationMessageDisplayed = true;
        }
        return HookCollection();
      }
      Hook.Singular = HookSingular.bind();
      Hook.Collection = HookCollection.bind();
      module.exports = Hook;
      module.exports.Hook = Hook;
      module.exports.Singular = Hook.Singular;
      module.exports.Collection = Hook.Collection;
    }
  });

  // node_modules/@octokit/endpoint/dist-web/index.js
  function lowercaseKeys(object) {
    if (!object) {
      return {};
    }
    return Object.keys(object).reduce((newObj, key) => {
      newObj[key.toLowerCase()] = object[key];
      return newObj;
    }, {});
  }
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
      return false;
    if (Object.prototype.toString.call(value) !== "[object Object]")
      return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null)
      return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
  }
  function mergeDeep(defaults, options) {
    const result = Object.assign({}, defaults);
    Object.keys(options).forEach((key) => {
      if (isPlainObject(options[key])) {
        if (!(key in defaults))
          Object.assign(result, { [key]: options[key] });
        else
          result[key] = mergeDeep(defaults[key], options[key]);
      } else {
        Object.assign(result, { [key]: options[key] });
      }
    });
    return result;
  }
  function removeUndefinedProperties(obj) {
    for (const key in obj) {
      if (obj[key] === void 0) {
        delete obj[key];
      }
    }
    return obj;
  }
  function merge(defaults, route, options) {
    if (typeof route === "string") {
      let [method, url] = route.split(" ");
      options = Object.assign(url ? { method, url } : { url: method }, options);
    } else {
      options = Object.assign({}, route);
    }
    options.headers = lowercaseKeys(options.headers);
    removeUndefinedProperties(options);
    removeUndefinedProperties(options.headers);
    const mergedOptions = mergeDeep(defaults || {}, options);
    if (options.url === "/graphql") {
      if (defaults && defaults.mediaType.previews?.length) {
        mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
          (preview) => !mergedOptions.mediaType.previews.includes(preview)
        ).concat(mergedOptions.mediaType.previews);
      }
      mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
    }
    return mergedOptions;
  }
  function addQueryParameters(url, parameters) {
    const separator = /\?/.test(url) ? "&" : "?";
    const names = Object.keys(parameters);
    if (names.length === 0) {
      return url;
    }
    return url + separator + names.map((name) => {
      if (name === "q") {
        return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
      }
      return `${name}=${encodeURIComponent(parameters[name])}`;
    }).join("&");
  }
  function removeNonChars(variableName) {
    return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
  }
  function extractUrlVariableNames(url) {
    const matches = url.match(urlVariableRegex);
    if (!matches) {
      return [];
    }
    return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
  }
  function omit(object, keysToOmit) {
    const result = { __proto__: null };
    for (const key of Object.keys(object)) {
      if (keysToOmit.indexOf(key) === -1) {
        result[key] = object[key];
      }
    }
    return result;
  }
  function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
      if (!/%[0-9A-Fa-f]/.test(part)) {
        part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
      }
      return part;
    }).join("");
  }
  function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeValue(operator, value, key) {
    value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
    if (key) {
      return encodeUnreserved(key) + "=" + value;
    } else {
      return value;
    }
  }
  function isDefined(value) {
    return value !== void 0 && value !== null;
  }
  function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
  }
  function getValues(context2, operator, key, modifier) {
    var value = context2[key], result = [];
    if (isDefined(value) && value !== "") {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
        if (modifier && modifier !== "*") {
          value = value.substring(0, parseInt(modifier, 10));
        }
        result.push(
          encodeValue(operator, value, isKeyOperator(operator) ? key : "")
        );
      } else {
        if (modifier === "*") {
          if (Array.isArray(value)) {
            value.filter(isDefined).forEach(function(value2) {
              result.push(
                encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
              );
            });
          } else {
            Object.keys(value).forEach(function(k) {
              if (isDefined(value[k])) {
                result.push(encodeValue(operator, value[k], k));
              }
            });
          }
        } else {
          const tmp = [];
          if (Array.isArray(value)) {
            value.filter(isDefined).forEach(function(value2) {
              tmp.push(encodeValue(operator, value2));
            });
          } else {
            Object.keys(value).forEach(function(k) {
              if (isDefined(value[k])) {
                tmp.push(encodeUnreserved(k));
                tmp.push(encodeValue(operator, value[k].toString()));
              }
            });
          }
          if (isKeyOperator(operator)) {
            result.push(encodeUnreserved(key) + "=" + tmp.join(","));
          } else if (tmp.length !== 0) {
            result.push(tmp.join(","));
          }
        }
      }
    } else {
      if (operator === ";") {
        if (isDefined(value)) {
          result.push(encodeUnreserved(key));
        }
      } else if (value === "" && (operator === "&" || operator === "?")) {
        result.push(encodeUnreserved(key) + "=");
      } else if (value === "") {
        result.push("");
      }
    }
    return result;
  }
  function parseUrl(template) {
    return {
      expand: expand.bind(null, template)
    };
  }
  function expand(template, context2) {
    var operators = ["+", "#", ".", "/", ";", "?", "&"];
    template = template.replace(
      /\{([^\{\}]+)\}|([^\{\}]+)/g,
      function(_, expression, literal) {
        if (expression) {
          let operator = "";
          const values = [];
          if (operators.indexOf(expression.charAt(0)) !== -1) {
            operator = expression.charAt(0);
            expression = expression.substr(1);
          }
          expression.split(/,/g).forEach(function(variable) {
            var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
            values.push(getValues(context2, operator, tmp[1], tmp[2] || tmp[3]));
          });
          if (operator && operator !== "+") {
            var separator = ",";
            if (operator === "?") {
              separator = "&";
            } else if (operator !== "#") {
              separator = operator;
            }
            return (values.length !== 0 ? operator : "") + values.join(separator);
          } else {
            return values.join(",");
          }
        } else {
          return encodeReserved(literal);
        }
      }
    );
    if (template === "/") {
      return template;
    } else {
      return template.replace(/\/$/, "");
    }
  }
  function parse(options) {
    let method = options.method.toUpperCase();
    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
    let headers = Object.assign({}, options.headers);
    let body;
    let parameters = omit(options, [
      "method",
      "baseUrl",
      "url",
      "headers",
      "request",
      "mediaType"
    ]);
    const urlVariableNames = extractUrlVariableNames(url);
    url = parseUrl(url).expand(parameters);
    if (!/^http/.test(url)) {
      url = options.baseUrl + url;
    }
    const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
    const remainingParameters = omit(parameters, omittedParameters);
    const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
    if (!isBinaryRequest) {
      if (options.mediaType.format) {
        headers.accept = headers.accept.split(/,/).map(
          (format) => format.replace(
            /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
            `application/vnd$1$2.${options.mediaType.format}`
          )
        ).join(",");
      }
      if (url.endsWith("/graphql")) {
        if (options.mediaType.previews?.length) {
          const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
          headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
            const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
            return `application/vnd.github.${preview}-preview${format}`;
          }).join(",");
        }
      }
    }
    if (["GET", "HEAD"].includes(method)) {
      url = addQueryParameters(url, remainingParameters);
    } else {
      if ("data" in remainingParameters) {
        body = remainingParameters.data;
      } else {
        if (Object.keys(remainingParameters).length) {
          body = remainingParameters;
        }
      }
    }
    if (!headers["content-type"] && typeof body !== "undefined") {
      headers["content-type"] = "application/json; charset=utf-8";
    }
    if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
      body = "";
    }
    return Object.assign(
      { method, url, headers },
      typeof body !== "undefined" ? { body } : null,
      options.request ? { request: options.request } : null
    );
  }
  function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
  }
  function withDefaults(oldDefaults, newDefaults) {
    const DEFAULTS2 = merge(oldDefaults, newDefaults);
    const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
    return Object.assign(endpoint2, {
      DEFAULTS: DEFAULTS2,
      defaults: withDefaults.bind(null, DEFAULTS2),
      merge: merge.bind(null, DEFAULTS2),
      parse
    });
  }
  var import_universal_user_agent, VERSION, userAgent, DEFAULTS, urlVariableRegex, endpoint;
  var init_dist_web = __esm({
    "node_modules/@octokit/endpoint/dist-web/index.js"() {
      import_universal_user_agent = __toESM(require_dist_node());
      VERSION = "9.0.5";
      userAgent = `octokit-endpoint.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`;
      DEFAULTS = {
        method: "GET",
        baseUrl: "https://api.github.com",
        headers: {
          accept: "application/vnd.github.v3+json",
          "user-agent": userAgent
        },
        mediaType: {
          format: ""
        }
      };
      urlVariableRegex = /\{[^}]+\}/g;
      endpoint = withDefaults(null, DEFAULTS);
    }
  });

  // node_modules/deprecation/dist-web/index.js
  var Deprecation;
  var init_dist_web2 = __esm({
    "node_modules/deprecation/dist-web/index.js"() {
      Deprecation = class extends Error {
        constructor(message) {
          super(message);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
          this.name = "Deprecation";
        }
      };
    }
  });

  // node_modules/wrappy/wrappy.js
  var require_wrappy = __commonJS({
    "node_modules/wrappy/wrappy.js"(exports, module) {
      module.exports = wrappy;
      function wrappy(fn, cb) {
        if (fn && cb) return wrappy(fn)(cb);
        if (typeof fn !== "function")
          throw new TypeError("need wrapper function");
        Object.keys(fn).forEach(function(k) {
          wrapper[k] = fn[k];
        });
        return wrapper;
        function wrapper() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          var ret = fn.apply(this, args);
          var cb2 = args[args.length - 1];
          if (typeof ret === "function" && ret !== cb2) {
            Object.keys(cb2).forEach(function(k) {
              ret[k] = cb2[k];
            });
          }
          return ret;
        }
      }
    }
  });

  // node_modules/once/once.js
  var require_once = __commonJS({
    "node_modules/once/once.js"(exports, module) {
      var wrappy = require_wrappy();
      module.exports = wrappy(once2);
      module.exports.strict = wrappy(onceStrict);
      once2.proto = once2(function() {
        Object.defineProperty(Function.prototype, "once", {
          value: function() {
            return once2(this);
          },
          configurable: true
        });
        Object.defineProperty(Function.prototype, "onceStrict", {
          value: function() {
            return onceStrict(this);
          },
          configurable: true
        });
      });
      function once2(fn) {
        var f = function() {
          if (f.called) return f.value;
          f.called = true;
          return f.value = fn.apply(this, arguments);
        };
        f.called = false;
        return f;
      }
      function onceStrict(fn) {
        var f = function() {
          if (f.called)
            throw new Error(f.onceError);
          f.called = true;
          return f.value = fn.apply(this, arguments);
        };
        var name = fn.name || "Function wrapped with `once`";
        f.onceError = name + " shouldn't be called more than once";
        f.called = false;
        return f;
      }
    }
  });

  // node_modules/@octokit/request/node_modules/@octokit/request-error/dist-web/index.js
  var import_once, logOnceCode, logOnceHeaders, RequestError;
  var init_dist_web3 = __esm({
    "node_modules/@octokit/request/node_modules/@octokit/request-error/dist-web/index.js"() {
      init_dist_web2();
      import_once = __toESM(require_once());
      logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
      logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
      RequestError = class extends Error {
        constructor(message, statusCode, options) {
          super(message);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
          this.name = "HttpError";
          this.status = statusCode;
          let headers;
          if ("headers" in options && typeof options.headers !== "undefined") {
            headers = options.headers;
          }
          if ("response" in options) {
            this.response = options.response;
            headers = options.response.headers;
          }
          const requestCopy = Object.assign({}, options.request);
          if (options.request.headers.authorization) {
            requestCopy.headers = Object.assign({}, options.request.headers, {
              authorization: options.request.headers.authorization.replace(
                / .*$/,
                " [REDACTED]"
              )
            });
          }
          requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
          this.request = requestCopy;
          Object.defineProperty(this, "code", {
            get() {
              logOnceCode(
                new Deprecation(
                  "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
                )
              );
              return statusCode;
            }
          });
          Object.defineProperty(this, "headers", {
            get() {
              logOnceHeaders(
                new Deprecation(
                  "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
                )
              );
              return headers || {};
            }
          });
        }
      };
    }
  });

  // node_modules/@octokit/request/dist-web/index.js
  var dist_web_exports = {};
  __export(dist_web_exports, {
    request: () => request
  });
  function isPlainObject2(value) {
    if (typeof value !== "object" || value === null)
      return false;
    if (Object.prototype.toString.call(value) !== "[object Object]")
      return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null)
      return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
  }
  function getBufferResponse(response) {
    return response.arrayBuffer();
  }
  function fetchWrapper(requestOptions) {
    const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
    const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
    if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
      requestOptions.body = JSON.stringify(requestOptions.body);
    }
    let headers = {};
    let status;
    let url;
    let { fetch: fetch2 } = globalThis;
    if (requestOptions.request?.fetch) {
      fetch2 = requestOptions.request.fetch;
    }
    if (!fetch2) {
      throw new Error(
        "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
      );
    }
    return fetch2(requestOptions.url, {
      method: requestOptions.method,
      body: requestOptions.body,
      redirect: requestOptions.request?.redirect,
      headers: requestOptions.headers,
      signal: requestOptions.request?.signal,
      // duplex must be set if request.body is ReadableStream or Async Iterables.
      // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
      ...requestOptions.body && { duplex: "half" }
    }).then(async (response) => {
      url = response.url;
      status = response.status;
      for (const keyAndValue of response.headers) {
        headers[keyAndValue[0]] = keyAndValue[1];
      }
      if ("deprecation" in headers) {
        const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
        const deprecationLink = matches && matches.pop();
        log.warn(
          `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
        );
      }
      if (status === 204 || status === 205) {
        return;
      }
      if (requestOptions.method === "HEAD") {
        if (status < 400) {
          return;
        }
        throw new RequestError(response.statusText, status, {
          response: {
            url,
            status,
            headers,
            data: void 0
          },
          request: requestOptions
        });
      }
      if (status === 304) {
        throw new RequestError("Not modified", status, {
          response: {
            url,
            status,
            headers,
            data: await getResponseData(response)
          },
          request: requestOptions
        });
      }
      if (status >= 400) {
        const data = await getResponseData(response);
        const error = new RequestError(toErrorMessage(data), status, {
          response: {
            url,
            status,
            headers,
            data
          },
          request: requestOptions
        });
        throw error;
      }
      return parseSuccessResponseBody ? await getResponseData(response) : response.body;
    }).then((data) => {
      return {
        status,
        url,
        headers,
        data
      };
    }).catch((error) => {
      if (error instanceof RequestError)
        throw error;
      else if (error.name === "AbortError")
        throw error;
      let message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
      throw new RequestError(message, 500, {
        request: requestOptions
      });
    });
  }
  async function getResponseData(response) {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
      return response.json().catch(() => response.text()).catch(() => "");
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
      return response.text();
    }
    return getBufferResponse(response);
  }
  function toErrorMessage(data) {
    if (typeof data === "string")
      return data;
    let suffix;
    if ("documentation_url" in data) {
      suffix = ` - ${data.documentation_url}`;
    } else {
      suffix = "";
    }
    if ("message" in data) {
      if (Array.isArray(data.errors)) {
        return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
      }
      return `${data.message}${suffix}`;
    }
    return `Unknown error: ${JSON.stringify(data)}`;
  }
  function withDefaults2(oldEndpoint, newDefaults) {
    const endpoint2 = oldEndpoint.defaults(newDefaults);
    const newApi = function(route, parameters) {
      const endpointOptions = endpoint2.merge(route, parameters);
      if (!endpointOptions.request || !endpointOptions.request.hook) {
        return fetchWrapper(endpoint2.parse(endpointOptions));
      }
      const request2 = (route2, parameters2) => {
        return fetchWrapper(
          endpoint2.parse(endpoint2.merge(route2, parameters2))
        );
      };
      Object.assign(request2, {
        endpoint: endpoint2,
        defaults: withDefaults2.bind(null, endpoint2)
      });
      return endpointOptions.request.hook(request2, endpointOptions);
    };
    return Object.assign(newApi, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
  }
  var import_universal_user_agent2, VERSION2, request;
  var init_dist_web4 = __esm({
    "node_modules/@octokit/request/dist-web/index.js"() {
      init_dist_web();
      import_universal_user_agent2 = __toESM(require_dist_node());
      init_dist_web3();
      VERSION2 = "8.4.0";
      request = withDefaults2(endpoint, {
        headers: {
          "user-agent": `octokit-request.js/${VERSION2} ${(0, import_universal_user_agent2.getUserAgent)()}`
        }
      });
    }
  });

  // node_modules/@octokit/graphql/dist-node/index.js
  var require_dist_node2 = __commonJS({
    "node_modules/@octokit/graphql/dist-node/index.js"(exports, module) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var dist_src_exports = {};
      __export2(dist_src_exports, {
        GraphqlResponseError: () => GraphqlResponseError,
        graphql: () => graphql2,
        withCustomRequest: () => withCustomRequest
      });
      module.exports = __toCommonJS2(dist_src_exports);
      var import_request3 = (init_dist_web4(), __toCommonJS(dist_web_exports));
      var import_universal_user_agent3 = require_dist_node();
      var VERSION4 = "7.1.0";
      var import_request2 = (init_dist_web4(), __toCommonJS(dist_web_exports));
      var import_request = (init_dist_web4(), __toCommonJS(dist_web_exports));
      function _buildMessageForResponseErrors(data) {
        return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
      }
      var GraphqlResponseError = class extends Error {
        constructor(request2, headers, response) {
          super(_buildMessageForResponseErrors(response));
          this.request = request2;
          this.headers = headers;
          this.response = response;
          this.name = "GraphqlResponseError";
          this.errors = response.errors;
          this.data = response.data;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        }
      };
      var NON_VARIABLE_OPTIONS = [
        "method",
        "baseUrl",
        "url",
        "headers",
        "request",
        "query",
        "mediaType"
      ];
      var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
      var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
      function graphql(request2, query, options) {
        if (options) {
          if (typeof query === "string" && "query" in options) {
            return Promise.reject(
              new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
            );
          }
          for (const key in options) {
            if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
              continue;
            return Promise.reject(
              new Error(
                `[@octokit/graphql] "${key}" cannot be used as variable name`
              )
            );
          }
        }
        const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
        const requestOptions = Object.keys(
          parsedOptions
        ).reduce((result, key) => {
          if (NON_VARIABLE_OPTIONS.includes(key)) {
            result[key] = parsedOptions[key];
            return result;
          }
          if (!result.variables) {
            result.variables = {};
          }
          result.variables[key] = parsedOptions[key];
          return result;
        }, {});
        const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
        if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
          requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
        }
        return request2(requestOptions).then((response) => {
          if (response.data.errors) {
            const headers = {};
            for (const key of Object.keys(response.headers)) {
              headers[key] = response.headers[key];
            }
            throw new GraphqlResponseError(
              requestOptions,
              headers,
              response.data
            );
          }
          return response.data.data;
        });
      }
      function withDefaults3(request2, newDefaults) {
        const newRequest = request2.defaults(newDefaults);
        const newApi = (query, options) => {
          return graphql(newRequest, query, options);
        };
        return Object.assign(newApi, {
          defaults: withDefaults3.bind(null, newRequest),
          endpoint: newRequest.endpoint
        });
      }
      var graphql2 = withDefaults3(import_request3.request, {
        headers: {
          "user-agent": `octokit-graphql.js/${VERSION4} ${(0, import_universal_user_agent3.getUserAgent)()}`
        },
        method: "POST",
        url: "/graphql"
      });
      function withCustomRequest(customRequest) {
        return withDefaults3(customRequest, {
          method: "POST",
          url: "/graphql"
        });
      }
    }
  });

  // node_modules/@octokit/auth-token/dist-web/index.js
  var dist_web_exports2 = {};
  __export(dist_web_exports2, {
    createTokenAuth: () => createTokenAuth
  });
  async function auth(token2) {
    const isApp = token2.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token2) || REGEX_IS_INSTALLATION.test(token2);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token2);
    const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
    return {
      type: "token",
      token: token2,
      tokenType
    };
  }
  function withAuthorizationPrefix(token2) {
    if (token2.split(/\./).length === 3) {
      return `bearer ${token2}`;
    }
    return `token ${token2}`;
  }
  async function hook(token2, request2, route, parameters) {
    const endpoint2 = request2.endpoint.merge(
      route,
      parameters
    );
    endpoint2.headers.authorization = withAuthorizationPrefix(token2);
    return request2(endpoint2);
  }
  var REGEX_IS_INSTALLATION_LEGACY, REGEX_IS_INSTALLATION, REGEX_IS_USER_TO_SERVER, createTokenAuth;
  var init_dist_web5 = __esm({
    "node_modules/@octokit/auth-token/dist-web/index.js"() {
      REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
      REGEX_IS_INSTALLATION = /^ghs_/;
      REGEX_IS_USER_TO_SERVER = /^ghu_/;
      createTokenAuth = function createTokenAuth2(token2) {
        if (!token2) {
          throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
        }
        if (typeof token2 !== "string") {
          throw new Error(
            "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
          );
        }
        token2 = token2.replace(/^(token|bearer) +/i, "");
        return Object.assign(auth.bind(null, token2), {
          hook: hook.bind(null, token2)
        });
      };
    }
  });

  // node_modules/@octokit/core/dist-node/index.js
  var require_dist_node3 = __commonJS({
    "node_modules/@octokit/core/dist-node/index.js"(exports, module) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var dist_src_exports = {};
      __export2(dist_src_exports, {
        Octokit: () => Octokit
      });
      module.exports = __toCommonJS2(dist_src_exports);
      var import_universal_user_agent3 = require_dist_node();
      var import_before_after_hook = require_before_after_hook();
      var import_request = (init_dist_web4(), __toCommonJS(dist_web_exports));
      var import_graphql = require_dist_node2();
      var import_auth_token = (init_dist_web5(), __toCommonJS(dist_web_exports2));
      var VERSION4 = "5.2.0";
      var noop = () => {
      };
      var consoleWarn = console.warn.bind(console);
      var consoleError = console.error.bind(console);
      var userAgentTrail = `octokit-core.js/${VERSION4} ${(0, import_universal_user_agent3.getUserAgent)()}`;
      var Octokit = class {
        static {
          this.VERSION = VERSION4;
        }
        static defaults(defaults) {
          const OctokitWithDefaults = class extends this {
            constructor(...args) {
              const options = args[0] || {};
              if (typeof defaults === "function") {
                super(defaults(options));
                return;
              }
              super(
                Object.assign(
                  {},
                  defaults,
                  options,
                  options.userAgent && defaults.userAgent ? {
                    userAgent: `${options.userAgent} ${defaults.userAgent}`
                  } : null
                )
              );
            }
          };
          return OctokitWithDefaults;
        }
        static {
          this.plugins = [];
        }
        /**
         * Attach a plugin (or many) to your Octokit instance.
         *
         * @example
         * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
         */
        static plugin(...newPlugins) {
          const currentPlugins = this.plugins;
          const NewOctokit = class extends this {
            static {
              this.plugins = currentPlugins.concat(
                newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
              );
            }
          };
          return NewOctokit;
        }
        constructor(options = {}) {
          const hook2 = new import_before_after_hook.Collection();
          const requestDefaults = {
            baseUrl: import_request.request.endpoint.DEFAULTS.baseUrl,
            headers: {},
            request: Object.assign({}, options.request, {
              // @ts-ignore internal usage only, no need to type
              hook: hook2.bind(null, "request")
            }),
            mediaType: {
              previews: [],
              format: ""
            }
          };
          requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
          if (options.baseUrl) {
            requestDefaults.baseUrl = options.baseUrl;
          }
          if (options.previews) {
            requestDefaults.mediaType.previews = options.previews;
          }
          if (options.timeZone) {
            requestDefaults.headers["time-zone"] = options.timeZone;
          }
          this.request = import_request.request.defaults(requestDefaults);
          this.graphql = (0, import_graphql.withCustomRequest)(this.request).defaults(requestDefaults);
          this.log = Object.assign(
            {
              debug: noop,
              info: noop,
              warn: consoleWarn,
              error: consoleError
            },
            options.log
          );
          this.hook = hook2;
          if (!options.authStrategy) {
            if (!options.auth) {
              this.auth = async () => ({
                type: "unauthenticated"
              });
            } else {
              const auth2 = (0, import_auth_token.createTokenAuth)(options.auth);
              hook2.wrap("request", auth2.hook);
              this.auth = auth2;
            }
          } else {
            const { authStrategy, ...otherOptions } = options;
            const auth2 = authStrategy(
              Object.assign(
                {
                  request: this.request,
                  log: this.log,
                  // we pass the current octokit instance as well as its constructor options
                  // to allow for authentication strategies that return a new octokit instance
                  // that shares the same internal state as the current one. The original
                  // requirement for this was the "event-octokit" authentication strategy
                  // of https://github.com/probot/octokit-auth-probot.
                  octokit: this,
                  octokitOptions: otherOptions
                },
                options.auth
              )
            );
            hook2.wrap("request", auth2.hook);
            this.auth = auth2;
          }
          const classConstructor = this.constructor;
          for (let i = 0; i < classConstructor.plugins.length; ++i) {
            Object.assign(this, classConstructor.plugins[i](this, options));
          }
        }
      };
    }
  });

  // node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js
  var dist_web_exports3 = {};
  __export(dist_web_exports3, {
    legacyRestEndpointMethods: () => legacyRestEndpointMethods,
    restEndpointMethods: () => restEndpointMethods
  });
  function endpointsToMethods(octokit2) {
    const newMethods = {};
    for (const scope of endpointMethodsMap.keys()) {
      newMethods[scope] = new Proxy({ octokit: octokit2, scope, cache: {} }, handler);
    }
    return newMethods;
  }
  function decorate(octokit2, scope, methodName, defaults, decorations) {
    const requestWithDefaults = octokit2.request.defaults(defaults);
    function withDecorations(...args) {
      let options = requestWithDefaults.endpoint.merge(...args);
      if (decorations.mapToData) {
        options = Object.assign({}, options, {
          data: options[decorations.mapToData],
          [decorations.mapToData]: void 0
        });
        return requestWithDefaults(options);
      }
      if (decorations.renamed) {
        const [newScope, newMethodName] = decorations.renamed;
        octokit2.log.warn(
          `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
        );
      }
      if (decorations.deprecated) {
        octokit2.log.warn(decorations.deprecated);
      }
      if (decorations.renamedParameters) {
        const options2 = requestWithDefaults.endpoint.merge(...args);
        for (const [name, alias] of Object.entries(
          decorations.renamedParameters
        )) {
          if (name in options2) {
            octokit2.log.warn(
              `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
            );
            if (!(alias in options2)) {
              options2[alias] = options2[name];
            }
            delete options2[name];
          }
        }
        return requestWithDefaults(options2);
      }
      return requestWithDefaults(...args);
    }
    return Object.assign(withDecorations, requestWithDefaults);
  }
  function restEndpointMethods(octokit2) {
    const api = endpointsToMethods(octokit2);
    return {
      rest: api
    };
  }
  function legacyRestEndpointMethods(octokit2) {
    const api = endpointsToMethods(octokit2);
    return {
      ...api,
      rest: api
    };
  }
  var VERSION3, Endpoints, endpoints_default, endpointMethodsMap, handler;
  var init_dist_web6 = __esm({
    "node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js"() {
      VERSION3 = "10.4.1";
      Endpoints = {
        actions: {
          addCustomLabelsToSelfHostedRunnerForOrg: [
            "POST /orgs/{org}/actions/runners/{runner_id}/labels"
          ],
          addCustomLabelsToSelfHostedRunnerForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
          ],
          addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
          ],
          addSelectedRepoToOrgVariable: [
            "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
          ],
          approveWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
          ],
          cancelWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
          ],
          createEnvironmentVariable: [
            "POST /repositories/{repository_id}/environments/{environment_name}/variables"
          ],
          createOrUpdateEnvironmentSecret: [
            "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
          ],
          createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
          createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
          ],
          createOrgVariable: ["POST /orgs/{org}/actions/variables"],
          createRegistrationTokenForOrg: [
            "POST /orgs/{org}/actions/runners/registration-token"
          ],
          createRegistrationTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/registration-token"
          ],
          createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
          createRemoveTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/remove-token"
          ],
          createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
          createWorkflowDispatch: [
            "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
          ],
          deleteActionsCacheById: [
            "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
          ],
          deleteActionsCacheByKey: [
            "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
          ],
          deleteArtifact: [
            "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
          ],
          deleteEnvironmentSecret: [
            "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
          ],
          deleteEnvironmentVariable: [
            "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
          ],
          deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
          deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
          deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
          ],
          deleteRepoVariable: [
            "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
          ],
          deleteSelfHostedRunnerFromOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}"
          ],
          deleteSelfHostedRunnerFromRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
          ],
          deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
          deleteWorkflowRunLogs: [
            "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
          ],
          disableSelectedRepositoryGithubActionsOrganization: [
            "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
          ],
          disableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
          ],
          downloadArtifact: [
            "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
          ],
          downloadJobLogsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
          ],
          downloadWorkflowRunAttemptLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
          ],
          downloadWorkflowRunLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
          ],
          enableSelectedRepositoryGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
          ],
          enableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
          ],
          forceCancelWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
          ],
          generateRunnerJitconfigForOrg: [
            "POST /orgs/{org}/actions/runners/generate-jitconfig"
          ],
          generateRunnerJitconfigForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
          ],
          getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
          getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
          getActionsCacheUsageByRepoForOrg: [
            "GET /orgs/{org}/actions/cache/usage-by-repository"
          ],
          getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
          getAllowedActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/selected-actions"
          ],
          getAllowedActionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
          ],
          getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
          getCustomOidcSubClaimForRepo: [
            "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
          ],
          getEnvironmentPublicKey: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
          ],
          getEnvironmentSecret: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
          ],
          getEnvironmentVariable: [
            "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
          ],
          getGithubActionsDefaultWorkflowPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions/workflow"
          ],
          getGithubActionsDefaultWorkflowPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/workflow"
          ],
          getGithubActionsPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions"
          ],
          getGithubActionsPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions"
          ],
          getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
          getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
          getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
          getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
          getPendingDeploymentsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
          ],
          getRepoPermissions: [
            "GET /repos/{owner}/{repo}/actions/permissions",
            {},
            { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
          ],
          getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
          getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
          getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
          getReviewsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
          ],
          getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
          getSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
          ],
          getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
          getWorkflowAccessToRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/access"
          ],
          getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
          getWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
          ],
          getWorkflowRunUsage: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
          ],
          getWorkflowUsage: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
          ],
          listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
          listEnvironmentSecrets: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
          ],
          listEnvironmentVariables: [
            "GET /repositories/{repository_id}/environments/{environment_name}/variables"
          ],
          listJobsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
          ],
          listJobsForWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
          ],
          listLabelsForSelfHostedRunnerForOrg: [
            "GET /orgs/{org}/actions/runners/{runner_id}/labels"
          ],
          listLabelsForSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
          ],
          listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
          listOrgVariables: ["GET /orgs/{org}/actions/variables"],
          listRepoOrganizationSecrets: [
            "GET /repos/{owner}/{repo}/actions/organization-secrets"
          ],
          listRepoOrganizationVariables: [
            "GET /repos/{owner}/{repo}/actions/organization-variables"
          ],
          listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
          listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
          listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
          listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
          listRunnerApplicationsForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/downloads"
          ],
          listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
          ],
          listSelectedReposForOrgVariable: [
            "GET /orgs/{org}/actions/variables/{name}/repositories"
          ],
          listSelectedRepositoriesEnabledGithubActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/repositories"
          ],
          listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
          listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
          listWorkflowRunArtifacts: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
          ],
          listWorkflowRuns: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
          ],
          listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
          reRunJobForWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
          ],
          reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
          reRunWorkflowFailedJobs: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
          ],
          removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
          ],
          removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
          ],
          removeCustomLabelFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
          ],
          removeCustomLabelFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
          ],
          removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
          ],
          removeSelectedRepoFromOrgVariable: [
            "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
          ],
          reviewCustomGatesForRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
          ],
          reviewPendingDeploymentsForRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
          ],
          setAllowedActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/selected-actions"
          ],
          setAllowedActionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
          ],
          setCustomLabelsForSelfHostedRunnerForOrg: [
            "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
          ],
          setCustomLabelsForSelfHostedRunnerForRepo: [
            "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
          ],
          setCustomOidcSubClaimForRepo: [
            "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
          ],
          setGithubActionsDefaultWorkflowPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/workflow"
          ],
          setGithubActionsDefaultWorkflowPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
          ],
          setGithubActionsPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions"
          ],
          setGithubActionsPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions"
          ],
          setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
          ],
          setSelectedReposForOrgVariable: [
            "PUT /orgs/{org}/actions/variables/{name}/repositories"
          ],
          setSelectedRepositoriesEnabledGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories"
          ],
          setWorkflowAccessToRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/access"
          ],
          updateEnvironmentVariable: [
            "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
          ],
          updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
          updateRepoVariable: [
            "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
          ]
        },
        activity: {
          checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
          deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
          deleteThreadSubscription: [
            "DELETE /notifications/threads/{thread_id}/subscription"
          ],
          getFeeds: ["GET /feeds"],
          getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
          getThread: ["GET /notifications/threads/{thread_id}"],
          getThreadSubscriptionForAuthenticatedUser: [
            "GET /notifications/threads/{thread_id}/subscription"
          ],
          listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
          listNotificationsForAuthenticatedUser: ["GET /notifications"],
          listOrgEventsForAuthenticatedUser: [
            "GET /users/{username}/events/orgs/{org}"
          ],
          listPublicEvents: ["GET /events"],
          listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
          listPublicEventsForUser: ["GET /users/{username}/events/public"],
          listPublicOrgEvents: ["GET /orgs/{org}/events"],
          listReceivedEventsForUser: ["GET /users/{username}/received_events"],
          listReceivedPublicEventsForUser: [
            "GET /users/{username}/received_events/public"
          ],
          listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
          listRepoNotificationsForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/notifications"
          ],
          listReposStarredByAuthenticatedUser: ["GET /user/starred"],
          listReposStarredByUser: ["GET /users/{username}/starred"],
          listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
          listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
          listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
          listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
          markNotificationsAsRead: ["PUT /notifications"],
          markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
          markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
          markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
          setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
          setThreadSubscription: [
            "PUT /notifications/threads/{thread_id}/subscription"
          ],
          starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
          unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
        },
        apps: {
          addRepoToInstallation: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
          ],
          addRepoToInstallationForAuthenticatedUser: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}"
          ],
          checkToken: ["POST /applications/{client_id}/token"],
          createFromManifest: ["POST /app-manifests/{code}/conversions"],
          createInstallationAccessToken: [
            "POST /app/installations/{installation_id}/access_tokens"
          ],
          deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
          deleteInstallation: ["DELETE /app/installations/{installation_id}"],
          deleteToken: ["DELETE /applications/{client_id}/token"],
          getAuthenticated: ["GET /app"],
          getBySlug: ["GET /apps/{app_slug}"],
          getInstallation: ["GET /app/installations/{installation_id}"],
          getOrgInstallation: ["GET /orgs/{org}/installation"],
          getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
          getSubscriptionPlanForAccount: [
            "GET /marketplace_listing/accounts/{account_id}"
          ],
          getSubscriptionPlanForAccountStubbed: [
            "GET /marketplace_listing/stubbed/accounts/{account_id}"
          ],
          getUserInstallation: ["GET /users/{username}/installation"],
          getWebhookConfigForApp: ["GET /app/hook/config"],
          getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
          listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
          listAccountsForPlanStubbed: [
            "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
          ],
          listInstallationReposForAuthenticatedUser: [
            "GET /user/installations/{installation_id}/repositories"
          ],
          listInstallationRequestsForAuthenticatedApp: [
            "GET /app/installation-requests"
          ],
          listInstallations: ["GET /app/installations"],
          listInstallationsForAuthenticatedUser: ["GET /user/installations"],
          listPlans: ["GET /marketplace_listing/plans"],
          listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
          listReposAccessibleToInstallation: ["GET /installation/repositories"],
          listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
          listSubscriptionsForAuthenticatedUserStubbed: [
            "GET /user/marketplace_purchases/stubbed"
          ],
          listWebhookDeliveries: ["GET /app/hook/deliveries"],
          redeliverWebhookDelivery: [
            "POST /app/hook/deliveries/{delivery_id}/attempts"
          ],
          removeRepoFromInstallation: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
          ],
          removeRepoFromInstallationForAuthenticatedUser: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
          ],
          resetToken: ["PATCH /applications/{client_id}/token"],
          revokeInstallationAccessToken: ["DELETE /installation/token"],
          scopeToken: ["POST /applications/{client_id}/token/scoped"],
          suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
          unsuspendInstallation: [
            "DELETE /app/installations/{installation_id}/suspended"
          ],
          updateWebhookConfigForApp: ["PATCH /app/hook/config"]
        },
        billing: {
          getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
          getGithubActionsBillingUser: [
            "GET /users/{username}/settings/billing/actions"
          ],
          getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
          getGithubPackagesBillingUser: [
            "GET /users/{username}/settings/billing/packages"
          ],
          getSharedStorageBillingOrg: [
            "GET /orgs/{org}/settings/billing/shared-storage"
          ],
          getSharedStorageBillingUser: [
            "GET /users/{username}/settings/billing/shared-storage"
          ]
        },
        checks: {
          create: ["POST /repos/{owner}/{repo}/check-runs"],
          createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
          get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
          getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
          listAnnotations: [
            "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
          ],
          listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
          listForSuite: [
            "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
          ],
          listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
          rerequestRun: [
            "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
          ],
          rerequestSuite: [
            "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
          ],
          setSuitesPreferences: [
            "PATCH /repos/{owner}/{repo}/check-suites/preferences"
          ],
          update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
        },
        codeScanning: {
          deleteAnalysis: [
            "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
          ],
          getAlert: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
            {},
            { renamedParameters: { alert_id: "alert_number" } }
          ],
          getAnalysis: [
            "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
          ],
          getCodeqlDatabase: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
          ],
          getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
          getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
          listAlertInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
          ],
          listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
          listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
          listAlertsInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
            {},
            { renamed: ["codeScanning", "listAlertInstances"] }
          ],
          listCodeqlDatabases: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
          ],
          listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
          updateAlert: [
            "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
          ],
          updateDefaultSetup: [
            "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
          ],
          uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
        },
        codesOfConduct: {
          getAllCodesOfConduct: ["GET /codes_of_conduct"],
          getConductCode: ["GET /codes_of_conduct/{key}"]
        },
        codespaces: {
          addRepositoryForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
          ],
          addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
          ],
          checkPermissionsForDevcontainer: [
            "GET /repos/{owner}/{repo}/codespaces/permissions_check"
          ],
          codespaceMachinesForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/machines"
          ],
          createForAuthenticatedUser: ["POST /user/codespaces"],
          createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
          ],
          createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
          ],
          createOrUpdateSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}"
          ],
          createWithPrForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
          ],
          createWithRepoForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/codespaces"
          ],
          deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
          deleteFromOrganization: [
            "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
          ],
          deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
          deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
          ],
          deleteSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}"
          ],
          exportForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/exports"
          ],
          getCodespacesForUserInOrg: [
            "GET /orgs/{org}/members/{username}/codespaces"
          ],
          getExportDetailsForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/exports/{export_id}"
          ],
          getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
          getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
          getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
          getPublicKeyForAuthenticatedUser: [
            "GET /user/codespaces/secrets/public-key"
          ],
          getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
          ],
          getRepoSecret: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
          ],
          getSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}"
          ],
          listDevcontainersInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/devcontainers"
          ],
          listForAuthenticatedUser: ["GET /user/codespaces"],
          listInOrganization: [
            "GET /orgs/{org}/codespaces",
            {},
            { renamedParameters: { org_id: "org" } }
          ],
          listInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces"
          ],
          listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
          listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
          listRepositoriesForSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}/repositories"
          ],
          listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
          listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
          ],
          preFlightWithRepoForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/new"
          ],
          publishForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/publish"
          ],
          removeRepositoryForSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
          ],
          removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
          ],
          repoMachinesForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/machines"
          ],
          setRepositoriesForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories"
          ],
          setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
          ],
          startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
          stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
          stopInOrganization: [
            "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
          ],
          updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
        },
        copilot: {
          addCopilotSeatsForTeams: [
            "POST /orgs/{org}/copilot/billing/selected_teams"
          ],
          addCopilotSeatsForUsers: [
            "POST /orgs/{org}/copilot/billing/selected_users"
          ],
          cancelCopilotSeatAssignmentForTeams: [
            "DELETE /orgs/{org}/copilot/billing/selected_teams"
          ],
          cancelCopilotSeatAssignmentForUsers: [
            "DELETE /orgs/{org}/copilot/billing/selected_users"
          ],
          getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
          getCopilotSeatDetailsForUser: [
            "GET /orgs/{org}/members/{username}/copilot"
          ],
          listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
        },
        dependabot: {
          addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
          ],
          createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
          ],
          createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
          ],
          deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
          deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
          ],
          getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
          getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
          getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
          getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
          ],
          getRepoSecret: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
          ],
          listAlertsForEnterprise: [
            "GET /enterprises/{enterprise}/dependabot/alerts"
          ],
          listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
          listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
          listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
          listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
          listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
          ],
          removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
          ],
          setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
          ],
          updateAlert: [
            "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
          ]
        },
        dependencyGraph: {
          createRepositorySnapshot: [
            "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
          ],
          diffRange: [
            "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
          ],
          exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
        },
        emojis: { get: ["GET /emojis"] },
        gists: {
          checkIsStarred: ["GET /gists/{gist_id}/star"],
          create: ["POST /gists"],
          createComment: ["POST /gists/{gist_id}/comments"],
          delete: ["DELETE /gists/{gist_id}"],
          deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
          fork: ["POST /gists/{gist_id}/forks"],
          get: ["GET /gists/{gist_id}"],
          getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
          getRevision: ["GET /gists/{gist_id}/{sha}"],
          list: ["GET /gists"],
          listComments: ["GET /gists/{gist_id}/comments"],
          listCommits: ["GET /gists/{gist_id}/commits"],
          listForUser: ["GET /users/{username}/gists"],
          listForks: ["GET /gists/{gist_id}/forks"],
          listPublic: ["GET /gists/public"],
          listStarred: ["GET /gists/starred"],
          star: ["PUT /gists/{gist_id}/star"],
          unstar: ["DELETE /gists/{gist_id}/star"],
          update: ["PATCH /gists/{gist_id}"],
          updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
        },
        git: {
          createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
          createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
          createRef: ["POST /repos/{owner}/{repo}/git/refs"],
          createTag: ["POST /repos/{owner}/{repo}/git/tags"],
          createTree: ["POST /repos/{owner}/{repo}/git/trees"],
          deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
          getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
          getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
          getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
          getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
          getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
          listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
          updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
        },
        gitignore: {
          getAllTemplates: ["GET /gitignore/templates"],
          getTemplate: ["GET /gitignore/templates/{name}"]
        },
        interactions: {
          getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
          getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
          getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
          getRestrictionsForYourPublicRepos: [
            "GET /user/interaction-limits",
            {},
            { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
          ],
          removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
          removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
          removeRestrictionsForRepo: [
            "DELETE /repos/{owner}/{repo}/interaction-limits"
          ],
          removeRestrictionsForYourPublicRepos: [
            "DELETE /user/interaction-limits",
            {},
            { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
          ],
          setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
          setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
          setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
          setRestrictionsForYourPublicRepos: [
            "PUT /user/interaction-limits",
            {},
            { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
          ]
        },
        issues: {
          addAssignees: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
          ],
          addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
          checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
          checkUserCanBeAssignedToIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
          ],
          create: ["POST /repos/{owner}/{repo}/issues"],
          createComment: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
          ],
          createLabel: ["POST /repos/{owner}/{repo}/labels"],
          createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
          deleteComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
          ],
          deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
          deleteMilestone: [
            "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
          ],
          get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
          getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
          getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
          getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
          getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
          list: ["GET /issues"],
          listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
          listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
          listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
          listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
          listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
          listEventsForTimeline: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
          ],
          listForAuthenticatedUser: ["GET /user/issues"],
          listForOrg: ["GET /orgs/{org}/issues"],
          listForRepo: ["GET /repos/{owner}/{repo}/issues"],
          listLabelsForMilestone: [
            "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
          ],
          listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
          listLabelsOnIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
          ],
          listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
          lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
          removeAllLabels: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
          ],
          removeAssignees: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
          ],
          removeLabel: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
          ],
          setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
          unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
          update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
          updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
          updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
          updateMilestone: [
            "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
          ]
        },
        licenses: {
          get: ["GET /licenses/{license}"],
          getAllCommonlyUsed: ["GET /licenses"],
          getForRepo: ["GET /repos/{owner}/{repo}/license"]
        },
        markdown: {
          render: ["POST /markdown"],
          renderRaw: [
            "POST /markdown/raw",
            { headers: { "content-type": "text/plain; charset=utf-8" } }
          ]
        },
        meta: {
          get: ["GET /meta"],
          getAllVersions: ["GET /versions"],
          getOctocat: ["GET /octocat"],
          getZen: ["GET /zen"],
          root: ["GET /"]
        },
        migrations: {
          cancelImport: [
            "DELETE /repos/{owner}/{repo}/import",
            {},
            {
              deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
            }
          ],
          deleteArchiveForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/archive"
          ],
          deleteArchiveForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/archive"
          ],
          downloadArchiveForOrg: [
            "GET /orgs/{org}/migrations/{migration_id}/archive"
          ],
          getArchiveForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/archive"
          ],
          getCommitAuthors: [
            "GET /repos/{owner}/{repo}/import/authors",
            {},
            {
              deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
            }
          ],
          getImportStatus: [
            "GET /repos/{owner}/{repo}/import",
            {},
            {
              deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
            }
          ],
          getLargeFiles: [
            "GET /repos/{owner}/{repo}/import/large_files",
            {},
            {
              deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
            }
          ],
          getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
          getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
          listForAuthenticatedUser: ["GET /user/migrations"],
          listForOrg: ["GET /orgs/{org}/migrations"],
          listReposForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/repositories"
          ],
          listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
          listReposForUser: [
            "GET /user/migrations/{migration_id}/repositories",
            {},
            { renamed: ["migrations", "listReposForAuthenticatedUser"] }
          ],
          mapCommitAuthor: [
            "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
            {},
            {
              deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
            }
          ],
          setLfsPreference: [
            "PATCH /repos/{owner}/{repo}/import/lfs",
            {},
            {
              deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
            }
          ],
          startForAuthenticatedUser: ["POST /user/migrations"],
          startForOrg: ["POST /orgs/{org}/migrations"],
          startImport: [
            "PUT /repos/{owner}/{repo}/import",
            {},
            {
              deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
            }
          ],
          unlockRepoForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
          ],
          unlockRepoForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
          ],
          updateImport: [
            "PATCH /repos/{owner}/{repo}/import",
            {},
            {
              deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
            }
          ]
        },
        oidc: {
          getOidcCustomSubTemplateForOrg: [
            "GET /orgs/{org}/actions/oidc/customization/sub"
          ],
          updateOidcCustomSubTemplateForOrg: [
            "PUT /orgs/{org}/actions/oidc/customization/sub"
          ]
        },
        orgs: {
          addSecurityManagerTeam: [
            "PUT /orgs/{org}/security-managers/teams/{team_slug}"
          ],
          assignTeamToOrgRole: [
            "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
          ],
          assignUserToOrgRole: [
            "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
          ],
          blockUser: ["PUT /orgs/{org}/blocks/{username}"],
          cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
          checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
          checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
          checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
          convertMemberToOutsideCollaborator: [
            "PUT /orgs/{org}/outside_collaborators/{username}"
          ],
          createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
          createInvitation: ["POST /orgs/{org}/invitations"],
          createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
          createOrUpdateCustomPropertiesValuesForRepos: [
            "PATCH /orgs/{org}/properties/values"
          ],
          createOrUpdateCustomProperty: [
            "PUT /orgs/{org}/properties/schema/{custom_property_name}"
          ],
          createWebhook: ["POST /orgs/{org}/hooks"],
          delete: ["DELETE /orgs/{org}"],
          deleteCustomOrganizationRole: [
            "DELETE /orgs/{org}/organization-roles/{role_id}"
          ],
          deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
          enableOrDisableSecurityProductOnAllOrgRepos: [
            "POST /orgs/{org}/{security_product}/{enablement}"
          ],
          get: ["GET /orgs/{org}"],
          getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
          getCustomProperty: [
            "GET /orgs/{org}/properties/schema/{custom_property_name}"
          ],
          getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
          getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
          getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
          getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
          getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
          getWebhookDelivery: [
            "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
          ],
          list: ["GET /organizations"],
          listAppInstallations: ["GET /orgs/{org}/installations"],
          listBlockedUsers: ["GET /orgs/{org}/blocks"],
          listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
          listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
          listForAuthenticatedUser: ["GET /user/orgs"],
          listForUser: ["GET /users/{username}/orgs"],
          listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
          listMembers: ["GET /orgs/{org}/members"],
          listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
          listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
          listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
          listOrgRoles: ["GET /orgs/{org}/organization-roles"],
          listOrganizationFineGrainedPermissions: [
            "GET /orgs/{org}/organization-fine-grained-permissions"
          ],
          listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
          listPatGrantRepositories: [
            "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
          ],
          listPatGrantRequestRepositories: [
            "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
          ],
          listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
          listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
          listPendingInvitations: ["GET /orgs/{org}/invitations"],
          listPublicMembers: ["GET /orgs/{org}/public_members"],
          listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
          listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
          listWebhooks: ["GET /orgs/{org}/hooks"],
          patchCustomOrganizationRole: [
            "PATCH /orgs/{org}/organization-roles/{role_id}"
          ],
          pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
          redeliverWebhookDelivery: [
            "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
          ],
          removeCustomProperty: [
            "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
          ],
          removeMember: ["DELETE /orgs/{org}/members/{username}"],
          removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
          removeOutsideCollaborator: [
            "DELETE /orgs/{org}/outside_collaborators/{username}"
          ],
          removePublicMembershipForAuthenticatedUser: [
            "DELETE /orgs/{org}/public_members/{username}"
          ],
          removeSecurityManagerTeam: [
            "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
          ],
          reviewPatGrantRequest: [
            "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
          ],
          reviewPatGrantRequestsInBulk: [
            "POST /orgs/{org}/personal-access-token-requests"
          ],
          revokeAllOrgRolesTeam: [
            "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
          ],
          revokeAllOrgRolesUser: [
            "DELETE /orgs/{org}/organization-roles/users/{username}"
          ],
          revokeOrgRoleTeam: [
            "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
          ],
          revokeOrgRoleUser: [
            "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
          ],
          setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
          setPublicMembershipForAuthenticatedUser: [
            "PUT /orgs/{org}/public_members/{username}"
          ],
          unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
          update: ["PATCH /orgs/{org}"],
          updateMembershipForAuthenticatedUser: [
            "PATCH /user/memberships/orgs/{org}"
          ],
          updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
          updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
          updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
          updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
        },
        packages: {
          deletePackageForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}"
          ],
          deletePackageForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
          ],
          deletePackageForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}"
          ],
          deletePackageVersionForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
          ],
          deletePackageVersionForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
          ],
          deletePackageVersionForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
          ],
          getAllPackageVersionsForAPackageOwnedByAnOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
            {},
            { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
          ],
          getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions",
            {},
            {
              renamed: [
                "packages",
                "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
              ]
            }
          ],
          getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions"
          ],
          getAllPackageVersionsForPackageOwnedByOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
          ],
          getAllPackageVersionsForPackageOwnedByUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions"
          ],
          getPackageForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}"
          ],
          getPackageForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}"
          ],
          getPackageForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}"
          ],
          getPackageVersionForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
          ],
          getPackageVersionForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
          ],
          getPackageVersionForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
          ],
          listDockerMigrationConflictingPackagesForAuthenticatedUser: [
            "GET /user/docker/conflicts"
          ],
          listDockerMigrationConflictingPackagesForOrganization: [
            "GET /orgs/{org}/docker/conflicts"
          ],
          listDockerMigrationConflictingPackagesForUser: [
            "GET /users/{username}/docker/conflicts"
          ],
          listPackagesForAuthenticatedUser: ["GET /user/packages"],
          listPackagesForOrganization: ["GET /orgs/{org}/packages"],
          listPackagesForUser: ["GET /users/{username}/packages"],
          restorePackageForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/restore{?token}"
          ],
          restorePackageForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
          ],
          restorePackageForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
          ],
          restorePackageVersionForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
          ],
          restorePackageVersionForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
          ],
          restorePackageVersionForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
          ]
        },
        projects: {
          addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
          createCard: ["POST /projects/columns/{column_id}/cards"],
          createColumn: ["POST /projects/{project_id}/columns"],
          createForAuthenticatedUser: ["POST /user/projects"],
          createForOrg: ["POST /orgs/{org}/projects"],
          createForRepo: ["POST /repos/{owner}/{repo}/projects"],
          delete: ["DELETE /projects/{project_id}"],
          deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
          deleteColumn: ["DELETE /projects/columns/{column_id}"],
          get: ["GET /projects/{project_id}"],
          getCard: ["GET /projects/columns/cards/{card_id}"],
          getColumn: ["GET /projects/columns/{column_id}"],
          getPermissionForUser: [
            "GET /projects/{project_id}/collaborators/{username}/permission"
          ],
          listCards: ["GET /projects/columns/{column_id}/cards"],
          listCollaborators: ["GET /projects/{project_id}/collaborators"],
          listColumns: ["GET /projects/{project_id}/columns"],
          listForOrg: ["GET /orgs/{org}/projects"],
          listForRepo: ["GET /repos/{owner}/{repo}/projects"],
          listForUser: ["GET /users/{username}/projects"],
          moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
          moveColumn: ["POST /projects/columns/{column_id}/moves"],
          removeCollaborator: [
            "DELETE /projects/{project_id}/collaborators/{username}"
          ],
          update: ["PATCH /projects/{project_id}"],
          updateCard: ["PATCH /projects/columns/cards/{card_id}"],
          updateColumn: ["PATCH /projects/columns/{column_id}"]
        },
        pulls: {
          checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
          create: ["POST /repos/{owner}/{repo}/pulls"],
          createReplyForReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
          ],
          createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
          createReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
          ],
          deletePendingReview: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
          ],
          deleteReviewComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
          ],
          dismissReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
          ],
          get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
          getReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
          ],
          getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
          list: ["GET /repos/{owner}/{repo}/pulls"],
          listCommentsForReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
          ],
          listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
          listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
          listRequestedReviewers: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
          ],
          listReviewComments: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
          ],
          listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
          listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
          merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
          removeRequestedReviewers: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
          ],
          requestReviewers: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
          ],
          submitReview: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
          ],
          update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
          updateBranch: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
          ],
          updateReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
          ],
          updateReviewComment: [
            "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
          ]
        },
        rateLimit: { get: ["GET /rate_limit"] },
        reactions: {
          createForCommitComment: [
            "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
          ],
          createForIssue: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
          ],
          createForIssueComment: [
            "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
          ],
          createForPullRequestReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
          ],
          createForRelease: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
          ],
          createForTeamDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
          ],
          createForTeamDiscussionInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
          ],
          deleteForCommitComment: [
            "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
          ],
          deleteForIssue: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
          ],
          deleteForIssueComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
          ],
          deleteForPullRequestComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
          ],
          deleteForRelease: [
            "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
          ],
          deleteForTeamDiscussion: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
          ],
          deleteForTeamDiscussionComment: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
          ],
          listForCommitComment: [
            "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
          ],
          listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
          listForIssueComment: [
            "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
          ],
          listForPullRequestReviewComment: [
            "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
          ],
          listForRelease: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
          ],
          listForTeamDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
          ],
          listForTeamDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
          ]
        },
        repos: {
          acceptInvitation: [
            "PATCH /user/repository_invitations/{invitation_id}",
            {},
            { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
          ],
          acceptInvitationForAuthenticatedUser: [
            "PATCH /user/repository_invitations/{invitation_id}"
          ],
          addAppAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" }
          ],
          addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
          addStatusCheckContexts: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" }
          ],
          addTeamAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" }
          ],
          addUserAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" }
          ],
          cancelPagesDeployment: [
            "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
          ],
          checkAutomatedSecurityFixes: [
            "GET /repos/{owner}/{repo}/automated-security-fixes"
          ],
          checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
          checkVulnerabilityAlerts: [
            "GET /repos/{owner}/{repo}/vulnerability-alerts"
          ],
          codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
          compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
          compareCommitsWithBasehead: [
            "GET /repos/{owner}/{repo}/compare/{basehead}"
          ],
          createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
          createCommitComment: [
            "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
          ],
          createCommitSignatureProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
          ],
          createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
          createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
          createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
          createDeploymentBranchPolicy: [
            "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
          ],
          createDeploymentProtectionRule: [
            "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
          ],
          createDeploymentStatus: [
            "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
          ],
          createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
          createForAuthenticatedUser: ["POST /user/repos"],
          createFork: ["POST /repos/{owner}/{repo}/forks"],
          createInOrg: ["POST /orgs/{org}/repos"],
          createOrUpdateCustomPropertiesValues: [
            "PATCH /repos/{owner}/{repo}/properties/values"
          ],
          createOrUpdateEnvironment: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}"
          ],
          createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
          createOrgRuleset: ["POST /orgs/{org}/rulesets"],
          createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
          createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
          createRelease: ["POST /repos/{owner}/{repo}/releases"],
          createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
          createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
          createUsingTemplate: [
            "POST /repos/{template_owner}/{template_repo}/generate"
          ],
          createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
          declineInvitation: [
            "DELETE /user/repository_invitations/{invitation_id}",
            {},
            { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
          ],
          declineInvitationForAuthenticatedUser: [
            "DELETE /user/repository_invitations/{invitation_id}"
          ],
          delete: ["DELETE /repos/{owner}/{repo}"],
          deleteAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
          ],
          deleteAdminBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
          ],
          deleteAnEnvironment: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
          ],
          deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
          deleteBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
          ],
          deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
          deleteCommitSignatureProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
          ],
          deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
          deleteDeployment: [
            "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
          ],
          deleteDeploymentBranchPolicy: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
          ],
          deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
          deleteInvitation: [
            "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
          ],
          deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
          deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
          deletePullRequestReviewProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
          ],
          deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
          deleteReleaseAsset: [
            "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
          ],
          deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
          deleteTagProtection: [
            "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
          ],
          deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
          disableAutomatedSecurityFixes: [
            "DELETE /repos/{owner}/{repo}/automated-security-fixes"
          ],
          disableDeploymentProtectionRule: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
          ],
          disablePrivateVulnerabilityReporting: [
            "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
          ],
          disableVulnerabilityAlerts: [
            "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
          ],
          downloadArchive: [
            "GET /repos/{owner}/{repo}/zipball/{ref}",
            {},
            { renamed: ["repos", "downloadZipballArchive"] }
          ],
          downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
          downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
          enableAutomatedSecurityFixes: [
            "PUT /repos/{owner}/{repo}/automated-security-fixes"
          ],
          enablePrivateVulnerabilityReporting: [
            "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
          ],
          enableVulnerabilityAlerts: [
            "PUT /repos/{owner}/{repo}/vulnerability-alerts"
          ],
          generateReleaseNotes: [
            "POST /repos/{owner}/{repo}/releases/generate-notes"
          ],
          get: ["GET /repos/{owner}/{repo}"],
          getAccessRestrictions: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
          ],
          getAdminBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
          ],
          getAllDeploymentProtectionRules: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
          ],
          getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
          getAllStatusCheckContexts: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
          ],
          getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
          getAppsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
          ],
          getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
          getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
          getBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection"
          ],
          getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
          getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
          getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
          getCollaboratorPermissionLevel: [
            "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
          ],
          getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
          getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
          getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
          getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
          getCommitSignatureProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
          ],
          getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
          getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
          getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
          getCustomDeploymentProtectionRule: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
          ],
          getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
          getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
          getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
          getDeploymentBranchPolicy: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
          ],
          getDeploymentStatus: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
          ],
          getEnvironment: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}"
          ],
          getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
          getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
          getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
          getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
          getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
          getOrgRulesets: ["GET /orgs/{org}/rulesets"],
          getPages: ["GET /repos/{owner}/{repo}/pages"],
          getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
          getPagesDeployment: [
            "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
          ],
          getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
          getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
          getPullRequestReviewProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
          ],
          getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
          getReadme: ["GET /repos/{owner}/{repo}/readme"],
          getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
          getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
          getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
          getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
          getRepoRuleSuite: [
            "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
          ],
          getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
          getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
          getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
          getStatusChecksProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
          ],
          getTeamsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
          ],
          getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
          getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
          getUsersWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
          ],
          getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
          getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
          getWebhookConfigForRepo: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
          ],
          getWebhookDelivery: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
          ],
          listActivities: ["GET /repos/{owner}/{repo}/activity"],
          listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
          listBranches: ["GET /repos/{owner}/{repo}/branches"],
          listBranchesForHeadCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
          ],
          listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
          listCommentsForCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
          ],
          listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
          listCommitStatusesForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
          ],
          listCommits: ["GET /repos/{owner}/{repo}/commits"],
          listContributors: ["GET /repos/{owner}/{repo}/contributors"],
          listCustomDeploymentRuleIntegrations: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
          ],
          listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
          listDeploymentBranchPolicies: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
          ],
          listDeploymentStatuses: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
          ],
          listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
          listForAuthenticatedUser: ["GET /user/repos"],
          listForOrg: ["GET /orgs/{org}/repos"],
          listForUser: ["GET /users/{username}/repos"],
          listForks: ["GET /repos/{owner}/{repo}/forks"],
          listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
          listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
          listLanguages: ["GET /repos/{owner}/{repo}/languages"],
          listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
          listPublic: ["GET /repositories"],
          listPullRequestsAssociatedWithCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
          ],
          listReleaseAssets: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
          ],
          listReleases: ["GET /repos/{owner}/{repo}/releases"],
          listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
          listTags: ["GET /repos/{owner}/{repo}/tags"],
          listTeams: ["GET /repos/{owner}/{repo}/teams"],
          listWebhookDeliveries: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
          ],
          listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
          merge: ["POST /repos/{owner}/{repo}/merges"],
          mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
          pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
          redeliverWebhookDelivery: [
            "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
          ],
          removeAppAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" }
          ],
          removeCollaborator: [
            "DELETE /repos/{owner}/{repo}/collaborators/{username}"
          ],
          removeStatusCheckContexts: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" }
          ],
          removeStatusCheckProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
          ],
          removeTeamAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" }
          ],
          removeUserAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" }
          ],
          renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
          replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
          requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
          setAdminBranchProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
          ],
          setAppAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" }
          ],
          setStatusCheckContexts: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" }
          ],
          setTeamAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" }
          ],
          setUserAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" }
          ],
          testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
          transfer: ["POST /repos/{owner}/{repo}/transfer"],
          update: ["PATCH /repos/{owner}/{repo}"],
          updateBranchProtection: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
          ],
          updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
          updateDeploymentBranchPolicy: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
          ],
          updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
          updateInvitation: [
            "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
          ],
          updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
          updatePullRequestReviewProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
          ],
          updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
          updateReleaseAsset: [
            "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
          ],
          updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
          updateStatusCheckPotection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
            {},
            { renamed: ["repos", "updateStatusCheckProtection"] }
          ],
          updateStatusCheckProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
          ],
          updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
          updateWebhookConfigForRepo: [
            "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
          ],
          uploadReleaseAsset: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
            { baseUrl: "https://uploads.github.com" }
          ]
        },
        search: {
          code: ["GET /search/code"],
          commits: ["GET /search/commits"],
          issuesAndPullRequests: ["GET /search/issues"],
          labels: ["GET /search/labels"],
          repos: ["GET /search/repositories"],
          topics: ["GET /search/topics"],
          users: ["GET /search/users"]
        },
        secretScanning: {
          getAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
          ],
          listAlertsForEnterprise: [
            "GET /enterprises/{enterprise}/secret-scanning/alerts"
          ],
          listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
          listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
          listLocationsForAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
          ],
          updateAlert: [
            "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
          ]
        },
        securityAdvisories: {
          createFork: [
            "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
          ],
          createPrivateVulnerabilityReport: [
            "POST /repos/{owner}/{repo}/security-advisories/reports"
          ],
          createRepositoryAdvisory: [
            "POST /repos/{owner}/{repo}/security-advisories"
          ],
          createRepositoryAdvisoryCveRequest: [
            "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
          ],
          getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
          getRepositoryAdvisory: [
            "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
          ],
          listGlobalAdvisories: ["GET /advisories"],
          listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
          listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
          updateRepositoryAdvisory: [
            "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
          ]
        },
        teams: {
          addOrUpdateMembershipForUserInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
          ],
          addOrUpdateProjectPermissionsInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
          ],
          addOrUpdateRepoPermissionsInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
          ],
          checkPermissionsForProjectInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
          ],
          checkPermissionsForRepoInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
          ],
          create: ["POST /orgs/{org}/teams"],
          createDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
          ],
          createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
          deleteDiscussionCommentInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
          ],
          deleteDiscussionInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
          ],
          deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
          getByName: ["GET /orgs/{org}/teams/{team_slug}"],
          getDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
          ],
          getDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
          ],
          getMembershipForUserInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
          ],
          list: ["GET /orgs/{org}/teams"],
          listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
          listDiscussionCommentsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
          ],
          listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
          listForAuthenticatedUser: ["GET /user/teams"],
          listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
          listPendingInvitationsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/invitations"
          ],
          listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
          listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
          removeMembershipForUserInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
          ],
          removeProjectInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
          ],
          removeRepoInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
          ],
          updateDiscussionCommentInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
          ],
          updateDiscussionInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
          ],
          updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
        },
        users: {
          addEmailForAuthenticated: [
            "POST /user/emails",
            {},
            { renamed: ["users", "addEmailForAuthenticatedUser"] }
          ],
          addEmailForAuthenticatedUser: ["POST /user/emails"],
          addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
          block: ["PUT /user/blocks/{username}"],
          checkBlocked: ["GET /user/blocks/{username}"],
          checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
          checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
          createGpgKeyForAuthenticated: [
            "POST /user/gpg_keys",
            {},
            { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
          ],
          createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
          createPublicSshKeyForAuthenticated: [
            "POST /user/keys",
            {},
            { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
          ],
          createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
          createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
          deleteEmailForAuthenticated: [
            "DELETE /user/emails",
            {},
            { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
          ],
          deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
          deleteGpgKeyForAuthenticated: [
            "DELETE /user/gpg_keys/{gpg_key_id}",
            {},
            { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
          ],
          deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
          deletePublicSshKeyForAuthenticated: [
            "DELETE /user/keys/{key_id}",
            {},
            { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
          ],
          deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
          deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
          deleteSshSigningKeyForAuthenticatedUser: [
            "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
          ],
          follow: ["PUT /user/following/{username}"],
          getAuthenticated: ["GET /user"],
          getByUsername: ["GET /users/{username}"],
          getContextForUser: ["GET /users/{username}/hovercard"],
          getGpgKeyForAuthenticated: [
            "GET /user/gpg_keys/{gpg_key_id}",
            {},
            { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
          ],
          getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
          getPublicSshKeyForAuthenticated: [
            "GET /user/keys/{key_id}",
            {},
            { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
          ],
          getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
          getSshSigningKeyForAuthenticatedUser: [
            "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
          ],
          list: ["GET /users"],
          listBlockedByAuthenticated: [
            "GET /user/blocks",
            {},
            { renamed: ["users", "listBlockedByAuthenticatedUser"] }
          ],
          listBlockedByAuthenticatedUser: ["GET /user/blocks"],
          listEmailsForAuthenticated: [
            "GET /user/emails",
            {},
            { renamed: ["users", "listEmailsForAuthenticatedUser"] }
          ],
          listEmailsForAuthenticatedUser: ["GET /user/emails"],
          listFollowedByAuthenticated: [
            "GET /user/following",
            {},
            { renamed: ["users", "listFollowedByAuthenticatedUser"] }
          ],
          listFollowedByAuthenticatedUser: ["GET /user/following"],
          listFollowersForAuthenticatedUser: ["GET /user/followers"],
          listFollowersForUser: ["GET /users/{username}/followers"],
          listFollowingForUser: ["GET /users/{username}/following"],
          listGpgKeysForAuthenticated: [
            "GET /user/gpg_keys",
            {},
            { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
          ],
          listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
          listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
          listPublicEmailsForAuthenticated: [
            "GET /user/public_emails",
            {},
            { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
          ],
          listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
          listPublicKeysForUser: ["GET /users/{username}/keys"],
          listPublicSshKeysForAuthenticated: [
            "GET /user/keys",
            {},
            { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
          ],
          listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
          listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
          listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
          listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
          listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
          setPrimaryEmailVisibilityForAuthenticated: [
            "PATCH /user/email/visibility",
            {},
            { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
          ],
          setPrimaryEmailVisibilityForAuthenticatedUser: [
            "PATCH /user/email/visibility"
          ],
          unblock: ["DELETE /user/blocks/{username}"],
          unfollow: ["DELETE /user/following/{username}"],
          updateAuthenticated: ["PATCH /user"]
        }
      };
      endpoints_default = Endpoints;
      endpointMethodsMap = /* @__PURE__ */ new Map();
      for (const [scope, endpoints] of Object.entries(endpoints_default)) {
        for (const [methodName, endpoint2] of Object.entries(endpoints)) {
          const [route, defaults, decorations] = endpoint2;
          const [method, url] = route.split(/ /);
          const endpointDefaults = Object.assign(
            {
              method,
              url
            },
            defaults
          );
          if (!endpointMethodsMap.has(scope)) {
            endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
          }
          endpointMethodsMap.get(scope).set(methodName, {
            scope,
            methodName,
            endpointDefaults,
            decorations
          });
        }
      }
      handler = {
        has({ scope }, methodName) {
          return endpointMethodsMap.get(scope).has(methodName);
        },
        getOwnPropertyDescriptor(target, methodName) {
          return {
            value: this.get(target, methodName),
            // ensures method is in the cache
            configurable: true,
            writable: true,
            enumerable: true
          };
        },
        defineProperty(target, methodName, descriptor) {
          Object.defineProperty(target.cache, methodName, descriptor);
          return true;
        },
        deleteProperty(target, methodName) {
          delete target.cache[methodName];
          return true;
        },
        ownKeys({ scope }) {
          return [...endpointMethodsMap.get(scope).keys()];
        },
        set(target, methodName, value) {
          return target.cache[methodName] = value;
        },
        get({ octokit: octokit2, scope, cache }, methodName) {
          if (cache[methodName]) {
            return cache[methodName];
          }
          const method = endpointMethodsMap.get(scope).get(methodName);
          if (!method) {
            return void 0;
          }
          const { endpointDefaults, decorations } = method;
          if (decorations) {
            cache[methodName] = decorate(
              octokit2,
              scope,
              methodName,
              endpointDefaults,
              decorations
            );
          } else {
            cache[methodName] = octokit2.request.defaults(endpointDefaults);
          }
          return cache[methodName];
        }
      };
      restEndpointMethods.VERSION = VERSION3;
      legacyRestEndpointMethods.VERSION = VERSION3;
    }
  });

  // node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
  var require_dist_node4 = __commonJS({
    "node_modules/@octokit/plugin-paginate-rest/dist-node/index.js"(exports, module) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var dist_src_exports = {};
      __export2(dist_src_exports, {
        composePaginateRest: () => composePaginateRest,
        isPaginatingEndpoint: () => isPaginatingEndpoint,
        paginateRest: () => paginateRest,
        paginatingEndpoints: () => paginatingEndpoints
      });
      module.exports = __toCommonJS2(dist_src_exports);
      var VERSION4 = "9.2.1";
      function normalizePaginatedListResponse(response) {
        if (!response.data) {
          return {
            ...response,
            data: []
          };
        }
        const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
        if (!responseNeedsNormalization)
          return response;
        const incompleteResults = response.data.incomplete_results;
        const repositorySelection = response.data.repository_selection;
        const totalCount = response.data.total_count;
        delete response.data.incomplete_results;
        delete response.data.repository_selection;
        delete response.data.total_count;
        const namespaceKey = Object.keys(response.data)[0];
        const data = response.data[namespaceKey];
        response.data = data;
        if (typeof incompleteResults !== "undefined") {
          response.data.incomplete_results = incompleteResults;
        }
        if (typeof repositorySelection !== "undefined") {
          response.data.repository_selection = repositorySelection;
        }
        response.data.total_count = totalCount;
        return response;
      }
      function iterator(octokit2, route, parameters) {
        const options = typeof route === "function" ? route.endpoint(parameters) : octokit2.request.endpoint(route, parameters);
        const requestMethod = typeof route === "function" ? route : octokit2.request;
        const method = options.method;
        const headers = options.headers;
        let url = options.url;
        return {
          [Symbol.asyncIterator]: () => ({
            async next() {
              if (!url)
                return { done: true };
              try {
                const response = await requestMethod({ method, url, headers });
                const normalizedResponse = normalizePaginatedListResponse(response);
                url = ((normalizedResponse.headers.link || "").match(
                  /<([^>]+)>;\s*rel="next"/
                ) || [])[1];
                return { value: normalizedResponse };
              } catch (error) {
                if (error.status !== 409)
                  throw error;
                url = "";
                return {
                  value: {
                    status: 200,
                    headers: {},
                    data: []
                  }
                };
              }
            }
          })
        };
      }
      function paginate(octokit2, route, parameters, mapFn) {
        if (typeof parameters === "function") {
          mapFn = parameters;
          parameters = void 0;
        }
        return gather(
          octokit2,
          [],
          iterator(octokit2, route, parameters)[Symbol.asyncIterator](),
          mapFn
        );
      }
      function gather(octokit2, results, iterator2, mapFn) {
        return iterator2.next().then((result) => {
          if (result.done) {
            return results;
          }
          let earlyExit = false;
          function done() {
            earlyExit = true;
          }
          results = results.concat(
            mapFn ? mapFn(result.value, done) : result.value.data
          );
          if (earlyExit) {
            return results;
          }
          return gather(octokit2, results, iterator2, mapFn);
        });
      }
      var composePaginateRest = Object.assign(paginate, {
        iterator
      });
      var paginatingEndpoints = [
        "GET /advisories",
        "GET /app/hook/deliveries",
        "GET /app/installation-requests",
        "GET /app/installations",
        "GET /assignments/{assignment_id}/accepted_assignments",
        "GET /classrooms",
        "GET /classrooms/{classroom_id}/assignments",
        "GET /enterprises/{enterprise}/dependabot/alerts",
        "GET /enterprises/{enterprise}/secret-scanning/alerts",
        "GET /events",
        "GET /gists",
        "GET /gists/public",
        "GET /gists/starred",
        "GET /gists/{gist_id}/comments",
        "GET /gists/{gist_id}/commits",
        "GET /gists/{gist_id}/forks",
        "GET /installation/repositories",
        "GET /issues",
        "GET /licenses",
        "GET /marketplace_listing/plans",
        "GET /marketplace_listing/plans/{plan_id}/accounts",
        "GET /marketplace_listing/stubbed/plans",
        "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
        "GET /networks/{owner}/{repo}/events",
        "GET /notifications",
        "GET /organizations",
        "GET /orgs/{org}/actions/cache/usage-by-repository",
        "GET /orgs/{org}/actions/permissions/repositories",
        "GET /orgs/{org}/actions/runners",
        "GET /orgs/{org}/actions/secrets",
        "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
        "GET /orgs/{org}/actions/variables",
        "GET /orgs/{org}/actions/variables/{name}/repositories",
        "GET /orgs/{org}/blocks",
        "GET /orgs/{org}/code-scanning/alerts",
        "GET /orgs/{org}/codespaces",
        "GET /orgs/{org}/codespaces/secrets",
        "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
        "GET /orgs/{org}/copilot/billing/seats",
        "GET /orgs/{org}/dependabot/alerts",
        "GET /orgs/{org}/dependabot/secrets",
        "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
        "GET /orgs/{org}/events",
        "GET /orgs/{org}/failed_invitations",
        "GET /orgs/{org}/hooks",
        "GET /orgs/{org}/hooks/{hook_id}/deliveries",
        "GET /orgs/{org}/installations",
        "GET /orgs/{org}/invitations",
        "GET /orgs/{org}/invitations/{invitation_id}/teams",
        "GET /orgs/{org}/issues",
        "GET /orgs/{org}/members",
        "GET /orgs/{org}/members/{username}/codespaces",
        "GET /orgs/{org}/migrations",
        "GET /orgs/{org}/migrations/{migration_id}/repositories",
        "GET /orgs/{org}/organization-roles/{role_id}/teams",
        "GET /orgs/{org}/organization-roles/{role_id}/users",
        "GET /orgs/{org}/outside_collaborators",
        "GET /orgs/{org}/packages",
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
        "GET /orgs/{org}/personal-access-token-requests",
        "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
        "GET /orgs/{org}/personal-access-tokens",
        "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
        "GET /orgs/{org}/projects",
        "GET /orgs/{org}/properties/values",
        "GET /orgs/{org}/public_members",
        "GET /orgs/{org}/repos",
        "GET /orgs/{org}/rulesets",
        "GET /orgs/{org}/rulesets/rule-suites",
        "GET /orgs/{org}/secret-scanning/alerts",
        "GET /orgs/{org}/security-advisories",
        "GET /orgs/{org}/teams",
        "GET /orgs/{org}/teams/{team_slug}/discussions",
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
        "GET /orgs/{org}/teams/{team_slug}/invitations",
        "GET /orgs/{org}/teams/{team_slug}/members",
        "GET /orgs/{org}/teams/{team_slug}/projects",
        "GET /orgs/{org}/teams/{team_slug}/repos",
        "GET /orgs/{org}/teams/{team_slug}/teams",
        "GET /projects/columns/{column_id}/cards",
        "GET /projects/{project_id}/collaborators",
        "GET /projects/{project_id}/columns",
        "GET /repos/{owner}/{repo}/actions/artifacts",
        "GET /repos/{owner}/{repo}/actions/caches",
        "GET /repos/{owner}/{repo}/actions/organization-secrets",
        "GET /repos/{owner}/{repo}/actions/organization-variables",
        "GET /repos/{owner}/{repo}/actions/runners",
        "GET /repos/{owner}/{repo}/actions/runs",
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
        "GET /repos/{owner}/{repo}/actions/secrets",
        "GET /repos/{owner}/{repo}/actions/variables",
        "GET /repos/{owner}/{repo}/actions/workflows",
        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
        "GET /repos/{owner}/{repo}/activity",
        "GET /repos/{owner}/{repo}/assignees",
        "GET /repos/{owner}/{repo}/branches",
        "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
        "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
        "GET /repos/{owner}/{repo}/code-scanning/alerts",
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
        "GET /repos/{owner}/{repo}/code-scanning/analyses",
        "GET /repos/{owner}/{repo}/codespaces",
        "GET /repos/{owner}/{repo}/codespaces/devcontainers",
        "GET /repos/{owner}/{repo}/codespaces/secrets",
        "GET /repos/{owner}/{repo}/collaborators",
        "GET /repos/{owner}/{repo}/comments",
        "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
        "GET /repos/{owner}/{repo}/commits",
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
        "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
        "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
        "GET /repos/{owner}/{repo}/commits/{ref}/status",
        "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
        "GET /repos/{owner}/{repo}/contributors",
        "GET /repos/{owner}/{repo}/dependabot/alerts",
        "GET /repos/{owner}/{repo}/dependabot/secrets",
        "GET /repos/{owner}/{repo}/deployments",
        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
        "GET /repos/{owner}/{repo}/environments",
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
        "GET /repos/{owner}/{repo}/events",
        "GET /repos/{owner}/{repo}/forks",
        "GET /repos/{owner}/{repo}/hooks",
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
        "GET /repos/{owner}/{repo}/invitations",
        "GET /repos/{owner}/{repo}/issues",
        "GET /repos/{owner}/{repo}/issues/comments",
        "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
        "GET /repos/{owner}/{repo}/issues/events",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
        "GET /repos/{owner}/{repo}/keys",
        "GET /repos/{owner}/{repo}/labels",
        "GET /repos/{owner}/{repo}/milestones",
        "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
        "GET /repos/{owner}/{repo}/notifications",
        "GET /repos/{owner}/{repo}/pages/builds",
        "GET /repos/{owner}/{repo}/projects",
        "GET /repos/{owner}/{repo}/pulls",
        "GET /repos/{owner}/{repo}/pulls/comments",
        "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
        "GET /repos/{owner}/{repo}/releases",
        "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
        "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
        "GET /repos/{owner}/{repo}/rules/branches/{branch}",
        "GET /repos/{owner}/{repo}/rulesets",
        "GET /repos/{owner}/{repo}/rulesets/rule-suites",
        "GET /repos/{owner}/{repo}/secret-scanning/alerts",
        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
        "GET /repos/{owner}/{repo}/security-advisories",
        "GET /repos/{owner}/{repo}/stargazers",
        "GET /repos/{owner}/{repo}/subscribers",
        "GET /repos/{owner}/{repo}/tags",
        "GET /repos/{owner}/{repo}/teams",
        "GET /repos/{owner}/{repo}/topics",
        "GET /repositories",
        "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
        "GET /repositories/{repository_id}/environments/{environment_name}/variables",
        "GET /search/code",
        "GET /search/commits",
        "GET /search/issues",
        "GET /search/labels",
        "GET /search/repositories",
        "GET /search/topics",
        "GET /search/users",
        "GET /teams/{team_id}/discussions",
        "GET /teams/{team_id}/discussions/{discussion_number}/comments",
        "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
        "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
        "GET /teams/{team_id}/invitations",
        "GET /teams/{team_id}/members",
        "GET /teams/{team_id}/projects",
        "GET /teams/{team_id}/repos",
        "GET /teams/{team_id}/teams",
        "GET /user/blocks",
        "GET /user/codespaces",
        "GET /user/codespaces/secrets",
        "GET /user/emails",
        "GET /user/followers",
        "GET /user/following",
        "GET /user/gpg_keys",
        "GET /user/installations",
        "GET /user/installations/{installation_id}/repositories",
        "GET /user/issues",
        "GET /user/keys",
        "GET /user/marketplace_purchases",
        "GET /user/marketplace_purchases/stubbed",
        "GET /user/memberships/orgs",
        "GET /user/migrations",
        "GET /user/migrations/{migration_id}/repositories",
        "GET /user/orgs",
        "GET /user/packages",
        "GET /user/packages/{package_type}/{package_name}/versions",
        "GET /user/public_emails",
        "GET /user/repos",
        "GET /user/repository_invitations",
        "GET /user/social_accounts",
        "GET /user/ssh_signing_keys",
        "GET /user/starred",
        "GET /user/subscriptions",
        "GET /user/teams",
        "GET /users",
        "GET /users/{username}/events",
        "GET /users/{username}/events/orgs/{org}",
        "GET /users/{username}/events/public",
        "GET /users/{username}/followers",
        "GET /users/{username}/following",
        "GET /users/{username}/gists",
        "GET /users/{username}/gpg_keys",
        "GET /users/{username}/keys",
        "GET /users/{username}/orgs",
        "GET /users/{username}/packages",
        "GET /users/{username}/projects",
        "GET /users/{username}/received_events",
        "GET /users/{username}/received_events/public",
        "GET /users/{username}/repos",
        "GET /users/{username}/social_accounts",
        "GET /users/{username}/ssh_signing_keys",
        "GET /users/{username}/starred",
        "GET /users/{username}/subscriptions"
      ];
      function isPaginatingEndpoint(arg) {
        if (typeof arg === "string") {
          return paginatingEndpoints.includes(arg);
        } else {
          return false;
        }
      }
      function paginateRest(octokit2) {
        return {
          paginate: Object.assign(paginate.bind(null, octokit2), {
            iterator: iterator.bind(null, octokit2)
          })
        };
      }
      paginateRest.VERSION = VERSION4;
    }
  });

  // node_modules/@actions/github/lib/utils.js
  var require_utils4 = __commonJS({
    "node_modules/@actions/github/lib/utils.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
      var Context = __importStar2(require_context());
      var Utils = __importStar2(require_utils3());
      var core_1 = require_dist_node3();
      var plugin_rest_endpoint_methods_1 = (init_dist_web6(), __toCommonJS(dist_web_exports3));
      var plugin_paginate_rest_1 = require_dist_node4();
      exports.context = new Context.Context();
      var baseUrl = Utils.getApiBaseUrl();
      exports.defaults = {
        baseUrl,
        request: {
          agent: Utils.getProxyAgent(baseUrl),
          fetch: Utils.getProxyFetch(baseUrl)
        }
      };
      exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
      function getOctokitOptions(token2, options) {
        const opts = Object.assign({}, options || {});
        const auth2 = Utils.getAuthString(token2, opts);
        if (auth2) {
          opts.auth = auth2;
        }
        return opts;
      }
      exports.getOctokitOptions = getOctokitOptions;
    }
  });

  // node_modules/@actions/github/lib/github.js
  var require_github = __commonJS({
    "node_modules/@actions/github/lib/github.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getOctokit = exports.context = void 0;
      var Context = __importStar2(require_context());
      var utils_1 = require_utils4();
      exports.context = new Context.Context();
      function getOctokit2(token2, options, ...additionalPlugins) {
        const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
        return new GitHubWithPlugins((0, utils_1.getOctokitOptions)(token2, options));
      }
      exports.getOctokit = getOctokit2;
    }
  });

  // node_modules/tslib/tslib.es6.mjs
  var tslib_es6_exports = {};
  __export(tslib_es6_exports, {
    __addDisposableResource: () => __addDisposableResource,
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldIn: () => __classPrivateFieldIn,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __disposeResources: () => __disposeResources,
    __esDecorate: () => __esDecorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __propKey: () => __propKey,
    __read: () => __read,
    __rest: () => __rest,
    __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
    __runInitializers: () => __runInitializers,
    __setFunctionName: () => __setFunctionName,
    __spread: () => __spread,
    __spreadArray: () => __spreadArray,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values,
    default: () => tslib_es6_default
  });
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context2 = {};
      for (var p in contextIn) context2[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context2.access[p] = contextIn.access[p];
      context2.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }
  function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  }
  function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
  }
  function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q2 = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f) {
      return function(v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q2.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q2[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  }
  function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  }
  function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  }
  function __disposeResources(env) {
    function fail(e) {
      env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  }
  function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
        return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
      });
    }
    return path;
  }
  var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
  var init_tslib_es6 = __esm({
    "node_modules/tslib/tslib.es6.mjs"() {
      extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      };
      __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
      };
      tslib_es6_default = {
        __extends,
        __assign,
        __rest,
        __decorate,
        __param,
        __esDecorate,
        __runInitializers,
        __propKey,
        __setFunctionName,
        __metadata,
        __awaiter,
        __generator,
        __createBinding,
        __exportStar,
        __values,
        __read,
        __spread,
        __spreadArrays,
        __spreadArray,
        __await,
        __asyncGenerator,
        __asyncDelegator,
        __asyncValues,
        __makeTemplateObject,
        __importStar,
        __importDefault,
        __classPrivateFieldGet,
        __classPrivateFieldSet,
        __classPrivateFieldIn,
        __addDisposableResource,
        __disposeResources,
        __rewriteRelativeImportExtension
      };
    }
  });

  // node_modules/ts-invariant/lib/invariant.cjs
  var require_invariant = __commonJS({
    "node_modules/ts-invariant/lib/invariant.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var genericMessage = "Invariant Violation";
      var _a = Object.setPrototypeOf;
      var setPrototypeOf = _a === void 0 ? function(obj, proto) {
        obj.__proto__ = proto;
        return obj;
      } : _a;
      var InvariantError = (
        /** @class */
        function(_super) {
          tslib.__extends(InvariantError2, _super);
          function InvariantError2(message) {
            if (message === void 0) {
              message = genericMessage;
            }
            var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
            _this.framesToPop = 1;
            _this.name = genericMessage;
            setPrototypeOf(_this, InvariantError2.prototype);
            return _this;
          }
          return InvariantError2;
        }(Error)
      );
      function invariant(condition, message) {
        if (!condition) {
          throw new InvariantError(message);
        }
      }
      var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
      var verbosityLevel = verbosityLevels.indexOf("log");
      function wrapConsoleMethod(name) {
        return function() {
          if (verbosityLevels.indexOf(name) >= verbosityLevel) {
            var method = console[name] || console.log;
            return method.apply(console, arguments);
          }
        };
      }
      (function(invariant2) {
        invariant2.debug = wrapConsoleMethod("debug");
        invariant2.log = wrapConsoleMethod("log");
        invariant2.warn = wrapConsoleMethod("warn");
        invariant2.error = wrapConsoleMethod("error");
      })(invariant || (invariant = {}));
      function setVerbosity(level) {
        var old = verbosityLevels[verbosityLevel];
        verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
        return old;
      }
      var invariant$1 = invariant;
      exports.InvariantError = InvariantError;
      exports["default"] = invariant$1;
      exports.invariant = invariant;
      exports.setVerbosity = setVerbosity;
    }
  });

  // node_modules/@apollo/client/utilities/globals/globals.cjs
  var require_globals = __commonJS({
    "node_modules/@apollo/client/utilities/globals/globals.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tsInvariant = require_invariant();
      var version = "3.12.7";
      function maybe(thunk) {
        try {
          return thunk();
        } catch (_a) {
        }
      }
      var global$1 = maybe(function() {
        return globalThis;
      }) || maybe(function() {
        return window;
      }) || maybe(function() {
        return self;
      }) || maybe(function() {
        return global;
      }) || maybe(function() {
        return maybe.constructor("return this")();
      });
      var prefixCounts = /* @__PURE__ */ new Map();
      function makeUniqueId(prefix) {
        var count = prefixCounts.get(prefix) || 1;
        prefixCounts.set(prefix, count + 1);
        return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
      }
      function stringifyForDisplay(value, space) {
        if (space === void 0) {
          space = 0;
        }
        var undefId = makeUniqueId("stringifyForDisplay");
        return JSON.stringify(value, function(key, value2) {
          return value2 === void 0 ? undefId : value2;
        }, space).split(JSON.stringify(undefId)).join("<undefined>");
      }
      function wrap(fn) {
        return function(message) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          if (typeof message === "number") {
            var arg0 = message;
            message = getHandledErrorMsg(arg0);
            if (!message) {
              message = getFallbackErrorMsg(arg0, args);
              args = [];
            }
          }
          fn.apply(void 0, [message].concat(args));
        };
      }
      var invariant = Object.assign(function invariant2(condition, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        if (!condition) {
          tsInvariant.invariant(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));
        }
      }, {
        debug: wrap(tsInvariant.invariant.debug),
        log: wrap(tsInvariant.invariant.log),
        warn: wrap(tsInvariant.invariant.warn),
        error: wrap(tsInvariant.invariant.error)
      });
      function newInvariantError(message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          optionalParams[_i - 1] = arguments[_i];
        }
        return new tsInvariant.InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));
      }
      var ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version);
      function stringify(arg) {
        if (typeof arg == "string") {
          return arg;
        }
        try {
          return stringifyForDisplay(arg, 2).slice(0, 1e3);
        } catch (_a) {
          return "<non-serializable>";
        }
      }
      function getHandledErrorMsg(message, messageArgs) {
        if (messageArgs === void 0) {
          messageArgs = [];
        }
        if (!message)
          return;
        return global$1[ApolloErrorMessageHandler] && global$1[ApolloErrorMessageHandler](message, messageArgs.map(stringify));
      }
      function getFallbackErrorMsg(message, messageArgs) {
        if (messageArgs === void 0) {
          messageArgs = [];
        }
        if (!message)
          return;
        return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
          version,
          message,
          args: messageArgs.map(stringify)
        })));
      }
      var DEV = globalThis.__DEV__ !== false;
      exports.InvariantError = tsInvariant.InvariantError;
      exports.DEV = DEV;
      exports.__DEV__ = DEV;
      exports.global = global$1;
      exports.invariant = invariant;
      exports.maybe = maybe;
      exports.newInvariantError = newInvariantError;
    }
  });

  // node_modules/graphql/version.js
  var require_version = __commonJS({
    "node_modules/graphql/version.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.versionInfo = exports.version = void 0;
      var version = "16.10.0";
      exports.version = version;
      var versionInfo = Object.freeze({
        major: 16,
        minor: 10,
        patch: 0,
        preReleaseTag: null
      });
      exports.versionInfo = versionInfo;
    }
  });

  // node_modules/graphql/jsutils/devAssert.js
  var require_devAssert = __commonJS({
    "node_modules/graphql/jsutils/devAssert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.devAssert = devAssert;
      function devAssert(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(message);
        }
      }
    }
  });

  // node_modules/graphql/jsutils/isPromise.js
  var require_isPromise = __commonJS({
    "node_modules/graphql/jsutils/isPromise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isPromise = isPromise;
      function isPromise(value) {
        return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
      }
    }
  });

  // node_modules/graphql/jsutils/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/graphql/jsutils/isObjectLike.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isObjectLike = isObjectLike;
      function isObjectLike(value) {
        return typeof value == "object" && value !== null;
      }
    }
  });

  // node_modules/graphql/jsutils/invariant.js
  var require_invariant2 = __commonJS({
    "node_modules/graphql/jsutils/invariant.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invariant = invariant;
      function invariant(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(
            message != null ? message : "Unexpected invariant triggered."
          );
        }
      }
    }
  });

  // node_modules/graphql/language/location.js
  var require_location = __commonJS({
    "node_modules/graphql/language/location.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getLocation = getLocation;
      var _invariant = require_invariant2();
      var LineRegExp = /\r\n|[\n\r]/g;
      function getLocation(source, position) {
        let lastLineStart = 0;
        let line = 1;
        for (const match of source.body.matchAll(LineRegExp)) {
          typeof match.index === "number" || (0, _invariant.invariant)(false);
          if (match.index >= position) {
            break;
          }
          lastLineStart = match.index + match[0].length;
          line += 1;
        }
        return {
          line,
          column: position + 1 - lastLineStart
        };
      }
    }
  });

  // node_modules/graphql/language/printLocation.js
  var require_printLocation = __commonJS({
    "node_modules/graphql/language/printLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printLocation = printLocation;
      exports.printSourceLocation = printSourceLocation;
      var _location = require_location();
      function printLocation(location) {
        return printSourceLocation(
          location.source,
          (0, _location.getLocation)(location.source, location.start)
        );
      }
      function printSourceLocation(source, sourceLocation) {
        const firstLineColumnOffset = source.locationOffset.column - 1;
        const body = "".padStart(firstLineColumnOffset) + source.body;
        const lineIndex = sourceLocation.line - 1;
        const lineOffset = source.locationOffset.line - 1;
        const lineNum = sourceLocation.line + lineOffset;
        const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
        const columnNum = sourceLocation.column + columnOffset;
        const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
        const lines = body.split(/\r\n|[\n\r]/g);
        const locationLine = lines[lineIndex];
        if (locationLine.length > 120) {
          const subLineIndex = Math.floor(columnNum / 80);
          const subLineColumnNum = columnNum % 80;
          const subLines = [];
          for (let i = 0; i < locationLine.length; i += 80) {
            subLines.push(locationLine.slice(i, i + 80));
          }
          return locationStr + printPrefixedLines([
            [`${lineNum} |`, subLines[0]],
            ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
            ["|", "^".padStart(subLineColumnNum)],
            ["|", subLines[subLineIndex + 1]]
          ]);
        }
        return locationStr + printPrefixedLines([
          // Lines specified like this: ["prefix", "string"],
          [`${lineNum - 1} |`, lines[lineIndex - 1]],
          [`${lineNum} |`, locationLine],
          ["|", "^".padStart(columnNum)],
          [`${lineNum + 1} |`, lines[lineIndex + 1]]
        ]);
      }
      function printPrefixedLines(lines) {
        const existingLines = lines.filter(([_, line]) => line !== void 0);
        const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
        return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
      }
    }
  });

  // node_modules/graphql/error/GraphQLError.js
  var require_GraphQLError = __commonJS({
    "node_modules/graphql/error/GraphQLError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLError = void 0;
      exports.formatError = formatError;
      exports.printError = printError;
      var _isObjectLike = require_isObjectLike();
      var _location = require_location();
      var _printLocation = require_printLocation();
      function toNormalizedOptions(args) {
        const firstArg = args[0];
        if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
          return {
            nodes: firstArg,
            source: args[1],
            positions: args[2],
            path: args[3],
            originalError: args[4],
            extensions: args[5]
          };
        }
        return firstArg;
      }
      var GraphQLError = class _GraphQLError extends Error {
        /**
         * An array of `{ line, column }` locations within the source GraphQL document
         * which correspond to this error.
         *
         * Errors during validation often contain multiple locations, for example to
         * point out two things with the same name. Errors during execution include a
         * single location, the field which produced the error.
         *
         * Enumerable, and appears in the result of JSON.stringify().
         */
        /**
         * An array describing the JSON-path into the execution response which
         * corresponds to this error. Only included for errors during execution.
         *
         * Enumerable, and appears in the result of JSON.stringify().
         */
        /**
         * An array of GraphQL AST Nodes corresponding to this error.
         */
        /**
         * The source GraphQL document for the first location of this error.
         *
         * Note that if this Error represents more than one node, the source may not
         * represent nodes after the first node.
         */
        /**
         * An array of character offsets within the source GraphQL document
         * which correspond to this error.
         */
        /**
         * The original error thrown from a field resolver during execution.
         */
        /**
         * Extension fields to add to the formatted error.
         */
        /**
         * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
         */
        constructor(message, ...rawArgs) {
          var _this$nodes, _nodeLocations$, _ref;
          const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
          super(message);
          this.name = "GraphQLError";
          this.path = path !== null && path !== void 0 ? path : void 0;
          this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
          this.nodes = undefinedIfEmpty(
            Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
          );
          const nodeLocations = undefinedIfEmpty(
            (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
          );
          this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
          this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
          this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map(
            (loc) => (0, _location.getLocation)(loc.source, loc.start)
          );
          const originalExtensions = (0, _isObjectLike.isObjectLike)(
            originalError === null || originalError === void 0 ? void 0 : originalError.extensions
          ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
          this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
          Object.defineProperties(this, {
            message: {
              writable: true,
              enumerable: true
            },
            name: {
              enumerable: false
            },
            nodes: {
              enumerable: false
            },
            source: {
              enumerable: false
            },
            positions: {
              enumerable: false
            },
            originalError: {
              enumerable: false
            }
          });
          if (originalError !== null && originalError !== void 0 && originalError.stack) {
            Object.defineProperty(this, "stack", {
              value: originalError.stack,
              writable: true,
              configurable: true
            });
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, _GraphQLError);
          } else {
            Object.defineProperty(this, "stack", {
              value: Error().stack,
              writable: true,
              configurable: true
            });
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLError";
        }
        toString() {
          let output = this.message;
          if (this.nodes) {
            for (const node of this.nodes) {
              if (node.loc) {
                output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
              }
            }
          } else if (this.source && this.locations) {
            for (const location of this.locations) {
              output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
            }
          }
          return output;
        }
        toJSON() {
          const formattedError = {
            message: this.message
          };
          if (this.locations != null) {
            formattedError.locations = this.locations;
          }
          if (this.path != null) {
            formattedError.path = this.path;
          }
          if (this.extensions != null && Object.keys(this.extensions).length > 0) {
            formattedError.extensions = this.extensions;
          }
          return formattedError;
        }
      };
      exports.GraphQLError = GraphQLError;
      function undefinedIfEmpty(array) {
        return array === void 0 || array.length === 0 ? void 0 : array;
      }
      function printError(error) {
        return error.toString();
      }
      function formatError(error) {
        return error.toJSON();
      }
    }
  });

  // node_modules/graphql/error/syntaxError.js
  var require_syntaxError = __commonJS({
    "node_modules/graphql/error/syntaxError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.syntaxError = syntaxError;
      var _GraphQLError = require_GraphQLError();
      function syntaxError(source, position, description) {
        return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
          source,
          positions: [position]
        });
      }
    }
  });

  // node_modules/graphql/language/ast.js
  var require_ast = __commonJS({
    "node_modules/graphql/language/ast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Token = exports.QueryDocumentKeys = exports.OperationTypeNode = exports.Location = void 0;
      exports.isNode = isNode;
      var Location = class {
        /**
         * The character offset at which this Node begins.
         */
        /**
         * The character offset at which this Node ends.
         */
        /**
         * The Token at which this Node begins.
         */
        /**
         * The Token at which this Node ends.
         */
        /**
         * The Source document the AST represents.
         */
        constructor(startToken, endToken, source) {
          this.start = startToken.start;
          this.end = endToken.end;
          this.startToken = startToken;
          this.endToken = endToken;
          this.source = source;
        }
        get [Symbol.toStringTag]() {
          return "Location";
        }
        toJSON() {
          return {
            start: this.start,
            end: this.end
          };
        }
      };
      exports.Location = Location;
      var Token = class {
        /**
         * The kind of Token.
         */
        /**
         * The character offset at which this Node begins.
         */
        /**
         * The character offset at which this Node ends.
         */
        /**
         * The 1-indexed line number on which this Token appears.
         */
        /**
         * The 1-indexed column number at which this Token begins.
         */
        /**
         * For non-punctuation tokens, represents the interpreted value of the token.
         *
         * Note: is undefined for punctuation tokens, but typed as string for
         * convenience in the parser.
         */
        /**
         * Tokens exist as nodes in a double-linked-list amongst all tokens
         * including ignored tokens. <SOF> is always the first node and <EOF>
         * the last.
         */
        constructor(kind, start, end, line, column, value) {
          this.kind = kind;
          this.start = start;
          this.end = end;
          this.line = line;
          this.column = column;
          this.value = value;
          this.prev = null;
          this.next = null;
        }
        get [Symbol.toStringTag]() {
          return "Token";
        }
        toJSON() {
          return {
            kind: this.kind,
            value: this.value,
            line: this.line,
            column: this.column
          };
        }
      };
      exports.Token = Token;
      var QueryDocumentKeys = {
        Name: [],
        Document: ["definitions"],
        OperationDefinition: [
          "name",
          "variableDefinitions",
          "directives",
          "selectionSet"
        ],
        VariableDefinition: ["variable", "type", "defaultValue", "directives"],
        Variable: ["name"],
        SelectionSet: ["selections"],
        Field: ["alias", "name", "arguments", "directives", "selectionSet"],
        Argument: ["name", "value"],
        FragmentSpread: ["name", "directives"],
        InlineFragment: ["typeCondition", "directives", "selectionSet"],
        FragmentDefinition: [
          "name",
          // Note: fragment variable definitions are deprecated and will removed in v17.0.0
          "variableDefinitions",
          "typeCondition",
          "directives",
          "selectionSet"
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ["values"],
        ObjectValue: ["fields"],
        ObjectField: ["name", "value"],
        Directive: ["name", "arguments"],
        NamedType: ["name"],
        ListType: ["type"],
        NonNullType: ["type"],
        SchemaDefinition: ["description", "directives", "operationTypes"],
        OperationTypeDefinition: ["type"],
        ScalarTypeDefinition: ["description", "name", "directives"],
        ObjectTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        FieldDefinition: ["description", "name", "arguments", "type", "directives"],
        InputValueDefinition: [
          "description",
          "name",
          "type",
          "defaultValue",
          "directives"
        ],
        InterfaceTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        UnionTypeDefinition: ["description", "name", "directives", "types"],
        EnumTypeDefinition: ["description", "name", "directives", "values"],
        EnumValueDefinition: ["description", "name", "directives"],
        InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
        DirectiveDefinition: ["description", "name", "arguments", "locations"],
        SchemaExtension: ["directives", "operationTypes"],
        ScalarTypeExtension: ["name", "directives"],
        ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
        InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
        UnionTypeExtension: ["name", "directives", "types"],
        EnumTypeExtension: ["name", "directives", "values"],
        InputObjectTypeExtension: ["name", "directives", "fields"]
      };
      exports.QueryDocumentKeys = QueryDocumentKeys;
      var kindValues = new Set(Object.keys(QueryDocumentKeys));
      function isNode(maybeNode) {
        const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
        return typeof maybeKind === "string" && kindValues.has(maybeKind);
      }
      var OperationTypeNode;
      exports.OperationTypeNode = OperationTypeNode;
      (function(OperationTypeNode2) {
        OperationTypeNode2["QUERY"] = "query";
        OperationTypeNode2["MUTATION"] = "mutation";
        OperationTypeNode2["SUBSCRIPTION"] = "subscription";
      })(OperationTypeNode || (exports.OperationTypeNode = OperationTypeNode = {}));
    }
  });

  // node_modules/graphql/language/directiveLocation.js
  var require_directiveLocation = __commonJS({
    "node_modules/graphql/language/directiveLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DirectiveLocation = void 0;
      var DirectiveLocation;
      exports.DirectiveLocation = DirectiveLocation;
      (function(DirectiveLocation2) {
        DirectiveLocation2["QUERY"] = "QUERY";
        DirectiveLocation2["MUTATION"] = "MUTATION";
        DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
        DirectiveLocation2["FIELD"] = "FIELD";
        DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
        DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
        DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
        DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
        DirectiveLocation2["SCHEMA"] = "SCHEMA";
        DirectiveLocation2["SCALAR"] = "SCALAR";
        DirectiveLocation2["OBJECT"] = "OBJECT";
        DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
        DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
        DirectiveLocation2["INTERFACE"] = "INTERFACE";
        DirectiveLocation2["UNION"] = "UNION";
        DirectiveLocation2["ENUM"] = "ENUM";
        DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
        DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
        DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
      })(DirectiveLocation || (exports.DirectiveLocation = DirectiveLocation = {}));
    }
  });

  // node_modules/graphql/language/kinds.js
  var require_kinds = __commonJS({
    "node_modules/graphql/language/kinds.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Kind = void 0;
      var Kind;
      exports.Kind = Kind;
      (function(Kind2) {
        Kind2["NAME"] = "Name";
        Kind2["DOCUMENT"] = "Document";
        Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
        Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
        Kind2["SELECTION_SET"] = "SelectionSet";
        Kind2["FIELD"] = "Field";
        Kind2["ARGUMENT"] = "Argument";
        Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
        Kind2["INLINE_FRAGMENT"] = "InlineFragment";
        Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
        Kind2["VARIABLE"] = "Variable";
        Kind2["INT"] = "IntValue";
        Kind2["FLOAT"] = "FloatValue";
        Kind2["STRING"] = "StringValue";
        Kind2["BOOLEAN"] = "BooleanValue";
        Kind2["NULL"] = "NullValue";
        Kind2["ENUM"] = "EnumValue";
        Kind2["LIST"] = "ListValue";
        Kind2["OBJECT"] = "ObjectValue";
        Kind2["OBJECT_FIELD"] = "ObjectField";
        Kind2["DIRECTIVE"] = "Directive";
        Kind2["NAMED_TYPE"] = "NamedType";
        Kind2["LIST_TYPE"] = "ListType";
        Kind2["NON_NULL_TYPE"] = "NonNullType";
        Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
        Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
        Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
        Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
        Kind2["FIELD_DEFINITION"] = "FieldDefinition";
        Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
        Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
        Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
        Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
        Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
        Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
        Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
        Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
        Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
        Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
        Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
        Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
        Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
        Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
      })(Kind || (exports.Kind = Kind = {}));
    }
  });

  // node_modules/graphql/language/characterClasses.js
  var require_characterClasses = __commonJS({
    "node_modules/graphql/language/characterClasses.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isDigit = isDigit;
      exports.isLetter = isLetter;
      exports.isNameContinue = isNameContinue;
      exports.isNameStart = isNameStart;
      exports.isWhiteSpace = isWhiteSpace;
      function isWhiteSpace(code) {
        return code === 9 || code === 32;
      }
      function isDigit(code) {
        return code >= 48 && code <= 57;
      }
      function isLetter(code) {
        return code >= 97 && code <= 122 || // A-Z
        code >= 65 && code <= 90;
      }
      function isNameStart(code) {
        return isLetter(code) || code === 95;
      }
      function isNameContinue(code) {
        return isLetter(code) || isDigit(code) || code === 95;
      }
    }
  });

  // node_modules/graphql/language/blockString.js
  var require_blockString = __commonJS({
    "node_modules/graphql/language/blockString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dedentBlockStringLines = dedentBlockStringLines;
      exports.isPrintableAsBlockString = isPrintableAsBlockString;
      exports.printBlockString = printBlockString;
      var _characterClasses = require_characterClasses();
      function dedentBlockStringLines(lines) {
        var _firstNonEmptyLine2;
        let commonIndent = Number.MAX_SAFE_INTEGER;
        let firstNonEmptyLine = null;
        let lastNonEmptyLine = -1;
        for (let i = 0; i < lines.length; ++i) {
          var _firstNonEmptyLine;
          const line = lines[i];
          const indent = leadingWhitespace(line);
          if (indent === line.length) {
            continue;
          }
          firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
          lastNonEmptyLine = i;
          if (i !== 0 && indent < commonIndent) {
            commonIndent = indent;
          }
        }
        return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
          (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
          lastNonEmptyLine + 1
        );
      }
      function leadingWhitespace(str) {
        let i = 0;
        while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
          ++i;
        }
        return i;
      }
      function isPrintableAsBlockString(value) {
        if (value === "") {
          return true;
        }
        let isEmptyLine = true;
        let hasIndent = false;
        let hasCommonIndent = true;
        let seenNonEmptyLine = false;
        for (let i = 0; i < value.length; ++i) {
          switch (value.codePointAt(i)) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 11:
            case 12:
            case 14:
            case 15:
              return false;
            // Has non-printable characters
            case 13:
              return false;
            // Has \r or \r\n which will be replaced as \n
            case 10:
              if (isEmptyLine && !seenNonEmptyLine) {
                return false;
              }
              seenNonEmptyLine = true;
              isEmptyLine = true;
              hasIndent = false;
              break;
            case 9:
            //   \t
            case 32:
              hasIndent || (hasIndent = isEmptyLine);
              break;
            default:
              hasCommonIndent && (hasCommonIndent = hasIndent);
              isEmptyLine = false;
          }
        }
        if (isEmptyLine) {
          return false;
        }
        if (hasCommonIndent && seenNonEmptyLine) {
          return false;
        }
        return true;
      }
      function printBlockString(value, options) {
        const escapedValue = value.replace(/"""/g, '\\"""');
        const lines = escapedValue.split(/\r\n|[\n\r]/g);
        const isSingleLine = lines.length === 1;
        const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
          (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
        );
        const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
        const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
        const hasTrailingSlash = value.endsWith("\\");
        const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
        const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
        (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
        let result = "";
        const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
        if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
          result += "\n";
        }
        result += escapedValue;
        if (printAsMultipleLines || forceTrailingNewline) {
          result += "\n";
        }
        return '"""' + result + '"""';
      }
    }
  });

  // node_modules/graphql/language/tokenKind.js
  var require_tokenKind = __commonJS({
    "node_modules/graphql/language/tokenKind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TokenKind = void 0;
      var TokenKind;
      exports.TokenKind = TokenKind;
      (function(TokenKind2) {
        TokenKind2["SOF"] = "<SOF>";
        TokenKind2["EOF"] = "<EOF>";
        TokenKind2["BANG"] = "!";
        TokenKind2["DOLLAR"] = "$";
        TokenKind2["AMP"] = "&";
        TokenKind2["PAREN_L"] = "(";
        TokenKind2["PAREN_R"] = ")";
        TokenKind2["SPREAD"] = "...";
        TokenKind2["COLON"] = ":";
        TokenKind2["EQUALS"] = "=";
        TokenKind2["AT"] = "@";
        TokenKind2["BRACKET_L"] = "[";
        TokenKind2["BRACKET_R"] = "]";
        TokenKind2["BRACE_L"] = "{";
        TokenKind2["PIPE"] = "|";
        TokenKind2["BRACE_R"] = "}";
        TokenKind2["NAME"] = "Name";
        TokenKind2["INT"] = "Int";
        TokenKind2["FLOAT"] = "Float";
        TokenKind2["STRING"] = "String";
        TokenKind2["BLOCK_STRING"] = "BlockString";
        TokenKind2["COMMENT"] = "Comment";
      })(TokenKind || (exports.TokenKind = TokenKind = {}));
    }
  });

  // node_modules/graphql/language/lexer.js
  var require_lexer = __commonJS({
    "node_modules/graphql/language/lexer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Lexer = void 0;
      exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast();
      var _blockString = require_blockString();
      var _characterClasses = require_characterClasses();
      var _tokenKind = require_tokenKind();
      var Lexer = class {
        /**
         * The previously focused non-ignored token.
         */
        /**
         * The currently focused non-ignored token.
         */
        /**
         * The (1-indexed) line containing the current token.
         */
        /**
         * The character offset at which the current line begins.
         */
        constructor(source) {
          const startOfFileToken = new _ast.Token(
            _tokenKind.TokenKind.SOF,
            0,
            0,
            0,
            0
          );
          this.source = source;
          this.lastToken = startOfFileToken;
          this.token = startOfFileToken;
          this.line = 1;
          this.lineStart = 0;
        }
        get [Symbol.toStringTag]() {
          return "Lexer";
        }
        /**
         * Advances the token stream to the next non-ignored token.
         */
        advance() {
          this.lastToken = this.token;
          const token2 = this.token = this.lookahead();
          return token2;
        }
        /**
         * Looks ahead and returns the next non-ignored token, but does not change
         * the state of Lexer.
         */
        lookahead() {
          let token2 = this.token;
          if (token2.kind !== _tokenKind.TokenKind.EOF) {
            do {
              if (token2.next) {
                token2 = token2.next;
              } else {
                const nextToken = readNextToken(this, token2.end);
                token2.next = nextToken;
                nextToken.prev = token2;
                token2 = nextToken;
              }
            } while (token2.kind === _tokenKind.TokenKind.COMMENT);
          }
          return token2;
        }
      };
      exports.Lexer = Lexer;
      function isPunctuatorTokenKind(kind) {
        return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
      }
      function isUnicodeScalarValue(code) {
        return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
      }
      function isSupplementaryCodePoint(body, location) {
        return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
      }
      function isLeadingSurrogate(code) {
        return code >= 55296 && code <= 56319;
      }
      function isTrailingSurrogate(code) {
        return code >= 56320 && code <= 57343;
      }
      function printCodePointAt(lexer, location) {
        const code = lexer.source.body.codePointAt(location);
        if (code === void 0) {
          return _tokenKind.TokenKind.EOF;
        } else if (code >= 32 && code <= 126) {
          const char = String.fromCodePoint(code);
          return char === '"' ? `'"'` : `"${char}"`;
        }
        return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
      }
      function createToken(lexer, kind, start, end, value) {
        const line = lexer.line;
        const col = 1 + start - lexer.lineStart;
        return new _ast.Token(kind, start, end, line, col, value);
      }
      function readNextToken(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          switch (code) {
            // Ignored ::
            //   - UnicodeBOM
            //   - WhiteSpace
            //   - LineTerminator
            //   - Comment
            //   - Comma
            //
            // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
            //
            // WhiteSpace ::
            //   - "Horizontal Tab (U+0009)"
            //   - "Space (U+0020)"
            //
            // Comma :: ,
            case 65279:
            // <BOM>
            case 9:
            // \t
            case 32:
            // <space>
            case 44:
              ++position;
              continue;
            // LineTerminator ::
            //   - "New Line (U+000A)"
            //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
            //   - "Carriage Return (U+000D)" "New Line (U+000A)"
            case 10:
              ++position;
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 13:
              if (body.charCodeAt(position + 1) === 10) {
                position += 2;
              } else {
                ++position;
              }
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            // Comment
            case 35:
              return readComment(lexer, position);
            // Token ::
            //   - Punctuator
            //   - Name
            //   - IntValue
            //   - FloatValue
            //   - StringValue
            //
            // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
            case 33:
              return createToken(
                lexer,
                _tokenKind.TokenKind.BANG,
                position,
                position + 1
              );
            case 36:
              return createToken(
                lexer,
                _tokenKind.TokenKind.DOLLAR,
                position,
                position + 1
              );
            case 38:
              return createToken(
                lexer,
                _tokenKind.TokenKind.AMP,
                position,
                position + 1
              );
            case 40:
              return createToken(
                lexer,
                _tokenKind.TokenKind.PAREN_L,
                position,
                position + 1
              );
            case 41:
              return createToken(
                lexer,
                _tokenKind.TokenKind.PAREN_R,
                position,
                position + 1
              );
            case 46:
              if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
                return createToken(
                  lexer,
                  _tokenKind.TokenKind.SPREAD,
                  position,
                  position + 3
                );
              }
              break;
            case 58:
              return createToken(
                lexer,
                _tokenKind.TokenKind.COLON,
                position,
                position + 1
              );
            case 61:
              return createToken(
                lexer,
                _tokenKind.TokenKind.EQUALS,
                position,
                position + 1
              );
            case 64:
              return createToken(
                lexer,
                _tokenKind.TokenKind.AT,
                position,
                position + 1
              );
            case 91:
              return createToken(
                lexer,
                _tokenKind.TokenKind.BRACKET_L,
                position,
                position + 1
              );
            case 93:
              return createToken(
                lexer,
                _tokenKind.TokenKind.BRACKET_R,
                position,
                position + 1
              );
            case 123:
              return createToken(
                lexer,
                _tokenKind.TokenKind.BRACE_L,
                position,
                position + 1
              );
            case 124:
              return createToken(
                lexer,
                _tokenKind.TokenKind.PIPE,
                position,
                position + 1
              );
            case 125:
              return createToken(
                lexer,
                _tokenKind.TokenKind.BRACE_R,
                position,
                position + 1
              );
            // StringValue
            case 34:
              if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
                return readBlockString(lexer, position);
              }
              return readString(lexer, position);
          }
          if ((0, _characterClasses.isDigit)(code) || code === 45) {
            return readNumber(lexer, position, code);
          }
          if ((0, _characterClasses.isNameStart)(code)) {
            return readName(lexer, position);
          }
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
          );
        }
        return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
      }
      function readComment(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            break;
          }
        }
        return createToken(
          lexer,
          _tokenKind.TokenKind.COMMENT,
          start,
          position,
          body.slice(start + 1, position)
        );
      }
      function readNumber(lexer, start, firstCode) {
        const body = lexer.source.body;
        let position = start;
        let code = firstCode;
        let isFloat = false;
        if (code === 45) {
          code = body.charCodeAt(++position);
        }
        if (code === 48) {
          code = body.charCodeAt(++position);
          if ((0, _characterClasses.isDigit)(code)) {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid number, unexpected digit after 0: ${printCodePointAt(
                lexer,
                position
              )}.`
            );
          }
        } else {
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46) {
          isFloat = true;
          code = body.charCodeAt(++position);
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 69 || code === 101) {
          isFloat = true;
          code = body.charCodeAt(++position);
          if (code === 43 || code === 45) {
            code = body.charCodeAt(++position);
          }
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid number, expected digit but got: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
        return createToken(
          lexer,
          isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,
          start,
          position,
          body.slice(start, position)
        );
      }
      function readDigits(lexer, start, firstCode) {
        if (!(0, _characterClasses.isDigit)(firstCode)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            start,
            `Invalid number, expected digit but got: ${printCodePointAt(
              lexer,
              start
            )}.`
          );
        }
        const body = lexer.source.body;
        let position = start + 1;
        while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
          ++position;
        }
        return position;
      }
      function readString(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        let chunkStart = position;
        let value = "";
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34) {
            value += body.slice(chunkStart, position);
            return createToken(
              lexer,
              _tokenKind.TokenKind.STRING,
              start,
              position + 1,
              value
            );
          }
          if (code === 92) {
            value += body.slice(chunkStart, position);
            const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
            value += escape.value;
            position += escape.size;
            chunkStart = position;
            continue;
          }
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid character within String: ${printCodePointAt(
                lexer,
                position
              )}.`
            );
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          "Unterminated string."
        );
      }
      function readEscapedUnicodeVariableWidth(lexer, position) {
        const body = lexer.source.body;
        let point = 0;
        let size = 3;
        while (size < 12) {
          const code = body.charCodeAt(position + size++);
          if (code === 125) {
            if (size < 5 || !isUnicodeScalarValue(point)) {
              break;
            }
            return {
              value: String.fromCodePoint(point),
              size
            };
          }
          point = point << 4 | readHexDigit(code);
          if (point < 0) {
            break;
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid Unicode escape sequence: "${body.slice(
            position,
            position + size
          )}".`
        );
      }
      function readEscapedUnicodeFixedWidth(lexer, position) {
        const body = lexer.source.body;
        const code = read16BitHexCode(body, position + 2);
        if (isUnicodeScalarValue(code)) {
          return {
            value: String.fromCodePoint(code),
            size: 6
          };
        }
        if (isLeadingSurrogate(code)) {
          if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
            const trailingCode = read16BitHexCode(body, position + 8);
            if (isTrailingSurrogate(trailingCode)) {
              return {
                value: String.fromCodePoint(code, trailingCode),
                size: 12
              };
            }
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
        );
      }
      function read16BitHexCode(body, position) {
        return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
      }
      function readHexDigit(code) {
        return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
      }
      function readEscapedCharacter(lexer, position) {
        const body = lexer.source.body;
        const code = body.charCodeAt(position + 1);
        switch (code) {
          case 34:
            return {
              value: '"',
              size: 2
            };
          case 92:
            return {
              value: "\\",
              size: 2
            };
          case 47:
            return {
              value: "/",
              size: 2
            };
          case 98:
            return {
              value: "\b",
              size: 2
            };
          case 102:
            return {
              value: "\f",
              size: 2
            };
          case 110:
            return {
              value: "\n",
              size: 2
            };
          case 114:
            return {
              value: "\r",
              size: 2
            };
          case 116:
            return {
              value: "	",
              size: 2
            };
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid character escape sequence: "${body.slice(
            position,
            position + 2
          )}".`
        );
      }
      function readBlockString(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let lineStart = lexer.lineStart;
        let position = start + 3;
        let chunkStart = position;
        let currentLine = "";
        const blockLines = [];
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            const token2 = createToken(
              lexer,
              _tokenKind.TokenKind.BLOCK_STRING,
              start,
              position + 3,
              // Return a string of the lines joined with U+000A.
              (0, _blockString.dedentBlockStringLines)(blockLines).join("\n")
            );
            lexer.line += blockLines.length - 1;
            lexer.lineStart = lineStart;
            return token2;
          }
          if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
            currentLine += body.slice(chunkStart, position);
            chunkStart = position + 1;
            position += 4;
            continue;
          }
          if (code === 10 || code === 13) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            if (code === 13 && body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            currentLine = "";
            chunkStart = position;
            lineStart = position;
            continue;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid character within String: ${printCodePointAt(
                lexer,
                position
              )}.`
            );
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          "Unterminated string."
        );
      }
      function readName(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if ((0, _characterClasses.isNameContinue)(code)) {
            ++position;
          } else {
            break;
          }
        }
        return createToken(
          lexer,
          _tokenKind.TokenKind.NAME,
          start,
          position,
          body.slice(start, position)
        );
      }
    }
  });

  // node_modules/graphql/jsutils/inspect.js
  var require_inspect = __commonJS({
    "node_modules/graphql/jsutils/inspect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.inspect = inspect;
      var MAX_ARRAY_LENGTH = 10;
      var MAX_RECURSIVE_DEPTH = 2;
      function inspect(value) {
        return formatValue(value, []);
      }
      function formatValue(value, seenValues) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(value);
          case "function":
            return value.name ? `[function ${value.name}]` : "[function]";
          case "object":
            return formatObjectValue(value, seenValues);
          default:
            return String(value);
        }
      }
      function formatObjectValue(value, previouslySeenValues) {
        if (value === null) {
          return "null";
        }
        if (previouslySeenValues.includes(value)) {
          return "[Circular]";
        }
        const seenValues = [...previouslySeenValues, value];
        if (isJSONable(value)) {
          const jsonValue = value.toJSON();
          if (jsonValue !== value) {
            return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
          }
        } else if (Array.isArray(value)) {
          return formatArray(value, seenValues);
        }
        return formatObject(value, seenValues);
      }
      function isJSONable(value) {
        return typeof value.toJSON === "function";
      }
      function formatObject(object, seenValues) {
        const entries = Object.entries(object);
        if (entries.length === 0) {
          return "{}";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
          return "[" + getObjectTag(object) + "]";
        }
        const properties = entries.map(
          ([key, value]) => key + ": " + formatValue(value, seenValues)
        );
        return "{ " + properties.join(", ") + " }";
      }
      function formatArray(array, seenValues) {
        if (array.length === 0) {
          return "[]";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
          return "[Array]";
        }
        const len = Math.min(MAX_ARRAY_LENGTH, array.length);
        const remaining = array.length - len;
        const items = [];
        for (let i = 0; i < len; ++i) {
          items.push(formatValue(array[i], seenValues));
        }
        if (remaining === 1) {
          items.push("... 1 more item");
        } else if (remaining > 1) {
          items.push(`... ${remaining} more items`);
        }
        return "[" + items.join(", ") + "]";
      }
      function getObjectTag(object) {
        const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
        if (tag === "Object" && typeof object.constructor === "function") {
          const name = object.constructor.name;
          if (typeof name === "string" && name !== "") {
            return name;
          }
        }
        return tag;
      }
    }
  });

  // node_modules/graphql/jsutils/instanceOf.js
  var require_instanceOf = __commonJS({
    "node_modules/graphql/jsutils/instanceOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.instanceOf = void 0;
      var _inspect = require_inspect();
      var isProduction = globalThis.process && // eslint-disable-next-line no-undef
      false;
      var instanceOf = (
        /* c8 ignore next 6 */
        // FIXME: https://github.com/graphql/graphql-js/issues/2317
        isProduction ? function instanceOf2(value, constructor) {
          return value instanceof constructor;
        } : function instanceOf2(value, constructor) {
          if (value instanceof constructor) {
            return true;
          }
          if (typeof value === "object" && value !== null) {
            var _value$constructor;
            const className = constructor.prototype[Symbol.toStringTag];
            const valueClassName = (
              // We still need to support constructor's name to detect conflicts with older versions of this library.
              Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
            );
            if (className === valueClassName) {
              const stringifiedValue = (0, _inspect.inspect)(value);
              throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
            }
          }
          return false;
        }
      );
      exports.instanceOf = instanceOf;
    }
  });

  // node_modules/graphql/language/source.js
  var require_source = __commonJS({
    "node_modules/graphql/language/source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Source = void 0;
      exports.isSource = isSource;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var Source = class {
        constructor(body, name = "GraphQL request", locationOffset = {
          line: 1,
          column: 1
        }) {
          typeof body === "string" || (0, _devAssert.devAssert)(
            false,
            `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`
          );
          this.body = body;
          this.name = name;
          this.locationOffset = locationOffset;
          this.locationOffset.line > 0 || (0, _devAssert.devAssert)(
            false,
            "line in locationOffset is 1-indexed and must be positive."
          );
          this.locationOffset.column > 0 || (0, _devAssert.devAssert)(
            false,
            "column in locationOffset is 1-indexed and must be positive."
          );
        }
        get [Symbol.toStringTag]() {
          return "Source";
        }
      };
      exports.Source = Source;
      function isSource(source) {
        return (0, _instanceOf.instanceOf)(source, Source);
      }
    }
  });

  // node_modules/graphql/language/parser.js
  var require_parser = __commonJS({
    "node_modules/graphql/language/parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Parser = void 0;
      exports.parse = parse2;
      exports.parseConstValue = parseConstValue;
      exports.parseType = parseType;
      exports.parseValue = parseValue;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _lexer = require_lexer();
      var _source = require_source();
      var _tokenKind = require_tokenKind();
      function parse2(source, options) {
        const parser = new Parser(source, options);
        const document = parser.parseDocument();
        Object.defineProperty(document, "tokenCount", {
          enumerable: false,
          value: parser.tokenCount
        });
        return document;
      }
      function parseValue(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseValueLiteral(false);
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseConstValue(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseConstValueLiteral();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseType(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const type = parser.parseTypeReference();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return type;
      }
      var Parser = class {
        constructor(source, options = {}) {
          const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
          this._lexer = new _lexer.Lexer(sourceObj);
          this._options = options;
          this._tokenCounter = 0;
        }
        get tokenCount() {
          return this._tokenCounter;
        }
        /**
         * Converts a name lex token into a name parse node.
         */
        parseName() {
          const token2 = this.expectToken(_tokenKind.TokenKind.NAME);
          return this.node(token2, {
            kind: _kinds.Kind.NAME,
            value: token2.value
          });
        }
        // Implements the parsing rules in the Document section.
        /**
         * Document : Definition+
         */
        parseDocument() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.DOCUMENT,
            definitions: this.many(
              _tokenKind.TokenKind.SOF,
              this.parseDefinition,
              _tokenKind.TokenKind.EOF
            )
          });
        }
        /**
         * Definition :
         *   - ExecutableDefinition
         *   - TypeSystemDefinition
         *   - TypeSystemExtension
         *
         * ExecutableDefinition :
         *   - OperationDefinition
         *   - FragmentDefinition
         *
         * TypeSystemDefinition :
         *   - SchemaDefinition
         *   - TypeDefinition
         *   - DirectiveDefinition
         *
         * TypeDefinition :
         *   - ScalarTypeDefinition
         *   - ObjectTypeDefinition
         *   - InterfaceTypeDefinition
         *   - UnionTypeDefinition
         *   - EnumTypeDefinition
         *   - InputObjectTypeDefinition
         */
        parseDefinition() {
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.parseOperationDefinition();
          }
          const hasDescription = this.peekDescription();
          const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaDefinition();
              case "scalar":
                return this.parseScalarTypeDefinition();
              case "type":
                return this.parseObjectTypeDefinition();
              case "interface":
                return this.parseInterfaceTypeDefinition();
              case "union":
                return this.parseUnionTypeDefinition();
              case "enum":
                return this.parseEnumTypeDefinition();
              case "input":
                return this.parseInputObjectTypeDefinition();
              case "directive":
                return this.parseDirectiveDefinition();
            }
            if (hasDescription) {
              throw (0, _syntaxError.syntaxError)(
                this._lexer.source,
                this._lexer.token.start,
                "Unexpected description, descriptions are supported only on type definitions."
              );
            }
            switch (keywordToken.value) {
              case "query":
              case "mutation":
              case "subscription":
                return this.parseOperationDefinition();
              case "fragment":
                return this.parseFragmentDefinition();
              case "extend":
                return this.parseTypeSystemExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        // Implements the parsing rules in the Operations section.
        /**
         * OperationDefinition :
         *  - SelectionSet
         *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
         */
        parseOperationDefinition() {
          const start = this._lexer.token;
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.node(start, {
              kind: _kinds.Kind.OPERATION_DEFINITION,
              operation: _ast.OperationTypeNode.QUERY,
              name: void 0,
              variableDefinitions: [],
              directives: [],
              selectionSet: this.parseSelectionSet()
            });
          }
          const operation = this.parseOperationType();
          let name;
          if (this.peek(_tokenKind.TokenKind.NAME)) {
            name = this.parseName();
          }
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation,
            name,
            variableDefinitions: this.parseVariableDefinitions(),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * OperationType : one of query mutation subscription
         */
        parseOperationType() {
          const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
          switch (operationToken.value) {
            case "query":
              return _ast.OperationTypeNode.QUERY;
            case "mutation":
              return _ast.OperationTypeNode.MUTATION;
            case "subscription":
              return _ast.OperationTypeNode.SUBSCRIPTION;
          }
          throw this.unexpected(operationToken);
        }
        /**
         * VariableDefinitions : ( VariableDefinition+ )
         */
        parseVariableDefinitions() {
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            this.parseVariableDefinition,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        /**
         * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
         */
        parseVariableDefinition() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.VARIABLE_DEFINITION,
            variable: this.parseVariable(),
            type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
            defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
            directives: this.parseConstDirectives()
          });
        }
        /**
         * Variable : $ Name
         */
        parseVariable() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.DOLLAR);
          return this.node(start, {
            kind: _kinds.Kind.VARIABLE,
            name: this.parseName()
          });
        }
        /**
         * ```
         * SelectionSet : { Selection+ }
         * ```
         */
        parseSelectionSet() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.SELECTION_SET,
            selections: this.many(
              _tokenKind.TokenKind.BRACE_L,
              this.parseSelection,
              _tokenKind.TokenKind.BRACE_R
            )
          });
        }
        /**
         * Selection :
         *   - Field
         *   - FragmentSpread
         *   - InlineFragment
         */
        parseSelection() {
          return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
        }
        /**
         * Field : Alias? Name Arguments? Directives? SelectionSet?
         *
         * Alias : Name :
         */
        parseField() {
          const start = this._lexer.token;
          const nameOrAlias = this.parseName();
          let alias;
          let name;
          if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
            alias = nameOrAlias;
            name = this.parseName();
          } else {
            name = nameOrAlias;
          }
          return this.node(start, {
            kind: _kinds.Kind.FIELD,
            alias,
            name,
            arguments: this.parseArguments(false),
            directives: this.parseDirectives(false),
            selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
          });
        }
        /**
         * Arguments[Const] : ( Argument[?Const]+ )
         */
        parseArguments(isConst) {
          const item = isConst ? this.parseConstArgument : this.parseArgument;
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            item,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        /**
         * Argument[Const] : Name : Value[?Const]
         */
        parseArgument(isConst = false) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.ARGUMENT,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        parseConstArgument() {
          return this.parseArgument(true);
        }
        // Implements the parsing rules in the Fragments section.
        /**
         * Corresponds to both FragmentSpread and InlineFragment in the spec.
         *
         * FragmentSpread : ... FragmentName Directives?
         *
         * InlineFragment : ... TypeCondition? Directives? SelectionSet
         */
        parseFragment() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.SPREAD);
          const hasTypeCondition = this.expectOptionalKeyword("on");
          if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_SPREAD,
              name: this.parseFragmentName(),
              directives: this.parseDirectives(false)
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.INLINE_FRAGMENT,
            typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * FragmentDefinition :
         *   - fragment FragmentName on TypeCondition Directives? SelectionSet
         *
         * TypeCondition : NamedType
         */
        parseFragmentDefinition() {
          const start = this._lexer.token;
          this.expectKeyword("fragment");
          if (this._options.allowLegacyFragmentVariables === true) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_DEFINITION,
              name: this.parseFragmentName(),
              variableDefinitions: this.parseVariableDefinitions(),
              typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
              directives: this.parseDirectives(false),
              selectionSet: this.parseSelectionSet()
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * FragmentName : Name but not `on`
         */
        parseFragmentName() {
          if (this._lexer.token.value === "on") {
            throw this.unexpected();
          }
          return this.parseName();
        }
        // Implements the parsing rules in the Values section.
        /**
         * Value[Const] :
         *   - [~Const] Variable
         *   - IntValue
         *   - FloatValue
         *   - StringValue
         *   - BooleanValue
         *   - NullValue
         *   - EnumValue
         *   - ListValue[?Const]
         *   - ObjectValue[?Const]
         *
         * BooleanValue : one of `true` `false`
         *
         * NullValue : `null`
         *
         * EnumValue : Name but not `true`, `false` or `null`
         */
        parseValueLiteral(isConst) {
          const token2 = this._lexer.token;
          switch (token2.kind) {
            case _tokenKind.TokenKind.BRACKET_L:
              return this.parseList(isConst);
            case _tokenKind.TokenKind.BRACE_L:
              return this.parseObject(isConst);
            case _tokenKind.TokenKind.INT:
              this.advanceLexer();
              return this.node(token2, {
                kind: _kinds.Kind.INT,
                value: token2.value
              });
            case _tokenKind.TokenKind.FLOAT:
              this.advanceLexer();
              return this.node(token2, {
                kind: _kinds.Kind.FLOAT,
                value: token2.value
              });
            case _tokenKind.TokenKind.STRING:
            case _tokenKind.TokenKind.BLOCK_STRING:
              return this.parseStringLiteral();
            case _tokenKind.TokenKind.NAME:
              this.advanceLexer();
              switch (token2.value) {
                case "true":
                  return this.node(token2, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: true
                  });
                case "false":
                  return this.node(token2, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: false
                  });
                case "null":
                  return this.node(token2, {
                    kind: _kinds.Kind.NULL
                  });
                default:
                  return this.node(token2, {
                    kind: _kinds.Kind.ENUM,
                    value: token2.value
                  });
              }
            case _tokenKind.TokenKind.DOLLAR:
              if (isConst) {
                this.expectToken(_tokenKind.TokenKind.DOLLAR);
                if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                  const varName = this._lexer.token.value;
                  throw (0, _syntaxError.syntaxError)(
                    this._lexer.source,
                    token2.start,
                    `Unexpected variable "$${varName}" in constant value.`
                  );
                } else {
                  throw this.unexpected(token2);
                }
              }
              return this.parseVariable();
            default:
              throw this.unexpected();
          }
        }
        parseConstValueLiteral() {
          return this.parseValueLiteral(true);
        }
        parseStringLiteral() {
          const token2 = this._lexer.token;
          this.advanceLexer();
          return this.node(token2, {
            kind: _kinds.Kind.STRING,
            value: token2.value,
            block: token2.kind === _tokenKind.TokenKind.BLOCK_STRING
          });
        }
        /**
         * ListValue[Const] :
         *   - [ ]
         *   - [ Value[?Const]+ ]
         */
        parseList(isConst) {
          const item = () => this.parseValueLiteral(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.LIST,
            values: this.any(
              _tokenKind.TokenKind.BRACKET_L,
              item,
              _tokenKind.TokenKind.BRACKET_R
            )
          });
        }
        /**
         * ```
         * ObjectValue[Const] :
         *   - { }
         *   - { ObjectField[?Const]+ }
         * ```
         */
        parseObject(isConst) {
          const item = () => this.parseObjectField(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.OBJECT,
            fields: this.any(
              _tokenKind.TokenKind.BRACE_L,
              item,
              _tokenKind.TokenKind.BRACE_R
            )
          });
        }
        /**
         * ObjectField[Const] : Name : Value[?Const]
         */
        parseObjectField(isConst) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_FIELD,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        // Implements the parsing rules in the Directives section.
        /**
         * Directives[Const] : Directive[?Const]+
         */
        parseDirectives(isConst) {
          const directives = [];
          while (this.peek(_tokenKind.TokenKind.AT)) {
            directives.push(this.parseDirective(isConst));
          }
          return directives;
        }
        parseConstDirectives() {
          return this.parseDirectives(true);
        }
        /**
         * ```
         * Directive[Const] : @ Name Arguments[?Const]?
         * ```
         */
        parseDirective(isConst) {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.AT);
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE,
            name: this.parseName(),
            arguments: this.parseArguments(isConst)
          });
        }
        // Implements the parsing rules in the Types section.
        /**
         * Type :
         *   - NamedType
         *   - ListType
         *   - NonNullType
         */
        parseTypeReference() {
          const start = this._lexer.token;
          let type;
          if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
            const innerType = this.parseTypeReference();
            this.expectToken(_tokenKind.TokenKind.BRACKET_R);
            type = this.node(start, {
              kind: _kinds.Kind.LIST_TYPE,
              type: innerType
            });
          } else {
            type = this.parseNamedType();
          }
          if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
            return this.node(start, {
              kind: _kinds.Kind.NON_NULL_TYPE,
              type
            });
          }
          return type;
        }
        /**
         * NamedType : Name
         */
        parseNamedType() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.NAMED_TYPE,
            name: this.parseName()
          });
        }
        // Implements the parsing rules in the Type Definition section.
        peekDescription() {
          return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
        }
        /**
         * Description : StringValue
         */
        parseDescription() {
          if (this.peekDescription()) {
            return this.parseStringLiteral();
          }
        }
        /**
         * ```
         * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
         * ```
         */
        parseSchemaDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.many(
            _tokenKind.TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_DEFINITION,
            description,
            directives,
            operationTypes
          });
        }
        /**
         * OperationTypeDefinition : OperationType : NamedType
         */
        parseOperationTypeDefinition() {
          const start = this._lexer.token;
          const operation = this.parseOperationType();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseNamedType();
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
            operation,
            type
          });
        }
        /**
         * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
         */
        parseScalarTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
            description,
            name,
            directives
          });
        }
        /**
         * ObjectTypeDefinition :
         *   Description?
         *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
         */
        parseObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * ImplementsInterfaces :
         *   - implements `&`? NamedType
         *   - ImplementsInterfaces & NamedType
         */
        parseImplementsInterfaces() {
          return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
        }
        /**
         * ```
         * FieldsDefinition : { FieldDefinition+ }
         * ```
         */
        parseFieldsDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseFieldDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        /**
         * FieldDefinition :
         *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
         */
        parseFieldDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseTypeReference();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.FIELD_DEFINITION,
            description,
            name,
            arguments: args,
            type,
            directives
          });
        }
        /**
         * ArgumentsDefinition : ( InputValueDefinition+ )
         */
        parseArgumentDefs() {
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            this.parseInputValueDef,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        /**
         * InputValueDefinition :
         *   - Description? Name : Type DefaultValue? Directives[Const]?
         */
        parseInputValueDef() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseTypeReference();
          let defaultValue;
          if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
            defaultValue = this.parseConstValueLiteral();
          }
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
            description,
            name,
            type,
            defaultValue,
            directives
          });
        }
        /**
         * InterfaceTypeDefinition :
         *   - Description? interface Name Directives[Const]? FieldsDefinition?
         */
        parseInterfaceTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * UnionTypeDefinition :
         *   - Description? union Name Directives[Const]? UnionMemberTypes?
         */
        parseUnionTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types = this.parseUnionMemberTypes();
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_DEFINITION,
            description,
            name,
            directives,
            types
          });
        }
        /**
         * UnionMemberTypes :
         *   - = `|`? NamedType
         *   - UnionMemberTypes | NamedType
         */
        parseUnionMemberTypes() {
          return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
        }
        /**
         * EnumTypeDefinition :
         *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
         */
        parseEnumTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
            description,
            name,
            directives,
            values
          });
        }
        /**
         * ```
         * EnumValuesDefinition : { EnumValueDefinition+ }
         * ```
         */
        parseEnumValuesDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseEnumValueDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        /**
         * EnumValueDefinition : Description? EnumValue Directives[Const]?
         */
        parseEnumValueDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseEnumValueName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
            description,
            name,
            directives
          });
        }
        /**
         * EnumValue : Name but not `true`, `false` or `null`
         */
        parseEnumValueName() {
          if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              this._lexer.token.start,
              `${getTokenDesc(
                this._lexer.token
              )} is reserved and cannot be used for an enum value.`
            );
          }
          return this.parseName();
        }
        /**
         * InputObjectTypeDefinition :
         *   - Description? input Name Directives[Const]? InputFieldsDefinition?
         */
        parseInputObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            description,
            name,
            directives,
            fields
          });
        }
        /**
         * ```
         * InputFieldsDefinition : { InputValueDefinition+ }
         * ```
         */
        parseInputFieldsDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseInputValueDef,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        /**
         * TypeSystemExtension :
         *   - SchemaExtension
         *   - TypeExtension
         *
         * TypeExtension :
         *   - ScalarTypeExtension
         *   - ObjectTypeExtension
         *   - InterfaceTypeExtension
         *   - UnionTypeExtension
         *   - EnumTypeExtension
         *   - InputObjectTypeDefinition
         */
        parseTypeSystemExtension() {
          const keywordToken = this._lexer.lookahead();
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaExtension();
              case "scalar":
                return this.parseScalarTypeExtension();
              case "type":
                return this.parseObjectTypeExtension();
              case "interface":
                return this.parseInterfaceTypeExtension();
              case "union":
                return this.parseUnionTypeExtension();
              case "enum":
                return this.parseEnumTypeExtension();
              case "input":
                return this.parseInputObjectTypeExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        /**
         * ```
         * SchemaExtension :
         *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
         *  - extend schema Directives[Const]
         * ```
         */
        parseSchemaExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
          if (directives.length === 0 && operationTypes.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_EXTENSION,
            directives,
            operationTypes
          });
        }
        /**
         * ScalarTypeExtension :
         *   - extend scalar Name Directives[Const]
         */
        parseScalarTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          if (directives.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
            name,
            directives
          });
        }
        /**
         * ObjectTypeExtension :
         *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
         *  - extend type Name ImplementsInterfaces? Directives[Const]
         *  - extend type Name ImplementsInterfaces
         */
        parseObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * InterfaceTypeExtension :
         *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
         *  - extend interface Name ImplementsInterfaces? Directives[Const]
         *  - extend interface Name ImplementsInterfaces
         */
        parseInterfaceTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * UnionTypeExtension :
         *   - extend union Name Directives[Const]? UnionMemberTypes
         *   - extend union Name Directives[Const]
         */
        parseUnionTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types = this.parseUnionMemberTypes();
          if (directives.length === 0 && types.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_EXTENSION,
            name,
            directives,
            types
          });
        }
        /**
         * EnumTypeExtension :
         *   - extend enum Name Directives[Const]? EnumValuesDefinition
         *   - extend enum Name Directives[Const]
         */
        parseEnumTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          if (directives.length === 0 && values.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
            name,
            directives,
            values
          });
        }
        /**
         * InputObjectTypeExtension :
         *   - extend input Name Directives[Const]? InputFieldsDefinition
         *   - extend input Name Directives[Const]
         */
        parseInputObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          if (directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            name,
            directives,
            fields
          });
        }
        /**
         * ```
         * DirectiveDefinition :
         *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
         * ```
         */
        parseDirectiveDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("directive");
          this.expectToken(_tokenKind.TokenKind.AT);
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          const repeatable = this.expectOptionalKeyword("repeatable");
          this.expectKeyword("on");
          const locations = this.parseDirectiveLocations();
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE_DEFINITION,
            description,
            name,
            arguments: args,
            repeatable,
            locations
          });
        }
        /**
         * DirectiveLocations :
         *   - `|`? DirectiveLocation
         *   - DirectiveLocations | DirectiveLocation
         */
        parseDirectiveLocations() {
          return this.delimitedMany(
            _tokenKind.TokenKind.PIPE,
            this.parseDirectiveLocation
          );
        }
        /*
         * DirectiveLocation :
         *   - ExecutableDirectiveLocation
         *   - TypeSystemDirectiveLocation
         *
         * ExecutableDirectiveLocation : one of
         *   `QUERY`
         *   `MUTATION`
         *   `SUBSCRIPTION`
         *   `FIELD`
         *   `FRAGMENT_DEFINITION`
         *   `FRAGMENT_SPREAD`
         *   `INLINE_FRAGMENT`
         *
         * TypeSystemDirectiveLocation : one of
         *   `SCHEMA`
         *   `SCALAR`
         *   `OBJECT`
         *   `FIELD_DEFINITION`
         *   `ARGUMENT_DEFINITION`
         *   `INTERFACE`
         *   `UNION`
         *   `ENUM`
         *   `ENUM_VALUE`
         *   `INPUT_OBJECT`
         *   `INPUT_FIELD_DEFINITION`
         */
        parseDirectiveLocation() {
          const start = this._lexer.token;
          const name = this.parseName();
          if (Object.prototype.hasOwnProperty.call(
            _directiveLocation.DirectiveLocation,
            name.value
          )) {
            return name;
          }
          throw this.unexpected(start);
        }
        // Core parsing utility functions
        /**
         * Returns a node that, if configured to do so, sets a "loc" field as a
         * location object, used to identify the place in the source that created a
         * given parsed object.
         */
        node(startToken, node) {
          if (this._options.noLocation !== true) {
            node.loc = new _ast.Location(
              startToken,
              this._lexer.lastToken,
              this._lexer.source
            );
          }
          return node;
        }
        /**
         * Determines if the next token is of a given kind
         */
        peek(kind) {
          return this._lexer.token.kind === kind;
        }
        /**
         * If the next token is of the given kind, return that token after advancing the lexer.
         * Otherwise, do not change the parser state and throw an error.
         */
        expectToken(kind) {
          const token2 = this._lexer.token;
          if (token2.kind === kind) {
            this.advanceLexer();
            return token2;
          }
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token2.start,
            `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token2)}.`
          );
        }
        /**
         * If the next token is of the given kind, return "true" after advancing the lexer.
         * Otherwise, do not change the parser state and return "false".
         */
        expectOptionalToken(kind) {
          const token2 = this._lexer.token;
          if (token2.kind === kind) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        /**
         * If the next token is a given keyword, advance the lexer.
         * Otherwise, do not change the parser state and throw an error.
         */
        expectKeyword(value) {
          const token2 = this._lexer.token;
          if (token2.kind === _tokenKind.TokenKind.NAME && token2.value === value) {
            this.advanceLexer();
          } else {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              token2.start,
              `Expected "${value}", found ${getTokenDesc(token2)}.`
            );
          }
        }
        /**
         * If the next token is a given keyword, return "true" after advancing the lexer.
         * Otherwise, do not change the parser state and return "false".
         */
        expectOptionalKeyword(value) {
          const token2 = this._lexer.token;
          if (token2.kind === _tokenKind.TokenKind.NAME && token2.value === value) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        /**
         * Helper function for creating an error when an unexpected lexed token is encountered.
         */
        unexpected(atToken) {
          const token2 = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
          return (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token2.start,
            `Unexpected ${getTokenDesc(token2)}.`
          );
        }
        /**
         * Returns a possibly empty list of parse nodes, determined by the parseFn.
         * This list begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        any(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          while (!this.expectOptionalToken(closeKind)) {
            nodes.push(parseFn.call(this));
          }
          return nodes;
        }
        /**
         * Returns a list of parse nodes, determined by the parseFn.
         * It can be empty only if open token is missing otherwise it will always return non-empty list
         * that begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        optionalMany(openKind, parseFn, closeKind) {
          if (this.expectOptionalToken(openKind)) {
            const nodes = [];
            do {
              nodes.push(parseFn.call(this));
            } while (!this.expectOptionalToken(closeKind));
            return nodes;
          }
          return [];
        }
        /**
         * Returns a non-empty list of parse nodes, determined by the parseFn.
         * This list begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        many(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        /**
         * Returns a non-empty list of parse nodes, determined by the parseFn.
         * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
         * Advances the parser to the next lex token after last item in the list.
         */
        delimitedMany(delimiterKind, parseFn) {
          this.expectOptionalToken(delimiterKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (this.expectOptionalToken(delimiterKind));
          return nodes;
        }
        advanceLexer() {
          const { maxTokens } = this._options;
          const token2 = this._lexer.advance();
          if (token2.kind !== _tokenKind.TokenKind.EOF) {
            ++this._tokenCounter;
            if (maxTokens !== void 0 && this._tokenCounter > maxTokens) {
              throw (0, _syntaxError.syntaxError)(
                this._lexer.source,
                token2.start,
                `Document contains more that ${maxTokens} tokens. Parsing aborted.`
              );
            }
          }
        }
      };
      exports.Parser = Parser;
      function getTokenDesc(token2) {
        const value = token2.value;
        return getTokenKindDesc(token2.kind) + (value != null ? ` "${value}"` : "");
      }
      function getTokenKindDesc(kind) {
        return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
      }
    }
  });

  // node_modules/graphql/jsutils/didYouMean.js
  var require_didYouMean = __commonJS({
    "node_modules/graphql/jsutils/didYouMean.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.didYouMean = didYouMean;
      var MAX_SUGGESTIONS = 5;
      function didYouMean(firstArg, secondArg) {
        const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
        let message = " Did you mean ";
        if (subMessage) {
          message += subMessage + " ";
        }
        const suggestions = suggestionsArg.map((x) => `"${x}"`);
        switch (suggestions.length) {
          case 0:
            return "";
          case 1:
            return message + suggestions[0] + "?";
          case 2:
            return message + suggestions[0] + " or " + suggestions[1] + "?";
        }
        const selected = suggestions.slice(0, MAX_SUGGESTIONS);
        const lastItem = selected.pop();
        return message + selected.join(", ") + ", or " + lastItem + "?";
      }
    }
  });

  // node_modules/graphql/jsutils/identityFunc.js
  var require_identityFunc = __commonJS({
    "node_modules/graphql/jsutils/identityFunc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.identityFunc = identityFunc;
      function identityFunc(x) {
        return x;
      }
    }
  });

  // node_modules/graphql/jsutils/keyMap.js
  var require_keyMap = __commonJS({
    "node_modules/graphql/jsutils/keyMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.keyMap = keyMap;
      function keyMap(list, keyFn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const item of list) {
          result[keyFn(item)] = item;
        }
        return result;
      }
    }
  });

  // node_modules/graphql/jsutils/keyValMap.js
  var require_keyValMap = __commonJS({
    "node_modules/graphql/jsutils/keyValMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.keyValMap = keyValMap;
      function keyValMap(list, keyFn, valFn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const item of list) {
          result[keyFn(item)] = valFn(item);
        }
        return result;
      }
    }
  });

  // node_modules/graphql/jsutils/mapValue.js
  var require_mapValue = __commonJS({
    "node_modules/graphql/jsutils/mapValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapValue = mapValue;
      function mapValue(map, fn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(map)) {
          result[key] = fn(map[key], key);
        }
        return result;
      }
    }
  });

  // node_modules/graphql/jsutils/naturalCompare.js
  var require_naturalCompare = __commonJS({
    "node_modules/graphql/jsutils/naturalCompare.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.naturalCompare = naturalCompare;
      function naturalCompare(aStr, bStr) {
        let aIndex = 0;
        let bIndex = 0;
        while (aIndex < aStr.length && bIndex < bStr.length) {
          let aChar = aStr.charCodeAt(aIndex);
          let bChar = bStr.charCodeAt(bIndex);
          if (isDigit(aChar) && isDigit(bChar)) {
            let aNum = 0;
            do {
              ++aIndex;
              aNum = aNum * 10 + aChar - DIGIT_0;
              aChar = aStr.charCodeAt(aIndex);
            } while (isDigit(aChar) && aNum > 0);
            let bNum = 0;
            do {
              ++bIndex;
              bNum = bNum * 10 + bChar - DIGIT_0;
              bChar = bStr.charCodeAt(bIndex);
            } while (isDigit(bChar) && bNum > 0);
            if (aNum < bNum) {
              return -1;
            }
            if (aNum > bNum) {
              return 1;
            }
          } else {
            if (aChar < bChar) {
              return -1;
            }
            if (aChar > bChar) {
              return 1;
            }
            ++aIndex;
            ++bIndex;
          }
        }
        return aStr.length - bStr.length;
      }
      var DIGIT_0 = 48;
      var DIGIT_9 = 57;
      function isDigit(code) {
        return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
      }
    }
  });

  // node_modules/graphql/jsutils/suggestionList.js
  var require_suggestionList = __commonJS({
    "node_modules/graphql/jsutils/suggestionList.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.suggestionList = suggestionList;
      var _naturalCompare = require_naturalCompare();
      function suggestionList(input2, options) {
        const optionsByDistance = /* @__PURE__ */ Object.create(null);
        const lexicalDistance = new LexicalDistance(input2);
        const threshold = Math.floor(input2.length * 0.4) + 1;
        for (const option of options) {
          const distance = lexicalDistance.measure(option, threshold);
          if (distance !== void 0) {
            optionsByDistance[option] = distance;
          }
        }
        return Object.keys(optionsByDistance).sort((a, b) => {
          const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
          return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
        });
      }
      var LexicalDistance = class {
        constructor(input2) {
          this._input = input2;
          this._inputLowerCase = input2.toLowerCase();
          this._inputArray = stringToArray(this._inputLowerCase);
          this._rows = [
            new Array(input2.length + 1).fill(0),
            new Array(input2.length + 1).fill(0),
            new Array(input2.length + 1).fill(0)
          ];
        }
        measure(option, threshold) {
          if (this._input === option) {
            return 0;
          }
          const optionLowerCase = option.toLowerCase();
          if (this._inputLowerCase === optionLowerCase) {
            return 1;
          }
          let a = stringToArray(optionLowerCase);
          let b = this._inputArray;
          if (a.length < b.length) {
            const tmp = a;
            a = b;
            b = tmp;
          }
          const aLength = a.length;
          const bLength = b.length;
          if (aLength - bLength > threshold) {
            return void 0;
          }
          const rows = this._rows;
          for (let j = 0; j <= bLength; j++) {
            rows[0][j] = j;
          }
          for (let i = 1; i <= aLength; i++) {
            const upRow = rows[(i - 1) % 3];
            const currentRow = rows[i % 3];
            let smallestCell = currentRow[0] = i;
            for (let j = 1; j <= bLength; j++) {
              const cost = a[i - 1] === b[j - 1] ? 0 : 1;
              let currentCell = Math.min(
                upRow[j] + 1,
                // delete
                currentRow[j - 1] + 1,
                // insert
                upRow[j - 1] + cost
                // substitute
              );
              if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
                const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
                currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
              }
              if (currentCell < smallestCell) {
                smallestCell = currentCell;
              }
              currentRow[j] = currentCell;
            }
            if (smallestCell > threshold) {
              return void 0;
            }
          }
          const distance = rows[aLength % 3][bLength];
          return distance <= threshold ? distance : void 0;
        }
      };
      function stringToArray(str) {
        const strLength = str.length;
        const array = new Array(strLength);
        for (let i = 0; i < strLength; ++i) {
          array[i] = str.charCodeAt(i);
        }
        return array;
      }
    }
  });

  // node_modules/graphql/jsutils/toObjMap.js
  var require_toObjMap = __commonJS({
    "node_modules/graphql/jsutils/toObjMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toObjMap = toObjMap;
      function toObjMap(obj) {
        if (obj == null) {
          return /* @__PURE__ */ Object.create(null);
        }
        if (Object.getPrototypeOf(obj) === null) {
          return obj;
        }
        const map = /* @__PURE__ */ Object.create(null);
        for (const [key, value] of Object.entries(obj)) {
          map[key] = value;
        }
        return map;
      }
    }
  });

  // node_modules/graphql/language/printString.js
  var require_printString = __commonJS({
    "node_modules/graphql/language/printString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printString = printString;
      function printString(str) {
        return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
      }
      var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
      function escapedReplacer(str) {
        return escapeSequences[str.charCodeAt(0)];
      }
      var escapeSequences = [
        "\\u0000",
        "\\u0001",
        "\\u0002",
        "\\u0003",
        "\\u0004",
        "\\u0005",
        "\\u0006",
        "\\u0007",
        "\\b",
        "\\t",
        "\\n",
        "\\u000B",
        "\\f",
        "\\r",
        "\\u000E",
        "\\u000F",
        "\\u0010",
        "\\u0011",
        "\\u0012",
        "\\u0013",
        "\\u0014",
        "\\u0015",
        "\\u0016",
        "\\u0017",
        "\\u0018",
        "\\u0019",
        "\\u001A",
        "\\u001B",
        "\\u001C",
        "\\u001D",
        "\\u001E",
        "\\u001F",
        "",
        "",
        '\\"',
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 2F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 3F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 4F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\\\",
        "",
        "",
        "",
        // 5F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 6F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\u007F",
        "\\u0080",
        "\\u0081",
        "\\u0082",
        "\\u0083",
        "\\u0084",
        "\\u0085",
        "\\u0086",
        "\\u0087",
        "\\u0088",
        "\\u0089",
        "\\u008A",
        "\\u008B",
        "\\u008C",
        "\\u008D",
        "\\u008E",
        "\\u008F",
        "\\u0090",
        "\\u0091",
        "\\u0092",
        "\\u0093",
        "\\u0094",
        "\\u0095",
        "\\u0096",
        "\\u0097",
        "\\u0098",
        "\\u0099",
        "\\u009A",
        "\\u009B",
        "\\u009C",
        "\\u009D",
        "\\u009E",
        "\\u009F"
      ];
    }
  });

  // node_modules/graphql/language/visitor.js
  var require_visitor = __commonJS({
    "node_modules/graphql/language/visitor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BREAK = void 0;
      exports.getEnterLeaveForKind = getEnterLeaveForKind;
      exports.getVisitFn = getVisitFn;
      exports.visit = visit;
      exports.visitInParallel = visitInParallel;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _ast = require_ast();
      var _kinds = require_kinds();
      var BREAK = Object.freeze({});
      exports.BREAK = BREAK;
      function visit(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
        const enterLeaveMap = /* @__PURE__ */ new Map();
        for (const kind of Object.values(_kinds.Kind)) {
          enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
        }
        let stack = void 0;
        let inArray = Array.isArray(root);
        let keys = [root];
        let index = -1;
        let edits = [];
        let node = root;
        let key = void 0;
        let parent = void 0;
        const path = [];
        const ancestors = [];
        do {
          index++;
          const isLeaving = index === keys.length;
          const isEdited = isLeaving && edits.length !== 0;
          if (isLeaving) {
            key = ancestors.length === 0 ? void 0 : path[path.length - 1];
            node = parent;
            parent = ancestors.pop();
            if (isEdited) {
              if (inArray) {
                node = node.slice();
                let editOffset = 0;
                for (const [editKey, editValue] of edits) {
                  const arrayKey = editKey - editOffset;
                  if (editValue === null) {
                    node.splice(arrayKey, 1);
                    editOffset++;
                  } else {
                    node[arrayKey] = editValue;
                  }
                }
              } else {
                node = Object.defineProperties(
                  {},
                  Object.getOwnPropertyDescriptors(node)
                );
                for (const [editKey, editValue] of edits) {
                  node[editKey] = editValue;
                }
              }
            }
            index = stack.index;
            keys = stack.keys;
            edits = stack.edits;
            inArray = stack.inArray;
            stack = stack.prev;
          } else if (parent) {
            key = inArray ? index : keys[index];
            node = parent[key];
            if (node === null || node === void 0) {
              continue;
            }
            path.push(key);
          }
          let result;
          if (!Array.isArray(node)) {
            var _enterLeaveMap$get, _enterLeaveMap$get2;
            (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
              false,
              `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
            );
            const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
            result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
            if (result === BREAK) {
              break;
            }
            if (result === false) {
              if (!isLeaving) {
                path.pop();
                continue;
              }
            } else if (result !== void 0) {
              edits.push([key, result]);
              if (!isLeaving) {
                if ((0, _ast.isNode)(result)) {
                  node = result;
                } else {
                  path.pop();
                  continue;
                }
              }
            }
          }
          if (result === void 0 && isEdited) {
            edits.push([key, node]);
          }
          if (isLeaving) {
            path.pop();
          } else {
            var _node$kind;
            stack = {
              inArray,
              index,
              keys,
              edits,
              prev: stack
            };
            inArray = Array.isArray(node);
            keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
            index = -1;
            edits = [];
            if (parent) {
              ancestors.push(parent);
            }
            parent = node;
          }
        } while (stack !== void 0);
        if (edits.length !== 0) {
          return edits[edits.length - 1][1];
        }
        return root;
      }
      function visitInParallel(visitors) {
        const skipping = new Array(visitors.length).fill(null);
        const mergedVisitor = /* @__PURE__ */ Object.create(null);
        for (const kind of Object.values(_kinds.Kind)) {
          let hasVisitor = false;
          const enterList = new Array(visitors.length).fill(void 0);
          const leaveList = new Array(visitors.length).fill(void 0);
          for (let i = 0; i < visitors.length; ++i) {
            const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
            hasVisitor || (hasVisitor = enter != null || leave != null);
            enterList[i] = enter;
            leaveList[i] = leave;
          }
          if (!hasVisitor) {
            continue;
          }
          const mergedEnterLeave = {
            enter(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _enterList$i;
                  const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                  if (result === false) {
                    skipping[i] = node;
                  } else if (result === BREAK) {
                    skipping[i] = BREAK;
                  } else if (result !== void 0) {
                    return result;
                  }
                }
              }
            },
            leave(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _leaveList$i;
                  const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                  if (result === BREAK) {
                    skipping[i] = BREAK;
                  } else if (result !== void 0 && result !== false) {
                    return result;
                  }
                } else if (skipping[i] === node) {
                  skipping[i] = null;
                }
              }
            }
          };
          mergedVisitor[kind] = mergedEnterLeave;
        }
        return mergedVisitor;
      }
      function getEnterLeaveForKind(visitor, kind) {
        const kindVisitor = visitor[kind];
        if (typeof kindVisitor === "object") {
          return kindVisitor;
        } else if (typeof kindVisitor === "function") {
          return {
            enter: kindVisitor,
            leave: void 0
          };
        }
        return {
          enter: visitor.enter,
          leave: visitor.leave
        };
      }
      function getVisitFn(visitor, kind, isLeaving) {
        const { enter, leave } = getEnterLeaveForKind(visitor, kind);
        return isLeaving ? leave : enter;
      }
    }
  });

  // node_modules/graphql/language/printer.js
  var require_printer = __commonJS({
    "node_modules/graphql/language/printer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.print = print;
      var _blockString = require_blockString();
      var _printString = require_printString();
      var _visitor = require_visitor();
      function print(ast) {
        return (0, _visitor.visit)(ast, printDocASTReducer);
      }
      var MAX_LINE_LENGTH = 80;
      var printDocASTReducer = {
        Name: {
          leave: (node) => node.value
        },
        Variable: {
          leave: (node) => "$" + node.name
        },
        // Document
        Document: {
          leave: (node) => join(node.definitions, "\n\n")
        },
        OperationDefinition: {
          leave(node) {
            const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
            const prefix = join(
              [
                node.operation,
                join([node.name, varDefs]),
                join(node.directives, " ")
              ],
              " "
            );
            return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
          }
        },
        VariableDefinition: {
          leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
        },
        SelectionSet: {
          leave: ({ selections }) => block(selections)
        },
        Field: {
          leave({ alias, name, arguments: args, directives, selectionSet }) {
            const prefix = wrap("", alias, ": ") + name;
            let argsLine = prefix + wrap("(", join(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH) {
              argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
            }
            return join([argsLine, join(directives, " "), selectionSet], " ");
          }
        },
        Argument: {
          leave: ({ name, value }) => name + ": " + value
        },
        // Fragments
        FragmentSpread: {
          leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
        },
        InlineFragment: {
          leave: ({ typeCondition, directives, selectionSet }) => join(
            [
              "...",
              wrap("on ", typeCondition),
              join(directives, " "),
              selectionSet
            ],
            " "
          )
        },
        FragmentDefinition: {
          leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
            // or removed in the future.
            `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
          )
        },
        // Value
        IntValue: {
          leave: ({ value }) => value
        },
        FloatValue: {
          leave: ({ value }) => value
        },
        StringValue: {
          leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
        },
        BooleanValue: {
          leave: ({ value }) => value ? "true" : "false"
        },
        NullValue: {
          leave: () => "null"
        },
        EnumValue: {
          leave: ({ value }) => value
        },
        ListValue: {
          leave: ({ values }) => "[" + join(values, ", ") + "]"
        },
        ObjectValue: {
          leave: ({ fields }) => "{" + join(fields, ", ") + "}"
        },
        ObjectField: {
          leave: ({ name, value }) => name + ": " + value
        },
        // Directive
        Directive: {
          leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
        },
        // Type
        NamedType: {
          leave: ({ name }) => name
        },
        ListType: {
          leave: ({ type }) => "[" + type + "]"
        },
        NonNullType: {
          leave: ({ type }) => type + "!"
        },
        // Type System Definitions
        SchemaDefinition: {
          leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
        },
        OperationTypeDefinition: {
          leave: ({ operation, type }) => operation + ": " + type
        },
        ScalarTypeDefinition: {
          leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
        },
        ObjectTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
            [
              "type",
              name,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        FieldDefinition: {
          leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
        },
        InputValueDefinition: {
          leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
            [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
            " "
          )
        },
        InterfaceTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
            [
              "interface",
              name,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        UnionTypeDefinition: {
          leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
            ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
            " "
          )
        },
        EnumTypeDefinition: {
          leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
        },
        EnumValueDefinition: {
          leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
        },
        InputObjectTypeDefinition: {
          leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
        },
        DirectiveDefinition: {
          leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
        },
        SchemaExtension: {
          leave: ({ directives, operationTypes }) => join(
            ["extend schema", join(directives, " "), block(operationTypes)],
            " "
          )
        },
        ScalarTypeExtension: {
          leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
        },
        ObjectTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join(
            [
              "extend type",
              name,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        InterfaceTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join(
            [
              "extend interface",
              name,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        UnionTypeExtension: {
          leave: ({ name, directives, types }) => join(
            [
              "extend union",
              name,
              join(directives, " "),
              wrap("= ", join(types, " | "))
            ],
            " "
          )
        },
        EnumTypeExtension: {
          leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
        },
        InputObjectTypeExtension: {
          leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
        }
      };
      function join(maybeArray, separator = "") {
        var _maybeArray$filter$jo;
        return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
      }
      function block(array) {
        return wrap("{\n", indent(join(array, "\n")), "\n}");
      }
      function wrap(start, maybeString, end = "") {
        return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
      }
      function indent(str) {
        return wrap("  ", str.replace(/\n/g, "\n  "));
      }
      function hasMultilineItems(maybeArray) {
        var _maybeArray$some;
        return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
      }
    }
  });

  // node_modules/graphql/utilities/valueFromASTUntyped.js
  var require_valueFromASTUntyped = __commonJS({
    "node_modules/graphql/utilities/valueFromASTUntyped.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.valueFromASTUntyped = valueFromASTUntyped;
      var _keyValMap = require_keyValMap();
      var _kinds = require_kinds();
      function valueFromASTUntyped(valueNode, variables) {
        switch (valueNode.kind) {
          case _kinds.Kind.NULL:
            return null;
          case _kinds.Kind.INT:
            return parseInt(valueNode.value, 10);
          case _kinds.Kind.FLOAT:
            return parseFloat(valueNode.value);
          case _kinds.Kind.STRING:
          case _kinds.Kind.ENUM:
          case _kinds.Kind.BOOLEAN:
            return valueNode.value;
          case _kinds.Kind.LIST:
            return valueNode.values.map(
              (node) => valueFromASTUntyped(node, variables)
            );
          case _kinds.Kind.OBJECT:
            return (0, _keyValMap.keyValMap)(
              valueNode.fields,
              (field) => field.name.value,
              (field) => valueFromASTUntyped(field.value, variables)
            );
          case _kinds.Kind.VARIABLE:
            return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
        }
      }
    }
  });

  // node_modules/graphql/type/assertName.js
  var require_assertName = __commonJS({
    "node_modules/graphql/type/assertName.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertEnumValueName = assertEnumValueName;
      exports.assertName = assertName;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _characterClasses = require_characterClasses();
      function assertName(name) {
        name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
        typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
        if (name.length === 0) {
          throw new _GraphQLError.GraphQLError(
            "Expected name to be a non-empty string."
          );
        }
        for (let i = 1; i < name.length; ++i) {
          if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
            throw new _GraphQLError.GraphQLError(
              `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
            );
          }
        }
        if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
          throw new _GraphQLError.GraphQLError(
            `Names must start with [_a-zA-Z] but "${name}" does not.`
          );
        }
        return name;
      }
      function assertEnumValueName(name) {
        if (name === "true" || name === "false" || name === "null") {
          throw new _GraphQLError.GraphQLError(
            `Enum values cannot be named: ${name}`
          );
        }
        return assertName(name);
      }
    }
  });

  // node_modules/graphql/type/definition.js
  var require_definition = __commonJS({
    "node_modules/graphql/type/definition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLUnionType = exports.GraphQLScalarType = exports.GraphQLObjectType = exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInterfaceType = exports.GraphQLInputObjectType = exports.GraphQLEnumType = void 0;
      exports.argsToArgsConfig = argsToArgsConfig;
      exports.assertAbstractType = assertAbstractType;
      exports.assertCompositeType = assertCompositeType;
      exports.assertEnumType = assertEnumType;
      exports.assertInputObjectType = assertInputObjectType;
      exports.assertInputType = assertInputType;
      exports.assertInterfaceType = assertInterfaceType;
      exports.assertLeafType = assertLeafType;
      exports.assertListType = assertListType;
      exports.assertNamedType = assertNamedType;
      exports.assertNonNullType = assertNonNullType;
      exports.assertNullableType = assertNullableType;
      exports.assertObjectType = assertObjectType;
      exports.assertOutputType = assertOutputType;
      exports.assertScalarType = assertScalarType;
      exports.assertType = assertType;
      exports.assertUnionType = assertUnionType;
      exports.assertWrappingType = assertWrappingType;
      exports.defineArguments = defineArguments;
      exports.getNamedType = getNamedType;
      exports.getNullableType = getNullableType;
      exports.isAbstractType = isAbstractType;
      exports.isCompositeType = isCompositeType;
      exports.isEnumType = isEnumType;
      exports.isInputObjectType = isInputObjectType;
      exports.isInputType = isInputType;
      exports.isInterfaceType = isInterfaceType;
      exports.isLeafType = isLeafType;
      exports.isListType = isListType;
      exports.isNamedType = isNamedType;
      exports.isNonNullType = isNonNullType;
      exports.isNullableType = isNullableType;
      exports.isObjectType = isObjectType;
      exports.isOutputType = isOutputType;
      exports.isRequiredArgument = isRequiredArgument;
      exports.isRequiredInputField = isRequiredInputField;
      exports.isScalarType = isScalarType;
      exports.isType = isType;
      exports.isUnionType = isUnionType;
      exports.isWrappingType = isWrappingType;
      exports.resolveObjMapThunk = resolveObjMapThunk;
      exports.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
      var _devAssert = require_devAssert();
      var _didYouMean = require_didYouMean();
      var _identityFunc = require_identityFunc();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _keyMap = require_keyMap();
      var _keyValMap = require_keyValMap();
      var _mapValue = require_mapValue();
      var _suggestionList = require_suggestionList();
      var _toObjMap = require_toObjMap();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _valueFromASTUntyped = require_valueFromASTUntyped();
      var _assertName = require_assertName();
      function isType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
      }
      function assertType(type) {
        if (!isType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`
          );
        }
        return type;
      }
      function isScalarType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLScalarType);
      }
      function assertScalarType(type) {
        if (!isScalarType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`
          );
        }
        return type;
      }
      function isObjectType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLObjectType);
      }
      function assertObjectType(type) {
        if (!isObjectType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`
          );
        }
        return type;
      }
      function isInterfaceType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType);
      }
      function assertInterfaceType(type) {
        if (!isInterfaceType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`
          );
        }
        return type;
      }
      function isUnionType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLUnionType);
      }
      function assertUnionType(type) {
        if (!isUnionType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`
          );
        }
        return type;
      }
      function isEnumType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLEnumType);
      }
      function assertEnumType(type) {
        if (!isEnumType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`
          );
        }
        return type;
      }
      function isInputObjectType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType);
      }
      function assertInputObjectType(type) {
        if (!isInputObjectType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(
              type
            )} to be a GraphQL Input Object type.`
          );
        }
        return type;
      }
      function isListType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLList);
      }
      function assertListType(type) {
        if (!isListType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`
          );
        }
        return type;
      }
      function isNonNullType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLNonNull);
      }
      function assertNonNullType(type) {
        if (!isNonNullType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`
          );
        }
        return type;
      }
      function isInputType(type) {
        return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
      }
      function assertInputType(type) {
        if (!isInputType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`
          );
        }
        return type;
      }
      function isOutputType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
      }
      function assertOutputType(type) {
        if (!isOutputType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`
          );
        }
        return type;
      }
      function isLeafType(type) {
        return isScalarType(type) || isEnumType(type);
      }
      function assertLeafType(type) {
        if (!isLeafType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`
          );
        }
        return type;
      }
      function isCompositeType(type) {
        return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
      }
      function assertCompositeType(type) {
        if (!isCompositeType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`
          );
        }
        return type;
      }
      function isAbstractType(type) {
        return isInterfaceType(type) || isUnionType(type);
      }
      function assertAbstractType(type) {
        if (!isAbstractType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`
          );
        }
        return type;
      }
      var GraphQLList = class {
        constructor(ofType) {
          isType(ofType) || (0, _devAssert.devAssert)(
            false,
            `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`
          );
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLList";
        }
        toString() {
          return "[" + String(this.ofType) + "]";
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLList = GraphQLList;
      var GraphQLNonNull = class {
        constructor(ofType) {
          isNullableType(ofType) || (0, _devAssert.devAssert)(
            false,
            `Expected ${(0, _inspect.inspect)(
              ofType
            )} to be a GraphQL nullable type.`
          );
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLNonNull";
        }
        toString() {
          return String(this.ofType) + "!";
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLNonNull = GraphQLNonNull;
      function isWrappingType(type) {
        return isListType(type) || isNonNullType(type);
      }
      function assertWrappingType(type) {
        if (!isWrappingType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`
          );
        }
        return type;
      }
      function isNullableType(type) {
        return isType(type) && !isNonNullType(type);
      }
      function assertNullableType(type) {
        if (!isNullableType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`
          );
        }
        return type;
      }
      function getNullableType(type) {
        if (type) {
          return isNonNullType(type) ? type.ofType : type;
        }
      }
      function isNamedType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
      }
      function assertNamedType(type) {
        if (!isNamedType(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`
          );
        }
        return type;
      }
      function getNamedType(type) {
        if (type) {
          let unwrappedType = type;
          while (isWrappingType(unwrappedType)) {
            unwrappedType = unwrappedType.ofType;
          }
          return unwrappedType;
        }
      }
      function resolveReadonlyArrayThunk(thunk) {
        return typeof thunk === "function" ? thunk() : thunk;
      }
      function resolveObjMapThunk(thunk) {
        return typeof thunk === "function" ? thunk() : thunk;
      }
      var GraphQLScalarType = class {
        constructor(config) {
          var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
          const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.specifiedByURL = config.specifiedByURL;
          this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
          this.parseValue = parseValue;
          this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue(
            (0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables)
          );
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          config.specifiedByURL == null || typeof config.specifiedByURL === "string" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, _inspect.inspect)(config.specifiedByURL)}.`
          );
          config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
          );
          if (config.parseLiteral) {
            typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.devAssert)(
              false,
              `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
            );
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLScalarType";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            specifiedByURL: this.specifiedByURL,
            serialize: this.serialize,
            parseValue: this.parseValue,
            parseLiteral: this.parseLiteral,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLScalarType = GraphQLScalarType;
      var GraphQLObjectType = class {
        constructor(config) {
          var _config$extensionASTN2;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.isTypeOf = config.isTypeOf;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
          this._fields = () => defineFieldMap(config);
          this._interfaces = () => defineInterfaces(config);
          config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "isTypeOf" as a function, but got: ${(0, _inspect.inspect)(config.isTypeOf)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            isTypeOf: this.isTypeOf,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLObjectType = GraphQLObjectType;
      function defineInterfaces(config) {
        var _config$interfaces;
        const interfaces = resolveReadonlyArrayThunk(
          (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
        );
        Array.isArray(interfaces) || (0, _devAssert.devAssert)(
          false,
          `${config.name} interfaces must be an Array or a function which returns an Array.`
        );
        return interfaces;
      }
      function defineFieldMap(config) {
        const fieldMap = resolveObjMapThunk(config.fields);
        isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
          false,
          `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
        );
        return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
          var _fieldConfig$args;
          isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(
            false,
            `${config.name}.${fieldName} field config must be an object.`
          );
          fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(
            false,
            `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`
          );
          const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
          isPlainObj(argsConfig) || (0, _devAssert.devAssert)(
            false,
            `${config.name}.${fieldName} args must be an object with argument names as keys.`
          );
          return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            args: defineArguments(argsConfig),
            resolve: fieldConfig.resolve,
            subscribe: fieldConfig.subscribe,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
          };
        });
      }
      function defineArguments(config) {
        return Object.entries(config).map(([argName, argConfig]) => ({
          name: (0, _assertName.assertName)(argName),
          description: argConfig.description,
          type: argConfig.type,
          defaultValue: argConfig.defaultValue,
          deprecationReason: argConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
          astNode: argConfig.astNode
        }));
      }
      function isPlainObj(obj) {
        return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
      }
      function fieldsToFieldsConfig(fields) {
        return (0, _mapValue.mapValue)(fields, (field) => ({
          description: field.description,
          type: field.type,
          args: argsToArgsConfig(field.args),
          resolve: field.resolve,
          subscribe: field.subscribe,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
      }
      function argsToArgsConfig(args) {
        return (0, _keyValMap.keyValMap)(
          args,
          (arg) => arg.name,
          (arg) => ({
            description: arg.description,
            type: arg.type,
            defaultValue: arg.defaultValue,
            deprecationReason: arg.deprecationReason,
            extensions: arg.extensions,
            astNode: arg.astNode
          })
        );
      }
      function isRequiredArgument(arg) {
        return isNonNullType(arg.type) && arg.defaultValue === void 0;
      }
      var GraphQLInterfaceType = class {
        constructor(config) {
          var _config$extensionASTN3;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.resolveType = config.resolveType;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
          this._fields = defineFieldMap.bind(void 0, config);
          this._interfaces = defineInterfaces.bind(void 0, config);
          config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config.resolveType)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInterfaceType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLInterfaceType = GraphQLInterfaceType;
      var GraphQLUnionType = class {
        constructor(config) {
          var _config$extensionASTN4;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.resolveType = config.resolveType;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
          this._types = defineTypes.bind(void 0, config);
          config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config.resolveType)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLUnionType";
        }
        getTypes() {
          if (typeof this._types === "function") {
            this._types = this._types();
          }
          return this._types;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            types: this.getTypes(),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLUnionType = GraphQLUnionType;
      function defineTypes(config) {
        const types = resolveReadonlyArrayThunk(config.types);
        Array.isArray(types) || (0, _devAssert.devAssert)(
          false,
          `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
        );
        return types;
      }
      var GraphQLEnumType = class {
        /* <T> */
        constructor(config) {
          var _config$extensionASTN5;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
          this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
          this._valueLookup = null;
          this._nameLookup = null;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLEnumType";
        }
        getValues() {
          if (typeof this._values === "function") {
            this._values = defineEnumValues(this.name, this._values());
          }
          return this._values;
        }
        getValue(name) {
          if (this._nameLookup === null) {
            this._nameLookup = (0, _keyMap.keyMap)(
              this.getValues(),
              (value) => value.name
            );
          }
          return this._nameLookup[name];
        }
        serialize(outputValue) {
          if (this._valueLookup === null) {
            this._valueLookup = new Map(
              this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
            );
          }
          const enumValue = this._valueLookup.get(outputValue);
          if (enumValue === void 0) {
            throw new _GraphQLError.GraphQLError(
              `Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(
                outputValue
              )}`
            );
          }
          return enumValue.name;
        }
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            const valueStr = (0, _inspect.inspect)(inputValue);
            throw new _GraphQLError.GraphQLError(
              `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
            );
          }
          const enumValue = this.getValue(inputValue);
          if (enumValue == null) {
            throw new _GraphQLError.GraphQLError(
              `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
            );
          }
          return enumValue.value;
        }
        parseLiteral(valueNode, _variables) {
          if (valueNode.kind !== _kinds.Kind.ENUM) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(
              `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
              {
                nodes: valueNode
              }
            );
          }
          const enumValue = this.getValue(valueNode.value);
          if (enumValue == null) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(
              `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
              {
                nodes: valueNode
              }
            );
          }
          return enumValue.value;
        }
        toConfig() {
          const values = (0, _keyValMap.keyValMap)(
            this.getValues(),
            (value) => value.name,
            (value) => ({
              description: value.description,
              value: value.value,
              deprecationReason: value.deprecationReason,
              extensions: value.extensions,
              astNode: value.astNode
            })
          );
          return {
            name: this.name,
            description: this.description,
            values,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLEnumType = GraphQLEnumType;
      function didYouMeanEnumValue(enumType, unknownValueStr) {
        const allNames = enumType.getValues().map((value) => value.name);
        const suggestedValues = (0, _suggestionList.suggestionList)(
          unknownValueStr,
          allNames
        );
        return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
      }
      function defineEnumValues(typeName, valueMap) {
        isPlainObj(valueMap) || (0, _devAssert.devAssert)(
          false,
          `${typeName} values must be an object with value names as keys.`
        );
        return Object.entries(valueMap).map(([valueName, valueConfig]) => {
          isPlainObj(valueConfig) || (0, _devAssert.devAssert)(
            false,
            `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${(0, _inspect.inspect)(
              valueConfig
            )}.`
          );
          return {
            name: (0, _assertName.assertEnumValueName)(valueName),
            description: valueConfig.description,
            value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
            deprecationReason: valueConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
            astNode: valueConfig.astNode
          };
        });
      }
      var GraphQLInputObjectType = class {
        constructor(config) {
          var _config$extensionASTN6, _config$isOneOf;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
          this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
          this._fields = defineInputFieldMap.bind(void 0, config);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInputObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        toConfig() {
          const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
            description: field.description,
            type: field.type,
            defaultValue: field.defaultValue,
            deprecationReason: field.deprecationReason,
            extensions: field.extensions,
            astNode: field.astNode
          }));
          return {
            name: this.name,
            description: this.description,
            fields,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes,
            isOneOf: this.isOneOf
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLInputObjectType = GraphQLInputObjectType;
      function defineInputFieldMap(config) {
        const fieldMap = resolveObjMapThunk(config.fields);
        isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
          false,
          `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
        );
        return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
          !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(
            false,
            `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
          );
          return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            defaultValue: fieldConfig.defaultValue,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
          };
        });
      }
      function isRequiredInputField(field) {
        return isNonNullType(field.type) && field.defaultValue === void 0;
      }
    }
  });

  // node_modules/graphql/utilities/typeComparators.js
  var require_typeComparators = __commonJS({
    "node_modules/graphql/utilities/typeComparators.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.doTypesOverlap = doTypesOverlap;
      exports.isEqualType = isEqualType;
      exports.isTypeSubTypeOf = isTypeSubTypeOf;
      var _definition = require_definition();
      function isEqualType(typeA, typeB) {
        if (typeA === typeB) {
          return true;
        }
        if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
          return isEqualType(typeA.ofType, typeB.ofType);
        }
        if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
          return isEqualType(typeA.ofType, typeB.ofType);
        }
        return false;
      }
      function isTypeSubTypeOf(schema, maybeSubType, superType) {
        if (maybeSubType === superType) {
          return true;
        }
        if ((0, _definition.isNonNullType)(superType)) {
          if ((0, _definition.isNonNullType)(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
          }
          return false;
        }
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
        }
        if ((0, _definition.isListType)(superType)) {
          if ((0, _definition.isListType)(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
          }
          return false;
        }
        if ((0, _definition.isListType)(maybeSubType)) {
          return false;
        }
        return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
      }
      function doTypesOverlap(schema, typeA, typeB) {
        if (typeA === typeB) {
          return true;
        }
        if ((0, _definition.isAbstractType)(typeA)) {
          if ((0, _definition.isAbstractType)(typeB)) {
            return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
          }
          return schema.isSubType(typeA, typeB);
        }
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.isSubType(typeB, typeA);
        }
        return false;
      }
    }
  });

  // node_modules/graphql/type/scalars.js
  var require_scalars = __commonJS({
    "node_modules/graphql/type/scalars.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLString = exports.GraphQLInt = exports.GraphQLID = exports.GraphQLFloat = exports.GraphQLBoolean = exports.GRAPHQL_MIN_INT = exports.GRAPHQL_MAX_INT = void 0;
      exports.isSpecifiedScalarType = isSpecifiedScalarType;
      exports.specifiedScalarTypes = void 0;
      var _inspect = require_inspect();
      var _isObjectLike = require_isObjectLike();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var GRAPHQL_MAX_INT = 2147483647;
      exports.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
      var GRAPHQL_MIN_INT = -2147483648;
      exports.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
      var GraphQLInt = new _definition.GraphQLScalarType({
        name: "Int",
        description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isInteger(num)) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
                coercedValue
              )}`
            );
          }
          if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(
              "Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue)
            );
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non 32-bit signed integer value: ${inputValue}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non-integer value: ${(0, _printer.print)(
                valueNode
              )}`,
              {
                nodes: valueNode
              }
            );
          }
          const num = parseInt(valueNode.value, 10);
          if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
              {
                nodes: valueNode
              }
            );
          }
          return num;
        }
      });
      exports.GraphQLInt = GraphQLInt;
      var GraphQLFloat = new _definition.GraphQLScalarType({
        name: "Float",
        description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isFinite(num)) {
            throw new _GraphQLError.GraphQLError(
              `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
                coercedValue
              )}`
            );
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
            throw new _GraphQLError.GraphQLError(
              `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(
              `Float cannot represent non numeric value: ${(0, _printer.print)(
                valueNode
              )}`,
              valueNode
            );
          }
          return parseFloat(valueNode.value);
        }
      });
      exports.GraphQLFloat = GraphQLFloat;
      var GraphQLString = new _definition.GraphQLScalarType({
        name: "String",
        description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (typeof coercedValue === "boolean") {
            return coercedValue ? "true" : "false";
          }
          if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
            return coercedValue.toString();
          }
          throw new _GraphQLError.GraphQLError(
            `String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            throw new _GraphQLError.GraphQLError(
              `String cannot represent a non string value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.STRING) {
            throw new _GraphQLError.GraphQLError(
              `String cannot represent a non string value: ${(0, _printer.print)(
                valueNode
              )}`,
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      exports.GraphQLString = GraphQLString;
      var GraphQLBoolean = new _definition.GraphQLScalarType({
        name: "Boolean",
        description: "The `Boolean` scalar type represents `true` or `false`.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue;
          }
          if (Number.isFinite(coercedValue)) {
            return coercedValue !== 0;
          }
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "boolean") {
            throw new _GraphQLError.GraphQLError(
              `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
            throw new _GraphQLError.GraphQLError(
              `Boolean cannot represent a non boolean value: ${(0, _printer.print)(
                valueNode
              )}`,
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      exports.GraphQLBoolean = GraphQLBoolean;
      var GraphQLID = new _definition.GraphQLScalarType({
        name: "ID",
        description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (Number.isInteger(coercedValue)) {
            return String(coercedValue);
          }
          throw new _GraphQLError.GraphQLError(
            `ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue === "string") {
            return inputValue;
          }
          if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
            return inputValue.toString();
          }
          throw new _GraphQLError.GraphQLError(
            `ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`
          );
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(
              "ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode),
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      exports.GraphQLID = GraphQLID;
      var specifiedScalarTypes = Object.freeze([
        GraphQLString,
        GraphQLInt,
        GraphQLFloat,
        GraphQLBoolean,
        GraphQLID
      ]);
      exports.specifiedScalarTypes = specifiedScalarTypes;
      function isSpecifiedScalarType(type) {
        return specifiedScalarTypes.some(({ name }) => type.name === name);
      }
      function serializeObject(outputValue) {
        if ((0, _isObjectLike.isObjectLike)(outputValue)) {
          if (typeof outputValue.valueOf === "function") {
            const valueOfResult = outputValue.valueOf();
            if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
              return valueOfResult;
            }
          }
          if (typeof outputValue.toJSON === "function") {
            return outputValue.toJSON();
          }
        }
        return outputValue;
      }
    }
  });

  // node_modules/graphql/type/directives.js
  var require_directives = __commonJS({
    "node_modules/graphql/type/directives.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLSpecifiedByDirective = exports.GraphQLSkipDirective = exports.GraphQLOneOfDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = void 0;
      exports.assertDirective = assertDirective;
      exports.isDirective = isDirective;
      exports.isSpecifiedDirective = isSpecifiedDirective;
      exports.specifiedDirectives = void 0;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _toObjMap = require_toObjMap();
      var _directiveLocation = require_directiveLocation();
      var _assertName = require_assertName();
      var _definition = require_definition();
      var _scalars = require_scalars();
      function isDirective(directive) {
        return (0, _instanceOf.instanceOf)(directive, GraphQLDirective);
      }
      function assertDirective(directive) {
        if (!isDirective(directive)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`
          );
        }
        return directive;
      }
      var GraphQLDirective = class {
        constructor(config) {
          var _config$isRepeatable, _config$args;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.locations = config.locations;
          this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          Array.isArray(config.locations) || (0, _devAssert.devAssert)(
            false,
            `@${config.name} locations must be an Array.`
          );
          const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
          (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(
            false,
            `@${config.name} args must be an object with argument names as keys.`
          );
          this.args = (0, _definition.defineArguments)(args);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLDirective";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            locations: this.locations,
            args: (0, _definition.argsToArgsConfig)(this.args),
            isRepeatable: this.isRepeatable,
            extensions: this.extensions,
            astNode: this.astNode
          };
        }
        toString() {
          return "@" + this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLDirective = GraphQLDirective;
      var GraphQLIncludeDirective = new GraphQLDirective({
        name: "include",
        description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD,
          _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Included when true."
          }
        }
      });
      exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
      var GraphQLSkipDirective = new GraphQLDirective({
        name: "skip",
        description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD,
          _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Skipped when true."
          }
        }
      });
      exports.GraphQLSkipDirective = GraphQLSkipDirective;
      var DEFAULT_DEPRECATION_REASON = "No longer supported";
      exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
      var GraphQLDeprecatedDirective = new GraphQLDirective({
        name: "deprecated",
        description: "Marks an element of a GraphQL schema as no longer supported.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          _directiveLocation.DirectiveLocation.ENUM_VALUE
        ],
        args: {
          reason: {
            type: _scalars.GraphQLString,
            description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
            defaultValue: DEFAULT_DEPRECATION_REASON
          }
        }
      });
      exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
      var GraphQLSpecifiedByDirective = new GraphQLDirective({
        name: "specifiedBy",
        description: "Exposes a URL that specifies the behavior of this scalar.",
        locations: [_directiveLocation.DirectiveLocation.SCALAR],
        args: {
          url: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            description: "The URL that specifies the behavior of this scalar."
          }
        }
      });
      exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
      var GraphQLOneOfDirective = new GraphQLDirective({
        name: "oneOf",
        description: "Indicates exactly one field must be supplied and this field must not be `null`.",
        locations: [_directiveLocation.DirectiveLocation.INPUT_OBJECT],
        args: {}
      });
      exports.GraphQLOneOfDirective = GraphQLOneOfDirective;
      var specifiedDirectives = Object.freeze([
        GraphQLIncludeDirective,
        GraphQLSkipDirective,
        GraphQLDeprecatedDirective,
        GraphQLSpecifiedByDirective,
        GraphQLOneOfDirective
      ]);
      exports.specifiedDirectives = specifiedDirectives;
      function isSpecifiedDirective(directive) {
        return specifiedDirectives.some(({ name }) => name === directive.name);
      }
    }
  });

  // node_modules/graphql/jsutils/isIterableObject.js
  var require_isIterableObject = __commonJS({
    "node_modules/graphql/jsutils/isIterableObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isIterableObject = isIterableObject;
      function isIterableObject(maybeIterable) {
        return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
      }
    }
  });

  // node_modules/graphql/utilities/astFromValue.js
  var require_astFromValue = __commonJS({
    "node_modules/graphql/utilities/astFromValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.astFromValue = astFromValue;
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _scalars = require_scalars();
      function astFromValue(value, type) {
        if ((0, _definition.isNonNullType)(type)) {
          const astValue = astFromValue(value, type.ofType);
          if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
            return null;
          }
          return astValue;
        }
        if (value === null) {
          return {
            kind: _kinds.Kind.NULL
          };
        }
        if (value === void 0) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, _isIterableObject.isIterableObject)(value)) {
            const valuesNodes = [];
            for (const item of value) {
              const itemNode = astFromValue(item, itemType);
              if (itemNode != null) {
                valuesNodes.push(itemNode);
              }
            }
            return {
              kind: _kinds.Kind.LIST,
              values: valuesNodes
            };
          }
          return astFromValue(value, itemType);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (!(0, _isObjectLike.isObjectLike)(value)) {
            return null;
          }
          const fieldNodes = [];
          for (const field of Object.values(type.getFields())) {
            const fieldValue = astFromValue(value[field.name], field.type);
            if (fieldValue) {
              fieldNodes.push({
                kind: _kinds.Kind.OBJECT_FIELD,
                name: {
                  kind: _kinds.Kind.NAME,
                  value: field.name
                },
                value: fieldValue
              });
            }
          }
          return {
            kind: _kinds.Kind.OBJECT,
            fields: fieldNodes
          };
        }
        if ((0, _definition.isLeafType)(type)) {
          const serialized = type.serialize(value);
          if (serialized == null) {
            return null;
          }
          if (typeof serialized === "boolean") {
            return {
              kind: _kinds.Kind.BOOLEAN,
              value: serialized
            };
          }
          if (typeof serialized === "number" && Number.isFinite(serialized)) {
            const stringNum = String(serialized);
            return integerStringRegExp.test(stringNum) ? {
              kind: _kinds.Kind.INT,
              value: stringNum
            } : {
              kind: _kinds.Kind.FLOAT,
              value: stringNum
            };
          }
          if (typeof serialized === "string") {
            if ((0, _definition.isEnumType)(type)) {
              return {
                kind: _kinds.Kind.ENUM,
                value: serialized
              };
            }
            if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
              return {
                kind: _kinds.Kind.INT,
                value: serialized
              };
            }
            return {
              kind: _kinds.Kind.STRING,
              value: serialized
            };
          }
          throw new TypeError(
            `Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`
          );
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected input type: " + (0, _inspect.inspect)(type)
        );
      }
      var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
    }
  });

  // node_modules/graphql/type/introspection.js
  var require_introspection = __commonJS({
    "node_modules/graphql/type/introspection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.introspectionTypes = exports.__TypeKind = exports.__Type = exports.__Schema = exports.__InputValue = exports.__Field = exports.__EnumValue = exports.__DirectiveLocation = exports.__Directive = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.TypeKind = exports.SchemaMetaFieldDef = void 0;
      exports.isIntrospectionType = isIntrospectionType;
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _directiveLocation = require_directiveLocation();
      var _printer = require_printer();
      var _astFromValue = require_astFromValue();
      var _definition = require_definition();
      var _scalars = require_scalars();
      var __Schema = new _definition.GraphQLObjectType({
        name: "__Schema",
        description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
        fields: () => ({
          description: {
            type: _scalars.GraphQLString,
            resolve: (schema) => schema.description
          },
          types: {
            description: "A list of all types supported by this server.",
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))
            ),
            resolve(schema) {
              return Object.values(schema.getTypeMap());
            }
          },
          queryType: {
            description: "The type that query operations will be rooted at.",
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (schema) => schema.getQueryType()
          },
          mutationType: {
            description: "If this server supports mutation, the type that mutation operations will be rooted at.",
            type: __Type,
            resolve: (schema) => schema.getMutationType()
          },
          subscriptionType: {
            description: "If this server support subscription, the type that subscription operations will be rooted at.",
            type: __Type,
            resolve: (schema) => schema.getSubscriptionType()
          },
          directives: {
            description: "A list of all directives supported by this server.",
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__Directive)
              )
            ),
            resolve: (schema) => schema.getDirectives()
          }
        })
      });
      exports.__Schema = __Schema;
      var __Directive = new _definition.GraphQLObjectType({
        name: "__Directive",
        description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (directive) => directive.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (directive) => directive.description
          },
          isRepeatable: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (directive) => directive.isRepeatable
          },
          locations: {
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__DirectiveLocation)
              )
            ),
            resolve: (directive) => directive.locations
          },
          args: {
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__InputValue)
              )
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          }
        })
      });
      exports.__Directive = __Directive;
      var __DirectiveLocation = new _definition.GraphQLEnumType({
        name: "__DirectiveLocation",
        description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
        values: {
          QUERY: {
            value: _directiveLocation.DirectiveLocation.QUERY,
            description: "Location adjacent to a query operation."
          },
          MUTATION: {
            value: _directiveLocation.DirectiveLocation.MUTATION,
            description: "Location adjacent to a mutation operation."
          },
          SUBSCRIPTION: {
            value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
            description: "Location adjacent to a subscription operation."
          },
          FIELD: {
            value: _directiveLocation.DirectiveLocation.FIELD,
            description: "Location adjacent to a field."
          },
          FRAGMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
            description: "Location adjacent to a fragment definition."
          },
          FRAGMENT_SPREAD: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
            description: "Location adjacent to a fragment spread."
          },
          INLINE_FRAGMENT: {
            value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
            description: "Location adjacent to an inline fragment."
          },
          VARIABLE_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
            description: "Location adjacent to a variable definition."
          },
          SCHEMA: {
            value: _directiveLocation.DirectiveLocation.SCHEMA,
            description: "Location adjacent to a schema definition."
          },
          SCALAR: {
            value: _directiveLocation.DirectiveLocation.SCALAR,
            description: "Location adjacent to a scalar definition."
          },
          OBJECT: {
            value: _directiveLocation.DirectiveLocation.OBJECT,
            description: "Location adjacent to an object type definition."
          },
          FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
            description: "Location adjacent to a field definition."
          },
          ARGUMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
            description: "Location adjacent to an argument definition."
          },
          INTERFACE: {
            value: _directiveLocation.DirectiveLocation.INTERFACE,
            description: "Location adjacent to an interface definition."
          },
          UNION: {
            value: _directiveLocation.DirectiveLocation.UNION,
            description: "Location adjacent to a union definition."
          },
          ENUM: {
            value: _directiveLocation.DirectiveLocation.ENUM,
            description: "Location adjacent to an enum definition."
          },
          ENUM_VALUE: {
            value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
            description: "Location adjacent to an enum value definition."
          },
          INPUT_OBJECT: {
            value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
            description: "Location adjacent to an input object type definition."
          },
          INPUT_FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
            description: "Location adjacent to an input object field definition."
          }
        }
      });
      exports.__DirectiveLocation = __DirectiveLocation;
      var __Type = new _definition.GraphQLObjectType({
        name: "__Type",
        description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
        fields: () => ({
          kind: {
            type: new _definition.GraphQLNonNull(__TypeKind),
            resolve(type) {
              if ((0, _definition.isScalarType)(type)) {
                return TypeKind.SCALAR;
              }
              if ((0, _definition.isObjectType)(type)) {
                return TypeKind.OBJECT;
              }
              if ((0, _definition.isInterfaceType)(type)) {
                return TypeKind.INTERFACE;
              }
              if ((0, _definition.isUnionType)(type)) {
                return TypeKind.UNION;
              }
              if ((0, _definition.isEnumType)(type)) {
                return TypeKind.ENUM;
              }
              if ((0, _definition.isInputObjectType)(type)) {
                return TypeKind.INPUT_OBJECT;
              }
              if ((0, _definition.isListType)(type)) {
                return TypeKind.LIST;
              }
              if ((0, _definition.isNonNullType)(type)) {
                return TypeKind.NON_NULL;
              }
              (0, _invariant.invariant)(
                false,
                `Unexpected type: "${(0, _inspect.inspect)(type)}".`
              );
            }
          },
          name: {
            type: _scalars.GraphQLString,
            resolve: (type) => "name" in type ? type.name : void 0
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (type) => (
              /* c8 ignore next */
              "description" in type ? type.description : void 0
            )
          },
          specifiedByURL: {
            type: _scalars.GraphQLString,
            resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
          },
          fields: {
            type: new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__Field)
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                const fields = Object.values(type.getFields());
                return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
              }
            }
          },
          interfaces: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve(type) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                return type.getInterfaces();
              }
            }
          },
          possibleTypes: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve(type, _args, _context, { schema }) {
              if ((0, _definition.isAbstractType)(type)) {
                return schema.getPossibleTypes(type);
              }
            }
          },
          enumValues: {
            type: new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__EnumValue)
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isEnumType)(type)) {
                const values = type.getValues();
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          inputFields: {
            type: new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue)
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isInputObjectType)(type)) {
                const values = Object.values(type.getFields());
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          ofType: {
            type: __Type,
            resolve: (type) => "ofType" in type ? type.ofType : void 0
          },
          isOneOf: {
            type: _scalars.GraphQLBoolean,
            resolve: (type) => {
              if ((0, _definition.isInputObjectType)(type)) {
                return type.isOneOf;
              }
            }
          }
        })
      });
      exports.__Type = __Type;
      var __Field = new _definition.GraphQLObjectType({
        name: "__Field",
        description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (field) => field.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (field) => field.description
          },
          args: {
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__InputValue)
              )
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (field) => field.type
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (field) => field.deprecationReason
          }
        })
      });
      exports.__Field = __Field;
      var __InputValue = new _definition.GraphQLObjectType({
        name: "__InputValue",
        description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (inputValue) => inputValue.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (inputValue) => inputValue.description
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (inputValue) => inputValue.type
          },
          defaultValue: {
            type: _scalars.GraphQLString,
            description: "A GraphQL-formatted string representing the default value for this input value.",
            resolve(inputValue) {
              const { type, defaultValue } = inputValue;
              const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
              return valueAST ? (0, _printer.print)(valueAST) : null;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (obj) => obj.deprecationReason
          }
        })
      });
      exports.__InputValue = __InputValue;
      var __EnumValue = new _definition.GraphQLObjectType({
        name: "__EnumValue",
        description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (enumValue) => enumValue.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (enumValue) => enumValue.description
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (enumValue) => enumValue.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (enumValue) => enumValue.deprecationReason
          }
        })
      });
      exports.__EnumValue = __EnumValue;
      var TypeKind;
      exports.TypeKind = TypeKind;
      (function(TypeKind2) {
        TypeKind2["SCALAR"] = "SCALAR";
        TypeKind2["OBJECT"] = "OBJECT";
        TypeKind2["INTERFACE"] = "INTERFACE";
        TypeKind2["UNION"] = "UNION";
        TypeKind2["ENUM"] = "ENUM";
        TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
        TypeKind2["LIST"] = "LIST";
        TypeKind2["NON_NULL"] = "NON_NULL";
      })(TypeKind || (exports.TypeKind = TypeKind = {}));
      var __TypeKind = new _definition.GraphQLEnumType({
        name: "__TypeKind",
        description: "An enum describing what kind of type a given `__Type` is.",
        values: {
          SCALAR: {
            value: TypeKind.SCALAR,
            description: "Indicates this type is a scalar."
          },
          OBJECT: {
            value: TypeKind.OBJECT,
            description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
          },
          INTERFACE: {
            value: TypeKind.INTERFACE,
            description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
          },
          UNION: {
            value: TypeKind.UNION,
            description: "Indicates this type is a union. `possibleTypes` is a valid field."
          },
          ENUM: {
            value: TypeKind.ENUM,
            description: "Indicates this type is an enum. `enumValues` is a valid field."
          },
          INPUT_OBJECT: {
            value: TypeKind.INPUT_OBJECT,
            description: "Indicates this type is an input object. `inputFields` is a valid field."
          },
          LIST: {
            value: TypeKind.LIST,
            description: "Indicates this type is a list. `ofType` is a valid field."
          },
          NON_NULL: {
            value: TypeKind.NON_NULL,
            description: "Indicates this type is a non-null. `ofType` is a valid field."
          }
        }
      });
      exports.__TypeKind = __TypeKind;
      var SchemaMetaFieldDef = {
        name: "__schema",
        type: new _definition.GraphQLNonNull(__Schema),
        description: "Access the current type schema of this server.",
        args: [],
        resolve: (_source, _args, _context, { schema }) => schema,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.SchemaMetaFieldDef = SchemaMetaFieldDef;
      var TypeMetaFieldDef = {
        name: "__type",
        type: __Type,
        description: "Request the type information of a single type.",
        args: [
          {
            name: "name",
            description: void 0,
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            defaultValue: void 0,
            deprecationReason: void 0,
            extensions: /* @__PURE__ */ Object.create(null),
            astNode: void 0
          }
        ],
        resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.TypeMetaFieldDef = TypeMetaFieldDef;
      var TypeNameMetaFieldDef = {
        name: "__typename",
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        description: "The name of the current Object type at runtime.",
        args: [],
        resolve: (_source, _args, _context, { parentType }) => parentType.name,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
      var introspectionTypes = Object.freeze([
        __Schema,
        __Directive,
        __DirectiveLocation,
        __Type,
        __Field,
        __InputValue,
        __EnumValue,
        __TypeKind
      ]);
      exports.introspectionTypes = introspectionTypes;
      function isIntrospectionType(type) {
        return introspectionTypes.some(({ name }) => type.name === name);
      }
    }
  });

  // node_modules/graphql/type/schema.js
  var require_schema = __commonJS({
    "node_modules/graphql/type/schema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLSchema = void 0;
      exports.assertSchema = assertSchema;
      exports.isSchema = isSchema;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _toObjMap = require_toObjMap();
      var _ast = require_ast();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      function isSchema(schema) {
        return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);
      }
      function assertSchema(schema) {
        if (!isSchema(schema)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`
          );
        }
        return schema;
      }
      var GraphQLSchema = class {
        // Used as a cache for validateSchema().
        constructor(config) {
          var _config$extensionASTN, _config$directives;
          this.__validationErrors = config.assumeValid === true ? [] : void 0;
          (0, _isObjectLike.isObjectLike)(config) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
          !config.types || Array.isArray(config.types) || (0, _devAssert.devAssert)(
            false,
            `"types" must be Array if provided but got: ${(0, _inspect.inspect)(
              config.types
            )}.`
          );
          !config.directives || Array.isArray(config.directives) || (0, _devAssert.devAssert)(
            false,
            `"directives" must be Array if provided but got: ${(0, _inspect.inspect)(config.directives)}.`
          );
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          this._queryType = config.query;
          this._mutationType = config.mutation;
          this._subscriptionType = config.subscription;
          this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
          const allReferencedTypes = new Set(config.types);
          if (config.types != null) {
            for (const type of config.types) {
              allReferencedTypes.delete(type);
              collectReferencedTypes(type, allReferencedTypes);
            }
          }
          if (this._queryType != null) {
            collectReferencedTypes(this._queryType, allReferencedTypes);
          }
          if (this._mutationType != null) {
            collectReferencedTypes(this._mutationType, allReferencedTypes);
          }
          if (this._subscriptionType != null) {
            collectReferencedTypes(this._subscriptionType, allReferencedTypes);
          }
          for (const directive of this._directives) {
            if ((0, _directives.isDirective)(directive)) {
              for (const arg of directive.args) {
                collectReferencedTypes(arg.type, allReferencedTypes);
              }
            }
          }
          collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
          this._typeMap = /* @__PURE__ */ Object.create(null);
          this._subTypeMap = /* @__PURE__ */ Object.create(null);
          this._implementationsMap = /* @__PURE__ */ Object.create(null);
          for (const namedType of allReferencedTypes) {
            if (namedType == null) {
              continue;
            }
            const typeName = namedType.name;
            typeName || (0, _devAssert.devAssert)(
              false,
              "One of the provided types for building the Schema is missing a name."
            );
            if (this._typeMap[typeName] !== void 0) {
              throw new Error(
                `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
              );
            }
            this._typeMap[typeName] = namedType;
            if ((0, _definition.isInterfaceType)(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if ((0, _definition.isInterfaceType)(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.interfaces.push(namedType);
                }
              }
            } else if ((0, _definition.isObjectType)(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if ((0, _definition.isInterfaceType)(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.objects.push(namedType);
                }
              }
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLSchema";
        }
        getQueryType() {
          return this._queryType;
        }
        getMutationType() {
          return this._mutationType;
        }
        getSubscriptionType() {
          return this._subscriptionType;
        }
        getRootType(operation) {
          switch (operation) {
            case _ast.OperationTypeNode.QUERY:
              return this.getQueryType();
            case _ast.OperationTypeNode.MUTATION:
              return this.getMutationType();
            case _ast.OperationTypeNode.SUBSCRIPTION:
              return this.getSubscriptionType();
          }
        }
        getTypeMap() {
          return this._typeMap;
        }
        getType(name) {
          return this.getTypeMap()[name];
        }
        getPossibleTypes(abstractType) {
          return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
        }
        getImplementations(interfaceType) {
          const implementations = this._implementationsMap[interfaceType.name];
          return implementations !== null && implementations !== void 0 ? implementations : {
            objects: [],
            interfaces: []
          };
        }
        isSubType(abstractType, maybeSubType) {
          let map = this._subTypeMap[abstractType.name];
          if (map === void 0) {
            map = /* @__PURE__ */ Object.create(null);
            if ((0, _definition.isUnionType)(abstractType)) {
              for (const type of abstractType.getTypes()) {
                map[type.name] = true;
              }
            } else {
              const implementations = this.getImplementations(abstractType);
              for (const type of implementations.objects) {
                map[type.name] = true;
              }
              for (const type of implementations.interfaces) {
                map[type.name] = true;
              }
            }
            this._subTypeMap[abstractType.name] = map;
          }
          return map[maybeSubType.name] !== void 0;
        }
        getDirectives() {
          return this._directives;
        }
        getDirective(name) {
          return this.getDirectives().find((directive) => directive.name === name);
        }
        toConfig() {
          return {
            description: this.description,
            query: this.getQueryType(),
            mutation: this.getMutationType(),
            subscription: this.getSubscriptionType(),
            types: Object.values(this.getTypeMap()),
            directives: this.getDirectives(),
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes,
            assumeValid: this.__validationErrors !== void 0
          };
        }
      };
      exports.GraphQLSchema = GraphQLSchema;
      function collectReferencedTypes(type, typeSet) {
        const namedType = (0, _definition.getNamedType)(type);
        if (!typeSet.has(namedType)) {
          typeSet.add(namedType);
          if ((0, _definition.isUnionType)(namedType)) {
            for (const memberType of namedType.getTypes()) {
              collectReferencedTypes(memberType, typeSet);
            }
          } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
            for (const interfaceType of namedType.getInterfaces()) {
              collectReferencedTypes(interfaceType, typeSet);
            }
            for (const field of Object.values(namedType.getFields())) {
              collectReferencedTypes(field.type, typeSet);
              for (const arg of field.args) {
                collectReferencedTypes(arg.type, typeSet);
              }
            }
          } else if ((0, _definition.isInputObjectType)(namedType)) {
            for (const field of Object.values(namedType.getFields())) {
              collectReferencedTypes(field.type, typeSet);
            }
          }
        }
        return typeSet;
      }
    }
  });

  // node_modules/graphql/type/validate.js
  var require_validate = __commonJS({
    "node_modules/graphql/type/validate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidSchema = assertValidSchema;
      exports.validateSchema = validateSchema;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _ast = require_ast();
      var _typeComparators = require_typeComparators();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _schema = require_schema();
      function validateSchema(schema) {
        (0, _schema.assertSchema)(schema);
        if (schema.__validationErrors) {
          return schema.__validationErrors;
        }
        const context2 = new SchemaValidationContext(schema);
        validateRootTypes(context2);
        validateDirectives(context2);
        validateTypes(context2);
        const errors = context2.getErrors();
        schema.__validationErrors = errors;
        return errors;
      }
      function assertValidSchema(schema) {
        const errors = validateSchema(schema);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
      var SchemaValidationContext = class {
        constructor(schema) {
          this._errors = [];
          this.schema = schema;
        }
        reportError(message, nodes) {
          const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
          this._errors.push(
            new _GraphQLError.GraphQLError(message, {
              nodes: _nodes
            })
          );
        }
        getErrors() {
          return this._errors;
        }
      };
      function validateRootTypes(context2) {
        const schema = context2.schema;
        const queryType = schema.getQueryType();
        if (!queryType) {
          context2.reportError("Query root type must be provided.", schema.astNode);
        } else if (!(0, _definition.isObjectType)(queryType)) {
          var _getOperationTypeNode;
          context2.reportError(
            `Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`,
            (_getOperationTypeNode = getOperationTypeNode(
              schema,
              _ast.OperationTypeNode.QUERY
            )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
          );
        }
        const mutationType = schema.getMutationType();
        if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
          var _getOperationTypeNode2;
          context2.reportError(
            `Mutation root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(mutationType)}.`,
            (_getOperationTypeNode2 = getOperationTypeNode(
              schema,
              _ast.OperationTypeNode.MUTATION
            )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
          );
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
          var _getOperationTypeNode3;
          context2.reportError(
            `Subscription root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(subscriptionType)}.`,
            (_getOperationTypeNode3 = getOperationTypeNode(
              schema,
              _ast.OperationTypeNode.SUBSCRIPTION
            )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
          );
        }
      }
      function getOperationTypeNode(schema, operation) {
        var _flatMap$find;
        return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          (schemaNode) => {
            var _schemaNode$operation;
            return (
              /* c8 ignore next */
              (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
            );
          }
        ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
      }
      function validateDirectives(context2) {
        for (const directive of context2.schema.getDirectives()) {
          if (!(0, _directives.isDirective)(directive)) {
            context2.reportError(
              `Expected directive but got: ${(0, _inspect.inspect)(directive)}.`,
              directive === null || directive === void 0 ? void 0 : directive.astNode
            );
            continue;
          }
          validateName(context2, directive);
          if (directive.locations.length === 0) {
            context2.reportError(
              `Directive @${directive.name} must include 1 or more locations.`,
              directive.astNode
            );
          }
          for (const arg of directive.args) {
            validateName(context2, arg);
            if (!(0, _definition.isInputType)(arg.type)) {
              context2.reportError(
                `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
                arg.astNode
              );
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
              var _arg$astNode;
              context2.reportError(
                `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
                [
                  getDeprecatedDirectiveNode(arg.astNode),
                  (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
                ]
              );
            }
          }
        }
      }
      function validateName(context2, node) {
        if (node.name.startsWith("__")) {
          context2.reportError(
            `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
            node.astNode
          );
        }
      }
      function validateTypes(context2) {
        const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context2);
        const typeMap = context2.schema.getTypeMap();
        for (const type of Object.values(typeMap)) {
          if (!(0, _definition.isNamedType)(type)) {
            context2.reportError(
              `Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`,
              type.astNode
            );
            continue;
          }
          if (!(0, _introspection.isIntrospectionType)(type)) {
            validateName(context2, type);
          }
          if ((0, _definition.isObjectType)(type)) {
            validateFields(context2, type);
            validateInterfaces(context2, type);
          } else if ((0, _definition.isInterfaceType)(type)) {
            validateFields(context2, type);
            validateInterfaces(context2, type);
          } else if ((0, _definition.isUnionType)(type)) {
            validateUnionMembers(context2, type);
          } else if ((0, _definition.isEnumType)(type)) {
            validateEnumValues(context2, type);
          } else if ((0, _definition.isInputObjectType)(type)) {
            validateInputFields(context2, type);
            validateInputObjectCircularRefs(type);
          }
        }
      }
      function validateFields(context2, type) {
        const fields = Object.values(type.getFields());
        if (fields.length === 0) {
          context2.reportError(`Type ${type.name} must define one or more fields.`, [
            type.astNode,
            ...type.extensionASTNodes
          ]);
        }
        for (const field of fields) {
          validateName(context2, field);
          if (!(0, _definition.isOutputType)(field.type)) {
            var _field$astNode;
            context2.reportError(
              `The type of ${type.name}.${field.name} must be Output Type but got: ${(0, _inspect.inspect)(field.type)}.`,
              (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
            );
          }
          for (const arg of field.args) {
            const argName = arg.name;
            validateName(context2, arg);
            if (!(0, _definition.isInputType)(arg.type)) {
              var _arg$astNode2;
              context2.reportError(
                `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
                (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
              );
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
              var _arg$astNode3;
              context2.reportError(
                `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
                [
                  getDeprecatedDirectiveNode(arg.astNode),
                  (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
                ]
              );
            }
          }
        }
      }
      function validateInterfaces(context2, type) {
        const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
        for (const iface of type.getInterfaces()) {
          if (!(0, _definition.isInterfaceType)(iface)) {
            context2.reportError(
              `Type ${(0, _inspect.inspect)(
                type
              )} must only implement Interface types, it cannot implement ${(0, _inspect.inspect)(iface)}.`,
              getAllImplementsInterfaceNodes(type, iface)
            );
            continue;
          }
          if (type === iface) {
            context2.reportError(
              `Type ${type.name} cannot implement itself because it would create a circular reference.`,
              getAllImplementsInterfaceNodes(type, iface)
            );
            continue;
          }
          if (ifaceTypeNames[iface.name]) {
            context2.reportError(
              `Type ${type.name} can only implement ${iface.name} once.`,
              getAllImplementsInterfaceNodes(type, iface)
            );
            continue;
          }
          ifaceTypeNames[iface.name] = true;
          validateTypeImplementsAncestors(context2, type, iface);
          validateTypeImplementsInterface(context2, type, iface);
        }
      }
      function validateTypeImplementsInterface(context2, type, iface) {
        const typeFieldMap = type.getFields();
        for (const ifaceField of Object.values(iface.getFields())) {
          const fieldName = ifaceField.name;
          const typeField = typeFieldMap[fieldName];
          if (!typeField) {
            context2.reportError(
              `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
              [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
            );
            continue;
          }
          if (!(0, _typeComparators.isTypeSubTypeOf)(
            context2.schema,
            typeField.type,
            ifaceField.type
          )) {
            var _ifaceField$astNode, _typeField$astNode;
            context2.reportError(
              `Interface field ${iface.name}.${fieldName} expects type ${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} is type ${(0, _inspect.inspect)(typeField.type)}.`,
              [
                (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
                (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
              ]
            );
          }
          for (const ifaceArg of ifaceField.args) {
            const argName = ifaceArg.name;
            const typeArg = typeField.args.find((arg) => arg.name === argName);
            if (!typeArg) {
              context2.reportError(
                `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
                [ifaceArg.astNode, typeField.astNode]
              );
              continue;
            }
            if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
              var _ifaceArg$astNode, _typeArg$astNode;
              context2.reportError(
                `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${(0, _inspect.inspect)(typeArg.type)}.`,
                [
                  (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                  (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
                ]
              );
            }
          }
          for (const typeArg of typeField.args) {
            const argName = typeArg.name;
            const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
            if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
              context2.reportError(
                `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
                [typeArg.astNode, ifaceField.astNode]
              );
            }
          }
        }
      }
      function validateTypeImplementsAncestors(context2, type, iface) {
        const ifaceInterfaces = type.getInterfaces();
        for (const transitive of iface.getInterfaces()) {
          if (!ifaceInterfaces.includes(transitive)) {
            context2.reportError(
              transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
              [
                ...getAllImplementsInterfaceNodes(iface, transitive),
                ...getAllImplementsInterfaceNodes(type, iface)
              ]
            );
          }
        }
      }
      function validateUnionMembers(context2, union) {
        const memberTypes = union.getTypes();
        if (memberTypes.length === 0) {
          context2.reportError(
            `Union type ${union.name} must define one or more member types.`,
            [union.astNode, ...union.extensionASTNodes]
          );
        }
        const includedTypeNames = /* @__PURE__ */ Object.create(null);
        for (const memberType of memberTypes) {
          if (includedTypeNames[memberType.name]) {
            context2.reportError(
              `Union type ${union.name} can only include type ${memberType.name} once.`,
              getUnionMemberTypeNodes(union, memberType.name)
            );
            continue;
          }
          includedTypeNames[memberType.name] = true;
          if (!(0, _definition.isObjectType)(memberType)) {
            context2.reportError(
              `Union type ${union.name} can only include Object types, it cannot include ${(0, _inspect.inspect)(memberType)}.`,
              getUnionMemberTypeNodes(union, String(memberType))
            );
          }
        }
      }
      function validateEnumValues(context2, enumType) {
        const enumValues = enumType.getValues();
        if (enumValues.length === 0) {
          context2.reportError(
            `Enum type ${enumType.name} must define one or more values.`,
            [enumType.astNode, ...enumType.extensionASTNodes]
          );
        }
        for (const enumValue of enumValues) {
          validateName(context2, enumValue);
        }
      }
      function validateInputFields(context2, inputObj) {
        const fields = Object.values(inputObj.getFields());
        if (fields.length === 0) {
          context2.reportError(
            `Input Object type ${inputObj.name} must define one or more fields.`,
            [inputObj.astNode, ...inputObj.extensionASTNodes]
          );
        }
        for (const field of fields) {
          validateName(context2, field);
          if (!(0, _definition.isInputType)(field.type)) {
            var _field$astNode2;
            context2.reportError(
              `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${(0, _inspect.inspect)(field.type)}.`,
              (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
            );
          }
          if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
            var _field$astNode3;
            context2.reportError(
              `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode(field.astNode),
                (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
              ]
            );
          }
          if (inputObj.isOneOf) {
            validateOneOfInputObjectField(inputObj, field, context2);
          }
        }
      }
      function validateOneOfInputObjectField(type, field, context2) {
        if ((0, _definition.isNonNullType)(field.type)) {
          var _field$astNode4;
          context2.reportError(
            `OneOf input field ${type.name}.${field.name} must be nullable.`,
            (_field$astNode4 = field.astNode) === null || _field$astNode4 === void 0 ? void 0 : _field$astNode4.type
          );
        }
        if (field.defaultValue !== void 0) {
          context2.reportError(
            `OneOf input field ${type.name}.${field.name} cannot have a default value.`,
            field.astNode
          );
        }
      }
      function createInputObjectCircularRefsValidator(context2) {
        const visitedTypes = /* @__PURE__ */ Object.create(null);
        const fieldPath = [];
        const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
        return detectCycleRecursive;
        function detectCycleRecursive(inputObj) {
          if (visitedTypes[inputObj.name]) {
            return;
          }
          visitedTypes[inputObj.name] = true;
          fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
          const fields = Object.values(inputObj.getFields());
          for (const field of fields) {
            if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
              const fieldType = field.type.ofType;
              const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
              fieldPath.push(field);
              if (cycleIndex === void 0) {
                detectCycleRecursive(fieldType);
              } else {
                const cyclePath = fieldPath.slice(cycleIndex);
                const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
                context2.reportError(
                  `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
                  cyclePath.map((fieldObj) => fieldObj.astNode)
                );
              }
              fieldPath.pop();
            }
          }
          fieldPathIndexByTypeName[inputObj.name] = void 0;
        }
      }
      function getAllImplementsInterfaceNodes(type, iface) {
        const { astNode, extensionASTNodes } = type;
        const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
        return nodes.flatMap((typeNode) => {
          var _typeNode$interfaces;
          return (
            /* c8 ignore next */
            (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
          );
        }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
      }
      function getUnionMemberTypeNodes(union, typeName) {
        const { astNode, extensionASTNodes } = union;
        const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
        return nodes.flatMap((unionNode) => {
          var _unionNode$types;
          return (
            /* c8 ignore next */
            (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
          );
        }).filter((typeNode) => typeNode.name.value === typeName);
      }
      function getDeprecatedDirectiveNode(definitionNode) {
        var _definitionNode$direc;
        return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
          (node) => node.name.value === _directives.GraphQLDeprecatedDirective.name
        );
      }
    }
  });

  // node_modules/graphql/utilities/typeFromAST.js
  var require_typeFromAST = __commonJS({
    "node_modules/graphql/utilities/typeFromAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.typeFromAST = typeFromAST;
      var _kinds = require_kinds();
      var _definition = require_definition();
      function typeFromAST(schema, typeNode) {
        switch (typeNode.kind) {
          case _kinds.Kind.LIST_TYPE: {
            const innerType = typeFromAST(schema, typeNode.type);
            return innerType && new _definition.GraphQLList(innerType);
          }
          case _kinds.Kind.NON_NULL_TYPE: {
            const innerType = typeFromAST(schema, typeNode.type);
            return innerType && new _definition.GraphQLNonNull(innerType);
          }
          case _kinds.Kind.NAMED_TYPE:
            return schema.getType(typeNode.name.value);
        }
      }
    }
  });

  // node_modules/graphql/utilities/TypeInfo.js
  var require_TypeInfo = __commonJS({
    "node_modules/graphql/utilities/TypeInfo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TypeInfo = void 0;
      exports.visitWithTypeInfo = visitWithTypeInfo;
      var _ast = require_ast();
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      var _definition = require_definition();
      var _introspection = require_introspection();
      var _typeFromAST = require_typeFromAST();
      var TypeInfo = class {
        constructor(schema, initialType, getFieldDefFn) {
          this._schema = schema;
          this._typeStack = [];
          this._parentTypeStack = [];
          this._inputTypeStack = [];
          this._fieldDefStack = [];
          this._defaultValueStack = [];
          this._directive = null;
          this._argument = null;
          this._enumValue = null;
          this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
          if (initialType) {
            if ((0, _definition.isInputType)(initialType)) {
              this._inputTypeStack.push(initialType);
            }
            if ((0, _definition.isCompositeType)(initialType)) {
              this._parentTypeStack.push(initialType);
            }
            if ((0, _definition.isOutputType)(initialType)) {
              this._typeStack.push(initialType);
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "TypeInfo";
        }
        getType() {
          if (this._typeStack.length > 0) {
            return this._typeStack[this._typeStack.length - 1];
          }
        }
        getParentType() {
          if (this._parentTypeStack.length > 0) {
            return this._parentTypeStack[this._parentTypeStack.length - 1];
          }
        }
        getInputType() {
          if (this._inputTypeStack.length > 0) {
            return this._inputTypeStack[this._inputTypeStack.length - 1];
          }
        }
        getParentInputType() {
          if (this._inputTypeStack.length > 1) {
            return this._inputTypeStack[this._inputTypeStack.length - 2];
          }
        }
        getFieldDef() {
          if (this._fieldDefStack.length > 0) {
            return this._fieldDefStack[this._fieldDefStack.length - 1];
          }
        }
        getDefaultValue() {
          if (this._defaultValueStack.length > 0) {
            return this._defaultValueStack[this._defaultValueStack.length - 1];
          }
        }
        getDirective() {
          return this._directive;
        }
        getArgument() {
          return this._argument;
        }
        getEnumValue() {
          return this._enumValue;
        }
        enter(node) {
          const schema = this._schema;
          switch (node.kind) {
            case _kinds.Kind.SELECTION_SET: {
              const namedType = (0, _definition.getNamedType)(this.getType());
              this._parentTypeStack.push(
                (0, _definition.isCompositeType)(namedType) ? namedType : void 0
              );
              break;
            }
            case _kinds.Kind.FIELD: {
              const parentType = this.getParentType();
              let fieldDef;
              let fieldType;
              if (parentType) {
                fieldDef = this._getFieldDef(schema, parentType, node);
                if (fieldDef) {
                  fieldType = fieldDef.type;
                }
              }
              this._fieldDefStack.push(fieldDef);
              this._typeStack.push(
                (0, _definition.isOutputType)(fieldType) ? fieldType : void 0
              );
              break;
            }
            case _kinds.Kind.DIRECTIVE:
              this._directive = schema.getDirective(node.name.value);
              break;
            case _kinds.Kind.OPERATION_DEFINITION: {
              const rootType = schema.getRootType(node.operation);
              this._typeStack.push(
                (0, _definition.isObjectType)(rootType) ? rootType : void 0
              );
              break;
            }
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION: {
              const typeConditionAST = node.typeCondition;
              const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
              this._typeStack.push(
                (0, _definition.isOutputType)(outputType) ? outputType : void 0
              );
              break;
            }
            case _kinds.Kind.VARIABLE_DEFINITION: {
              const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
              this._inputTypeStack.push(
                (0, _definition.isInputType)(inputType) ? inputType : void 0
              );
              break;
            }
            case _kinds.Kind.ARGUMENT: {
              var _this$getDirective;
              let argDef;
              let argType;
              const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
              if (fieldOrDirective) {
                argDef = fieldOrDirective.args.find(
                  (arg) => arg.name === node.name.value
                );
                if (argDef) {
                  argType = argDef.type;
                }
              }
              this._argument = argDef;
              this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
              this._inputTypeStack.push(
                (0, _definition.isInputType)(argType) ? argType : void 0
              );
              break;
            }
            case _kinds.Kind.LIST: {
              const listType = (0, _definition.getNullableType)(this.getInputType());
              const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
              this._defaultValueStack.push(void 0);
              this._inputTypeStack.push(
                (0, _definition.isInputType)(itemType) ? itemType : void 0
              );
              break;
            }
            case _kinds.Kind.OBJECT_FIELD: {
              const objectType = (0, _definition.getNamedType)(this.getInputType());
              let inputFieldType;
              let inputField;
              if ((0, _definition.isInputObjectType)(objectType)) {
                inputField = objectType.getFields()[node.name.value];
                if (inputField) {
                  inputFieldType = inputField.type;
                }
              }
              this._defaultValueStack.push(
                inputField ? inputField.defaultValue : void 0
              );
              this._inputTypeStack.push(
                (0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0
              );
              break;
            }
            case _kinds.Kind.ENUM: {
              const enumType = (0, _definition.getNamedType)(this.getInputType());
              let enumValue;
              if ((0, _definition.isEnumType)(enumType)) {
                enumValue = enumType.getValue(node.value);
              }
              this._enumValue = enumValue;
              break;
            }
            default:
          }
        }
        leave(node) {
          switch (node.kind) {
            case _kinds.Kind.SELECTION_SET:
              this._parentTypeStack.pop();
              break;
            case _kinds.Kind.FIELD:
              this._fieldDefStack.pop();
              this._typeStack.pop();
              break;
            case _kinds.Kind.DIRECTIVE:
              this._directive = null;
              break;
            case _kinds.Kind.OPERATION_DEFINITION:
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION:
              this._typeStack.pop();
              break;
            case _kinds.Kind.VARIABLE_DEFINITION:
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.ARGUMENT:
              this._argument = null;
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.LIST:
            case _kinds.Kind.OBJECT_FIELD:
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.ENUM:
              this._enumValue = null;
              break;
            default:
          }
        }
      };
      exports.TypeInfo = TypeInfo;
      function getFieldDef(schema, parentType, fieldNode) {
        const name = fieldNode.name.value;
        if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.SchemaMetaFieldDef;
        }
        if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.TypeMetaFieldDef;
        }
        if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
          return _introspection.TypeNameMetaFieldDef;
        }
        if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
          return parentType.getFields()[name];
        }
      }
      function visitWithTypeInfo(typeInfo, visitor) {
        return {
          enter(...args) {
            const node = args[0];
            typeInfo.enter(node);
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
            if (fn) {
              const result = fn.apply(visitor, args);
              if (result !== void 0) {
                typeInfo.leave(node);
                if ((0, _ast.isNode)(result)) {
                  typeInfo.enter(result);
                }
              }
              return result;
            }
          },
          leave(...args) {
            const node = args[0];
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
            let result;
            if (fn) {
              result = fn.apply(visitor, args);
            }
            typeInfo.leave(node);
            return result;
          }
        };
      }
    }
  });

  // node_modules/graphql/language/predicates.js
  var require_predicates = __commonJS({
    "node_modules/graphql/language/predicates.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isConstValueNode = isConstValueNode;
      exports.isDefinitionNode = isDefinitionNode;
      exports.isExecutableDefinitionNode = isExecutableDefinitionNode;
      exports.isSelectionNode = isSelectionNode;
      exports.isTypeDefinitionNode = isTypeDefinitionNode;
      exports.isTypeExtensionNode = isTypeExtensionNode;
      exports.isTypeNode = isTypeNode;
      exports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
      exports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
      exports.isValueNode = isValueNode;
      var _kinds = require_kinds();
      function isDefinitionNode(node) {
        return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
      }
      function isExecutableDefinitionNode(node) {
        return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
      }
      function isSelectionNode(node) {
        return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
      }
      function isValueNode(node) {
        return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
      }
      function isConstValueNode(node) {
        return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
      }
      function isTypeNode(node) {
        return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
      }
      function isTypeSystemDefinitionNode(node) {
        return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
      }
      function isTypeDefinitionNode(node) {
        return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
      }
      function isTypeSystemExtensionNode(node) {
        return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
      }
      function isTypeExtensionNode(node) {
        return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
    }
  });

  // node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
  var require_ExecutableDefinitionsRule = __commonJS({
    "node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      function ExecutableDefinitionsRule(context2) {
        return {
          Document(node) {
            for (const definition of node.definitions) {
              if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
                const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `The ${defName} definition is not executable.`,
                    {
                      nodes: definition
                    }
                  )
                );
              }
            }
            return false;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
  var require_FieldsOnCorrectTypeRule = __commonJS({
    "node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
      var _didYouMean = require_didYouMean();
      var _naturalCompare = require_naturalCompare();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function FieldsOnCorrectTypeRule(context2) {
        return {
          Field(node) {
            const type = context2.getParentType();
            if (type) {
              const fieldDef = context2.getFieldDef();
              if (!fieldDef) {
                const schema = context2.getSchema();
                const fieldName = node.name.value;
                let suggestion = (0, _didYouMean.didYouMean)(
                  "to use an inline fragment on",
                  getSuggestedTypeNames(schema, type, fieldName)
                );
                if (suggestion === "") {
                  suggestion = (0, _didYouMean.didYouMean)(
                    getSuggestedFieldNames(type, fieldName)
                  );
                }
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          }
        };
      }
      function getSuggestedTypeNames(schema, type, fieldName) {
        if (!(0, _definition.isAbstractType)(type)) {
          return [];
        }
        const suggestedTypes = /* @__PURE__ */ new Set();
        const usageCount = /* @__PURE__ */ Object.create(null);
        for (const possibleType of schema.getPossibleTypes(type)) {
          if (!possibleType.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleType);
          usageCount[possibleType.name] = 1;
          for (const possibleInterface of possibleType.getInterfaces()) {
            var _usageCount$possibleI;
            if (!possibleInterface.getFields()[fieldName]) {
              continue;
            }
            suggestedTypes.add(possibleInterface);
            usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
          }
        }
        return [...suggestedTypes].sort((typeA, typeB) => {
          const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
          if (usageCountDiff !== 0) {
            return usageCountDiff;
          }
          if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
            return -1;
          }
          if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
            return 1;
          }
          return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
        }).map((x) => x.name);
      }
      function getSuggestedFieldNames(type, fieldName) {
        if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
          const possibleFieldNames = Object.keys(type.getFields());
          return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
        }
        return [];
      }
    }
  });

  // node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
  var require_FragmentsOnCompositeTypesRule = __commonJS({
    "node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      var _typeFromAST = require_typeFromAST();
      function FragmentsOnCompositeTypesRule(context2) {
        return {
          InlineFragment(node) {
            const typeCondition = node.typeCondition;
            if (typeCondition) {
              const type = (0, _typeFromAST.typeFromAST)(
                context2.getSchema(),
                typeCondition
              );
              if (type && !(0, _definition.isCompositeType)(type)) {
                const typeStr = (0, _printer.print)(typeCondition);
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Fragment cannot condition on non composite type "${typeStr}".`,
                    {
                      nodes: typeCondition
                    }
                  )
                );
              }
            }
          },
          FragmentDefinition(node) {
            const type = (0, _typeFromAST.typeFromAST)(
              context2.getSchema(),
              node.typeCondition
            );
            if (type && !(0, _definition.isCompositeType)(type)) {
              const typeStr = (0, _printer.print)(node.typeCondition);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
                  {
                    nodes: node.typeCondition
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
  var require_KnownArgumentNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
      exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
      var _didYouMean = require_didYouMean();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _directives = require_directives();
      function KnownArgumentNamesRule(context2) {
        return {
          // eslint-disable-next-line new-cap
          ...KnownArgumentNamesOnDirectivesRule(context2),
          Argument(argNode) {
            const argDef = context2.getArgument();
            const fieldDef = context2.getFieldDef();
            const parentType = context2.getParentType();
            if (!argDef && fieldDef && parentType) {
              const argName = argNode.name.value;
              const knownArgsNames = fieldDef.args.map((arg) => arg.name);
              const suggestions = (0, _suggestionList.suggestionList)(
                argName,
                knownArgsNames
              );
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                  {
                    nodes: argNode
                  }
                )
              );
            }
          }
        };
      }
      function KnownArgumentNamesOnDirectivesRule(context2) {
        const directiveArgs = /* @__PURE__ */ Object.create(null);
        const schema = context2.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
        }
        const astDefinitions = context2.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
          }
        }
        return {
          Directive(directiveNode) {
            const directiveName = directiveNode.name.value;
            const knownArgs = directiveArgs[directiveName];
            if (directiveNode.arguments && knownArgs) {
              for (const argNode of directiveNode.arguments) {
                const argName = argNode.name.value;
                if (!knownArgs.includes(argName)) {
                  const suggestions = (0, _suggestionList.suggestionList)(
                    argName,
                    knownArgs
                  );
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions),
                      {
                        nodes: argNode
                      }
                    )
                  );
                }
              }
            }
            return false;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/KnownDirectivesRule.js
  var require_KnownDirectivesRule = __commonJS({
    "node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownDirectivesRule = KnownDirectivesRule;
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _GraphQLError = require_GraphQLError();
      var _ast = require_ast();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _directives = require_directives();
      function KnownDirectivesRule(context2) {
        const locationsMap = /* @__PURE__ */ Object.create(null);
        const schema = context2.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          locationsMap[directive.name] = directive.locations;
        }
        const astDefinitions = context2.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            locationsMap[def.name.value] = def.locations.map((name) => name.value);
          }
        }
        return {
          Directive(node, _key, _parent, _path, ancestors) {
            const name = node.name.value;
            const locations = locationsMap[name];
            if (!locations) {
              context2.reportError(
                new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
                  nodes: node
                })
              );
              return;
            }
            const candidateLocation = getDirectiveLocationForASTPath(ancestors);
            if (candidateLocation && !locations.includes(candidateLocation)) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Directive "@${name}" may not be used on ${candidateLocation}.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
      function getDirectiveLocationForASTPath(ancestors) {
        const appliedTo = ancestors[ancestors.length - 1];
        "kind" in appliedTo || (0, _invariant.invariant)(false);
        switch (appliedTo.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            return getDirectiveLocationForOperation(appliedTo.operation);
          case _kinds.Kind.FIELD:
            return _directiveLocation.DirectiveLocation.FIELD;
          case _kinds.Kind.FRAGMENT_SPREAD:
            return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
          case _kinds.Kind.INLINE_FRAGMENT:
            return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
          case _kinds.Kind.VARIABLE_DEFINITION:
            return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
          case _kinds.Kind.SCHEMA_DEFINITION:
          case _kinds.Kind.SCHEMA_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCHEMA;
          case _kinds.Kind.SCALAR_TYPE_DEFINITION:
          case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCALAR;
          case _kinds.Kind.OBJECT_TYPE_DEFINITION:
          case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.OBJECT;
          case _kinds.Kind.FIELD_DEFINITION:
            return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
          case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INTERFACE;
          case _kinds.Kind.UNION_TYPE_DEFINITION:
          case _kinds.Kind.UNION_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.UNION;
          case _kinds.Kind.ENUM_TYPE_DEFINITION:
          case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.ENUM;
          case _kinds.Kind.ENUM_VALUE_DEFINITION:
            return _directiveLocation.DirectiveLocation.ENUM_VALUE;
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
          case _kinds.Kind.INPUT_VALUE_DEFINITION: {
            const parentNode = ancestors[ancestors.length - 3];
            "kind" in parentNode || (0, _invariant.invariant)(false);
            return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
          }
          // Not reachable, all possible types have been considered.
          /* c8 ignore next */
          default:
            (0, _invariant.invariant)(
              false,
              "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind)
            );
        }
      }
      function getDirectiveLocationForOperation(operation) {
        switch (operation) {
          case _ast.OperationTypeNode.QUERY:
            return _directiveLocation.DirectiveLocation.QUERY;
          case _ast.OperationTypeNode.MUTATION:
            return _directiveLocation.DirectiveLocation.MUTATION;
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
  var require_KnownFragmentNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
      var _GraphQLError = require_GraphQLError();
      function KnownFragmentNamesRule(context2) {
        return {
          FragmentSpread(node) {
            const fragmentName = node.name.value;
            const fragment = context2.getFragment(fragmentName);
            if (!fragment) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Unknown fragment "${fragmentName}".`,
                  {
                    nodes: node.name
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/KnownTypeNamesRule.js
  var require_KnownTypeNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownTypeNamesRule = KnownTypeNamesRule;
      var _didYouMean = require_didYouMean();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _predicates = require_predicates();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      function KnownTypeNamesRule(context2) {
        const schema = context2.getSchema();
        const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const definedTypes = /* @__PURE__ */ Object.create(null);
        for (const def of context2.getDocument().definitions) {
          if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = true;
          }
        }
        const typeNames = [
          ...Object.keys(existingTypesMap),
          ...Object.keys(definedTypes)
        ];
        return {
          NamedType(node, _1, parent, _2, ancestors) {
            const typeName = node.name.value;
            if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
              var _ancestors$;
              const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
              const isSDL = definitionNode != null && isSDLNode(definitionNode);
              if (isSDL && standardTypeNames.includes(typeName)) {
                return;
              }
              const suggestedTypes = (0, _suggestionList.suggestionList)(
                typeName,
                isSDL ? standardTypeNames.concat(typeNames) : typeNames
              );
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes),
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
      var standardTypeNames = [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
      ].map((type) => type.name);
      function isSDLNode(value) {
        return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
      }
    }
  });

  // node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
  var require_LoneAnonymousOperationRule = __commonJS({
    "node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      function LoneAnonymousOperationRule(context2) {
        let operationCount = 0;
        return {
          Document(node) {
            operationCount = node.definitions.filter(
              (definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION
            ).length;
          },
          OperationDefinition(node) {
            if (!node.name && operationCount > 1) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  "This anonymous operation must be the only defined operation.",
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
  var require_LoneSchemaDefinitionRule = __commonJS({
    "node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
      var _GraphQLError = require_GraphQLError();
      function LoneSchemaDefinitionRule(context2) {
        var _ref, _ref2, _oldSchema$astNode;
        const oldSchema = context2.getSchema();
        const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
        let schemaDefinitionsCount = 0;
        return {
          SchemaDefinition(node) {
            if (alreadyDefined) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  "Cannot define a new schema within a schema extension.",
                  {
                    nodes: node
                  }
                )
              );
              return;
            }
            if (schemaDefinitionsCount > 0) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  "Must provide only one schema definition.",
                  {
                    nodes: node
                  }
                )
              );
            }
            ++schemaDefinitionsCount;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.js
  var require_MaxIntrospectionDepthRule = __commonJS({
    "node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MaxIntrospectionDepthRule = MaxIntrospectionDepthRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var MAX_LISTS_DEPTH = 3;
      function MaxIntrospectionDepthRule(context2) {
        function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
          if (node.kind === _kinds.Kind.FRAGMENT_SPREAD) {
            const fragmentName = node.name.value;
            if (visitedFragments[fragmentName] === true) {
              return false;
            }
            const fragment = context2.getFragment(fragmentName);
            if (!fragment) {
              return false;
            }
            try {
              visitedFragments[fragmentName] = true;
              return checkDepth(fragment, visitedFragments, depth);
            } finally {
              visitedFragments[fragmentName] = void 0;
            }
          }
          if (node.kind === _kinds.Kind.FIELD && // check all introspection lists
          (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
            depth++;
            if (depth >= MAX_LISTS_DEPTH) {
              return true;
            }
          }
          if ("selectionSet" in node && node.selectionSet) {
            for (const child of node.selectionSet.selections) {
              if (checkDepth(child, visitedFragments, depth)) {
                return true;
              }
            }
          }
          return false;
        }
        return {
          Field(node) {
            if (node.name.value === "__schema" || node.name.value === "__type") {
              if (checkDepth(node)) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    "Maximum introspection depth exceeded",
                    {
                      nodes: [node]
                    }
                  )
                );
                return false;
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
  var require_NoFragmentCyclesRule = __commonJS({
    "node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
      var _GraphQLError = require_GraphQLError();
      function NoFragmentCyclesRule(context2) {
        const visitedFrags = /* @__PURE__ */ Object.create(null);
        const spreadPath = [];
        const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: () => false,
          FragmentDefinition(node) {
            detectCycleRecursive(node);
            return false;
          }
        };
        function detectCycleRecursive(fragment) {
          if (visitedFrags[fragment.name.value]) {
            return;
          }
          const fragmentName = fragment.name.value;
          visitedFrags[fragmentName] = true;
          const spreadNodes = context2.getFragmentSpreads(fragment.selectionSet);
          if (spreadNodes.length === 0) {
            return;
          }
          spreadPathIndexByName[fragmentName] = spreadPath.length;
          for (const spreadNode of spreadNodes) {
            const spreadName = spreadNode.name.value;
            const cycleIndex = spreadPathIndexByName[spreadName];
            spreadPath.push(spreadNode);
            if (cycleIndex === void 0) {
              const spreadFragment = context2.getFragment(spreadName);
              if (spreadFragment) {
                detectCycleRecursive(spreadFragment);
              }
            } else {
              const cyclePath = spreadPath.slice(cycleIndex);
              const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
                  {
                    nodes: cyclePath
                  }
                )
              );
            }
            spreadPath.pop();
          }
          spreadPathIndexByName[fragmentName] = void 0;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
  var require_NoUndefinedVariablesRule = __commonJS({
    "node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
      var _GraphQLError = require_GraphQLError();
      function NoUndefinedVariablesRule(context2) {
        let variableNameDefined = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: {
            enter() {
              variableNameDefined = /* @__PURE__ */ Object.create(null);
            },
            leave(operation) {
              const usages = context2.getRecursiveVariableUsages(operation);
              for (const { node } of usages) {
                const varName = node.name.value;
                if (variableNameDefined[varName] !== true) {
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                      {
                        nodes: [node, operation]
                      }
                    )
                  );
                }
              }
            }
          },
          VariableDefinition(node) {
            variableNameDefined[node.variable.name.value] = true;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
  var require_NoUnusedFragmentsRule = __commonJS({
    "node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
      var _GraphQLError = require_GraphQLError();
      function NoUnusedFragmentsRule(context2) {
        const operationDefs = [];
        const fragmentDefs = [];
        return {
          OperationDefinition(node) {
            operationDefs.push(node);
            return false;
          },
          FragmentDefinition(node) {
            fragmentDefs.push(node);
            return false;
          },
          Document: {
            leave() {
              const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
              for (const operation of operationDefs) {
                for (const fragment of context2.getRecursivelyReferencedFragments(
                  operation
                )) {
                  fragmentNameUsed[fragment.name.value] = true;
                }
              }
              for (const fragmentDef of fragmentDefs) {
                const fragName = fragmentDef.name.value;
                if (fragmentNameUsed[fragName] !== true) {
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `Fragment "${fragName}" is never used.`,
                      {
                        nodes: fragmentDef
                      }
                    )
                  );
                }
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
  var require_NoUnusedVariablesRule = __commonJS({
    "node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
      var _GraphQLError = require_GraphQLError();
      function NoUnusedVariablesRule(context2) {
        let variableDefs = [];
        return {
          OperationDefinition: {
            enter() {
              variableDefs = [];
            },
            leave(operation) {
              const variableNameUsed = /* @__PURE__ */ Object.create(null);
              const usages = context2.getRecursiveVariableUsages(operation);
              for (const { node } of usages) {
                variableNameUsed[node.name.value] = true;
              }
              for (const variableDef of variableDefs) {
                const variableName = variableDef.variable.name.value;
                if (variableNameUsed[variableName] !== true) {
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                      {
                        nodes: variableDef
                      }
                    )
                  );
                }
              }
            }
          },
          VariableDefinition(def) {
            variableDefs.push(def);
          }
        };
      }
    }
  });

  // node_modules/graphql/utilities/sortValueNode.js
  var require_sortValueNode = __commonJS({
    "node_modules/graphql/utilities/sortValueNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sortValueNode = sortValueNode;
      var _naturalCompare = require_naturalCompare();
      var _kinds = require_kinds();
      function sortValueNode(valueNode) {
        switch (valueNode.kind) {
          case _kinds.Kind.OBJECT:
            return { ...valueNode, fields: sortFields(valueNode.fields) };
          case _kinds.Kind.LIST:
            return { ...valueNode, values: valueNode.values.map(sortValueNode) };
          case _kinds.Kind.INT:
          case _kinds.Kind.FLOAT:
          case _kinds.Kind.STRING:
          case _kinds.Kind.BOOLEAN:
          case _kinds.Kind.NULL:
          case _kinds.Kind.ENUM:
          case _kinds.Kind.VARIABLE:
            return valueNode;
        }
      }
      function sortFields(fields) {
        return fields.map((fieldNode) => ({
          ...fieldNode,
          value: sortValueNode(fieldNode.value)
        })).sort(
          (fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value)
        );
      }
    }
  });

  // node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
  var require_OverlappingFieldsCanBeMergedRule = __commonJS({
    "node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _sortValueNode = require_sortValueNode();
      var _typeFromAST = require_typeFromAST();
      function reasonMessage(reason) {
        if (Array.isArray(reason)) {
          return reason.map(
            ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
          ).join(" and ");
        }
        return reason;
      }
      function OverlappingFieldsCanBeMergedRule(context2) {
        const comparedFieldsAndFragmentPairs = new OrderedPairSet();
        const comparedFragmentPairs = new PairSet();
        const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
        return {
          SelectionSet(selectionSet) {
            const conflicts = findConflictsWithinSelectionSet(
              context2,
              cachedFieldsAndFragmentNames,
              comparedFieldsAndFragmentPairs,
              comparedFragmentPairs,
              context2.getParentType(),
              selectionSet
            );
            for (const [[responseName, reason], fields1, fields2] of conflicts) {
              const reasonMsg = reasonMessage(reason);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
                  {
                    nodes: fields1.concat(fields2)
                  }
                )
              );
            }
          }
        };
      }
      function findConflictsWithinSelectionSet(context2, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet) {
        const conflicts = [];
        const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
          context2,
          cachedFieldsAndFragmentNames,
          parentType,
          selectionSet
        );
        collectConflictsWithin(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          fieldMap
        );
        if (fragmentNames.length !== 0) {
          for (let i = 0; i < fragmentNames.length; i++) {
            collectConflictsBetweenFieldsAndFragment(
              context2,
              conflicts,
              cachedFieldsAndFragmentNames,
              comparedFieldsAndFragmentPairs,
              comparedFragmentPairs,
              false,
              fieldMap,
              fragmentNames[i]
            );
            for (let j = i + 1; j < fragmentNames.length; j++) {
              collectConflictsBetweenFragments(
                context2,
                conflicts,
                cachedFieldsAndFragmentNames,
                comparedFieldsAndFragmentPairs,
                comparedFragmentPairs,
                false,
                fragmentNames[i],
                fragmentNames[j]
              );
            }
          }
        }
        return conflicts;
      }
      function collectConflictsBetweenFieldsAndFragment(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
        if (comparedFieldsAndFragmentPairs.has(
          fieldMap,
          fragmentName,
          areMutuallyExclusive
        )) {
          return;
        }
        comparedFieldsAndFragmentPairs.add(
          fieldMap,
          fragmentName,
          areMutuallyExclusive
        );
        const fragment = context2.getFragment(fragmentName);
        if (!fragment) {
          return;
        }
        const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
          context2,
          cachedFieldsAndFragmentNames,
          fragment
        );
        if (fieldMap === fieldMap2) {
          return;
        }
        collectConflictsBetween(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap,
          fieldMap2
        );
        for (const referencedFragmentName of referencedFragmentNames) {
          collectConflictsBetweenFieldsAndFragment(
            context2,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fieldMap,
            referencedFragmentName
          );
        }
      }
      function collectConflictsBetweenFragments(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
        if (fragmentName1 === fragmentName2) {
          return;
        }
        if (comparedFragmentPairs.has(
          fragmentName1,
          fragmentName2,
          areMutuallyExclusive
        )) {
          return;
        }
        comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
        const fragment1 = context2.getFragment(fragmentName1);
        const fragment2 = context2.getFragment(fragmentName2);
        if (!fragment1 || !fragment2) {
          return;
        }
        const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
          context2,
          cachedFieldsAndFragmentNames,
          fragment1
        );
        const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
          context2,
          cachedFieldsAndFragmentNames,
          fragment2
        );
        collectConflictsBetween(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap1,
          fieldMap2
        );
        for (const referencedFragmentName2 of referencedFragmentNames2) {
          collectConflictsBetweenFragments(
            context2,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fragmentName1,
            referencedFragmentName2
          );
        }
        for (const referencedFragmentName1 of referencedFragmentNames1) {
          collectConflictsBetweenFragments(
            context2,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            areMutuallyExclusive,
            referencedFragmentName1,
            fragmentName2
          );
        }
      }
      function findConflictsBetweenSubSelectionSets(context2, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
        const conflicts = [];
        const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
          context2,
          cachedFieldsAndFragmentNames,
          parentType1,
          selectionSet1
        );
        const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
          context2,
          cachedFieldsAndFragmentNames,
          parentType2,
          selectionSet2
        );
        collectConflictsBetween(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap1,
          fieldMap2
        );
        for (const fragmentName2 of fragmentNames2) {
          collectConflictsBetweenFieldsAndFragment(
            context2,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fieldMap1,
            fragmentName2
          );
        }
        for (const fragmentName1 of fragmentNames1) {
          collectConflictsBetweenFieldsAndFragment(
            context2,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fieldMap2,
            fragmentName1
          );
        }
        for (const fragmentName1 of fragmentNames1) {
          for (const fragmentName2 of fragmentNames2) {
            collectConflictsBetweenFragments(
              context2,
              conflicts,
              cachedFieldsAndFragmentNames,
              comparedFieldsAndFragmentPairs,
              comparedFragmentPairs,
              areMutuallyExclusive,
              fragmentName1,
              fragmentName2
            );
          }
        }
        return conflicts;
      }
      function collectConflictsWithin(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
        for (const [responseName, fields] of Object.entries(fieldMap)) {
          if (fields.length > 1) {
            for (let i = 0; i < fields.length; i++) {
              for (let j = i + 1; j < fields.length; j++) {
                const conflict = findConflict(
                  context2,
                  cachedFieldsAndFragmentNames,
                  comparedFieldsAndFragmentPairs,
                  comparedFragmentPairs,
                  false,
                  // within one collection is never mutually exclusive
                  responseName,
                  fields[i],
                  fields[j]
                );
                if (conflict) {
                  conflicts.push(conflict);
                }
              }
            }
          }
        }
      }
      function collectConflictsBetween(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
        for (const [responseName, fields1] of Object.entries(fieldMap1)) {
          const fields2 = fieldMap2[responseName];
          if (fields2) {
            for (const field1 of fields1) {
              for (const field2 of fields2) {
                const conflict = findConflict(
                  context2,
                  cachedFieldsAndFragmentNames,
                  comparedFieldsAndFragmentPairs,
                  comparedFragmentPairs,
                  parentFieldsAreMutuallyExclusive,
                  responseName,
                  field1,
                  field2
                );
                if (conflict) {
                  conflicts.push(conflict);
                }
              }
            }
          }
        }
      }
      function findConflict(context2, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
        const [parentType1, node1, def1] = field1;
        const [parentType2, node2, def2] = field2;
        const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
        if (!areMutuallyExclusive) {
          const name1 = node1.name.value;
          const name2 = node2.name.value;
          if (name1 !== name2) {
            return [
              [responseName, `"${name1}" and "${name2}" are different fields`],
              [node1],
              [node2]
            ];
          }
          if (!sameArguments(node1, node2)) {
            return [
              [responseName, "they have differing arguments"],
              [node1],
              [node2]
            ];
          }
        }
        const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
        const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
        if (type1 && type2 && doTypesConflict(type1, type2)) {
          return [
            [
              responseName,
              `they return conflicting types "${(0, _inspect.inspect)(
                type1
              )}" and "${(0, _inspect.inspect)(type2)}"`
            ],
            [node1],
            [node2]
          ];
        }
        const selectionSet1 = node1.selectionSet;
        const selectionSet2 = node2.selectionSet;
        if (selectionSet1 && selectionSet2) {
          const conflicts = findConflictsBetweenSubSelectionSets(
            context2,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            areMutuallyExclusive,
            (0, _definition.getNamedType)(type1),
            selectionSet1,
            (0, _definition.getNamedType)(type2),
            selectionSet2
          );
          return subfieldConflicts(conflicts, responseName, node1, node2);
        }
      }
      function sameArguments(node1, node2) {
        const args1 = node1.arguments;
        const args2 = node2.arguments;
        if (args1 === void 0 || args1.length === 0) {
          return args2 === void 0 || args2.length === 0;
        }
        if (args2 === void 0 || args2.length === 0) {
          return false;
        }
        if (args1.length !== args2.length) {
          return false;
        }
        const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
        return args1.every((arg1) => {
          const value1 = arg1.value;
          const value2 = values2.get(arg1.name.value);
          if (value2 === void 0) {
            return false;
          }
          return stringifyValue(value1) === stringifyValue(value2);
        });
      }
      function stringifyValue(value) {
        return (0, _printer.print)((0, _sortValueNode.sortValueNode)(value));
      }
      function doTypesConflict(type1, type2) {
        if ((0, _definition.isListType)(type1)) {
          return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
        }
        if ((0, _definition.isListType)(type2)) {
          return true;
        }
        if ((0, _definition.isNonNullType)(type1)) {
          return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
        }
        if ((0, _definition.isNonNullType)(type2)) {
          return true;
        }
        if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
          return type1 !== type2;
        }
        return false;
      }
      function getFieldsAndFragmentNames(context2, cachedFieldsAndFragmentNames, parentType, selectionSet) {
        const cached = cachedFieldsAndFragmentNames.get(selectionSet);
        if (cached) {
          return cached;
        }
        const nodeAndDefs = /* @__PURE__ */ Object.create(null);
        const fragmentNames = /* @__PURE__ */ Object.create(null);
        _collectFieldsAndFragmentNames(
          context2,
          parentType,
          selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        const result = [nodeAndDefs, Object.keys(fragmentNames)];
        cachedFieldsAndFragmentNames.set(selectionSet, result);
        return result;
      }
      function getReferencedFieldsAndFragmentNames(context2, cachedFieldsAndFragmentNames, fragment) {
        const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
        if (cached) {
          return cached;
        }
        const fragmentType = (0, _typeFromAST.typeFromAST)(
          context2.getSchema(),
          fragment.typeCondition
        );
        return getFieldsAndFragmentNames(
          context2,
          cachedFieldsAndFragmentNames,
          fragmentType,
          fragment.selectionSet
        );
      }
      function _collectFieldsAndFragmentNames(context2, parentType, selectionSet, nodeAndDefs, fragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case _kinds.Kind.FIELD: {
              const fieldName = selection.name.value;
              let fieldDef;
              if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
                fieldDef = parentType.getFields()[fieldName];
              }
              const responseName = selection.alias ? selection.alias.value : fieldName;
              if (!nodeAndDefs[responseName]) {
                nodeAndDefs[responseName] = [];
              }
              nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
              break;
            }
            case _kinds.Kind.FRAGMENT_SPREAD:
              fragmentNames[selection.name.value] = true;
              break;
            case _kinds.Kind.INLINE_FRAGMENT: {
              const typeCondition = selection.typeCondition;
              const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context2.getSchema(), typeCondition) : parentType;
              _collectFieldsAndFragmentNames(
                context2,
                inlineFragmentType,
                selection.selectionSet,
                nodeAndDefs,
                fragmentNames
              );
              break;
            }
          }
        }
      }
      function subfieldConflicts(conflicts, responseName, node1, node2) {
        if (conflicts.length > 0) {
          return [
            [responseName, conflicts.map(([reason]) => reason)],
            [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
            [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
          ];
        }
      }
      var OrderedPairSet = class {
        constructor() {
          this._data = /* @__PURE__ */ new Map();
        }
        has(a, b, weaklyPresent) {
          var _this$_data$get;
          const result = (_this$_data$get = this._data.get(a)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b);
          if (result === void 0) {
            return false;
          }
          return weaklyPresent ? true : weaklyPresent === result;
        }
        add(a, b, weaklyPresent) {
          const map = this._data.get(a);
          if (map === void 0) {
            this._data.set(a, /* @__PURE__ */ new Map([[b, weaklyPresent]]));
          } else {
            map.set(b, weaklyPresent);
          }
        }
      };
      var PairSet = class {
        constructor() {
          this._orderedPairSet = new OrderedPairSet();
        }
        has(a, b, weaklyPresent) {
          return a < b ? this._orderedPairSet.has(a, b, weaklyPresent) : this._orderedPairSet.has(b, a, weaklyPresent);
        }
        add(a, b, weaklyPresent) {
          if (a < b) {
            this._orderedPairSet.add(a, b, weaklyPresent);
          } else {
            this._orderedPairSet.add(b, a, weaklyPresent);
          }
        }
      };
    }
  });

  // node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
  var require_PossibleFragmentSpreadsRule = __commonJS({
    "node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      var _typeComparators = require_typeComparators();
      var _typeFromAST = require_typeFromAST();
      function PossibleFragmentSpreadsRule(context2) {
        return {
          InlineFragment(node) {
            const fragType = context2.getType();
            const parentType = context2.getParentType();
            if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(
              context2.getSchema(),
              fragType,
              parentType
            )) {
              const parentTypeStr = (0, _inspect.inspect)(parentType);
              const fragTypeStr = (0, _inspect.inspect)(fragType);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          FragmentSpread(node) {
            const fragName = node.name.value;
            const fragType = getFragmentType(context2, fragName);
            const parentType = context2.getParentType();
            if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(
              context2.getSchema(),
              fragType,
              parentType
            )) {
              const parentTypeStr = (0, _inspect.inspect)(parentType);
              const fragTypeStr = (0, _inspect.inspect)(fragType);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
      function getFragmentType(context2, name) {
        const frag = context2.getFragment(name);
        if (frag) {
          const type = (0, _typeFromAST.typeFromAST)(
            context2.getSchema(),
            frag.typeCondition
          );
          if ((0, _definition.isCompositeType)(type)) {
            return type;
          }
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
  var require_PossibleTypeExtensionsRule = __commonJS({
    "node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _definition = require_definition();
      function PossibleTypeExtensionsRule(context2) {
        const schema = context2.getSchema();
        const definedTypes = /* @__PURE__ */ Object.create(null);
        for (const def of context2.getDocument().definitions) {
          if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = def;
          }
        }
        return {
          ScalarTypeExtension: checkExtension,
          ObjectTypeExtension: checkExtension,
          InterfaceTypeExtension: checkExtension,
          UnionTypeExtension: checkExtension,
          EnumTypeExtension: checkExtension,
          InputObjectTypeExtension: checkExtension
        };
        function checkExtension(node) {
          const typeName = node.name.value;
          const defNode = definedTypes[typeName];
          const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
          let expectedKind;
          if (defNode) {
            expectedKind = defKindToExtKind[defNode.kind];
          } else if (existingType) {
            expectedKind = typeToExtKind(existingType);
          }
          if (expectedKind) {
            if (expectedKind !== node.kind) {
              const kindStr = extensionKindToTypeName(node.kind);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Cannot extend non-${kindStr} type "${typeName}".`,
                  {
                    nodes: defNode ? [defNode, node] : node
                  }
                )
              );
            }
          } else {
            const allTypeNames = Object.keys({
              ...definedTypes,
              ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
            });
            const suggestedTypes = (0, _suggestionList.suggestionList)(
              typeName,
              allTypeNames
            );
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes),
                {
                  nodes: node.name
                }
              )
            );
          }
        }
      }
      var defKindToExtKind = {
        [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
        [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
        [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
        [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
        [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
        [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
      };
      function typeToExtKind(type) {
        if ((0, _definition.isScalarType)(type)) {
          return _kinds.Kind.SCALAR_TYPE_EXTENSION;
        }
        if ((0, _definition.isObjectType)(type)) {
          return _kinds.Kind.OBJECT_TYPE_EXTENSION;
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
        }
        if ((0, _definition.isUnionType)(type)) {
          return _kinds.Kind.UNION_TYPE_EXTENSION;
        }
        if ((0, _definition.isEnumType)(type)) {
          return _kinds.Kind.ENUM_TYPE_EXTENSION;
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
      function extensionKindToTypeName(kind) {
        switch (kind) {
          case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return "scalar";
          case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return "object";
          case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return "interface";
          case _kinds.Kind.UNION_TYPE_EXTENSION:
            return "union";
          case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return "enum";
          case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return "input object";
          // Not reachable. All possible types have been considered
          /* c8 ignore next */
          default:
            (0, _invariant.invariant)(
              false,
              "Unexpected kind: " + (0, _inspect.inspect)(kind)
            );
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
  var require_ProvidedRequiredArgumentsRule = __commonJS({
    "node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
      exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _directives = require_directives();
      function ProvidedRequiredArgumentsRule(context2) {
        return {
          // eslint-disable-next-line new-cap
          ...ProvidedRequiredArgumentsOnDirectivesRule(context2),
          Field: {
            // Validate on leave to allow for deeper errors to appear first.
            leave(fieldNode) {
              var _fieldNode$arguments;
              const fieldDef = context2.getFieldDef();
              if (!fieldDef) {
                return false;
              }
              const providedArgs = new Set(
                // FIXME: https://github.com/graphql/graphql-js/issues/2203
                /* c8 ignore next */
                (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
              );
              for (const argDef of fieldDef.args) {
                if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                  const argTypeStr = (0, _inspect.inspect)(argDef.type);
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                      {
                        nodes: fieldNode
                      }
                    )
                  );
                }
              }
            }
          }
        };
      }
      function ProvidedRequiredArgumentsOnDirectivesRule(context2) {
        var _schema$getDirectives;
        const requiredArgsMap = /* @__PURE__ */ Object.create(null);
        const schema = context2.getSchema();
        const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(
            directive.args.filter(_definition.isRequiredArgument),
            (arg) => arg.name
          );
        }
        const astDefinitions = context2.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(
              argNodes.filter(isRequiredArgumentNode),
              (arg) => arg.name.value
            );
          }
        }
        return {
          Directive: {
            // Validate on leave to allow for deeper errors to appear first.
            leave(directiveNode) {
              const directiveName = directiveNode.name.value;
              const requiredArgs = requiredArgsMap[directiveName];
              if (requiredArgs) {
                var _directiveNode$argume;
                const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
                const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
                for (const [argName, argDef] of Object.entries(requiredArgs)) {
                  if (!argNodeMap.has(argName)) {
                    const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                    context2.reportError(
                      new _GraphQLError.GraphQLError(
                        `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                        {
                          nodes: directiveNode
                        }
                      )
                    );
                  }
                }
              }
            }
          }
        };
      }
      function isRequiredArgumentNode(arg) {
        return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
      }
    }
  });

  // node_modules/graphql/validation/rules/ScalarLeafsRule.js
  var require_ScalarLeafsRule = __commonJS({
    "node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ScalarLeafsRule = ScalarLeafsRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function ScalarLeafsRule(context2) {
        return {
          Field(node) {
            const type = context2.getType();
            const selectionSet = node.selectionSet;
            if (type) {
              if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
                if (selectionSet) {
                  const fieldName = node.name.value;
                  const typeStr = (0, _inspect.inspect)(type);
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                      {
                        nodes: selectionSet
                      }
                    )
                  );
                }
              } else if (!selectionSet) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type);
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
                    {
                      nodes: node
                    }
                  )
                );
              } else if (selectionSet.selections.length === 0) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type);
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/jsutils/printPathArray.js
  var require_printPathArray = __commonJS({
    "node_modules/graphql/jsutils/printPathArray.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printPathArray = printPathArray;
      function printPathArray(path) {
        return path.map(
          (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
        ).join("");
      }
    }
  });

  // node_modules/graphql/jsutils/Path.js
  var require_Path = __commonJS({
    "node_modules/graphql/jsutils/Path.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.addPath = addPath;
      exports.pathToArray = pathToArray;
      function addPath(prev, key, typename) {
        return {
          prev,
          key,
          typename
        };
      }
      function pathToArray(path) {
        const flattened = [];
        let curr = path;
        while (curr) {
          flattened.push(curr.key);
          curr = curr.prev;
        }
        return flattened.reverse();
      }
    }
  });

  // node_modules/graphql/utilities/coerceInputValue.js
  var require_coerceInputValue = __commonJS({
    "node_modules/graphql/utilities/coerceInputValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.coerceInputValue = coerceInputValue;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _Path = require_Path();
      var _printPathArray = require_printPathArray();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function coerceInputValue(inputValue, type, onError = defaultOnError) {
        return coerceInputValueImpl(inputValue, type, onError, void 0);
      }
      function defaultOnError(path, invalidValue, error) {
        let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
        if (path.length > 0) {
          errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
        }
        error.message = errorPrefix + ": " + error.message;
        throw error;
      }
      function coerceInputValueImpl(inputValue, type, onError, path) {
        if ((0, _definition.isNonNullType)(type)) {
          if (inputValue != null) {
            return coerceInputValueImpl(inputValue, type.ofType, onError, path);
          }
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(
              `Expected non-nullable type "${(0, _inspect.inspect)(
                type
              )}" not to be null.`
            )
          );
          return;
        }
        if (inputValue == null) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, _isIterableObject.isIterableObject)(inputValue)) {
            return Array.from(inputValue, (itemValue, index) => {
              const itemPath = (0, _Path.addPath)(path, index, void 0);
              return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
            });
          }
          return [coerceInputValueImpl(inputValue, itemType, onError, path)];
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (!(0, _isObjectLike.isObjectLike)(inputValue)) {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Expected type "${type.name}" to be an object.`
              )
            );
            return;
          }
          const coercedValue = {};
          const fieldDefs = type.getFields();
          for (const field of Object.values(fieldDefs)) {
            const fieldValue = inputValue[field.name];
            if (fieldValue === void 0) {
              if (field.defaultValue !== void 0) {
                coercedValue[field.name] = field.defaultValue;
              } else if ((0, _definition.isNonNullType)(field.type)) {
                const typeStr = (0, _inspect.inspect)(field.type);
                onError(
                  (0, _Path.pathToArray)(path),
                  inputValue,
                  new _GraphQLError.GraphQLError(
                    `Field "${field.name}" of required type "${typeStr}" was not provided.`
                  )
                );
              }
              continue;
            }
            coercedValue[field.name] = coerceInputValueImpl(
              fieldValue,
              field.type,
              onError,
              (0, _Path.addPath)(path, field.name, type.name)
            );
          }
          for (const fieldName of Object.keys(inputValue)) {
            if (!fieldDefs[fieldName]) {
              const suggestions = (0, _suggestionList.suggestionList)(
                fieldName,
                Object.keys(type.getFields())
              );
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Field "${fieldName}" is not defined by type "${type.name}".` + (0, _didYouMean.didYouMean)(suggestions)
                )
              );
            }
          }
          if (type.isOneOf) {
            const keys = Object.keys(coercedValue);
            if (keys.length !== 1) {
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Exactly one key must be specified for OneOf type "${type.name}".`
                )
              );
            }
            const key = keys[0];
            const value = coercedValue[key];
            if (value === null) {
              onError(
                (0, _Path.pathToArray)(path).concat(key),
                value,
                new _GraphQLError.GraphQLError(`Field "${key}" must be non-null.`)
              );
            }
          }
          return coercedValue;
        }
        if ((0, _definition.isLeafType)(type)) {
          let parseResult;
          try {
            parseResult = type.parseValue(inputValue);
          } catch (error) {
            if (error instanceof _GraphQLError.GraphQLError) {
              onError((0, _Path.pathToArray)(path), inputValue, error);
            } else {
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Expected type "${type.name}". ` + error.message,
                  {
                    originalError: error
                  }
                )
              );
            }
            return;
          }
          if (parseResult === void 0) {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(`Expected type "${type.name}".`)
            );
          }
          return parseResult;
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected input type: " + (0, _inspect.inspect)(type)
        );
      }
    }
  });

  // node_modules/graphql/utilities/valueFromAST.js
  var require_valueFromAST = __commonJS({
    "node_modules/graphql/utilities/valueFromAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.valueFromAST = valueFromAST;
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _keyMap = require_keyMap();
      var _kinds = require_kinds();
      var _definition = require_definition();
      function valueFromAST(valueNode, type, variables) {
        if (!valueNode) {
          return;
        }
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variables == null || variables[variableName] === void 0) {
            return;
          }
          const variableValue = variables[variableName];
          if (variableValue === null && (0, _definition.isNonNullType)(type)) {
            return;
          }
          return variableValue;
        }
        if ((0, _definition.isNonNullType)(type)) {
          if (valueNode.kind === _kinds.Kind.NULL) {
            return;
          }
          return valueFromAST(valueNode, type.ofType, variables);
        }
        if (valueNode.kind === _kinds.Kind.NULL) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if (valueNode.kind === _kinds.Kind.LIST) {
            const coercedValues = [];
            for (const itemNode of valueNode.values) {
              if (isMissingVariable(itemNode, variables)) {
                if ((0, _definition.isNonNullType)(itemType)) {
                  return;
                }
                coercedValues.push(null);
              } else {
                const itemValue = valueFromAST(itemNode, itemType, variables);
                if (itemValue === void 0) {
                  return;
                }
                coercedValues.push(itemValue);
              }
            }
            return coercedValues;
          }
          const coercedValue = valueFromAST(valueNode, itemType, variables);
          if (coercedValue === void 0) {
            return;
          }
          return [coercedValue];
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (valueNode.kind !== _kinds.Kind.OBJECT) {
            return;
          }
          const coercedObj = /* @__PURE__ */ Object.create(null);
          const fieldNodes = (0, _keyMap.keyMap)(
            valueNode.fields,
            (field) => field.name.value
          );
          for (const field of Object.values(type.getFields())) {
            const fieldNode = fieldNodes[field.name];
            if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
              if (field.defaultValue !== void 0) {
                coercedObj[field.name] = field.defaultValue;
              } else if ((0, _definition.isNonNullType)(field.type)) {
                return;
              }
              continue;
            }
            const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
            if (fieldValue === void 0) {
              return;
            }
            coercedObj[field.name] = fieldValue;
          }
          if (type.isOneOf) {
            const keys = Object.keys(coercedObj);
            if (keys.length !== 1) {
              return;
            }
            if (coercedObj[keys[0]] === null) {
              return;
            }
          }
          return coercedObj;
        }
        if ((0, _definition.isLeafType)(type)) {
          let result;
          try {
            result = type.parseLiteral(valueNode, variables);
          } catch (_error) {
            return;
          }
          if (result === void 0) {
            return;
          }
          return result;
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected input type: " + (0, _inspect.inspect)(type)
        );
      }
      function isMissingVariable(valueNode, variables) {
        return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
      }
    }
  });

  // node_modules/graphql/execution/values.js
  var require_values = __commonJS({
    "node_modules/graphql/execution/values.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getArgumentValues = getArgumentValues;
      exports.getDirectiveValues = getDirectiveValues;
      exports.getVariableValues = getVariableValues;
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _printPathArray = require_printPathArray();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _coerceInputValue = require_coerceInputValue();
      var _typeFromAST = require_typeFromAST();
      var _valueFromAST = require_valueFromAST();
      function getVariableValues(schema, varDefNodes, inputs, options) {
        const errors = [];
        const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
        try {
          const coerced = coerceVariableValues(
            schema,
            varDefNodes,
            inputs,
            (error) => {
              if (maxErrors != null && errors.length >= maxErrors) {
                throw new _GraphQLError.GraphQLError(
                  "Too many errors processing variables, error limit reached. Execution aborted."
                );
              }
              errors.push(error);
            }
          );
          if (errors.length === 0) {
            return {
              coerced
            };
          }
        } catch (error) {
          errors.push(error);
        }
        return {
          errors
        };
      }
      function coerceVariableValues(schema, varDefNodes, inputs, onError) {
        const coercedValues = {};
        for (const varDefNode of varDefNodes) {
          const varName = varDefNode.variable.name.value;
          const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
          if (!(0, _definition.isInputType)(varType)) {
            const varTypeStr = (0, _printer.print)(varDefNode.type);
            onError(
              new _GraphQLError.GraphQLError(
                `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
                {
                  nodes: varDefNode.type
                }
              )
            );
            continue;
          }
          if (!hasOwnProperty(inputs, varName)) {
            if (varDefNode.defaultValue) {
              coercedValues[varName] = (0, _valueFromAST.valueFromAST)(
                varDefNode.defaultValue,
                varType
              );
            } else if ((0, _definition.isNonNullType)(varType)) {
              const varTypeStr = (0, _inspect.inspect)(varType);
              onError(
                new _GraphQLError.GraphQLError(
                  `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
                  {
                    nodes: varDefNode
                  }
                )
              );
            }
            continue;
          }
          const value = inputs[varName];
          if (value === null && (0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(
              new _GraphQLError.GraphQLError(
                `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
                {
                  nodes: varDefNode
                }
              )
            );
            continue;
          }
          coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(
            value,
            varType,
            (path, invalidValue, error) => {
              let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
              if (path.length > 0) {
                prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(
                  path
                )}"`;
              }
              onError(
                new _GraphQLError.GraphQLError(prefix + "; " + error.message, {
                  nodes: varDefNode,
                  originalError: error
                })
              );
            }
          );
        }
        return coercedValues;
      }
      function getArgumentValues(def, node, variableValues) {
        var _node$arguments;
        const coercedValues = {};
        const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
        const argNodeMap = (0, _keyMap.keyMap)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const argDef of def.args) {
          const name = argDef.name;
          const argType = argDef.type;
          const argumentNode = argNodeMap[name];
          if (!argumentNode) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError(
                `Argument "${name}" of required type "${(0, _inspect.inspect)(
                  argType
                )}" was not provided.`,
                {
                  nodes: node
                }
              );
            }
            continue;
          }
          const valueNode = argumentNode.value;
          let isNull = valueNode.kind === _kinds.Kind.NULL;
          if (valueNode.kind === _kinds.Kind.VARIABLE) {
            const variableName = valueNode.name.value;
            if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
              if (argDef.defaultValue !== void 0) {
                coercedValues[name] = argDef.defaultValue;
              } else if ((0, _definition.isNonNullType)(argType)) {
                throw new _GraphQLError.GraphQLError(
                  `Argument "${name}" of required type "${(0, _inspect.inspect)(
                    argType
                  )}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
                  {
                    nodes: valueNode
                  }
                );
              }
              continue;
            }
            isNull = variableValues[variableName] == null;
          }
          if (isNull && (0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(
              `Argument "${name}" of non-null type "${(0, _inspect.inspect)(
                argType
              )}" must not be null.`,
              {
                nodes: valueNode
              }
            );
          }
          const coercedValue = (0, _valueFromAST.valueFromAST)(
            valueNode,
            argType,
            variableValues
          );
          if (coercedValue === void 0) {
            throw new _GraphQLError.GraphQLError(
              `Argument "${name}" has invalid value ${(0, _printer.print)(
                valueNode
              )}.`,
              {
                nodes: valueNode
              }
            );
          }
          coercedValues[name] = coercedValue;
        }
        return coercedValues;
      }
      function getDirectiveValues(directiveDef, node, variableValues) {
        var _node$directives;
        const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
          (directive) => directive.name.value === directiveDef.name
        );
        if (directiveNode) {
          return getArgumentValues(directiveDef, directiveNode, variableValues);
        }
      }
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
    }
  });

  // node_modules/graphql/execution/collectFields.js
  var require_collectFields = __commonJS({
    "node_modules/graphql/execution/collectFields.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.collectFields = collectFields;
      exports.collectSubfields = collectSubfields;
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _directives = require_directives();
      var _typeFromAST = require_typeFromAST();
      var _values = require_values();
      function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
        const fields = /* @__PURE__ */ new Map();
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selectionSet,
          fields,
          /* @__PURE__ */ new Set()
        );
        return fields;
      }
      function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
        const subFieldNodes = /* @__PURE__ */ new Map();
        const visitedFragmentNames = /* @__PURE__ */ new Set();
        for (const node of fieldNodes) {
          if (node.selectionSet) {
            collectFieldsImpl(
              schema,
              fragments,
              variableValues,
              returnType,
              node.selectionSet,
              subFieldNodes,
              visitedFragmentNames
            );
          }
        }
        return subFieldNodes;
      }
      function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case _kinds.Kind.FIELD: {
              if (!shouldIncludeNode(variableValues, selection)) {
                continue;
              }
              const name = getFieldEntryKey(selection);
              const fieldList = fields.get(name);
              if (fieldList !== void 0) {
                fieldList.push(selection);
              } else {
                fields.set(name, [selection]);
              }
              break;
            }
            case _kinds.Kind.INLINE_FRAGMENT: {
              if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
                continue;
              }
              collectFieldsImpl(
                schema,
                fragments,
                variableValues,
                runtimeType,
                selection.selectionSet,
                fields,
                visitedFragmentNames
              );
              break;
            }
            case _kinds.Kind.FRAGMENT_SPREAD: {
              const fragName = selection.name.value;
              if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
                continue;
              }
              visitedFragmentNames.add(fragName);
              const fragment = fragments[fragName];
              if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
                continue;
              }
              collectFieldsImpl(
                schema,
                fragments,
                variableValues,
                runtimeType,
                fragment.selectionSet,
                fields,
                visitedFragmentNames
              );
              break;
            }
          }
        }
      }
      function shouldIncludeNode(variableValues, node) {
        const skip = (0, _values.getDirectiveValues)(
          _directives.GraphQLSkipDirective,
          node,
          variableValues
        );
        if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
          return false;
        }
        const include = (0, _values.getDirectiveValues)(
          _directives.GraphQLIncludeDirective,
          node,
          variableValues
        );
        if ((include === null || include === void 0 ? void 0 : include.if) === false) {
          return false;
        }
        return true;
      }
      function doesFragmentConditionMatch(schema, fragment, type) {
        const typeConditionNode = fragment.typeCondition;
        if (!typeConditionNode) {
          return true;
        }
        const conditionalType = (0, _typeFromAST.typeFromAST)(
          schema,
          typeConditionNode
        );
        if (conditionalType === type) {
          return true;
        }
        if ((0, _definition.isAbstractType)(conditionalType)) {
          return schema.isSubType(conditionalType, type);
        }
        return false;
      }
      function getFieldEntryKey(node) {
        return node.alias ? node.alias.value : node.name.value;
      }
    }
  });

  // node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
  var require_SingleFieldSubscriptionsRule = __commonJS({
    "node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _collectFields = require_collectFields();
      function SingleFieldSubscriptionsRule(context2) {
        return {
          OperationDefinition(node) {
            if (node.operation === "subscription") {
              const schema = context2.getSchema();
              const subscriptionType = schema.getSubscriptionType();
              if (subscriptionType) {
                const operationName = node.name ? node.name.value : null;
                const variableValues = /* @__PURE__ */ Object.create(null);
                const document = context2.getDocument();
                const fragments = /* @__PURE__ */ Object.create(null);
                for (const definition of document.definitions) {
                  if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                    fragments[definition.name.value] = definition;
                  }
                }
                const fields = (0, _collectFields.collectFields)(
                  schema,
                  fragments,
                  variableValues,
                  subscriptionType,
                  node.selectionSet
                );
                if (fields.size > 1) {
                  const fieldSelectionLists = [...fields.values()];
                  const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                  const extraFieldSelections = extraFieldSelectionLists.flat();
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                      {
                        nodes: extraFieldSelections
                      }
                    )
                  );
                }
                for (const fieldNodes of fields.values()) {
                  const field = fieldNodes[0];
                  const fieldName = field.name.value;
                  if (fieldName.startsWith("__")) {
                    context2.reportError(
                      new _GraphQLError.GraphQLError(
                        operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                        {
                          nodes: fieldNodes
                        }
                      )
                    );
                  }
                }
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/jsutils/groupBy.js
  var require_groupBy = __commonJS({
    "node_modules/graphql/jsutils/groupBy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.groupBy = groupBy;
      function groupBy(list, keyFn) {
        const result = /* @__PURE__ */ new Map();
        for (const item of list) {
          const key = keyFn(item);
          const group = result.get(key);
          if (group === void 0) {
            result.set(key, [item]);
          } else {
            group.push(item);
          }
        }
        return result;
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
  var require_UniqueArgumentDefinitionNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueArgumentDefinitionNamesRule(context2) {
        return {
          DirectiveDefinition(directiveNode) {
            var _directiveNode$argume;
            const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
            return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
          },
          InterfaceTypeDefinition: checkArgUniquenessPerField,
          InterfaceTypeExtension: checkArgUniquenessPerField,
          ObjectTypeDefinition: checkArgUniquenessPerField,
          ObjectTypeExtension: checkArgUniquenessPerField
        };
        function checkArgUniquenessPerField(typeNode) {
          var _typeNode$fields;
          const typeName = typeNode.name.value;
          const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
          for (const fieldDef of fieldNodes) {
            var _fieldDef$arguments;
            const fieldName = fieldDef.name.value;
            const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
            checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
          }
          return false;
        }
        function checkArgUniqueness(parentName, argumentNodes) {
          const seenArgs = (0, _groupBy.groupBy)(
            argumentNodes,
            (arg) => arg.name.value
          );
          for (const [argName, argNodes] of seenArgs) {
            if (argNodes.length > 1) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Argument "${parentName}(${argName}:)" can only be defined once.`,
                  {
                    nodes: argNodes.map((node) => node.name)
                  }
                )
              );
            }
          }
          return false;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
  var require_UniqueArgumentNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueArgumentNamesRule(context2) {
        return {
          Field: checkArgUniqueness,
          Directive: checkArgUniqueness
        };
        function checkArgUniqueness(parentNode) {
          var _parentNode$arguments;
          const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
          const seenArgs = (0, _groupBy.groupBy)(
            argumentNodes,
            (arg) => arg.name.value
          );
          for (const [argName, argNodes] of seenArgs) {
            if (argNodes.length > 1) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one argument named "${argName}".`,
                  {
                    nodes: argNodes.map((node) => node.name)
                  }
                )
              );
            }
          }
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
  var require_UniqueDirectiveNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueDirectiveNamesRule(context2) {
        const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
        const schema = context2.getSchema();
        return {
          DirectiveDefinition(node) {
            const directiveName = node.name.value;
            if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
                  {
                    nodes: node.name
                  }
                )
              );
              return;
            }
            if (knownDirectiveNames[directiveName]) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one directive named "@${directiveName}".`,
                  {
                    nodes: [knownDirectiveNames[directiveName], node.name]
                  }
                )
              );
            } else {
              knownDirectiveNames[directiveName] = node.name;
            }
            return false;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
  var require_UniqueDirectivesPerLocationRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _directives = require_directives();
      function UniqueDirectivesPerLocationRule(context2) {
        const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
        const schema = context2.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
        }
        const astDefinitions = context2.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            uniqueDirectiveMap[def.name.value] = !def.repeatable;
          }
        }
        const schemaDirectives = /* @__PURE__ */ Object.create(null);
        const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
        return {
          // Many different AST nodes may contain directives. Rather than listing
          // them all, just listen for entering any node, and check to see if it
          // defines any directives.
          enter(node) {
            if (!("directives" in node) || !node.directives) {
              return;
            }
            let seenDirectives;
            if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
              seenDirectives = schemaDirectives;
            } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
              const typeName = node.name.value;
              seenDirectives = typeDirectivesMap[typeName];
              if (seenDirectives === void 0) {
                typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
              }
            } else {
              seenDirectives = /* @__PURE__ */ Object.create(null);
            }
            for (const directive of node.directives) {
              const directiveName = directive.name.value;
              if (uniqueDirectiveMap[directiveName]) {
                if (seenDirectives[directiveName]) {
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `The directive "@${directiveName}" can only be used once at this location.`,
                      {
                        nodes: [seenDirectives[directiveName], directive]
                      }
                    )
                  );
                } else {
                  seenDirectives[directiveName] = directive;
                }
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
  var require_UniqueEnumValueNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function UniqueEnumValueNamesRule(context2) {
        const schema = context2.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const knownValueNames = /* @__PURE__ */ Object.create(null);
        return {
          EnumTypeDefinition: checkValueUniqueness,
          EnumTypeExtension: checkValueUniqueness
        };
        function checkValueUniqueness(node) {
          var _node$values;
          const typeName = node.name.value;
          if (!knownValueNames[typeName]) {
            knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
          }
          const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
          const valueNames = knownValueNames[typeName];
          for (const valueDef of valueNodes) {
            const valueName = valueDef.name.value;
            const existingType = existingTypeMap[typeName];
            if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
                  {
                    nodes: valueDef.name
                  }
                )
              );
            } else if (valueNames[valueName]) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Enum value "${typeName}.${valueName}" can only be defined once.`,
                  {
                    nodes: [valueNames[valueName], valueDef.name]
                  }
                )
              );
            } else {
              valueNames[valueName] = valueDef.name;
            }
          }
          return false;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
  var require_UniqueFieldDefinitionNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function UniqueFieldDefinitionNamesRule(context2) {
        const schema = context2.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const knownFieldNames = /* @__PURE__ */ Object.create(null);
        return {
          InputObjectTypeDefinition: checkFieldUniqueness,
          InputObjectTypeExtension: checkFieldUniqueness,
          InterfaceTypeDefinition: checkFieldUniqueness,
          InterfaceTypeExtension: checkFieldUniqueness,
          ObjectTypeDefinition: checkFieldUniqueness,
          ObjectTypeExtension: checkFieldUniqueness
        };
        function checkFieldUniqueness(node) {
          var _node$fields;
          const typeName = node.name.value;
          if (!knownFieldNames[typeName]) {
            knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
          }
          const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
          const fieldNames = knownFieldNames[typeName];
          for (const fieldDef of fieldNodes) {
            const fieldName = fieldDef.name.value;
            if (hasField(existingTypeMap[typeName], fieldName)) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
                  {
                    nodes: fieldDef.name
                  }
                )
              );
            } else if (fieldNames[fieldName]) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${typeName}.${fieldName}" can only be defined once.`,
                  {
                    nodes: [fieldNames[fieldName], fieldDef.name]
                  }
                )
              );
            } else {
              fieldNames[fieldName] = fieldDef.name;
            }
          }
          return false;
        }
      }
      function hasField(type, fieldName) {
        if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
          return type.getFields()[fieldName] != null;
        }
        return false;
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
  var require_UniqueFragmentNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueFragmentNamesRule(context2) {
        const knownFragmentNames = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: () => false,
          FragmentDefinition(node) {
            const fragmentName = node.name.value;
            if (knownFragmentNames[fragmentName]) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one fragment named "${fragmentName}".`,
                  {
                    nodes: [knownFragmentNames[fragmentName], node.name]
                  }
                )
              );
            } else {
              knownFragmentNames[fragmentName] = node.name;
            }
            return false;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
  var require_UniqueInputFieldNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
      var _invariant = require_invariant2();
      var _GraphQLError = require_GraphQLError();
      function UniqueInputFieldNamesRule(context2) {
        const knownNameStack = [];
        let knownNames = /* @__PURE__ */ Object.create(null);
        return {
          ObjectValue: {
            enter() {
              knownNameStack.push(knownNames);
              knownNames = /* @__PURE__ */ Object.create(null);
            },
            leave() {
              const prevKnownNames = knownNameStack.pop();
              prevKnownNames || (0, _invariant.invariant)(false);
              knownNames = prevKnownNames;
            }
          },
          ObjectField(node) {
            const fieldName = node.name.value;
            if (knownNames[fieldName]) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one input field named "${fieldName}".`,
                  {
                    nodes: [knownNames[fieldName], node.name]
                  }
                )
              );
            } else {
              knownNames[fieldName] = node.name;
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
  var require_UniqueOperationNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueOperationNamesRule(context2) {
        const knownOperationNames = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition(node) {
            const operationName = node.name;
            if (operationName) {
              if (knownOperationNames[operationName.value]) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `There can be only one operation named "${operationName.value}".`,
                    {
                      nodes: [
                        knownOperationNames[operationName.value],
                        operationName
                      ]
                    }
                  )
                );
              } else {
                knownOperationNames[operationName.value] = operationName;
              }
            }
            return false;
          },
          FragmentDefinition: () => false
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
  var require_UniqueOperationTypesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueOperationTypesRule(context2) {
        const schema = context2.getSchema();
        const definedOperationTypes = /* @__PURE__ */ Object.create(null);
        const existingOperationTypes = schema ? {
          query: schema.getQueryType(),
          mutation: schema.getMutationType(),
          subscription: schema.getSubscriptionType()
        } : {};
        return {
          SchemaDefinition: checkOperationTypes,
          SchemaExtension: checkOperationTypes
        };
        function checkOperationTypes(node) {
          var _node$operationTypes;
          const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
          for (const operationType of operationTypesNodes) {
            const operation = operationType.operation;
            const alreadyDefinedOperationType = definedOperationTypes[operation];
            if (existingOperationTypes[operation]) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Type for ${operation} already defined in the schema. It cannot be redefined.`,
                  {
                    nodes: operationType
                  }
                )
              );
            } else if (alreadyDefinedOperationType) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one ${operation} type in schema.`,
                  {
                    nodes: [alreadyDefinedOperationType, operationType]
                  }
                )
              );
            } else {
              definedOperationTypes[operation] = operationType;
            }
          }
          return false;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
  var require_UniqueTypeNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueTypeNamesRule(context2) {
        const knownTypeNames = /* @__PURE__ */ Object.create(null);
        const schema = context2.getSchema();
        return {
          ScalarTypeDefinition: checkTypeName,
          ObjectTypeDefinition: checkTypeName,
          InterfaceTypeDefinition: checkTypeName,
          UnionTypeDefinition: checkTypeName,
          EnumTypeDefinition: checkTypeName,
          InputObjectTypeDefinition: checkTypeName
        };
        function checkTypeName(node) {
          const typeName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
                {
                  nodes: node.name
                }
              )
            );
            return;
          }
          if (knownTypeNames[typeName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one type named "${typeName}".`,
                {
                  nodes: [knownTypeNames[typeName], node.name]
                }
              )
            );
          } else {
            knownTypeNames[typeName] = node.name;
          }
          return false;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
  var require_UniqueVariableNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueVariableNamesRule(context2) {
        return {
          OperationDefinition(operationNode) {
            var _operationNode$variab;
            const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
            const seenVariableDefinitions = (0, _groupBy.groupBy)(
              variableDefinitions,
              (node) => node.variable.name.value
            );
            for (const [variableName, variableNodes] of seenVariableDefinitions) {
              if (variableNodes.length > 1) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `There can be only one variable named "$${variableName}".`,
                    {
                      nodes: variableNodes.map((node) => node.variable.name)
                    }
                  )
                );
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
  var require_ValuesOfCorrectTypeRule = __commonJS({
    "node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      function ValuesOfCorrectTypeRule(context2) {
        let variableDefinitions = {};
        return {
          OperationDefinition: {
            enter() {
              variableDefinitions = {};
            }
          },
          VariableDefinition(definition) {
            variableDefinitions[definition.variable.name.value] = definition;
          },
          ListValue(node) {
            const type = (0, _definition.getNullableType)(
              context2.getParentInputType()
            );
            if (!(0, _definition.isListType)(type)) {
              isValidValueNode(context2, node);
              return false;
            }
          },
          ObjectValue(node) {
            const type = (0, _definition.getNamedType)(context2.getInputType());
            if (!(0, _definition.isInputObjectType)(type)) {
              isValidValueNode(context2, node);
              return false;
            }
            const fieldNodeMap = (0, _keyMap.keyMap)(
              node.fields,
              (field) => field.name.value
            );
            for (const fieldDef of Object.values(type.getFields())) {
              const fieldNode = fieldNodeMap[fieldDef.name];
              if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
                const typeStr = (0, _inspect.inspect)(fieldDef.type);
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
            if (type.isOneOf) {
              validateOneOfInputObject(
                context2,
                node,
                type,
                fieldNodeMap,
                variableDefinitions
              );
            }
          },
          ObjectField(node) {
            const parentType = (0, _definition.getNamedType)(
              context2.getParentInputType()
            );
            const fieldType = context2.getInputType();
            if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
              const suggestions = (0, _suggestionList.suggestionList)(
                node.name.value,
                Object.keys(parentType.getFields())
              );
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          NullValue(node) {
            const type = context2.getInputType();
            if ((0, _definition.isNonNullType)(type)) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Expected value of type "${(0, _inspect.inspect)(
                    type
                  )}", found ${(0, _printer.print)(node)}.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          EnumValue: (node) => isValidValueNode(context2, node),
          IntValue: (node) => isValidValueNode(context2, node),
          FloatValue: (node) => isValidValueNode(context2, node),
          StringValue: (node) => isValidValueNode(context2, node),
          BooleanValue: (node) => isValidValueNode(context2, node)
        };
      }
      function isValidValueNode(context2, node) {
        const locationType = context2.getInputType();
        if (!locationType) {
          return;
        }
        const type = (0, _definition.getNamedType)(locationType);
        if (!(0, _definition.isLeafType)(type)) {
          const typeStr = (0, _inspect.inspect)(locationType);
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}.`,
              {
                nodes: node
              }
            )
          );
          return;
        }
        try {
          const parseResult = type.parseLiteral(
            node,
            void 0
            /* variables */
          );
          if (parseResult === void 0) {
            const typeStr = (0, _inspect.inspect)(locationType);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                  node
                )}.`,
                {
                  nodes: node
                }
              )
            );
          }
        } catch (error) {
          const typeStr = (0, _inspect.inspect)(locationType);
          if (error instanceof _GraphQLError.GraphQLError) {
            context2.reportError(error);
          } else {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                  node
                )}; ` + error.message,
                {
                  nodes: node,
                  originalError: error
                }
              )
            );
          }
        }
      }
      function validateOneOfInputObject(context2, node, type, fieldNodeMap, variableDefinitions) {
        var _fieldNodeMap$keys$;
        const keys = Object.keys(fieldNodeMap);
        const isNotExactlyOneField = keys.length !== 1;
        if (isNotExactlyOneField) {
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `OneOf Input Object "${type.name}" must specify exactly one key.`,
              {
                nodes: [node]
              }
            )
          );
          return;
        }
        const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
        const isNullLiteral = !value || value.kind === _kinds.Kind.NULL;
        const isVariable = (value === null || value === void 0 ? void 0 : value.kind) === _kinds.Kind.VARIABLE;
        if (isNullLiteral) {
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Field "${type.name}.${keys[0]}" must be non-null.`,
              {
                nodes: [node]
              }
            )
          );
          return;
        }
        if (isVariable) {
          const variableName = value.name.value;
          const definition = variableDefinitions[variableName];
          const isNullableVariable = definition.type.kind !== _kinds.Kind.NON_NULL_TYPE;
          if (isNullableVariable) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type.name}".`,
                {
                  nodes: [node]
                }
              )
            );
          }
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
  var require_VariablesAreInputTypesRule = __commonJS({
    "node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      var _typeFromAST = require_typeFromAST();
      function VariablesAreInputTypesRule(context2) {
        return {
          VariableDefinition(node) {
            const type = (0, _typeFromAST.typeFromAST)(
              context2.getSchema(),
              node.type
            );
            if (type !== void 0 && !(0, _definition.isInputType)(type)) {
              const variableName = node.variable.name.value;
              const typeName = (0, _printer.print)(node.type);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
                  {
                    nodes: node.type
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
  var require_VariablesInAllowedPositionRule = __commonJS({
    "node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _typeComparators = require_typeComparators();
      var _typeFromAST = require_typeFromAST();
      function VariablesInAllowedPositionRule(context2) {
        let varDefMap = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: {
            enter() {
              varDefMap = /* @__PURE__ */ Object.create(null);
            },
            leave(operation) {
              const usages = context2.getRecursiveVariableUsages(operation);
              for (const { node, type, defaultValue } of usages) {
                const varName = node.name.value;
                const varDef = varDefMap[varName];
                if (varDef && type) {
                  const schema = context2.getSchema();
                  const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                  if (varType && !allowedVariableUsage(
                    schema,
                    varType,
                    varDef.defaultValue,
                    type,
                    defaultValue
                  )) {
                    const varTypeStr = (0, _inspect.inspect)(varType);
                    const typeStr = (0, _inspect.inspect)(type);
                    context2.reportError(
                      new _GraphQLError.GraphQLError(
                        `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                        {
                          nodes: [varDef, node]
                        }
                      )
                    );
                  }
                }
              }
            }
          },
          VariableDefinition(node) {
            varDefMap[node.variable.name.value] = node;
          }
        };
      }
      function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
        if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
          const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
          const hasLocationDefaultValue = locationDefaultValue !== void 0;
          if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
            return false;
          }
          const nullableLocationType = locationType.ofType;
          return (0, _typeComparators.isTypeSubTypeOf)(
            schema,
            varType,
            nullableLocationType
          );
        }
        return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
      }
    }
  });

  // node_modules/graphql/validation/specifiedRules.js
  var require_specifiedRules = __commonJS({
    "node_modules/graphql/validation/specifiedRules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.specifiedSDLRules = exports.specifiedRules = exports.recommendedRules = void 0;
      var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
      var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
      var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
      var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
      var _KnownDirectivesRule = require_KnownDirectivesRule();
      var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
      var _KnownTypeNamesRule = require_KnownTypeNamesRule();
      var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
      var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
      var _MaxIntrospectionDepthRule = require_MaxIntrospectionDepthRule();
      var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
      var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
      var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
      var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
      var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
      var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
      var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
      var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
      var _ScalarLeafsRule = require_ScalarLeafsRule();
      var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
      var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
      var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
      var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
      var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
      var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
      var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
      var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
      var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
      var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
      var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
      var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
      var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
      var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
      var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
      var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
      var recommendedRules = Object.freeze([
        _MaxIntrospectionDepthRule.MaxIntrospectionDepthRule
      ]);
      exports.recommendedRules = recommendedRules;
      var specifiedRules = Object.freeze([
        _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
        _UniqueOperationNamesRule.UniqueOperationNamesRule,
        _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
        _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
        _KnownTypeNamesRule.KnownTypeNamesRule,
        _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
        _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
        _ScalarLeafsRule.ScalarLeafsRule,
        _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
        _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
        _KnownFragmentNamesRule.KnownFragmentNamesRule,
        _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
        _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
        _NoFragmentCyclesRule.NoFragmentCyclesRule,
        _UniqueVariableNamesRule.UniqueVariableNamesRule,
        _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
        _NoUnusedVariablesRule.NoUnusedVariablesRule,
        _KnownDirectivesRule.KnownDirectivesRule,
        _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
        _KnownArgumentNamesRule.KnownArgumentNamesRule,
        _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
        _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
        _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
        _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
        _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
        _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
        ...recommendedRules
      ]);
      exports.specifiedRules = specifiedRules;
      var specifiedSDLRules = Object.freeze([
        _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
        _UniqueOperationTypesRule.UniqueOperationTypesRule,
        _UniqueTypeNamesRule.UniqueTypeNamesRule,
        _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
        _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
        _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
        _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
        _KnownTypeNamesRule.KnownTypeNamesRule,
        _KnownDirectivesRule.KnownDirectivesRule,
        _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
        _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
        _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
        _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
        _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
        _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
      ]);
      exports.specifiedSDLRules = specifiedSDLRules;
    }
  });

  // node_modules/graphql/validation/ValidationContext.js
  var require_ValidationContext = __commonJS({
    "node_modules/graphql/validation/ValidationContext.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      var _TypeInfo = require_TypeInfo();
      var ASTValidationContext = class {
        constructor(ast, onError) {
          this._ast = ast;
          this._fragments = void 0;
          this._fragmentSpreads = /* @__PURE__ */ new Map();
          this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
          this._onError = onError;
        }
        get [Symbol.toStringTag]() {
          return "ASTValidationContext";
        }
        reportError(error) {
          this._onError(error);
        }
        getDocument() {
          return this._ast;
        }
        getFragment(name) {
          let fragments;
          if (this._fragments) {
            fragments = this._fragments;
          } else {
            fragments = /* @__PURE__ */ Object.create(null);
            for (const defNode of this.getDocument().definitions) {
              if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                fragments[defNode.name.value] = defNode;
              }
            }
            this._fragments = fragments;
          }
          return fragments[name];
        }
        getFragmentSpreads(node) {
          let spreads = this._fragmentSpreads.get(node);
          if (!spreads) {
            spreads = [];
            const setsToVisit = [node];
            let set;
            while (set = setsToVisit.pop()) {
              for (const selection of set.selections) {
                if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                  spreads.push(selection);
                } else if (selection.selectionSet) {
                  setsToVisit.push(selection.selectionSet);
                }
              }
            }
            this._fragmentSpreads.set(node, spreads);
          }
          return spreads;
        }
        getRecursivelyReferencedFragments(operation) {
          let fragments = this._recursivelyReferencedFragments.get(operation);
          if (!fragments) {
            fragments = [];
            const collectedNames = /* @__PURE__ */ Object.create(null);
            const nodesToVisit = [operation.selectionSet];
            let node;
            while (node = nodesToVisit.pop()) {
              for (const spread of this.getFragmentSpreads(node)) {
                const fragName = spread.name.value;
                if (collectedNames[fragName] !== true) {
                  collectedNames[fragName] = true;
                  const fragment = this.getFragment(fragName);
                  if (fragment) {
                    fragments.push(fragment);
                    nodesToVisit.push(fragment.selectionSet);
                  }
                }
              }
            }
            this._recursivelyReferencedFragments.set(operation, fragments);
          }
          return fragments;
        }
      };
      exports.ASTValidationContext = ASTValidationContext;
      var SDLValidationContext = class extends ASTValidationContext {
        constructor(ast, schema, onError) {
          super(ast, onError);
          this._schema = schema;
        }
        get [Symbol.toStringTag]() {
          return "SDLValidationContext";
        }
        getSchema() {
          return this._schema;
        }
      };
      exports.SDLValidationContext = SDLValidationContext;
      var ValidationContext = class extends ASTValidationContext {
        constructor(schema, ast, typeInfo, onError) {
          super(ast, onError);
          this._schema = schema;
          this._typeInfo = typeInfo;
          this._variableUsages = /* @__PURE__ */ new Map();
          this._recursiveVariableUsages = /* @__PURE__ */ new Map();
        }
        get [Symbol.toStringTag]() {
          return "ValidationContext";
        }
        getSchema() {
          return this._schema;
        }
        getVariableUsages(node) {
          let usages = this._variableUsages.get(node);
          if (!usages) {
            const newUsages = [];
            const typeInfo = new _TypeInfo.TypeInfo(this._schema);
            (0, _visitor.visit)(
              node,
              (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
                VariableDefinition: () => false,
                Variable(variable) {
                  newUsages.push({
                    node: variable,
                    type: typeInfo.getInputType(),
                    defaultValue: typeInfo.getDefaultValue()
                  });
                }
              })
            );
            usages = newUsages;
            this._variableUsages.set(node, usages);
          }
          return usages;
        }
        getRecursiveVariableUsages(operation) {
          let usages = this._recursiveVariableUsages.get(operation);
          if (!usages) {
            usages = this.getVariableUsages(operation);
            for (const frag of this.getRecursivelyReferencedFragments(operation)) {
              usages = usages.concat(this.getVariableUsages(frag));
            }
            this._recursiveVariableUsages.set(operation, usages);
          }
          return usages;
        }
        getType() {
          return this._typeInfo.getType();
        }
        getParentType() {
          return this._typeInfo.getParentType();
        }
        getInputType() {
          return this._typeInfo.getInputType();
        }
        getParentInputType() {
          return this._typeInfo.getParentInputType();
        }
        getFieldDef() {
          return this._typeInfo.getFieldDef();
        }
        getDirective() {
          return this._typeInfo.getDirective();
        }
        getArgument() {
          return this._typeInfo.getArgument();
        }
        getEnumValue() {
          return this._typeInfo.getEnumValue();
        }
      };
      exports.ValidationContext = ValidationContext;
    }
  });

  // node_modules/graphql/validation/validate.js
  var require_validate2 = __commonJS({
    "node_modules/graphql/validation/validate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidSDL = assertValidSDL;
      exports.assertValidSDLExtension = assertValidSDLExtension;
      exports.validate = validate;
      exports.validateSDL = validateSDL;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _visitor = require_visitor();
      var _validate = require_validate();
      var _TypeInfo = require_TypeInfo();
      var _specifiedRules = require_specifiedRules();
      var _ValidationContext = require_ValidationContext();
      function validate(schema, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema)) {
        var _options$maxErrors;
        const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
        documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
        (0, _validate.assertValidSchema)(schema);
        const abortObj = Object.freeze({});
        const errors = [];
        const context2 = new _ValidationContext.ValidationContext(
          schema,
          documentAST,
          typeInfo,
          (error) => {
            if (errors.length >= maxErrors) {
              errors.push(
                new _GraphQLError.GraphQLError(
                  "Too many validation errors, error limit reached. Validation aborted."
                )
              );
              throw abortObj;
            }
            errors.push(error);
          }
        );
        const visitor = (0, _visitor.visitInParallel)(
          rules.map((rule) => rule(context2))
        );
        try {
          (0, _visitor.visit)(
            documentAST,
            (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor)
          );
        } catch (e) {
          if (e !== abortObj) {
            throw e;
          }
        }
        return errors;
      }
      function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
        const errors = [];
        const context2 = new _ValidationContext.SDLValidationContext(
          documentAST,
          schemaToExtend,
          (error) => {
            errors.push(error);
          }
        );
        const visitors = rules.map((rule) => rule(context2));
        (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
        return errors;
      }
      function assertValidSDL(documentAST) {
        const errors = validateSDL(documentAST);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
      function assertValidSDLExtension(documentAST, schema) {
        const errors = validateSDL(documentAST, schema);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
    }
  });

  // node_modules/graphql/jsutils/memoize3.js
  var require_memoize3 = __commonJS({
    "node_modules/graphql/jsutils/memoize3.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.memoize3 = memoize3;
      function memoize3(fn) {
        let cache0;
        return function memoized(a1, a2, a3) {
          if (cache0 === void 0) {
            cache0 = /* @__PURE__ */ new WeakMap();
          }
          let cache1 = cache0.get(a1);
          if (cache1 === void 0) {
            cache1 = /* @__PURE__ */ new WeakMap();
            cache0.set(a1, cache1);
          }
          let cache2 = cache1.get(a2);
          if (cache2 === void 0) {
            cache2 = /* @__PURE__ */ new WeakMap();
            cache1.set(a2, cache2);
          }
          let fnResult = cache2.get(a3);
          if (fnResult === void 0) {
            fnResult = fn(a1, a2, a3);
            cache2.set(a3, fnResult);
          }
          return fnResult;
        };
      }
    }
  });

  // node_modules/graphql/jsutils/promiseForObject.js
  var require_promiseForObject = __commonJS({
    "node_modules/graphql/jsutils/promiseForObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.promiseForObject = promiseForObject;
      function promiseForObject(object) {
        return Promise.all(Object.values(object)).then((resolvedValues) => {
          const resolvedObject = /* @__PURE__ */ Object.create(null);
          for (const [i, key] of Object.keys(object).entries()) {
            resolvedObject[key] = resolvedValues[i];
          }
          return resolvedObject;
        });
      }
    }
  });

  // node_modules/graphql/jsutils/promiseReduce.js
  var require_promiseReduce = __commonJS({
    "node_modules/graphql/jsutils/promiseReduce.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.promiseReduce = promiseReduce;
      var _isPromise = require_isPromise();
      function promiseReduce(values, callbackFn, initialValue) {
        let accumulator = initialValue;
        for (const value of values) {
          accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
        }
        return accumulator;
      }
    }
  });

  // node_modules/graphql/jsutils/toError.js
  var require_toError = __commonJS({
    "node_modules/graphql/jsutils/toError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toError = toError;
      var _inspect = require_inspect();
      function toError(thrownValue) {
        return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
      }
      var NonErrorThrown = class extends Error {
        constructor(thrownValue) {
          super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
          this.name = "NonErrorThrown";
          this.thrownValue = thrownValue;
        }
      };
    }
  });

  // node_modules/graphql/error/locatedError.js
  var require_locatedError = __commonJS({
    "node_modules/graphql/error/locatedError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.locatedError = locatedError;
      var _toError = require_toError();
      var _GraphQLError = require_GraphQLError();
      function locatedError(rawOriginalError, nodes, path) {
        var _nodes;
        const originalError = (0, _toError.toError)(rawOriginalError);
        if (isLocatedGraphQLError(originalError)) {
          return originalError;
        }
        return new _GraphQLError.GraphQLError(originalError.message, {
          nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
          source: originalError.source,
          positions: originalError.positions,
          path,
          originalError
        });
      }
      function isLocatedGraphQLError(error) {
        return Array.isArray(error.path);
      }
    }
  });

  // node_modules/graphql/execution/execute.js
  var require_execute = __commonJS({
    "node_modules/graphql/execution/execute.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidExecutionArguments = assertValidExecutionArguments;
      exports.buildExecutionContext = buildExecutionContext;
      exports.buildResolveInfo = buildResolveInfo;
      exports.defaultTypeResolver = exports.defaultFieldResolver = void 0;
      exports.execute = execute;
      exports.executeSync = executeSync;
      exports.getFieldDef = getFieldDef;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _isPromise = require_isPromise();
      var _memoize = require_memoize3();
      var _Path = require_Path();
      var _promiseForObject = require_promiseForObject();
      var _promiseReduce = require_promiseReduce();
      var _GraphQLError = require_GraphQLError();
      var _locatedError = require_locatedError();
      var _ast = require_ast();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _introspection = require_introspection();
      var _validate = require_validate();
      var _collectFields = require_collectFields();
      var _values = require_values();
      var collectSubfields = (0, _memoize.memoize3)(
        (exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(
          exeContext.schema,
          exeContext.fragments,
          exeContext.variableValues,
          returnType,
          fieldNodes
        )
      );
      function execute(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(
          false,
          "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
        );
        const { schema, document, variableValues, rootValue } = args;
        assertValidExecutionArguments(schema, document, variableValues);
        const exeContext = buildExecutionContext(args);
        if (!("schema" in exeContext)) {
          return {
            errors: exeContext
          };
        }
        try {
          const { operation } = exeContext;
          const result = executeOperation(exeContext, operation, rootValue);
          if ((0, _isPromise.isPromise)(result)) {
            return result.then(
              (data) => buildResponse(data, exeContext.errors),
              (error) => {
                exeContext.errors.push(error);
                return buildResponse(null, exeContext.errors);
              }
            );
          }
          return buildResponse(result, exeContext.errors);
        } catch (error) {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        }
      }
      function executeSync(args) {
        const result = execute(args);
        if ((0, _isPromise.isPromise)(result)) {
          throw new Error("GraphQL execution failed to complete synchronously.");
        }
        return result;
      }
      function buildResponse(data, errors) {
        return errors.length === 0 ? {
          data
        } : {
          errors,
          data
        };
      }
      function assertValidExecutionArguments(schema, document, rawVariableValues) {
        document || (0, _devAssert.devAssert)(false, "Must provide document.");
        (0, _validate.assertValidSchema)(schema);
        rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(
          false,
          "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
        );
      }
      function buildExecutionContext(args) {
        var _definition$name, _operation$variableDe;
        const {
          schema,
          document,
          rootValue,
          contextValue,
          variableValues: rawVariableValues,
          operationName,
          fieldResolver,
          typeResolver,
          subscribeFieldResolver
        } = args;
        let operation;
        const fragments = /* @__PURE__ */ Object.create(null);
        for (const definition of document.definitions) {
          switch (definition.kind) {
            case _kinds.Kind.OPERATION_DEFINITION:
              if (operationName == null) {
                if (operation !== void 0) {
                  return [
                    new _GraphQLError.GraphQLError(
                      "Must provide operation name if query contains multiple operations."
                    )
                  ];
                }
                operation = definition;
              } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
                operation = definition;
              }
              break;
            case _kinds.Kind.FRAGMENT_DEFINITION:
              fragments[definition.name.value] = definition;
              break;
            default:
          }
        }
        if (!operation) {
          if (operationName != null) {
            return [
              new _GraphQLError.GraphQLError(
                `Unknown operation named "${operationName}".`
              )
            ];
          }
          return [new _GraphQLError.GraphQLError("Must provide an operation.")];
        }
        const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
        const coercedVariableValues = (0, _values.getVariableValues)(
          schema,
          variableDefinitions,
          rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
          {
            maxErrors: 50
          }
        );
        if (coercedVariableValues.errors) {
          return coercedVariableValues.errors;
        }
        return {
          schema,
          fragments,
          rootValue,
          contextValue,
          operation,
          variableValues: coercedVariableValues.coerced,
          fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
          typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
          subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
          errors: []
        };
      }
      function executeOperation(exeContext, operation, rootValue) {
        const rootType = exeContext.schema.getRootType(operation.operation);
        if (rootType == null) {
          throw new _GraphQLError.GraphQLError(
            `Schema is not configured to execute ${operation.operation} operation.`,
            {
              nodes: operation
            }
          );
        }
        const rootFields = (0, _collectFields.collectFields)(
          exeContext.schema,
          exeContext.fragments,
          exeContext.variableValues,
          rootType,
          operation.selectionSet
        );
        const path = void 0;
        switch (operation.operation) {
          case _ast.OperationTypeNode.QUERY:
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
          case _ast.OperationTypeNode.MUTATION:
            return executeFieldsSerially(
              exeContext,
              rootType,
              rootValue,
              path,
              rootFields
            );
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
        }
      }
      function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
        return (0, _promiseReduce.promiseReduce)(
          fields.entries(),
          (results, [responseName, fieldNodes]) => {
            const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
            const result = executeField(
              exeContext,
              parentType,
              sourceValue,
              fieldNodes,
              fieldPath
            );
            if (result === void 0) {
              return results;
            }
            if ((0, _isPromise.isPromise)(result)) {
              return result.then((resolvedResult) => {
                results[responseName] = resolvedResult;
                return results;
              });
            }
            results[responseName] = result;
            return results;
          },
          /* @__PURE__ */ Object.create(null)
        );
      }
      function executeFields(exeContext, parentType, sourceValue, path, fields) {
        const results = /* @__PURE__ */ Object.create(null);
        let containsPromise = false;
        try {
          for (const [responseName, fieldNodes] of fields.entries()) {
            const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
            const result = executeField(
              exeContext,
              parentType,
              sourceValue,
              fieldNodes,
              fieldPath
            );
            if (result !== void 0) {
              results[responseName] = result;
              if ((0, _isPromise.isPromise)(result)) {
                containsPromise = true;
              }
            }
          }
        } catch (error) {
          if (containsPromise) {
            return (0, _promiseForObject.promiseForObject)(results).finally(() => {
              throw error;
            });
          }
          throw error;
        }
        if (!containsPromise) {
          return results;
        }
        return (0, _promiseForObject.promiseForObject)(results);
      }
      function executeField(exeContext, parentType, source, fieldNodes, path) {
        var _fieldDef$resolve;
        const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
        if (!fieldDef) {
          return;
        }
        const returnType = fieldDef.type;
        const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
        const info = buildResolveInfo(
          exeContext,
          fieldDef,
          fieldNodes,
          parentType,
          path
        );
        try {
          const args = (0, _values.getArgumentValues)(
            fieldDef,
            fieldNodes[0],
            exeContext.variableValues
          );
          const contextValue = exeContext.contextValue;
          const result = resolveFn(source, args, contextValue, info);
          let completed;
          if ((0, _isPromise.isPromise)(result)) {
            completed = result.then(
              (resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved)
            );
          } else {
            completed = completeValue(
              exeContext,
              returnType,
              fieldNodes,
              info,
              path,
              result
            );
          }
          if ((0, _isPromise.isPromise)(completed)) {
            return completed.then(void 0, (rawError) => {
              const error = (0, _locatedError.locatedError)(
                rawError,
                fieldNodes,
                (0, _Path.pathToArray)(path)
              );
              return handleFieldError(error, returnType, exeContext);
            });
          }
          return completed;
        } catch (rawError) {
          const error = (0, _locatedError.locatedError)(
            rawError,
            fieldNodes,
            (0, _Path.pathToArray)(path)
          );
          return handleFieldError(error, returnType, exeContext);
        }
      }
      function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
        return {
          fieldName: fieldDef.name,
          fieldNodes,
          returnType: fieldDef.type,
          parentType,
          path,
          schema: exeContext.schema,
          fragments: exeContext.fragments,
          rootValue: exeContext.rootValue,
          operation: exeContext.operation,
          variableValues: exeContext.variableValues
        };
      }
      function handleFieldError(error, returnType, exeContext) {
        if ((0, _definition.isNonNullType)(returnType)) {
          throw error;
        }
        exeContext.errors.push(error);
        return null;
      }
      function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
        if (result instanceof Error) {
          throw result;
        }
        if ((0, _definition.isNonNullType)(returnType)) {
          const completed = completeValue(
            exeContext,
            returnType.ofType,
            fieldNodes,
            info,
            path,
            result
          );
          if (completed === null) {
            throw new Error(
              `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`
            );
          }
          return completed;
        }
        if (result == null) {
          return null;
        }
        if ((0, _definition.isListType)(returnType)) {
          return completeListValue(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          );
        }
        if ((0, _definition.isLeafType)(returnType)) {
          return completeLeafValue(returnType, result);
        }
        if ((0, _definition.isAbstractType)(returnType)) {
          return completeAbstractValue(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          );
        }
        if ((0, _definition.isObjectType)(returnType)) {
          return completeObjectValue(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          );
        }
        (0, _invariant.invariant)(
          false,
          "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType)
        );
      }
      function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
        if (!(0, _isIterableObject.isIterableObject)(result)) {
          throw new _GraphQLError.GraphQLError(
            `Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`
          );
        }
        const itemType = returnType.ofType;
        let containsPromise = false;
        const completedResults = Array.from(result, (item, index) => {
          const itemPath = (0, _Path.addPath)(path, index, void 0);
          try {
            let completedItem;
            if ((0, _isPromise.isPromise)(item)) {
              completedItem = item.then(
                (resolved) => completeValue(
                  exeContext,
                  itemType,
                  fieldNodes,
                  info,
                  itemPath,
                  resolved
                )
              );
            } else {
              completedItem = completeValue(
                exeContext,
                itemType,
                fieldNodes,
                info,
                itemPath,
                item
              );
            }
            if ((0, _isPromise.isPromise)(completedItem)) {
              containsPromise = true;
              return completedItem.then(void 0, (rawError) => {
                const error = (0, _locatedError.locatedError)(
                  rawError,
                  fieldNodes,
                  (0, _Path.pathToArray)(itemPath)
                );
                return handleFieldError(error, itemType, exeContext);
              });
            }
            return completedItem;
          } catch (rawError) {
            const error = (0, _locatedError.locatedError)(
              rawError,
              fieldNodes,
              (0, _Path.pathToArray)(itemPath)
            );
            return handleFieldError(error, itemType, exeContext);
          }
        });
        return containsPromise ? Promise.all(completedResults) : completedResults;
      }
      function completeLeafValue(returnType, result) {
        const serializedResult = returnType.serialize(result);
        if (serializedResult == null) {
          throw new Error(
            `Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to return non-nullable value, returned: ${(0, _inspect.inspect)(
              serializedResult
            )}`
          );
        }
        return serializedResult;
      }
      function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
        var _returnType$resolveTy;
        const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
        const contextValue = exeContext.contextValue;
        const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
        if ((0, _isPromise.isPromise)(runtimeType)) {
          return runtimeType.then(
            (resolvedRuntimeType) => completeObjectValue(
              exeContext,
              ensureValidRuntimeType(
                resolvedRuntimeType,
                exeContext,
                returnType,
                fieldNodes,
                info,
                result
              ),
              fieldNodes,
              info,
              path,
              result
            )
          );
        }
        return completeObjectValue(
          exeContext,
          ensureValidRuntimeType(
            runtimeType,
            exeContext,
            returnType,
            fieldNodes,
            info,
            result
          ),
          fieldNodes,
          info,
          path,
          result
        );
      }
      function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
        if (runtimeTypeName == null) {
          throw new _GraphQLError.GraphQLError(
            `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
            fieldNodes
          );
        }
        if ((0, _definition.isObjectType)(runtimeTypeName)) {
          throw new _GraphQLError.GraphQLError(
            "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
          );
        }
        if (typeof runtimeTypeName !== "string") {
          throw new _GraphQLError.GraphQLError(
            `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`
          );
        }
        const runtimeType = exeContext.schema.getType(runtimeTypeName);
        if (runtimeType == null) {
          throw new _GraphQLError.GraphQLError(
            `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
            {
              nodes: fieldNodes
            }
          );
        }
        if (!(0, _definition.isObjectType)(runtimeType)) {
          throw new _GraphQLError.GraphQLError(
            `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
            {
              nodes: fieldNodes
            }
          );
        }
        if (!exeContext.schema.isSubType(returnType, runtimeType)) {
          throw new _GraphQLError.GraphQLError(
            `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
            {
              nodes: fieldNodes
            }
          );
        }
        return runtimeType;
      }
      function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
        const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
        if (returnType.isTypeOf) {
          const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
          if ((0, _isPromise.isPromise)(isTypeOf)) {
            return isTypeOf.then((resolvedIsTypeOf) => {
              if (!resolvedIsTypeOf) {
                throw invalidReturnTypeError(returnType, result, fieldNodes);
              }
              return executeFields(
                exeContext,
                returnType,
                result,
                path,
                subFieldNodes
              );
            });
          }
          if (!isTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
          }
        }
        return executeFields(exeContext, returnType, result, path, subFieldNodes);
      }
      function invalidReturnTypeError(returnType, result, fieldNodes) {
        return new _GraphQLError.GraphQLError(
          `Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`,
          {
            nodes: fieldNodes
          }
        );
      }
      var defaultTypeResolver = function(value, contextValue, info, abstractType) {
        if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
          return value.__typename;
        }
        const possibleTypes = info.schema.getPossibleTypes(abstractType);
        const promisedIsTypeOfResults = [];
        for (let i = 0; i < possibleTypes.length; i++) {
          const type = possibleTypes[i];
          if (type.isTypeOf) {
            const isTypeOfResult = type.isTypeOf(value, contextValue, info);
            if ((0, _isPromise.isPromise)(isTypeOfResult)) {
              promisedIsTypeOfResults[i] = isTypeOfResult;
            } else if (isTypeOfResult) {
              return type.name;
            }
          }
        }
        if (promisedIsTypeOfResults.length) {
          return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
            for (let i = 0; i < isTypeOfResults.length; i++) {
              if (isTypeOfResults[i]) {
                return possibleTypes[i].name;
              }
            }
          });
        }
      };
      exports.defaultTypeResolver = defaultTypeResolver;
      var defaultFieldResolver = function(source, args, contextValue, info) {
        if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
          const property = source[info.fieldName];
          if (typeof property === "function") {
            return source[info.fieldName](args, contextValue, info);
          }
          return property;
        }
      };
      exports.defaultFieldResolver = defaultFieldResolver;
      function getFieldDef(schema, parentType, fieldNode) {
        const fieldName = fieldNode.name.value;
        if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.SchemaMetaFieldDef;
        } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.TypeMetaFieldDef;
        } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
          return _introspection.TypeNameMetaFieldDef;
        }
        return parentType.getFields()[fieldName];
      }
    }
  });

  // node_modules/graphql/graphql.js
  var require_graphql = __commonJS({
    "node_modules/graphql/graphql.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.graphql = graphql;
      exports.graphqlSync = graphqlSync;
      var _devAssert = require_devAssert();
      var _isPromise = require_isPromise();
      var _parser = require_parser();
      var _validate = require_validate();
      var _validate2 = require_validate2();
      var _execute = require_execute();
      function graphql(args) {
        return new Promise((resolve) => resolve(graphqlImpl(args)));
      }
      function graphqlSync(args) {
        const result = graphqlImpl(args);
        if ((0, _isPromise.isPromise)(result)) {
          throw new Error("GraphQL execution failed to complete synchronously.");
        }
        return result;
      }
      function graphqlImpl(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(
          false,
          "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
        );
        const {
          schema,
          source,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        } = args;
        const schemaValidationErrors = (0, _validate.validateSchema)(schema);
        if (schemaValidationErrors.length > 0) {
          return {
            errors: schemaValidationErrors
          };
        }
        let document;
        try {
          document = (0, _parser.parse)(source);
        } catch (syntaxError) {
          return {
            errors: [syntaxError]
          };
        }
        const validationErrors = (0, _validate2.validate)(schema, document);
        if (validationErrors.length > 0) {
          return {
            errors: validationErrors
          };
        }
        return (0, _execute.execute)({
          schema,
          document,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        });
      }
    }
  });

  // node_modules/graphql/type/index.js
  var require_type = __commonJS({
    "node_modules/graphql/type/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
        enumerable: true,
        get: function() {
          return _directives.DEFAULT_DEPRECATION_REASON;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
        enumerable: true,
        get: function() {
          return _scalars.GRAPHQL_MAX_INT;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
        enumerable: true,
        get: function() {
          return _scalars.GRAPHQL_MIN_INT;
        }
      });
      Object.defineProperty(exports, "GraphQLBoolean", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLBoolean;
        }
      });
      Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLDeprecatedDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLEnumType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLEnumType;
        }
      });
      Object.defineProperty(exports, "GraphQLFloat", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLFloat;
        }
      });
      Object.defineProperty(exports, "GraphQLID", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLID;
        }
      });
      Object.defineProperty(exports, "GraphQLIncludeDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLIncludeDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLInputObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLInt", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLInt;
        }
      });
      Object.defineProperty(exports, "GraphQLInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLInterfaceType;
        }
      });
      Object.defineProperty(exports, "GraphQLList", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLList;
        }
      });
      Object.defineProperty(exports, "GraphQLNonNull", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLNonNull;
        }
      });
      Object.defineProperty(exports, "GraphQLObjectType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLOneOfDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLOneOfDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLScalarType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLScalarType;
        }
      });
      Object.defineProperty(exports, "GraphQLSchema", {
        enumerable: true,
        get: function() {
          return _schema.GraphQLSchema;
        }
      });
      Object.defineProperty(exports, "GraphQLSkipDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLSkipDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLSpecifiedByDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLString", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLString;
        }
      });
      Object.defineProperty(exports, "GraphQLUnionType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLUnionType;
        }
      });
      Object.defineProperty(exports, "SchemaMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.SchemaMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeKind", {
        enumerable: true,
        get: function() {
          return _introspection.TypeKind;
        }
      });
      Object.defineProperty(exports, "TypeMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.TypeMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeNameMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.TypeNameMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "__Directive", {
        enumerable: true,
        get: function() {
          return _introspection.__Directive;
        }
      });
      Object.defineProperty(exports, "__DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _introspection.__DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "__EnumValue", {
        enumerable: true,
        get: function() {
          return _introspection.__EnumValue;
        }
      });
      Object.defineProperty(exports, "__Field", {
        enumerable: true,
        get: function() {
          return _introspection.__Field;
        }
      });
      Object.defineProperty(exports, "__InputValue", {
        enumerable: true,
        get: function() {
          return _introspection.__InputValue;
        }
      });
      Object.defineProperty(exports, "__Schema", {
        enumerable: true,
        get: function() {
          return _introspection.__Schema;
        }
      });
      Object.defineProperty(exports, "__Type", {
        enumerable: true,
        get: function() {
          return _introspection.__Type;
        }
      });
      Object.defineProperty(exports, "__TypeKind", {
        enumerable: true,
        get: function() {
          return _introspection.__TypeKind;
        }
      });
      Object.defineProperty(exports, "assertAbstractType", {
        enumerable: true,
        get: function() {
          return _definition.assertAbstractType;
        }
      });
      Object.defineProperty(exports, "assertCompositeType", {
        enumerable: true,
        get: function() {
          return _definition.assertCompositeType;
        }
      });
      Object.defineProperty(exports, "assertDirective", {
        enumerable: true,
        get: function() {
          return _directives.assertDirective;
        }
      });
      Object.defineProperty(exports, "assertEnumType", {
        enumerable: true,
        get: function() {
          return _definition.assertEnumType;
        }
      });
      Object.defineProperty(exports, "assertEnumValueName", {
        enumerable: true,
        get: function() {
          return _assertName.assertEnumValueName;
        }
      });
      Object.defineProperty(exports, "assertInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.assertInputObjectType;
        }
      });
      Object.defineProperty(exports, "assertInputType", {
        enumerable: true,
        get: function() {
          return _definition.assertInputType;
        }
      });
      Object.defineProperty(exports, "assertInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.assertInterfaceType;
        }
      });
      Object.defineProperty(exports, "assertLeafType", {
        enumerable: true,
        get: function() {
          return _definition.assertLeafType;
        }
      });
      Object.defineProperty(exports, "assertListType", {
        enumerable: true,
        get: function() {
          return _definition.assertListType;
        }
      });
      Object.defineProperty(exports, "assertName", {
        enumerable: true,
        get: function() {
          return _assertName.assertName;
        }
      });
      Object.defineProperty(exports, "assertNamedType", {
        enumerable: true,
        get: function() {
          return _definition.assertNamedType;
        }
      });
      Object.defineProperty(exports, "assertNonNullType", {
        enumerable: true,
        get: function() {
          return _definition.assertNonNullType;
        }
      });
      Object.defineProperty(exports, "assertNullableType", {
        enumerable: true,
        get: function() {
          return _definition.assertNullableType;
        }
      });
      Object.defineProperty(exports, "assertObjectType", {
        enumerable: true,
        get: function() {
          return _definition.assertObjectType;
        }
      });
      Object.defineProperty(exports, "assertOutputType", {
        enumerable: true,
        get: function() {
          return _definition.assertOutputType;
        }
      });
      Object.defineProperty(exports, "assertScalarType", {
        enumerable: true,
        get: function() {
          return _definition.assertScalarType;
        }
      });
      Object.defineProperty(exports, "assertSchema", {
        enumerable: true,
        get: function() {
          return _schema.assertSchema;
        }
      });
      Object.defineProperty(exports, "assertType", {
        enumerable: true,
        get: function() {
          return _definition.assertType;
        }
      });
      Object.defineProperty(exports, "assertUnionType", {
        enumerable: true,
        get: function() {
          return _definition.assertUnionType;
        }
      });
      Object.defineProperty(exports, "assertValidSchema", {
        enumerable: true,
        get: function() {
          return _validate.assertValidSchema;
        }
      });
      Object.defineProperty(exports, "assertWrappingType", {
        enumerable: true,
        get: function() {
          return _definition.assertWrappingType;
        }
      });
      Object.defineProperty(exports, "getNamedType", {
        enumerable: true,
        get: function() {
          return _definition.getNamedType;
        }
      });
      Object.defineProperty(exports, "getNullableType", {
        enumerable: true,
        get: function() {
          return _definition.getNullableType;
        }
      });
      Object.defineProperty(exports, "introspectionTypes", {
        enumerable: true,
        get: function() {
          return _introspection.introspectionTypes;
        }
      });
      Object.defineProperty(exports, "isAbstractType", {
        enumerable: true,
        get: function() {
          return _definition.isAbstractType;
        }
      });
      Object.defineProperty(exports, "isCompositeType", {
        enumerable: true,
        get: function() {
          return _definition.isCompositeType;
        }
      });
      Object.defineProperty(exports, "isDirective", {
        enumerable: true,
        get: function() {
          return _directives.isDirective;
        }
      });
      Object.defineProperty(exports, "isEnumType", {
        enumerable: true,
        get: function() {
          return _definition.isEnumType;
        }
      });
      Object.defineProperty(exports, "isInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.isInputObjectType;
        }
      });
      Object.defineProperty(exports, "isInputType", {
        enumerable: true,
        get: function() {
          return _definition.isInputType;
        }
      });
      Object.defineProperty(exports, "isInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.isInterfaceType;
        }
      });
      Object.defineProperty(exports, "isIntrospectionType", {
        enumerable: true,
        get: function() {
          return _introspection.isIntrospectionType;
        }
      });
      Object.defineProperty(exports, "isLeafType", {
        enumerable: true,
        get: function() {
          return _definition.isLeafType;
        }
      });
      Object.defineProperty(exports, "isListType", {
        enumerable: true,
        get: function() {
          return _definition.isListType;
        }
      });
      Object.defineProperty(exports, "isNamedType", {
        enumerable: true,
        get: function() {
          return _definition.isNamedType;
        }
      });
      Object.defineProperty(exports, "isNonNullType", {
        enumerable: true,
        get: function() {
          return _definition.isNonNullType;
        }
      });
      Object.defineProperty(exports, "isNullableType", {
        enumerable: true,
        get: function() {
          return _definition.isNullableType;
        }
      });
      Object.defineProperty(exports, "isObjectType", {
        enumerable: true,
        get: function() {
          return _definition.isObjectType;
        }
      });
      Object.defineProperty(exports, "isOutputType", {
        enumerable: true,
        get: function() {
          return _definition.isOutputType;
        }
      });
      Object.defineProperty(exports, "isRequiredArgument", {
        enumerable: true,
        get: function() {
          return _definition.isRequiredArgument;
        }
      });
      Object.defineProperty(exports, "isRequiredInputField", {
        enumerable: true,
        get: function() {
          return _definition.isRequiredInputField;
        }
      });
      Object.defineProperty(exports, "isScalarType", {
        enumerable: true,
        get: function() {
          return _definition.isScalarType;
        }
      });
      Object.defineProperty(exports, "isSchema", {
        enumerable: true,
        get: function() {
          return _schema.isSchema;
        }
      });
      Object.defineProperty(exports, "isSpecifiedDirective", {
        enumerable: true,
        get: function() {
          return _directives.isSpecifiedDirective;
        }
      });
      Object.defineProperty(exports, "isSpecifiedScalarType", {
        enumerable: true,
        get: function() {
          return _scalars.isSpecifiedScalarType;
        }
      });
      Object.defineProperty(exports, "isType", {
        enumerable: true,
        get: function() {
          return _definition.isType;
        }
      });
      Object.defineProperty(exports, "isUnionType", {
        enumerable: true,
        get: function() {
          return _definition.isUnionType;
        }
      });
      Object.defineProperty(exports, "isWrappingType", {
        enumerable: true,
        get: function() {
          return _definition.isWrappingType;
        }
      });
      Object.defineProperty(exports, "resolveObjMapThunk", {
        enumerable: true,
        get: function() {
          return _definition.resolveObjMapThunk;
        }
      });
      Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
        enumerable: true,
        get: function() {
          return _definition.resolveReadonlyArrayThunk;
        }
      });
      Object.defineProperty(exports, "specifiedDirectives", {
        enumerable: true,
        get: function() {
          return _directives.specifiedDirectives;
        }
      });
      Object.defineProperty(exports, "specifiedScalarTypes", {
        enumerable: true,
        get: function() {
          return _scalars.specifiedScalarTypes;
        }
      });
      Object.defineProperty(exports, "validateSchema", {
        enumerable: true,
        get: function() {
          return _validate.validateSchema;
        }
      });
      var _schema = require_schema();
      var _definition = require_definition();
      var _directives = require_directives();
      var _scalars = require_scalars();
      var _introspection = require_introspection();
      var _validate = require_validate();
      var _assertName = require_assertName();
    }
  });

  // node_modules/graphql/language/index.js
  var require_language = __commonJS({
    "node_modules/graphql/language/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BREAK", {
        enumerable: true,
        get: function() {
          return _visitor.BREAK;
        }
      });
      Object.defineProperty(exports, "DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _directiveLocation.DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "Kind", {
        enumerable: true,
        get: function() {
          return _kinds.Kind;
        }
      });
      Object.defineProperty(exports, "Lexer", {
        enumerable: true,
        get: function() {
          return _lexer.Lexer;
        }
      });
      Object.defineProperty(exports, "Location", {
        enumerable: true,
        get: function() {
          return _ast.Location;
        }
      });
      Object.defineProperty(exports, "OperationTypeNode", {
        enumerable: true,
        get: function() {
          return _ast.OperationTypeNode;
        }
      });
      Object.defineProperty(exports, "Source", {
        enumerable: true,
        get: function() {
          return _source.Source;
        }
      });
      Object.defineProperty(exports, "Token", {
        enumerable: true,
        get: function() {
          return _ast.Token;
        }
      });
      Object.defineProperty(exports, "TokenKind", {
        enumerable: true,
        get: function() {
          return _tokenKind.TokenKind;
        }
      });
      Object.defineProperty(exports, "getEnterLeaveForKind", {
        enumerable: true,
        get: function() {
          return _visitor.getEnterLeaveForKind;
        }
      });
      Object.defineProperty(exports, "getLocation", {
        enumerable: true,
        get: function() {
          return _location.getLocation;
        }
      });
      Object.defineProperty(exports, "getVisitFn", {
        enumerable: true,
        get: function() {
          return _visitor.getVisitFn;
        }
      });
      Object.defineProperty(exports, "isConstValueNode", {
        enumerable: true,
        get: function() {
          return _predicates.isConstValueNode;
        }
      });
      Object.defineProperty(exports, "isDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isExecutableDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isExecutableDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isSelectionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isSelectionNode;
        }
      });
      Object.defineProperty(exports, "isTypeDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeExtensionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeExtensionNode;
        }
      });
      Object.defineProperty(exports, "isTypeNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeSystemDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemExtensionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeSystemExtensionNode;
        }
      });
      Object.defineProperty(exports, "isValueNode", {
        enumerable: true,
        get: function() {
          return _predicates.isValueNode;
        }
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function() {
          return _parser.parse;
        }
      });
      Object.defineProperty(exports, "parseConstValue", {
        enumerable: true,
        get: function() {
          return _parser.parseConstValue;
        }
      });
      Object.defineProperty(exports, "parseType", {
        enumerable: true,
        get: function() {
          return _parser.parseType;
        }
      });
      Object.defineProperty(exports, "parseValue", {
        enumerable: true,
        get: function() {
          return _parser.parseValue;
        }
      });
      Object.defineProperty(exports, "print", {
        enumerable: true,
        get: function() {
          return _printer.print;
        }
      });
      Object.defineProperty(exports, "printLocation", {
        enumerable: true,
        get: function() {
          return _printLocation.printLocation;
        }
      });
      Object.defineProperty(exports, "printSourceLocation", {
        enumerable: true,
        get: function() {
          return _printLocation.printSourceLocation;
        }
      });
      Object.defineProperty(exports, "visit", {
        enumerable: true,
        get: function() {
          return _visitor.visit;
        }
      });
      Object.defineProperty(exports, "visitInParallel", {
        enumerable: true,
        get: function() {
          return _visitor.visitInParallel;
        }
      });
      var _source = require_source();
      var _location = require_location();
      var _printLocation = require_printLocation();
      var _kinds = require_kinds();
      var _tokenKind = require_tokenKind();
      var _lexer = require_lexer();
      var _parser = require_parser();
      var _printer = require_printer();
      var _visitor = require_visitor();
      var _ast = require_ast();
      var _predicates = require_predicates();
      var _directiveLocation = require_directiveLocation();
    }
  });

  // node_modules/graphql/jsutils/isAsyncIterable.js
  var require_isAsyncIterable = __commonJS({
    "node_modules/graphql/jsutils/isAsyncIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isAsyncIterable = isAsyncIterable;
      function isAsyncIterable(maybeAsyncIterable) {
        return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
      }
    }
  });

  // node_modules/graphql/execution/mapAsyncIterator.js
  var require_mapAsyncIterator = __commonJS({
    "node_modules/graphql/execution/mapAsyncIterator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapAsyncIterator = mapAsyncIterator;
      function mapAsyncIterator(iterable, callback) {
        const iterator = iterable[Symbol.asyncIterator]();
        async function mapResult(result) {
          if (result.done) {
            return result;
          }
          try {
            return {
              value: await callback(result.value),
              done: false
            };
          } catch (error) {
            if (typeof iterator.return === "function") {
              try {
                await iterator.return();
              } catch (_e) {
              }
            }
            throw error;
          }
        }
        return {
          async next() {
            return mapResult(await iterator.next());
          },
          async return() {
            return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
              value: void 0,
              done: true
            };
          },
          async throw(error) {
            if (typeof iterator.throw === "function") {
              return mapResult(await iterator.throw(error));
            }
            throw error;
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
    }
  });

  // node_modules/graphql/execution/subscribe.js
  var require_subscribe = __commonJS({
    "node_modules/graphql/execution/subscribe.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSourceEventStream = createSourceEventStream;
      exports.subscribe = subscribe;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _isAsyncIterable = require_isAsyncIterable();
      var _Path = require_Path();
      var _GraphQLError = require_GraphQLError();
      var _locatedError = require_locatedError();
      var _collectFields = require_collectFields();
      var _execute = require_execute();
      var _mapAsyncIterator = require_mapAsyncIterator();
      var _values = require_values();
      async function subscribe(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(
          false,
          "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
        );
        const resultOrStream = await createSourceEventStream(args);
        if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
          return resultOrStream;
        }
        const mapSourceToResponse = (payload) => (0, _execute.execute)({ ...args, rootValue: payload });
        return (0, _mapAsyncIterator.mapAsyncIterator)(
          resultOrStream,
          mapSourceToResponse
        );
      }
      function toNormalizedArgs(args) {
        const firstArg = args[0];
        if (firstArg && "document" in firstArg) {
          return firstArg;
        }
        return {
          schema: firstArg,
          // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
          document: args[1],
          rootValue: args[2],
          contextValue: args[3],
          variableValues: args[4],
          operationName: args[5],
          subscribeFieldResolver: args[6]
        };
      }
      async function createSourceEventStream(...rawArgs) {
        const args = toNormalizedArgs(rawArgs);
        const { schema, document, variableValues } = args;
        (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);
        const exeContext = (0, _execute.buildExecutionContext)(args);
        if (!("schema" in exeContext)) {
          return {
            errors: exeContext
          };
        }
        try {
          const eventStream = await executeSubscription(exeContext);
          if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
            throw new Error(
              `Subscription field must return Async Iterable. Received: ${(0, _inspect.inspect)(eventStream)}.`
            );
          }
          return eventStream;
        } catch (error) {
          if (error instanceof _GraphQLError.GraphQLError) {
            return {
              errors: [error]
            };
          }
          throw error;
        }
      }
      async function executeSubscription(exeContext) {
        const { schema, fragments, operation, variableValues, rootValue } = exeContext;
        const rootType = schema.getSubscriptionType();
        if (rootType == null) {
          throw new _GraphQLError.GraphQLError(
            "Schema is not configured to execute subscription operation.",
            {
              nodes: operation
            }
          );
        }
        const rootFields = (0, _collectFields.collectFields)(
          schema,
          fragments,
          variableValues,
          rootType,
          operation.selectionSet
        );
        const [responseName, fieldNodes] = [...rootFields.entries()][0];
        const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);
        if (!fieldDef) {
          const fieldName = fieldNodes[0].name.value;
          throw new _GraphQLError.GraphQLError(
            `The subscription field "${fieldName}" is not defined.`,
            {
              nodes: fieldNodes
            }
          );
        }
        const path = (0, _Path.addPath)(void 0, responseName, rootType.name);
        const info = (0, _execute.buildResolveInfo)(
          exeContext,
          fieldDef,
          fieldNodes,
          rootType,
          path
        );
        try {
          var _fieldDef$subscribe;
          const args = (0, _values.getArgumentValues)(
            fieldDef,
            fieldNodes[0],
            variableValues
          );
          const contextValue = exeContext.contextValue;
          const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
          const eventStream = await resolveFn(rootValue, args, contextValue, info);
          if (eventStream instanceof Error) {
            throw eventStream;
          }
          return eventStream;
        } catch (error) {
          throw (0, _locatedError.locatedError)(
            error,
            fieldNodes,
            (0, _Path.pathToArray)(path)
          );
        }
      }
    }
  });

  // node_modules/graphql/execution/index.js
  var require_execution = __commonJS({
    "node_modules/graphql/execution/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "createSourceEventStream", {
        enumerable: true,
        get: function() {
          return _subscribe.createSourceEventStream;
        }
      });
      Object.defineProperty(exports, "defaultFieldResolver", {
        enumerable: true,
        get: function() {
          return _execute.defaultFieldResolver;
        }
      });
      Object.defineProperty(exports, "defaultTypeResolver", {
        enumerable: true,
        get: function() {
          return _execute.defaultTypeResolver;
        }
      });
      Object.defineProperty(exports, "execute", {
        enumerable: true,
        get: function() {
          return _execute.execute;
        }
      });
      Object.defineProperty(exports, "executeSync", {
        enumerable: true,
        get: function() {
          return _execute.executeSync;
        }
      });
      Object.defineProperty(exports, "getArgumentValues", {
        enumerable: true,
        get: function() {
          return _values.getArgumentValues;
        }
      });
      Object.defineProperty(exports, "getDirectiveValues", {
        enumerable: true,
        get: function() {
          return _values.getDirectiveValues;
        }
      });
      Object.defineProperty(exports, "getVariableValues", {
        enumerable: true,
        get: function() {
          return _values.getVariableValues;
        }
      });
      Object.defineProperty(exports, "responsePathAsArray", {
        enumerable: true,
        get: function() {
          return _Path.pathToArray;
        }
      });
      Object.defineProperty(exports, "subscribe", {
        enumerable: true,
        get: function() {
          return _subscribe.subscribe;
        }
      });
      var _Path = require_Path();
      var _execute = require_execute();
      var _subscribe = require_subscribe();
      var _values = require_values();
    }
  });

  // node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
  var require_NoDeprecatedCustomRule = __commonJS({
    "node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
      var _invariant = require_invariant2();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function NoDeprecatedCustomRule(context2) {
        return {
          Field(node) {
            const fieldDef = context2.getFieldDef();
            const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
            if (fieldDef && deprecationReason != null) {
              const parentType = context2.getParentType();
              parentType != null || (0, _invariant.invariant)(false);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          Argument(node) {
            const argDef = context2.getArgument();
            const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
            if (argDef && deprecationReason != null) {
              const directiveDef = context2.getDirective();
              if (directiveDef != null) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                    {
                      nodes: node
                    }
                  )
                );
              } else {
                const parentType = context2.getParentType();
                const fieldDef = context2.getFieldDef();
                parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          },
          ObjectField(node) {
            const inputObjectDef = (0, _definition.getNamedType)(
              context2.getParentInputType()
            );
            if ((0, _definition.isInputObjectType)(inputObjectDef)) {
              const inputFieldDef = inputObjectDef.getFields()[node.name.value];
              const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
              if (deprecationReason != null) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          },
          EnumValue(node) {
            const enumValueDef = context2.getEnumValue();
            const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
            if (enumValueDef && deprecationReason != null) {
              const enumTypeDef = (0, _definition.getNamedType)(
                context2.getInputType()
              );
              enumTypeDef != null || (0, _invariant.invariant)(false);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
  var require_NoSchemaIntrospectionCustomRule = __commonJS({
    "node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      var _introspection = require_introspection();
      function NoSchemaIntrospectionCustomRule(context2) {
        return {
          Field(node) {
            const type = (0, _definition.getNamedType)(context2.getType());
            if (type && (0, _introspection.isIntrospectionType)(type)) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/index.js
  var require_validation = __commonJS({
    "node_modules/graphql/validation/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "ExecutableDefinitionsRule", {
        enumerable: true,
        get: function() {
          return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
        }
      });
      Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
        enumerable: true,
        get: function() {
          return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
        }
      });
      Object.defineProperty(exports, "KnownArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownArgumentNamesRule.KnownArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownDirectivesRule", {
        enumerable: true,
        get: function() {
          return _KnownDirectivesRule.KnownDirectivesRule;
        }
      });
      Object.defineProperty(exports, "KnownFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownFragmentNamesRule.KnownFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownTypeNamesRule.KnownTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "LoneAnonymousOperationRule", {
        enumerable: true,
        get: function() {
          return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
        }
      });
      Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
        enumerable: true,
        get: function() {
          return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
        }
      });
      Object.defineProperty(exports, "MaxIntrospectionDepthRule", {
        enumerable: true,
        get: function() {
          return _MaxIntrospectionDepthRule.MaxIntrospectionDepthRule;
        }
      });
      Object.defineProperty(exports, "NoDeprecatedCustomRule", {
        enumerable: true,
        get: function() {
          return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
        }
      });
      Object.defineProperty(exports, "NoFragmentCyclesRule", {
        enumerable: true,
        get: function() {
          return _NoFragmentCyclesRule.NoFragmentCyclesRule;
        }
      });
      Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
        enumerable: true,
        get: function() {
          return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
        }
      });
      Object.defineProperty(exports, "NoUndefinedVariablesRule", {
        enumerable: true,
        get: function() {
          return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedFragmentsRule", {
        enumerable: true,
        get: function() {
          return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedVariablesRule", {
        enumerable: true,
        get: function() {
          return _NoUnusedVariablesRule.NoUnusedVariablesRule;
        }
      });
      Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
        enumerable: true,
        get: function() {
          return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
        }
      });
      Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
        enumerable: true,
        get: function() {
          return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
        }
      });
      Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
        enumerable: true,
        get: function() {
          return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
        }
      });
      Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
        enumerable: true,
        get: function() {
          return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
        }
      });
      Object.defineProperty(exports, "ScalarLeafsRule", {
        enumerable: true,
        get: function() {
          return _ScalarLeafsRule.ScalarLeafsRule;
        }
      });
      Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
        enumerable: true,
        get: function() {
          return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
        enumerable: true,
        get: function() {
          return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
        }
      });
      Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueOperationNamesRule.UniqueOperationNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationTypesRule", {
        enumerable: true,
        get: function() {
          return _UniqueOperationTypesRule.UniqueOperationTypesRule;
        }
      });
      Object.defineProperty(exports, "UniqueTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueTypeNamesRule.UniqueTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueVariableNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueVariableNamesRule.UniqueVariableNamesRule;
        }
      });
      Object.defineProperty(exports, "ValidationContext", {
        enumerable: true,
        get: function() {
          return _ValidationContext.ValidationContext;
        }
      });
      Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "VariablesAreInputTypesRule", {
        enumerable: true,
        get: function() {
          return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
        }
      });
      Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
        enumerable: true,
        get: function() {
          return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
        }
      });
      Object.defineProperty(exports, "recommendedRules", {
        enumerable: true,
        get: function() {
          return _specifiedRules.recommendedRules;
        }
      });
      Object.defineProperty(exports, "specifiedRules", {
        enumerable: true,
        get: function() {
          return _specifiedRules.specifiedRules;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function() {
          return _validate.validate;
        }
      });
      var _validate = require_validate2();
      var _ValidationContext = require_ValidationContext();
      var _specifiedRules = require_specifiedRules();
      var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
      var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
      var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
      var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
      var _KnownDirectivesRule = require_KnownDirectivesRule();
      var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
      var _KnownTypeNamesRule = require_KnownTypeNamesRule();
      var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
      var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
      var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
      var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
      var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
      var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
      var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
      var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
      var _ScalarLeafsRule = require_ScalarLeafsRule();
      var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
      var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
      var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
      var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
      var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
      var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
      var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
      var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
      var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
      var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
      var _MaxIntrospectionDepthRule = require_MaxIntrospectionDepthRule();
      var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
      var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
      var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
      var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
      var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
      var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
      var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
      var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
      var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
      var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
    }
  });

  // node_modules/graphql/error/index.js
  var require_error = __commonJS({
    "node_modules/graphql/error/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "GraphQLError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.GraphQLError;
        }
      });
      Object.defineProperty(exports, "formatError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.formatError;
        }
      });
      Object.defineProperty(exports, "locatedError", {
        enumerable: true,
        get: function() {
          return _locatedError.locatedError;
        }
      });
      Object.defineProperty(exports, "printError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.printError;
        }
      });
      Object.defineProperty(exports, "syntaxError", {
        enumerable: true,
        get: function() {
          return _syntaxError.syntaxError;
        }
      });
      var _GraphQLError = require_GraphQLError();
      var _syntaxError = require_syntaxError();
      var _locatedError = require_locatedError();
    }
  });

  // node_modules/graphql/utilities/getIntrospectionQuery.js
  var require_getIntrospectionQuery = __commonJS({
    "node_modules/graphql/utilities/getIntrospectionQuery.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getIntrospectionQuery = getIntrospectionQuery;
      function getIntrospectionQuery(options) {
        const optionsWithDefault = {
          descriptions: true,
          specifiedByUrl: false,
          directiveIsRepeatable: false,
          schemaDescription: false,
          inputValueDeprecation: false,
          oneOf: false,
          ...options
        };
        const descriptions = optionsWithDefault.descriptions ? "description" : "";
        const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
        const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
        const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
        function inputDeprecation(str) {
          return optionsWithDefault.inputValueDeprecation ? str : "";
        }
        const oneOf = optionsWithDefault.oneOf ? "isOneOf" : "";
        return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name kind }
        mutationType { name kind }
        subscriptionType { name kind }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      ${oneOf}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
      }
    }
  });

  // node_modules/graphql/utilities/getOperationAST.js
  var require_getOperationAST = __commonJS({
    "node_modules/graphql/utilities/getOperationAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getOperationAST = getOperationAST;
      var _kinds = require_kinds();
      function getOperationAST(documentAST, operationName) {
        let operation = null;
        for (const definition of documentAST.definitions) {
          if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
            var _definition$name;
            if (operationName == null) {
              if (operation) {
                return null;
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              return definition;
            }
          }
        }
        return operation;
      }
    }
  });

  // node_modules/graphql/utilities/getOperationRootType.js
  var require_getOperationRootType = __commonJS({
    "node_modules/graphql/utilities/getOperationRootType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getOperationRootType = getOperationRootType;
      var _GraphQLError = require_GraphQLError();
      function getOperationRootType(schema, operation) {
        if (operation.operation === "query") {
          const queryType = schema.getQueryType();
          if (!queryType) {
            throw new _GraphQLError.GraphQLError(
              "Schema does not define the required query root type.",
              {
                nodes: operation
              }
            );
          }
          return queryType;
        }
        if (operation.operation === "mutation") {
          const mutationType = schema.getMutationType();
          if (!mutationType) {
            throw new _GraphQLError.GraphQLError(
              "Schema is not configured for mutations.",
              {
                nodes: operation
              }
            );
          }
          return mutationType;
        }
        if (operation.operation === "subscription") {
          const subscriptionType = schema.getSubscriptionType();
          if (!subscriptionType) {
            throw new _GraphQLError.GraphQLError(
              "Schema is not configured for subscriptions.",
              {
                nodes: operation
              }
            );
          }
          return subscriptionType;
        }
        throw new _GraphQLError.GraphQLError(
          "Can only have query, mutation and subscription operations.",
          {
            nodes: operation
          }
        );
      }
    }
  });

  // node_modules/graphql/utilities/introspectionFromSchema.js
  var require_introspectionFromSchema = __commonJS({
    "node_modules/graphql/utilities/introspectionFromSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.introspectionFromSchema = introspectionFromSchema;
      var _invariant = require_invariant2();
      var _parser = require_parser();
      var _execute = require_execute();
      var _getIntrospectionQuery = require_getIntrospectionQuery();
      function introspectionFromSchema(schema, options) {
        const optionsWithDefaults = {
          specifiedByUrl: true,
          directiveIsRepeatable: true,
          schemaDescription: true,
          inputValueDeprecation: true,
          oneOf: true,
          ...options
        };
        const document = (0, _parser.parse)(
          (0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults)
        );
        const result = (0, _execute.executeSync)({
          schema,
          document
        });
        !result.errors && result.data || (0, _invariant.invariant)(false);
        return result.data;
      }
    }
  });

  // node_modules/graphql/utilities/buildClientSchema.js
  var require_buildClientSchema = __commonJS({
    "node_modules/graphql/utilities/buildClientSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.buildClientSchema = buildClientSchema;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _isObjectLike = require_isObjectLike();
      var _keyValMap = require_keyValMap();
      var _parser = require_parser();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _schema = require_schema();
      var _valueFromAST = require_valueFromAST();
      function buildClientSchema(introspection, options) {
        (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(
          false,
          `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`
        );
        const schemaIntrospection = introspection.__schema;
        const typeMap = (0, _keyValMap.keyValMap)(
          schemaIntrospection.types,
          (typeIntrospection) => typeIntrospection.name,
          (typeIntrospection) => buildType(typeIntrospection)
        );
        for (const stdType of [
          ..._scalars.specifiedScalarTypes,
          ..._introspection.introspectionTypes
        ]) {
          if (typeMap[stdType.name]) {
            typeMap[stdType.name] = stdType;
          }
        }
        const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
        const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
        const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
        const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
        return new _schema.GraphQLSchema({
          description: schemaIntrospection.description,
          query: queryType,
          mutation: mutationType,
          subscription: subscriptionType,
          types: Object.values(typeMap),
          directives,
          assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
        });
        function getType(typeRef) {
          if (typeRef.kind === _introspection.TypeKind.LIST) {
            const itemRef = typeRef.ofType;
            if (!itemRef) {
              throw new Error("Decorated type deeper than introspection query.");
            }
            return new _definition.GraphQLList(getType(itemRef));
          }
          if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
            const nullableRef = typeRef.ofType;
            if (!nullableRef) {
              throw new Error("Decorated type deeper than introspection query.");
            }
            const nullableType = getType(nullableRef);
            return new _definition.GraphQLNonNull(
              (0, _definition.assertNullableType)(nullableType)
            );
          }
          return getNamedType(typeRef);
        }
        function getNamedType(typeRef) {
          const typeName = typeRef.name;
          if (!typeName) {
            throw new Error(
              `Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`
            );
          }
          const type = typeMap[typeName];
          if (!type) {
            throw new Error(
              `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
            );
          }
          return type;
        }
        function getObjectType(typeRef) {
          return (0, _definition.assertObjectType)(getNamedType(typeRef));
        }
        function getInterfaceType(typeRef) {
          return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
        }
        function buildType(type) {
          if (type != null && type.name != null && type.kind != null) {
            switch (type.kind) {
              case _introspection.TypeKind.SCALAR:
                return buildScalarDef(type);
              case _introspection.TypeKind.OBJECT:
                return buildObjectDef(type);
              case _introspection.TypeKind.INTERFACE:
                return buildInterfaceDef(type);
              case _introspection.TypeKind.UNION:
                return buildUnionDef(type);
              case _introspection.TypeKind.ENUM:
                return buildEnumDef(type);
              case _introspection.TypeKind.INPUT_OBJECT:
                return buildInputObjectDef(type);
            }
          }
          const typeStr = (0, _inspect.inspect)(type);
          throw new Error(
            `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
          );
        }
        function buildScalarDef(scalarIntrospection) {
          return new _definition.GraphQLScalarType({
            name: scalarIntrospection.name,
            description: scalarIntrospection.description,
            specifiedByURL: scalarIntrospection.specifiedByURL
          });
        }
        function buildImplementationsList(implementingIntrospection) {
          if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
            return [];
          }
          if (!implementingIntrospection.interfaces) {
            const implementingIntrospectionStr = (0, _inspect.inspect)(
              implementingIntrospection
            );
            throw new Error(
              `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
            );
          }
          return implementingIntrospection.interfaces.map(getInterfaceType);
        }
        function buildObjectDef(objectIntrospection) {
          return new _definition.GraphQLObjectType({
            name: objectIntrospection.name,
            description: objectIntrospection.description,
            interfaces: () => buildImplementationsList(objectIntrospection),
            fields: () => buildFieldDefMap(objectIntrospection)
          });
        }
        function buildInterfaceDef(interfaceIntrospection) {
          return new _definition.GraphQLInterfaceType({
            name: interfaceIntrospection.name,
            description: interfaceIntrospection.description,
            interfaces: () => buildImplementationsList(interfaceIntrospection),
            fields: () => buildFieldDefMap(interfaceIntrospection)
          });
        }
        function buildUnionDef(unionIntrospection) {
          if (!unionIntrospection.possibleTypes) {
            const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
            throw new Error(
              `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
            );
          }
          return new _definition.GraphQLUnionType({
            name: unionIntrospection.name,
            description: unionIntrospection.description,
            types: () => unionIntrospection.possibleTypes.map(getObjectType)
          });
        }
        function buildEnumDef(enumIntrospection) {
          if (!enumIntrospection.enumValues) {
            const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
            throw new Error(
              `Introspection result missing enumValues: ${enumIntrospectionStr}.`
            );
          }
          return new _definition.GraphQLEnumType({
            name: enumIntrospection.name,
            description: enumIntrospection.description,
            values: (0, _keyValMap.keyValMap)(
              enumIntrospection.enumValues,
              (valueIntrospection) => valueIntrospection.name,
              (valueIntrospection) => ({
                description: valueIntrospection.description,
                deprecationReason: valueIntrospection.deprecationReason
              })
            )
          });
        }
        function buildInputObjectDef(inputObjectIntrospection) {
          if (!inputObjectIntrospection.inputFields) {
            const inputObjectIntrospectionStr = (0, _inspect.inspect)(
              inputObjectIntrospection
            );
            throw new Error(
              `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
            );
          }
          return new _definition.GraphQLInputObjectType({
            name: inputObjectIntrospection.name,
            description: inputObjectIntrospection.description,
            fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),
            isOneOf: inputObjectIntrospection.isOneOf
          });
        }
        function buildFieldDefMap(typeIntrospection) {
          if (!typeIntrospection.fields) {
            throw new Error(
              `Introspection result missing fields: ${(0, _inspect.inspect)(
                typeIntrospection
              )}.`
            );
          }
          return (0, _keyValMap.keyValMap)(
            typeIntrospection.fields,
            (fieldIntrospection) => fieldIntrospection.name,
            buildField
          );
        }
        function buildField(fieldIntrospection) {
          const type = getType(fieldIntrospection.type);
          if (!(0, _definition.isOutputType)(type)) {
            const typeStr = (0, _inspect.inspect)(type);
            throw new Error(
              `Introspection must provide output type for fields, but received: ${typeStr}.`
            );
          }
          if (!fieldIntrospection.args) {
            const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
            throw new Error(
              `Introspection result missing field args: ${fieldIntrospectionStr}.`
            );
          }
          return {
            description: fieldIntrospection.description,
            deprecationReason: fieldIntrospection.deprecationReason,
            type,
            args: buildInputValueDefMap(fieldIntrospection.args)
          };
        }
        function buildInputValueDefMap(inputValueIntrospections) {
          return (0, _keyValMap.keyValMap)(
            inputValueIntrospections,
            (inputValue) => inputValue.name,
            buildInputValue
          );
        }
        function buildInputValue(inputValueIntrospection) {
          const type = getType(inputValueIntrospection.type);
          if (!(0, _definition.isInputType)(type)) {
            const typeStr = (0, _inspect.inspect)(type);
            throw new Error(
              `Introspection must provide input type for arguments, but received: ${typeStr}.`
            );
          }
          const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)(
            (0, _parser.parseValue)(inputValueIntrospection.defaultValue),
            type
          ) : void 0;
          return {
            description: inputValueIntrospection.description,
            type,
            defaultValue,
            deprecationReason: inputValueIntrospection.deprecationReason
          };
        }
        function buildDirective(directiveIntrospection) {
          if (!directiveIntrospection.args) {
            const directiveIntrospectionStr = (0, _inspect.inspect)(
              directiveIntrospection
            );
            throw new Error(
              `Introspection result missing directive args: ${directiveIntrospectionStr}.`
            );
          }
          if (!directiveIntrospection.locations) {
            const directiveIntrospectionStr = (0, _inspect.inspect)(
              directiveIntrospection
            );
            throw new Error(
              `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
            );
          }
          return new _directives.GraphQLDirective({
            name: directiveIntrospection.name,
            description: directiveIntrospection.description,
            isRepeatable: directiveIntrospection.isRepeatable,
            locations: directiveIntrospection.locations.slice(),
            args: buildInputValueDefMap(directiveIntrospection.args)
          });
        }
      }
    }
  });

  // node_modules/graphql/utilities/extendSchema.js
  var require_extendSchema = __commonJS({
    "node_modules/graphql/utilities/extendSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.extendSchema = extendSchema;
      exports.extendSchemaImpl = extendSchemaImpl;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _keyMap = require_keyMap();
      var _mapValue = require_mapValue();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _schema = require_schema();
      var _validate = require_validate2();
      var _values = require_values();
      var _valueFromAST = require_valueFromAST();
      function extendSchema(schema, documentAST, options) {
        (0, _schema.assertSchema)(schema);
        documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
        if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
          (0, _validate.assertValidSDLExtension)(documentAST, schema);
        }
        const schemaConfig = schema.toConfig();
        const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
        return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
      }
      function extendSchemaImpl(schemaConfig, documentAST, options) {
        var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
        const typeDefs = [];
        const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
        const directiveDefs = [];
        let schemaDef;
        const schemaExtensions = [];
        for (const def of documentAST.definitions) {
          if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
            schemaDef = def;
          } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            schemaExtensions.push(def);
          } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
            typeDefs.push(def);
          } else if ((0, _predicates.isTypeExtensionNode)(def)) {
            const extendedTypeName = def.name.value;
            const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
            typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
          } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            directiveDefs.push(def);
          }
        }
        if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
          return schemaConfig;
        }
        const typeMap = /* @__PURE__ */ Object.create(null);
        for (const existingType of schemaConfig.types) {
          typeMap[existingType.name] = extendNamedType(existingType);
        }
        for (const typeNode of typeDefs) {
          var _stdTypeMap$name;
          const name = typeNode.name.value;
          typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
        }
        const operationTypes = {
          // Get the extended root operation types.
          query: schemaConfig.query && replaceNamedType(schemaConfig.query),
          mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
          subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
          // Then, incorporate schema definition and all schema extensions.
          ...schemaDef && getOperationTypes([schemaDef]),
          ...getOperationTypes(schemaExtensions)
        };
        return {
          description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
          ...operationTypes,
          types: Object.values(typeMap),
          directives: [
            ...schemaConfig.directives.map(replaceDirective),
            ...directiveDefs.map(buildDirective)
          ],
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
          extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
          assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
        };
        function replaceType(type) {
          if ((0, _definition.isListType)(type)) {
            return new _definition.GraphQLList(replaceType(type.ofType));
          }
          if ((0, _definition.isNonNullType)(type)) {
            return new _definition.GraphQLNonNull(replaceType(type.ofType));
          }
          return replaceNamedType(type);
        }
        function replaceNamedType(type) {
          return typeMap[type.name];
        }
        function replaceDirective(directive) {
          const config = directive.toConfig();
          return new _directives.GraphQLDirective({
            ...config,
            args: (0, _mapValue.mapValue)(config.args, extendArg)
          });
        }
        function extendNamedType(type) {
          if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
            return type;
          }
          if ((0, _definition.isScalarType)(type)) {
            return extendScalarType(type);
          }
          if ((0, _definition.isObjectType)(type)) {
            return extendObjectType(type);
          }
          if ((0, _definition.isInterfaceType)(type)) {
            return extendInterfaceType(type);
          }
          if ((0, _definition.isUnionType)(type)) {
            return extendUnionType(type);
          }
          if ((0, _definition.isEnumType)(type)) {
            return extendEnumType(type);
          }
          if ((0, _definition.isInputObjectType)(type)) {
            return extendInputObjectType(type);
          }
          (0, _invariant.invariant)(
            false,
            "Unexpected type: " + (0, _inspect.inspect)(type)
          );
        }
        function extendInputObjectType(type) {
          var _typeExtensionsMap$co;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
          return new _definition.GraphQLInputObjectType({
            ...config,
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, (field) => ({
                ...field,
                type: replaceType(field.type)
              })),
              ...buildInputFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendEnumType(type) {
          var _typeExtensionsMap$ty;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
          return new _definition.GraphQLEnumType({
            ...config,
            values: { ...config.values, ...buildEnumValueMap(extensions) },
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendScalarType(type) {
          var _typeExtensionsMap$co2;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
          let specifiedByURL = config.specifiedByURL;
          for (const extensionNode of extensions) {
            var _getSpecifiedByURL;
            specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
          }
          return new _definition.GraphQLScalarType({
            ...config,
            specifiedByURL,
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendObjectType(type) {
          var _typeExtensionsMap$co3;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
          return new _definition.GraphQLObjectType({
            ...config,
            interfaces: () => [
              ...type.getInterfaces().map(replaceNamedType),
              ...buildInterfaces(extensions)
            ],
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, extendField),
              ...buildFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendInterfaceType(type) {
          var _typeExtensionsMap$co4;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
          return new _definition.GraphQLInterfaceType({
            ...config,
            interfaces: () => [
              ...type.getInterfaces().map(replaceNamedType),
              ...buildInterfaces(extensions)
            ],
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, extendField),
              ...buildFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendUnionType(type) {
          var _typeExtensionsMap$co5;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
          return new _definition.GraphQLUnionType({
            ...config,
            types: () => [
              ...type.getTypes().map(replaceNamedType),
              ...buildUnionTypes(extensions)
            ],
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendField(field) {
          return {
            ...field,
            type: replaceType(field.type),
            args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
          };
        }
        function extendArg(arg) {
          return { ...arg, type: replaceType(arg.type) };
        }
        function getOperationTypes(nodes) {
          const opTypes = {};
          for (const node of nodes) {
            var _node$operationTypes;
            const operationTypesNodes = (
              /* c8 ignore next */
              (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
            );
            for (const operationType of operationTypesNodes) {
              opTypes[operationType.operation] = getNamedType(operationType.type);
            }
          }
          return opTypes;
        }
        function getNamedType(node) {
          var _stdTypeMap$name2;
          const name = node.name.value;
          const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
          if (type === void 0) {
            throw new Error(`Unknown type: "${name}".`);
          }
          return type;
        }
        function getWrappedType(node) {
          if (node.kind === _kinds.Kind.LIST_TYPE) {
            return new _definition.GraphQLList(getWrappedType(node.type));
          }
          if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
            return new _definition.GraphQLNonNull(getWrappedType(node.type));
          }
          return getNamedType(node);
        }
        function buildDirective(node) {
          var _node$description;
          return new _directives.GraphQLDirective({
            name: node.name.value,
            description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
            // @ts-expect-error
            locations: node.locations.map(({ value }) => value),
            isRepeatable: node.repeatable,
            args: buildArgumentMap(node.arguments),
            astNode: node
          });
        }
        function buildFieldMap(nodes) {
          const fieldConfigMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$fields;
            const nodeFields = (
              /* c8 ignore next */
              (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
            );
            for (const field of nodeFields) {
              var _field$description;
              fieldConfigMap[field.name.value] = {
                // Note: While this could make assertions to get the correctly typed
                // value, that would throw immediately while type system validation
                // with validateSchema() will produce more actionable results.
                type: getWrappedType(field.type),
                description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
                args: buildArgumentMap(field.arguments),
                deprecationReason: getDeprecationReason(field),
                astNode: field
              };
            }
          }
          return fieldConfigMap;
        }
        function buildArgumentMap(args) {
          const argsNodes = (
            /* c8 ignore next */
            args !== null && args !== void 0 ? args : []
          );
          const argConfigMap = /* @__PURE__ */ Object.create(null);
          for (const arg of argsNodes) {
            var _arg$description;
            const type = getWrappedType(arg.type);
            argConfigMap[arg.name.value] = {
              type,
              description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
              defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
              deprecationReason: getDeprecationReason(arg),
              astNode: arg
            };
          }
          return argConfigMap;
        }
        function buildInputFieldMap(nodes) {
          const inputFieldMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$fields2;
            const fieldsNodes = (
              /* c8 ignore next */
              (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
            );
            for (const field of fieldsNodes) {
              var _field$description2;
              const type = getWrappedType(field.type);
              inputFieldMap[field.name.value] = {
                type,
                description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
                defaultValue: (0, _valueFromAST.valueFromAST)(
                  field.defaultValue,
                  type
                ),
                deprecationReason: getDeprecationReason(field),
                astNode: field
              };
            }
          }
          return inputFieldMap;
        }
        function buildEnumValueMap(nodes) {
          const enumValueMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$values;
            const valuesNodes = (
              /* c8 ignore next */
              (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
            );
            for (const value of valuesNodes) {
              var _value$description;
              enumValueMap[value.name.value] = {
                description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
                deprecationReason: getDeprecationReason(value),
                astNode: value
              };
            }
          }
          return enumValueMap;
        }
        function buildInterfaces(nodes) {
          return nodes.flatMap(
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            (node) => {
              var _node$interfaces$map, _node$interfaces;
              return (
                /* c8 ignore next */
                (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
              );
            }
          );
        }
        function buildUnionTypes(nodes) {
          return nodes.flatMap(
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            (node) => {
              var _node$types$map, _node$types;
              return (
                /* c8 ignore next */
                (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : []
              );
            }
          );
        }
        function buildType(astNode) {
          var _typeExtensionsMap$na;
          const name = astNode.name.value;
          const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
          switch (astNode.kind) {
            case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
              var _astNode$description;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLObjectType({
                name,
                description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
                interfaces: () => buildInterfaces(allNodes),
                fields: () => buildFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
              var _astNode$description2;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLInterfaceType({
                name,
                description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
                interfaces: () => buildInterfaces(allNodes),
                fields: () => buildFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.ENUM_TYPE_DEFINITION: {
              var _astNode$description3;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLEnumType({
                name,
                description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
                values: buildEnumValueMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.UNION_TYPE_DEFINITION: {
              var _astNode$description4;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLUnionType({
                name,
                description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
                types: () => buildUnionTypes(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
              var _astNode$description5;
              return new _definition.GraphQLScalarType({
                name,
                description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
                specifiedByURL: getSpecifiedByURL(astNode),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
              var _astNode$description6;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLInputObjectType({
                name,
                description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
                fields: () => buildInputFieldMap(allNodes),
                astNode,
                extensionASTNodes,
                isOneOf: isOneOf(astNode)
              });
            }
          }
        }
      }
      var stdTypeMap = (0, _keyMap.keyMap)(
        [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes],
        (type) => type.name
      );
      function getDeprecationReason(node) {
        const deprecated = (0, _values.getDirectiveValues)(
          _directives.GraphQLDeprecatedDirective,
          node
        );
        return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
      }
      function getSpecifiedByURL(node) {
        const specifiedBy = (0, _values.getDirectiveValues)(
          _directives.GraphQLSpecifiedByDirective,
          node
        );
        return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
      }
      function isOneOf(node) {
        return Boolean(
          (0, _values.getDirectiveValues)(_directives.GraphQLOneOfDirective, node)
        );
      }
    }
  });

  // node_modules/graphql/utilities/buildASTSchema.js
  var require_buildASTSchema = __commonJS({
    "node_modules/graphql/utilities/buildASTSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.buildASTSchema = buildASTSchema;
      exports.buildSchema = buildSchema;
      var _devAssert = require_devAssert();
      var _kinds = require_kinds();
      var _parser = require_parser();
      var _directives = require_directives();
      var _schema = require_schema();
      var _validate = require_validate2();
      var _extendSchema = require_extendSchema();
      function buildASTSchema(documentAST, options) {
        documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
        if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
          (0, _validate.assertValidSDL)(documentAST);
        }
        const emptySchemaConfig = {
          description: void 0,
          types: [],
          directives: [],
          extensions: /* @__PURE__ */ Object.create(null),
          extensionASTNodes: [],
          assumeValid: false
        };
        const config = (0, _extendSchema.extendSchemaImpl)(
          emptySchemaConfig,
          documentAST,
          options
        );
        if (config.astNode == null) {
          for (const type of config.types) {
            switch (type.name) {
              // Note: While this could make early assertions to get the correctly
              // typed values below, that would throw immediately while type system
              // validation with validateSchema() will produce more actionable results.
              case "Query":
                config.query = type;
                break;
              case "Mutation":
                config.mutation = type;
                break;
              case "Subscription":
                config.subscription = type;
                break;
            }
          }
        }
        const directives = [
          ...config.directives,
          // If specified directives were not explicitly declared, add them.
          ..._directives.specifiedDirectives.filter(
            (stdDirective) => config.directives.every(
              (directive) => directive.name !== stdDirective.name
            )
          )
        ];
        return new _schema.GraphQLSchema({ ...config, directives });
      }
      function buildSchema(source, options) {
        const document = (0, _parser.parse)(source, {
          noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
          allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
        });
        return buildASTSchema(document, {
          assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
          assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
        });
      }
    }
  });

  // node_modules/graphql/utilities/lexicographicSortSchema.js
  var require_lexicographicSortSchema = __commonJS({
    "node_modules/graphql/utilities/lexicographicSortSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lexicographicSortSchema = lexicographicSortSchema;
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _keyValMap = require_keyValMap();
      var _naturalCompare = require_naturalCompare();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _schema = require_schema();
      function lexicographicSortSchema(schema) {
        const schemaConfig = schema.toConfig();
        const typeMap = (0, _keyValMap.keyValMap)(
          sortByName(schemaConfig.types),
          (type) => type.name,
          sortNamedType
        );
        return new _schema.GraphQLSchema({
          ...schemaConfig,
          types: Object.values(typeMap),
          directives: sortByName(schemaConfig.directives).map(sortDirective),
          query: replaceMaybeType(schemaConfig.query),
          mutation: replaceMaybeType(schemaConfig.mutation),
          subscription: replaceMaybeType(schemaConfig.subscription)
        });
        function replaceType(type) {
          if ((0, _definition.isListType)(type)) {
            return new _definition.GraphQLList(replaceType(type.ofType));
          } else if ((0, _definition.isNonNullType)(type)) {
            return new _definition.GraphQLNonNull(replaceType(type.ofType));
          }
          return replaceNamedType(type);
        }
        function replaceNamedType(type) {
          return typeMap[type.name];
        }
        function replaceMaybeType(maybeType) {
          return maybeType && replaceNamedType(maybeType);
        }
        function sortDirective(directive) {
          const config = directive.toConfig();
          return new _directives.GraphQLDirective({
            ...config,
            locations: sortBy(config.locations, (x) => x),
            args: sortArgs(config.args)
          });
        }
        function sortArgs(args) {
          return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
        }
        function sortFields(fieldsMap) {
          return sortObjMap(fieldsMap, (field) => ({
            ...field,
            type: replaceType(field.type),
            args: field.args && sortArgs(field.args)
          }));
        }
        function sortInputFields(fieldsMap) {
          return sortObjMap(fieldsMap, (field) => ({
            ...field,
            type: replaceType(field.type)
          }));
        }
        function sortTypes(array) {
          return sortByName(array).map(replaceNamedType);
        }
        function sortNamedType(type) {
          if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
            return type;
          }
          if ((0, _definition.isObjectType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLObjectType({
              ...config,
              interfaces: () => sortTypes(config.interfaces),
              fields: () => sortFields(config.fields)
            });
          }
          if ((0, _definition.isInterfaceType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLInterfaceType({
              ...config,
              interfaces: () => sortTypes(config.interfaces),
              fields: () => sortFields(config.fields)
            });
          }
          if ((0, _definition.isUnionType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLUnionType({
              ...config,
              types: () => sortTypes(config.types)
            });
          }
          if ((0, _definition.isEnumType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLEnumType({
              ...config,
              values: sortObjMap(config.values, (value) => value)
            });
          }
          if ((0, _definition.isInputObjectType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLInputObjectType({
              ...config,
              fields: () => sortInputFields(config.fields)
            });
          }
          (0, _invariant.invariant)(
            false,
            "Unexpected type: " + (0, _inspect.inspect)(type)
          );
        }
      }
      function sortObjMap(map, sortValueFn) {
        const sortedMap = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)) {
          sortedMap[key] = sortValueFn(map[key]);
        }
        return sortedMap;
      }
      function sortByName(array) {
        return sortBy(array, (obj) => obj.name);
      }
      function sortBy(array, mapToKey) {
        return array.slice().sort((obj1, obj2) => {
          const key1 = mapToKey(obj1);
          const key2 = mapToKey(obj2);
          return (0, _naturalCompare.naturalCompare)(key1, key2);
        });
      }
    }
  });

  // node_modules/graphql/utilities/printSchema.js
  var require_printSchema = __commonJS({
    "node_modules/graphql/utilities/printSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printIntrospectionSchema = printIntrospectionSchema;
      exports.printSchema = printSchema;
      exports.printType = printType;
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _blockString = require_blockString();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _astFromValue = require_astFromValue();
      function printSchema(schema) {
        return printFilteredSchema(
          schema,
          (n) => !(0, _directives.isSpecifiedDirective)(n),
          isDefinedType
        );
      }
      function printIntrospectionSchema(schema) {
        return printFilteredSchema(
          schema,
          _directives.isSpecifiedDirective,
          _introspection.isIntrospectionType
        );
      }
      function isDefinedType(type) {
        return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
      }
      function printFilteredSchema(schema, directiveFilter, typeFilter) {
        const directives = schema.getDirectives().filter(directiveFilter);
        const types = Object.values(schema.getTypeMap()).filter(typeFilter);
        return [
          printSchemaDefinition(schema),
          ...directives.map((directive) => printDirective(directive)),
          ...types.map((type) => printType(type))
        ].filter(Boolean).join("\n\n");
      }
      function printSchemaDefinition(schema) {
        if (schema.description == null && isSchemaOfCommonNames(schema)) {
          return;
        }
        const operationTypes = [];
        const queryType = schema.getQueryType();
        if (queryType) {
          operationTypes.push(`  query: ${queryType.name}`);
        }
        const mutationType = schema.getMutationType();
        if (mutationType) {
          operationTypes.push(`  mutation: ${mutationType.name}`);
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          operationTypes.push(`  subscription: ${subscriptionType.name}`);
        }
        return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
      }
      function isSchemaOfCommonNames(schema) {
        const queryType = schema.getQueryType();
        if (queryType && queryType.name !== "Query") {
          return false;
        }
        const mutationType = schema.getMutationType();
        if (mutationType && mutationType.name !== "Mutation") {
          return false;
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && subscriptionType.name !== "Subscription") {
          return false;
        }
        return true;
      }
      function printType(type) {
        if ((0, _definition.isScalarType)(type)) {
          return printScalar(type);
        }
        if ((0, _definition.isObjectType)(type)) {
          return printObject(type);
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return printInterface(type);
        }
        if ((0, _definition.isUnionType)(type)) {
          return printUnion(type);
        }
        if ((0, _definition.isEnumType)(type)) {
          return printEnum(type);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return printInputObject(type);
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
      function printScalar(type) {
        return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
      }
      function printImplementedInterfaces(type) {
        const interfaces = type.getInterfaces();
        return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
      }
      function printObject(type) {
        return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
      }
      function printInterface(type) {
        return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
      }
      function printUnion(type) {
        const types = type.getTypes();
        const possibleTypes = types.length ? " = " + types.join(" | ") : "";
        return printDescription(type) + "union " + type.name + possibleTypes;
      }
      function printEnum(type) {
        const values = type.getValues().map(
          (value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason)
        );
        return printDescription(type) + `enum ${type.name}` + printBlock(values);
      }
      function printInputObject(type) {
        const fields = Object.values(type.getFields()).map(
          (f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f)
        );
        return printDescription(type) + `input ${type.name}` + (type.isOneOf ? " @oneOf" : "") + printBlock(fields);
      }
      function printFields(type) {
        const fields = Object.values(type.getFields()).map(
          (f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason)
        );
        return printBlock(fields);
      }
      function printBlock(items) {
        return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
      }
      function printArgs(args, indentation = "") {
        if (args.length === 0) {
          return "";
        }
        if (args.every((arg) => !arg.description)) {
          return "(" + args.map(printInputValue).join(", ") + ")";
        }
        return "(\n" + args.map(
          (arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)
        ).join("\n") + "\n" + indentation + ")";
      }
      function printInputValue(arg) {
        const defaultAST = (0, _astFromValue.astFromValue)(
          arg.defaultValue,
          arg.type
        );
        let argDecl = arg.name + ": " + String(arg.type);
        if (defaultAST) {
          argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
        }
        return argDecl + printDeprecated(arg.deprecationReason);
      }
      function printDirective(directive) {
        return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
      }
      function printDeprecated(reason) {
        if (reason == null) {
          return "";
        }
        if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
          const astValue = (0, _printer.print)({
            kind: _kinds.Kind.STRING,
            value: reason
          });
          return ` @deprecated(reason: ${astValue})`;
        }
        return " @deprecated";
      }
      function printSpecifiedByURL(scalar) {
        if (scalar.specifiedByURL == null) {
          return "";
        }
        const astValue = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: scalar.specifiedByURL
        });
        return ` @specifiedBy(url: ${astValue})`;
      }
      function printDescription(def, indentation = "", firstInBlock = true) {
        const { description } = def;
        if (description == null) {
          return "";
        }
        const blockString = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: description,
          block: (0, _blockString.isPrintableAsBlockString)(description)
        });
        const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
        return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
      }
    }
  });

  // node_modules/graphql/utilities/concatAST.js
  var require_concatAST = __commonJS({
    "node_modules/graphql/utilities/concatAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.concatAST = concatAST;
      var _kinds = require_kinds();
      function concatAST(documents) {
        const definitions = [];
        for (const doc of documents) {
          definitions.push(...doc.definitions);
        }
        return {
          kind: _kinds.Kind.DOCUMENT,
          definitions
        };
      }
    }
  });

  // node_modules/graphql/utilities/separateOperations.js
  var require_separateOperations = __commonJS({
    "node_modules/graphql/utilities/separateOperations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.separateOperations = separateOperations;
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      function separateOperations(documentAST) {
        const operations = [];
        const depGraph = /* @__PURE__ */ Object.create(null);
        for (const definitionNode of documentAST.definitions) {
          switch (definitionNode.kind) {
            case _kinds.Kind.OPERATION_DEFINITION:
              operations.push(definitionNode);
              break;
            case _kinds.Kind.FRAGMENT_DEFINITION:
              depGraph[definitionNode.name.value] = collectDependencies(
                definitionNode.selectionSet
              );
              break;
            default:
          }
        }
        const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
        for (const operation of operations) {
          const dependencies = /* @__PURE__ */ new Set();
          for (const fragmentName of collectDependencies(operation.selectionSet)) {
            collectTransitiveDependencies(dependencies, depGraph, fragmentName);
          }
          const operationName = operation.name ? operation.name.value : "";
          separatedDocumentASTs[operationName] = {
            kind: _kinds.Kind.DOCUMENT,
            definitions: documentAST.definitions.filter(
              (node) => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
            )
          };
        }
        return separatedDocumentASTs;
      }
      function collectTransitiveDependencies(collected, depGraph, fromName) {
        if (!collected.has(fromName)) {
          collected.add(fromName);
          const immediateDeps = depGraph[fromName];
          if (immediateDeps !== void 0) {
            for (const toName of immediateDeps) {
              collectTransitiveDependencies(collected, depGraph, toName);
            }
          }
        }
      }
      function collectDependencies(selectionSet) {
        const dependencies = [];
        (0, _visitor.visit)(selectionSet, {
          FragmentSpread(node) {
            dependencies.push(node.name.value);
          }
        });
        return dependencies;
      }
    }
  });

  // node_modules/graphql/utilities/stripIgnoredCharacters.js
  var require_stripIgnoredCharacters = __commonJS({
    "node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stripIgnoredCharacters = stripIgnoredCharacters;
      var _blockString = require_blockString();
      var _lexer = require_lexer();
      var _source = require_source();
      var _tokenKind = require_tokenKind();
      function stripIgnoredCharacters(source) {
        const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        const body = sourceObj.body;
        const lexer = new _lexer.Lexer(sourceObj);
        let strippedBody = "";
        let wasLastAddedTokenNonPunctuator = false;
        while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
          const currentToken = lexer.token;
          const tokenKind = currentToken.kind;
          const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(
            currentToken.kind
          );
          if (wasLastAddedTokenNonPunctuator) {
            if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
              strippedBody += " ";
            }
          }
          const tokenBody = body.slice(currentToken.start, currentToken.end);
          if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
            strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
              minimize: true
            });
          } else {
            strippedBody += tokenBody;
          }
          wasLastAddedTokenNonPunctuator = isNonPunctuator;
        }
        return strippedBody;
      }
    }
  });

  // node_modules/graphql/utilities/assertValidName.js
  var require_assertValidName = __commonJS({
    "node_modules/graphql/utilities/assertValidName.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidName = assertValidName;
      exports.isValidNameError = isValidNameError;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _assertName = require_assertName();
      function assertValidName(name) {
        const error = isValidNameError(name);
        if (error) {
          throw error;
        }
        return name;
      }
      function isValidNameError(name) {
        typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
        if (name.startsWith("__")) {
          return new _GraphQLError.GraphQLError(
            `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
          );
        }
        try {
          (0, _assertName.assertName)(name);
        } catch (error) {
          return error;
        }
      }
    }
  });

  // node_modules/graphql/utilities/findBreakingChanges.js
  var require_findBreakingChanges = __commonJS({
    "node_modules/graphql/utilities/findBreakingChanges.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DangerousChangeType = exports.BreakingChangeType = void 0;
      exports.findBreakingChanges = findBreakingChanges;
      exports.findDangerousChanges = findDangerousChanges;
      var _inspect = require_inspect();
      var _invariant = require_invariant2();
      var _keyMap = require_keyMap();
      var _printer = require_printer();
      var _definition = require_definition();
      var _scalars = require_scalars();
      var _astFromValue = require_astFromValue();
      var _sortValueNode = require_sortValueNode();
      var BreakingChangeType;
      exports.BreakingChangeType = BreakingChangeType;
      (function(BreakingChangeType2) {
        BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
        BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
        BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
        BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
        BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
        BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
        BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
        BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
        BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
        BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
        BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
        BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
        BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
        BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
        BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
        BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
      })(
        BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {})
      );
      var DangerousChangeType;
      exports.DangerousChangeType = DangerousChangeType;
      (function(DangerousChangeType2) {
        DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
        DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
        DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
        DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
        DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
        DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
      })(
        DangerousChangeType || (exports.DangerousChangeType = DangerousChangeType = {})
      );
      function findBreakingChanges(oldSchema, newSchema) {
        return findSchemaChanges(oldSchema, newSchema).filter(
          (change) => change.type in BreakingChangeType
        );
      }
      function findDangerousChanges(oldSchema, newSchema) {
        return findSchemaChanges(oldSchema, newSchema).filter(
          (change) => change.type in DangerousChangeType
        );
      }
      function findSchemaChanges(oldSchema, newSchema) {
        return [
          ...findTypeChanges(oldSchema, newSchema),
          ...findDirectiveChanges(oldSchema, newSchema)
        ];
      }
      function findDirectiveChanges(oldSchema, newSchema) {
        const schemaChanges = [];
        const directivesDiff = diff(
          oldSchema.getDirectives(),
          newSchema.getDirectives()
        );
        for (const oldDirective of directivesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REMOVED,
            description: `${oldDirective.name} was removed.`
          });
        }
        for (const [oldDirective, newDirective] of directivesDiff.persisted) {
          const argsDiff = diff(oldDirective.args, newDirective.args);
          for (const newArg of argsDiff.added) {
            if ((0, _definition.isRequiredArgument)(newArg)) {
              schemaChanges.push({
                type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
                description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
              });
            }
          }
          for (const oldArg of argsDiff.removed) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
              description: `${oldArg.name} was removed from ${oldDirective.name}.`
            });
          }
          if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
              description: `Repeatable flag was removed from ${oldDirective.name}.`
            });
          }
          for (const location of oldDirective.locations) {
            if (!newDirective.locations.includes(location)) {
              schemaChanges.push({
                type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
                description: `${location} was removed from ${oldDirective.name}.`
              });
            }
          }
        }
        return schemaChanges;
      }
      function findTypeChanges(oldSchema, newSchema) {
        const schemaChanges = [];
        const typesDiff = diff(
          Object.values(oldSchema.getTypeMap()),
          Object.values(newSchema.getTypeMap())
        );
        for (const oldType of typesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_REMOVED,
            description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
          });
        }
        for (const [oldType, newType] of typesDiff.persisted) {
          if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
            schemaChanges.push(...findEnumTypeChanges(oldType, newType));
          } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
            schemaChanges.push(...findUnionTypeChanges(oldType, newType));
          } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
            schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
          } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
            schemaChanges.push(
              ...findFieldChanges(oldType, newType),
              ...findImplementedInterfacesChanges(oldType, newType)
            );
          } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
            schemaChanges.push(
              ...findFieldChanges(oldType, newType),
              ...findImplementedInterfacesChanges(oldType, newType)
            );
          } else if (oldType.constructor !== newType.constructor) {
            schemaChanges.push({
              type: BreakingChangeType.TYPE_CHANGED_KIND,
              description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findInputObjectTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const fieldsDiff = diff(
          Object.values(oldType.getFields()),
          Object.values(newType.getFields())
        );
        for (const newField of fieldsDiff.added) {
          if ((0, _definition.isRequiredInputField)(newField)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
              description: `A required field ${newField.name} on input type ${oldType.name} was added.`
            });
          } else {
            schemaChanges.push({
              type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
              description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
            });
          }
        }
        for (const oldField of fieldsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_REMOVED,
            description: `${oldType.name}.${oldField.name} was removed.`
          });
        }
        for (const [oldField, newField] of fieldsDiff.persisted) {
          const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
            oldField.type,
            newField.type
          );
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.FIELD_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findUnionTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
        for (const newPossibleType of possibleTypesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.TYPE_ADDED_TO_UNION,
            description: `${newPossibleType.name} was added to union type ${oldType.name}.`
          });
        }
        for (const oldPossibleType of possibleTypesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
            description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
          });
        }
        return schemaChanges;
      }
      function findEnumTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const valuesDiff = diff(oldType.getValues(), newType.getValues());
        for (const newValue of valuesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
            description: `${newValue.name} was added to enum type ${oldType.name}.`
          });
        }
        for (const oldValue of valuesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
            description: `${oldValue.name} was removed from enum type ${oldType.name}.`
          });
        }
        return schemaChanges;
      }
      function findImplementedInterfacesChanges(oldType, newType) {
        const schemaChanges = [];
        const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
        for (const newInterface of interfacesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
            description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
          });
        }
        for (const oldInterface of interfacesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
            description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
          });
        }
        return schemaChanges;
      }
      function findFieldChanges(oldType, newType) {
        const schemaChanges = [];
        const fieldsDiff = diff(
          Object.values(oldType.getFields()),
          Object.values(newType.getFields())
        );
        for (const oldField of fieldsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_REMOVED,
            description: `${oldType.name}.${oldField.name} was removed.`
          });
        }
        for (const [oldField, newField] of fieldsDiff.persisted) {
          schemaChanges.push(...findArgChanges(oldType, oldField, newField));
          const isSafe = isChangeSafeForObjectOrInterfaceField(
            oldField.type,
            newField.type
          );
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.FIELD_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findArgChanges(oldType, oldField, newField) {
        const schemaChanges = [];
        const argsDiff = diff(oldField.args, newField.args);
        for (const oldArg of argsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_REMOVED,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
          });
        }
        for (const [oldArg, newArg] of argsDiff.persisted) {
          const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
            oldArg.type,
            newArg.type
          );
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.ARG_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
            });
          } else if (oldArg.defaultValue !== void 0) {
            if (newArg.defaultValue === void 0) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
              });
            } else {
              const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
              const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
              if (oldValueStr !== newValueStr) {
                schemaChanges.push({
                  type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                  description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
                });
              }
            }
          }
        }
        for (const newArg of argsDiff.added) {
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_ARG_ADDED,
              description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
            });
          } else {
            schemaChanges.push({
              type: DangerousChangeType.OPTIONAL_ARG_ADDED,
              description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
            });
          }
        }
        return schemaChanges;
      }
      function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
        if ((0, _definition.isListType)(oldType)) {
          return (
            // if they're both lists, make sure the underlying types are compatible
            (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(
              oldType.ofType,
              newType.ofType
            ) || // moving from nullable to non-null of the same underlying type is safe
            (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
          );
        }
        if ((0, _definition.isNonNullType)(oldType)) {
          return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
        }
        return (
          // if they're both named types, see if their names are equivalent
          (0, _definition.isNamedType)(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
          (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
        );
      }
      function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
        if ((0, _definition.isListType)(oldType)) {
          return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
        }
        if ((0, _definition.isNonNullType)(oldType)) {
          return (
            // if they're both non-null, make sure the underlying types are
            // compatible
            (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
              oldType.ofType,
              newType.ofType
            ) || // moving from non-null to nullable of the same underlying type is safe
            !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
          );
        }
        return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
      }
      function typeKindName(type) {
        if ((0, _definition.isScalarType)(type)) {
          return "a Scalar type";
        }
        if ((0, _definition.isObjectType)(type)) {
          return "an Object type";
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return "an Interface type";
        }
        if ((0, _definition.isUnionType)(type)) {
          return "a Union type";
        }
        if ((0, _definition.isEnumType)(type)) {
          return "an Enum type";
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return "an Input type";
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
      function stringifyValue(value, type) {
        const ast = (0, _astFromValue.astFromValue)(value, type);
        ast != null || (0, _invariant.invariant)(false);
        return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
      }
      function diff(oldArray, newArray) {
        const added = [];
        const removed = [];
        const persisted = [];
        const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
        const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
        for (const oldItem of oldArray) {
          const newItem = newMap[oldItem.name];
          if (newItem === void 0) {
            removed.push(oldItem);
          } else {
            persisted.push([oldItem, newItem]);
          }
        }
        for (const newItem of newArray) {
          if (oldMap[newItem.name] === void 0) {
            added.push(newItem);
          }
        }
        return {
          added,
          persisted,
          removed
        };
      }
    }
  });

  // node_modules/graphql/utilities/index.js
  var require_utilities = __commonJS({
    "node_modules/graphql/utilities/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BreakingChangeType", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.BreakingChangeType;
        }
      });
      Object.defineProperty(exports, "DangerousChangeType", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.DangerousChangeType;
        }
      });
      Object.defineProperty(exports, "TypeInfo", {
        enumerable: true,
        get: function() {
          return _TypeInfo.TypeInfo;
        }
      });
      Object.defineProperty(exports, "assertValidName", {
        enumerable: true,
        get: function() {
          return _assertValidName.assertValidName;
        }
      });
      Object.defineProperty(exports, "astFromValue", {
        enumerable: true,
        get: function() {
          return _astFromValue.astFromValue;
        }
      });
      Object.defineProperty(exports, "buildASTSchema", {
        enumerable: true,
        get: function() {
          return _buildASTSchema.buildASTSchema;
        }
      });
      Object.defineProperty(exports, "buildClientSchema", {
        enumerable: true,
        get: function() {
          return _buildClientSchema.buildClientSchema;
        }
      });
      Object.defineProperty(exports, "buildSchema", {
        enumerable: true,
        get: function() {
          return _buildASTSchema.buildSchema;
        }
      });
      Object.defineProperty(exports, "coerceInputValue", {
        enumerable: true,
        get: function() {
          return _coerceInputValue.coerceInputValue;
        }
      });
      Object.defineProperty(exports, "concatAST", {
        enumerable: true,
        get: function() {
          return _concatAST.concatAST;
        }
      });
      Object.defineProperty(exports, "doTypesOverlap", {
        enumerable: true,
        get: function() {
          return _typeComparators.doTypesOverlap;
        }
      });
      Object.defineProperty(exports, "extendSchema", {
        enumerable: true,
        get: function() {
          return _extendSchema.extendSchema;
        }
      });
      Object.defineProperty(exports, "findBreakingChanges", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.findBreakingChanges;
        }
      });
      Object.defineProperty(exports, "findDangerousChanges", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.findDangerousChanges;
        }
      });
      Object.defineProperty(exports, "getIntrospectionQuery", {
        enumerable: true,
        get: function() {
          return _getIntrospectionQuery.getIntrospectionQuery;
        }
      });
      Object.defineProperty(exports, "getOperationAST", {
        enumerable: true,
        get: function() {
          return _getOperationAST.getOperationAST;
        }
      });
      Object.defineProperty(exports, "getOperationRootType", {
        enumerable: true,
        get: function() {
          return _getOperationRootType.getOperationRootType;
        }
      });
      Object.defineProperty(exports, "introspectionFromSchema", {
        enumerable: true,
        get: function() {
          return _introspectionFromSchema.introspectionFromSchema;
        }
      });
      Object.defineProperty(exports, "isEqualType", {
        enumerable: true,
        get: function() {
          return _typeComparators.isEqualType;
        }
      });
      Object.defineProperty(exports, "isTypeSubTypeOf", {
        enumerable: true,
        get: function() {
          return _typeComparators.isTypeSubTypeOf;
        }
      });
      Object.defineProperty(exports, "isValidNameError", {
        enumerable: true,
        get: function() {
          return _assertValidName.isValidNameError;
        }
      });
      Object.defineProperty(exports, "lexicographicSortSchema", {
        enumerable: true,
        get: function() {
          return _lexicographicSortSchema.lexicographicSortSchema;
        }
      });
      Object.defineProperty(exports, "printIntrospectionSchema", {
        enumerable: true,
        get: function() {
          return _printSchema.printIntrospectionSchema;
        }
      });
      Object.defineProperty(exports, "printSchema", {
        enumerable: true,
        get: function() {
          return _printSchema.printSchema;
        }
      });
      Object.defineProperty(exports, "printType", {
        enumerable: true,
        get: function() {
          return _printSchema.printType;
        }
      });
      Object.defineProperty(exports, "separateOperations", {
        enumerable: true,
        get: function() {
          return _separateOperations.separateOperations;
        }
      });
      Object.defineProperty(exports, "stripIgnoredCharacters", {
        enumerable: true,
        get: function() {
          return _stripIgnoredCharacters.stripIgnoredCharacters;
        }
      });
      Object.defineProperty(exports, "typeFromAST", {
        enumerable: true,
        get: function() {
          return _typeFromAST.typeFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromAST", {
        enumerable: true,
        get: function() {
          return _valueFromAST.valueFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromASTUntyped", {
        enumerable: true,
        get: function() {
          return _valueFromASTUntyped.valueFromASTUntyped;
        }
      });
      Object.defineProperty(exports, "visitWithTypeInfo", {
        enumerable: true,
        get: function() {
          return _TypeInfo.visitWithTypeInfo;
        }
      });
      var _getIntrospectionQuery = require_getIntrospectionQuery();
      var _getOperationAST = require_getOperationAST();
      var _getOperationRootType = require_getOperationRootType();
      var _introspectionFromSchema = require_introspectionFromSchema();
      var _buildClientSchema = require_buildClientSchema();
      var _buildASTSchema = require_buildASTSchema();
      var _extendSchema = require_extendSchema();
      var _lexicographicSortSchema = require_lexicographicSortSchema();
      var _printSchema = require_printSchema();
      var _typeFromAST = require_typeFromAST();
      var _valueFromAST = require_valueFromAST();
      var _valueFromASTUntyped = require_valueFromASTUntyped();
      var _astFromValue = require_astFromValue();
      var _TypeInfo = require_TypeInfo();
      var _coerceInputValue = require_coerceInputValue();
      var _concatAST = require_concatAST();
      var _separateOperations = require_separateOperations();
      var _stripIgnoredCharacters = require_stripIgnoredCharacters();
      var _typeComparators = require_typeComparators();
      var _assertValidName = require_assertValidName();
      var _findBreakingChanges = require_findBreakingChanges();
    }
  });

  // node_modules/graphql/index.js
  var require_graphql2 = __commonJS({
    "node_modules/graphql/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BREAK", {
        enumerable: true,
        get: function() {
          return _index2.BREAK;
        }
      });
      Object.defineProperty(exports, "BreakingChangeType", {
        enumerable: true,
        get: function() {
          return _index6.BreakingChangeType;
        }
      });
      Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
        enumerable: true,
        get: function() {
          return _index.DEFAULT_DEPRECATION_REASON;
        }
      });
      Object.defineProperty(exports, "DangerousChangeType", {
        enumerable: true,
        get: function() {
          return _index6.DangerousChangeType;
        }
      });
      Object.defineProperty(exports, "DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _index2.DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "ExecutableDefinitionsRule", {
        enumerable: true,
        get: function() {
          return _index4.ExecutableDefinitionsRule;
        }
      });
      Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _index4.FieldsOnCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.FragmentsOnCompositeTypesRule;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
        enumerable: true,
        get: function() {
          return _index.GRAPHQL_MAX_INT;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
        enumerable: true,
        get: function() {
          return _index.GRAPHQL_MIN_INT;
        }
      });
      Object.defineProperty(exports, "GraphQLBoolean", {
        enumerable: true,
        get: function() {
          return _index.GraphQLBoolean;
        }
      });
      Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLDeprecatedDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLEnumType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLEnumType;
        }
      });
      Object.defineProperty(exports, "GraphQLError", {
        enumerable: true,
        get: function() {
          return _index5.GraphQLError;
        }
      });
      Object.defineProperty(exports, "GraphQLFloat", {
        enumerable: true,
        get: function() {
          return _index.GraphQLFloat;
        }
      });
      Object.defineProperty(exports, "GraphQLID", {
        enumerable: true,
        get: function() {
          return _index.GraphQLID;
        }
      });
      Object.defineProperty(exports, "GraphQLIncludeDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLIncludeDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInputObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLInt", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInt;
        }
      });
      Object.defineProperty(exports, "GraphQLInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInterfaceType;
        }
      });
      Object.defineProperty(exports, "GraphQLList", {
        enumerable: true,
        get: function() {
          return _index.GraphQLList;
        }
      });
      Object.defineProperty(exports, "GraphQLNonNull", {
        enumerable: true,
        get: function() {
          return _index.GraphQLNonNull;
        }
      });
      Object.defineProperty(exports, "GraphQLObjectType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLOneOfDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLOneOfDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLScalarType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLScalarType;
        }
      });
      Object.defineProperty(exports, "GraphQLSchema", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSchema;
        }
      });
      Object.defineProperty(exports, "GraphQLSkipDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSkipDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSpecifiedByDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLString", {
        enumerable: true,
        get: function() {
          return _index.GraphQLString;
        }
      });
      Object.defineProperty(exports, "GraphQLUnionType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLUnionType;
        }
      });
      Object.defineProperty(exports, "Kind", {
        enumerable: true,
        get: function() {
          return _index2.Kind;
        }
      });
      Object.defineProperty(exports, "KnownArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownDirectivesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownDirectivesRule;
        }
      });
      Object.defineProperty(exports, "KnownFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "Lexer", {
        enumerable: true,
        get: function() {
          return _index2.Lexer;
        }
      });
      Object.defineProperty(exports, "Location", {
        enumerable: true,
        get: function() {
          return _index2.Location;
        }
      });
      Object.defineProperty(exports, "LoneAnonymousOperationRule", {
        enumerable: true,
        get: function() {
          return _index4.LoneAnonymousOperationRule;
        }
      });
      Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
        enumerable: true,
        get: function() {
          return _index4.LoneSchemaDefinitionRule;
        }
      });
      Object.defineProperty(exports, "MaxIntrospectionDepthRule", {
        enumerable: true,
        get: function() {
          return _index4.MaxIntrospectionDepthRule;
        }
      });
      Object.defineProperty(exports, "NoDeprecatedCustomRule", {
        enumerable: true,
        get: function() {
          return _index4.NoDeprecatedCustomRule;
        }
      });
      Object.defineProperty(exports, "NoFragmentCyclesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoFragmentCyclesRule;
        }
      });
      Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
        enumerable: true,
        get: function() {
          return _index4.NoSchemaIntrospectionCustomRule;
        }
      });
      Object.defineProperty(exports, "NoUndefinedVariablesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUndefinedVariablesRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedFragmentsRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUnusedFragmentsRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedVariablesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUnusedVariablesRule;
        }
      });
      Object.defineProperty(exports, "OperationTypeNode", {
        enumerable: true,
        get: function() {
          return _index2.OperationTypeNode;
        }
      });
      Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
        enumerable: true,
        get: function() {
          return _index4.OverlappingFieldsCanBeMergedRule;
        }
      });
      Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
        enumerable: true,
        get: function() {
          return _index4.PossibleFragmentSpreadsRule;
        }
      });
      Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
        enumerable: true,
        get: function() {
          return _index4.PossibleTypeExtensionsRule;
        }
      });
      Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
        enumerable: true,
        get: function() {
          return _index4.ProvidedRequiredArgumentsRule;
        }
      });
      Object.defineProperty(exports, "ScalarLeafsRule", {
        enumerable: true,
        get: function() {
          return _index4.ScalarLeafsRule;
        }
      });
      Object.defineProperty(exports, "SchemaMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.SchemaMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
        enumerable: true,
        get: function() {
          return _index4.SingleFieldSubscriptionsRule;
        }
      });
      Object.defineProperty(exports, "Source", {
        enumerable: true,
        get: function() {
          return _index2.Source;
        }
      });
      Object.defineProperty(exports, "Token", {
        enumerable: true,
        get: function() {
          return _index2.Token;
        }
      });
      Object.defineProperty(exports, "TokenKind", {
        enumerable: true,
        get: function() {
          return _index2.TokenKind;
        }
      });
      Object.defineProperty(exports, "TypeInfo", {
        enumerable: true,
        get: function() {
          return _index6.TypeInfo;
        }
      });
      Object.defineProperty(exports, "TypeKind", {
        enumerable: true,
        get: function() {
          return _index.TypeKind;
        }
      });
      Object.defineProperty(exports, "TypeMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.TypeMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeNameMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.TypeNameMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueArgumentDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueDirectiveNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueDirectivesPerLocationRule;
        }
      });
      Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueEnumValueNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueFieldDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueInputFieldNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueOperationNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueOperationTypesRule;
        }
      });
      Object.defineProperty(exports, "UniqueTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueVariableNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueVariableNamesRule;
        }
      });
      Object.defineProperty(exports, "ValidationContext", {
        enumerable: true,
        get: function() {
          return _index4.ValidationContext;
        }
      });
      Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _index4.ValuesOfCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "VariablesAreInputTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.VariablesAreInputTypesRule;
        }
      });
      Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
        enumerable: true,
        get: function() {
          return _index4.VariablesInAllowedPositionRule;
        }
      });
      Object.defineProperty(exports, "__Directive", {
        enumerable: true,
        get: function() {
          return _index.__Directive;
        }
      });
      Object.defineProperty(exports, "__DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _index.__DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "__EnumValue", {
        enumerable: true,
        get: function() {
          return _index.__EnumValue;
        }
      });
      Object.defineProperty(exports, "__Field", {
        enumerable: true,
        get: function() {
          return _index.__Field;
        }
      });
      Object.defineProperty(exports, "__InputValue", {
        enumerable: true,
        get: function() {
          return _index.__InputValue;
        }
      });
      Object.defineProperty(exports, "__Schema", {
        enumerable: true,
        get: function() {
          return _index.__Schema;
        }
      });
      Object.defineProperty(exports, "__Type", {
        enumerable: true,
        get: function() {
          return _index.__Type;
        }
      });
      Object.defineProperty(exports, "__TypeKind", {
        enumerable: true,
        get: function() {
          return _index.__TypeKind;
        }
      });
      Object.defineProperty(exports, "assertAbstractType", {
        enumerable: true,
        get: function() {
          return _index.assertAbstractType;
        }
      });
      Object.defineProperty(exports, "assertCompositeType", {
        enumerable: true,
        get: function() {
          return _index.assertCompositeType;
        }
      });
      Object.defineProperty(exports, "assertDirective", {
        enumerable: true,
        get: function() {
          return _index.assertDirective;
        }
      });
      Object.defineProperty(exports, "assertEnumType", {
        enumerable: true,
        get: function() {
          return _index.assertEnumType;
        }
      });
      Object.defineProperty(exports, "assertEnumValueName", {
        enumerable: true,
        get: function() {
          return _index.assertEnumValueName;
        }
      });
      Object.defineProperty(exports, "assertInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.assertInputObjectType;
        }
      });
      Object.defineProperty(exports, "assertInputType", {
        enumerable: true,
        get: function() {
          return _index.assertInputType;
        }
      });
      Object.defineProperty(exports, "assertInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.assertInterfaceType;
        }
      });
      Object.defineProperty(exports, "assertLeafType", {
        enumerable: true,
        get: function() {
          return _index.assertLeafType;
        }
      });
      Object.defineProperty(exports, "assertListType", {
        enumerable: true,
        get: function() {
          return _index.assertListType;
        }
      });
      Object.defineProperty(exports, "assertName", {
        enumerable: true,
        get: function() {
          return _index.assertName;
        }
      });
      Object.defineProperty(exports, "assertNamedType", {
        enumerable: true,
        get: function() {
          return _index.assertNamedType;
        }
      });
      Object.defineProperty(exports, "assertNonNullType", {
        enumerable: true,
        get: function() {
          return _index.assertNonNullType;
        }
      });
      Object.defineProperty(exports, "assertNullableType", {
        enumerable: true,
        get: function() {
          return _index.assertNullableType;
        }
      });
      Object.defineProperty(exports, "assertObjectType", {
        enumerable: true,
        get: function() {
          return _index.assertObjectType;
        }
      });
      Object.defineProperty(exports, "assertOutputType", {
        enumerable: true,
        get: function() {
          return _index.assertOutputType;
        }
      });
      Object.defineProperty(exports, "assertScalarType", {
        enumerable: true,
        get: function() {
          return _index.assertScalarType;
        }
      });
      Object.defineProperty(exports, "assertSchema", {
        enumerable: true,
        get: function() {
          return _index.assertSchema;
        }
      });
      Object.defineProperty(exports, "assertType", {
        enumerable: true,
        get: function() {
          return _index.assertType;
        }
      });
      Object.defineProperty(exports, "assertUnionType", {
        enumerable: true,
        get: function() {
          return _index.assertUnionType;
        }
      });
      Object.defineProperty(exports, "assertValidName", {
        enumerable: true,
        get: function() {
          return _index6.assertValidName;
        }
      });
      Object.defineProperty(exports, "assertValidSchema", {
        enumerable: true,
        get: function() {
          return _index.assertValidSchema;
        }
      });
      Object.defineProperty(exports, "assertWrappingType", {
        enumerable: true,
        get: function() {
          return _index.assertWrappingType;
        }
      });
      Object.defineProperty(exports, "astFromValue", {
        enumerable: true,
        get: function() {
          return _index6.astFromValue;
        }
      });
      Object.defineProperty(exports, "buildASTSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildASTSchema;
        }
      });
      Object.defineProperty(exports, "buildClientSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildClientSchema;
        }
      });
      Object.defineProperty(exports, "buildSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildSchema;
        }
      });
      Object.defineProperty(exports, "coerceInputValue", {
        enumerable: true,
        get: function() {
          return _index6.coerceInputValue;
        }
      });
      Object.defineProperty(exports, "concatAST", {
        enumerable: true,
        get: function() {
          return _index6.concatAST;
        }
      });
      Object.defineProperty(exports, "createSourceEventStream", {
        enumerable: true,
        get: function() {
          return _index3.createSourceEventStream;
        }
      });
      Object.defineProperty(exports, "defaultFieldResolver", {
        enumerable: true,
        get: function() {
          return _index3.defaultFieldResolver;
        }
      });
      Object.defineProperty(exports, "defaultTypeResolver", {
        enumerable: true,
        get: function() {
          return _index3.defaultTypeResolver;
        }
      });
      Object.defineProperty(exports, "doTypesOverlap", {
        enumerable: true,
        get: function() {
          return _index6.doTypesOverlap;
        }
      });
      Object.defineProperty(exports, "execute", {
        enumerable: true,
        get: function() {
          return _index3.execute;
        }
      });
      Object.defineProperty(exports, "executeSync", {
        enumerable: true,
        get: function() {
          return _index3.executeSync;
        }
      });
      Object.defineProperty(exports, "extendSchema", {
        enumerable: true,
        get: function() {
          return _index6.extendSchema;
        }
      });
      Object.defineProperty(exports, "findBreakingChanges", {
        enumerable: true,
        get: function() {
          return _index6.findBreakingChanges;
        }
      });
      Object.defineProperty(exports, "findDangerousChanges", {
        enumerable: true,
        get: function() {
          return _index6.findDangerousChanges;
        }
      });
      Object.defineProperty(exports, "formatError", {
        enumerable: true,
        get: function() {
          return _index5.formatError;
        }
      });
      Object.defineProperty(exports, "getArgumentValues", {
        enumerable: true,
        get: function() {
          return _index3.getArgumentValues;
        }
      });
      Object.defineProperty(exports, "getDirectiveValues", {
        enumerable: true,
        get: function() {
          return _index3.getDirectiveValues;
        }
      });
      Object.defineProperty(exports, "getEnterLeaveForKind", {
        enumerable: true,
        get: function() {
          return _index2.getEnterLeaveForKind;
        }
      });
      Object.defineProperty(exports, "getIntrospectionQuery", {
        enumerable: true,
        get: function() {
          return _index6.getIntrospectionQuery;
        }
      });
      Object.defineProperty(exports, "getLocation", {
        enumerable: true,
        get: function() {
          return _index2.getLocation;
        }
      });
      Object.defineProperty(exports, "getNamedType", {
        enumerable: true,
        get: function() {
          return _index.getNamedType;
        }
      });
      Object.defineProperty(exports, "getNullableType", {
        enumerable: true,
        get: function() {
          return _index.getNullableType;
        }
      });
      Object.defineProperty(exports, "getOperationAST", {
        enumerable: true,
        get: function() {
          return _index6.getOperationAST;
        }
      });
      Object.defineProperty(exports, "getOperationRootType", {
        enumerable: true,
        get: function() {
          return _index6.getOperationRootType;
        }
      });
      Object.defineProperty(exports, "getVariableValues", {
        enumerable: true,
        get: function() {
          return _index3.getVariableValues;
        }
      });
      Object.defineProperty(exports, "getVisitFn", {
        enumerable: true,
        get: function() {
          return _index2.getVisitFn;
        }
      });
      Object.defineProperty(exports, "graphql", {
        enumerable: true,
        get: function() {
          return _graphql.graphql;
        }
      });
      Object.defineProperty(exports, "graphqlSync", {
        enumerable: true,
        get: function() {
          return _graphql.graphqlSync;
        }
      });
      Object.defineProperty(exports, "introspectionFromSchema", {
        enumerable: true,
        get: function() {
          return _index6.introspectionFromSchema;
        }
      });
      Object.defineProperty(exports, "introspectionTypes", {
        enumerable: true,
        get: function() {
          return _index.introspectionTypes;
        }
      });
      Object.defineProperty(exports, "isAbstractType", {
        enumerable: true,
        get: function() {
          return _index.isAbstractType;
        }
      });
      Object.defineProperty(exports, "isCompositeType", {
        enumerable: true,
        get: function() {
          return _index.isCompositeType;
        }
      });
      Object.defineProperty(exports, "isConstValueNode", {
        enumerable: true,
        get: function() {
          return _index2.isConstValueNode;
        }
      });
      Object.defineProperty(exports, "isDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isDirective", {
        enumerable: true,
        get: function() {
          return _index.isDirective;
        }
      });
      Object.defineProperty(exports, "isEnumType", {
        enumerable: true,
        get: function() {
          return _index.isEnumType;
        }
      });
      Object.defineProperty(exports, "isEqualType", {
        enumerable: true,
        get: function() {
          return _index6.isEqualType;
        }
      });
      Object.defineProperty(exports, "isExecutableDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isExecutableDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.isInputObjectType;
        }
      });
      Object.defineProperty(exports, "isInputType", {
        enumerable: true,
        get: function() {
          return _index.isInputType;
        }
      });
      Object.defineProperty(exports, "isInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.isInterfaceType;
        }
      });
      Object.defineProperty(exports, "isIntrospectionType", {
        enumerable: true,
        get: function() {
          return _index.isIntrospectionType;
        }
      });
      Object.defineProperty(exports, "isLeafType", {
        enumerable: true,
        get: function() {
          return _index.isLeafType;
        }
      });
      Object.defineProperty(exports, "isListType", {
        enumerable: true,
        get: function() {
          return _index.isListType;
        }
      });
      Object.defineProperty(exports, "isNamedType", {
        enumerable: true,
        get: function() {
          return _index.isNamedType;
        }
      });
      Object.defineProperty(exports, "isNonNullType", {
        enumerable: true,
        get: function() {
          return _index.isNonNullType;
        }
      });
      Object.defineProperty(exports, "isNullableType", {
        enumerable: true,
        get: function() {
          return _index.isNullableType;
        }
      });
      Object.defineProperty(exports, "isObjectType", {
        enumerable: true,
        get: function() {
          return _index.isObjectType;
        }
      });
      Object.defineProperty(exports, "isOutputType", {
        enumerable: true,
        get: function() {
          return _index.isOutputType;
        }
      });
      Object.defineProperty(exports, "isRequiredArgument", {
        enumerable: true,
        get: function() {
          return _index.isRequiredArgument;
        }
      });
      Object.defineProperty(exports, "isRequiredInputField", {
        enumerable: true,
        get: function() {
          return _index.isRequiredInputField;
        }
      });
      Object.defineProperty(exports, "isScalarType", {
        enumerable: true,
        get: function() {
          return _index.isScalarType;
        }
      });
      Object.defineProperty(exports, "isSchema", {
        enumerable: true,
        get: function() {
          return _index.isSchema;
        }
      });
      Object.defineProperty(exports, "isSelectionNode", {
        enumerable: true,
        get: function() {
          return _index2.isSelectionNode;
        }
      });
      Object.defineProperty(exports, "isSpecifiedDirective", {
        enumerable: true,
        get: function() {
          return _index.isSpecifiedDirective;
        }
      });
      Object.defineProperty(exports, "isSpecifiedScalarType", {
        enumerable: true,
        get: function() {
          return _index.isSpecifiedScalarType;
        }
      });
      Object.defineProperty(exports, "isType", {
        enumerable: true,
        get: function() {
          return _index.isType;
        }
      });
      Object.defineProperty(exports, "isTypeDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeExtensionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeExtensionNode;
        }
      });
      Object.defineProperty(exports, "isTypeNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeNode;
        }
      });
      Object.defineProperty(exports, "isTypeSubTypeOf", {
        enumerable: true,
        get: function() {
          return _index6.isTypeSubTypeOf;
        }
      });
      Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeSystemDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemExtensionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeSystemExtensionNode;
        }
      });
      Object.defineProperty(exports, "isUnionType", {
        enumerable: true,
        get: function() {
          return _index.isUnionType;
        }
      });
      Object.defineProperty(exports, "isValidNameError", {
        enumerable: true,
        get: function() {
          return _index6.isValidNameError;
        }
      });
      Object.defineProperty(exports, "isValueNode", {
        enumerable: true,
        get: function() {
          return _index2.isValueNode;
        }
      });
      Object.defineProperty(exports, "isWrappingType", {
        enumerable: true,
        get: function() {
          return _index.isWrappingType;
        }
      });
      Object.defineProperty(exports, "lexicographicSortSchema", {
        enumerable: true,
        get: function() {
          return _index6.lexicographicSortSchema;
        }
      });
      Object.defineProperty(exports, "locatedError", {
        enumerable: true,
        get: function() {
          return _index5.locatedError;
        }
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function() {
          return _index2.parse;
        }
      });
      Object.defineProperty(exports, "parseConstValue", {
        enumerable: true,
        get: function() {
          return _index2.parseConstValue;
        }
      });
      Object.defineProperty(exports, "parseType", {
        enumerable: true,
        get: function() {
          return _index2.parseType;
        }
      });
      Object.defineProperty(exports, "parseValue", {
        enumerable: true,
        get: function() {
          return _index2.parseValue;
        }
      });
      Object.defineProperty(exports, "print", {
        enumerable: true,
        get: function() {
          return _index2.print;
        }
      });
      Object.defineProperty(exports, "printError", {
        enumerable: true,
        get: function() {
          return _index5.printError;
        }
      });
      Object.defineProperty(exports, "printIntrospectionSchema", {
        enumerable: true,
        get: function() {
          return _index6.printIntrospectionSchema;
        }
      });
      Object.defineProperty(exports, "printLocation", {
        enumerable: true,
        get: function() {
          return _index2.printLocation;
        }
      });
      Object.defineProperty(exports, "printSchema", {
        enumerable: true,
        get: function() {
          return _index6.printSchema;
        }
      });
      Object.defineProperty(exports, "printSourceLocation", {
        enumerable: true,
        get: function() {
          return _index2.printSourceLocation;
        }
      });
      Object.defineProperty(exports, "printType", {
        enumerable: true,
        get: function() {
          return _index6.printType;
        }
      });
      Object.defineProperty(exports, "recommendedRules", {
        enumerable: true,
        get: function() {
          return _index4.recommendedRules;
        }
      });
      Object.defineProperty(exports, "resolveObjMapThunk", {
        enumerable: true,
        get: function() {
          return _index.resolveObjMapThunk;
        }
      });
      Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
        enumerable: true,
        get: function() {
          return _index.resolveReadonlyArrayThunk;
        }
      });
      Object.defineProperty(exports, "responsePathAsArray", {
        enumerable: true,
        get: function() {
          return _index3.responsePathAsArray;
        }
      });
      Object.defineProperty(exports, "separateOperations", {
        enumerable: true,
        get: function() {
          return _index6.separateOperations;
        }
      });
      Object.defineProperty(exports, "specifiedDirectives", {
        enumerable: true,
        get: function() {
          return _index.specifiedDirectives;
        }
      });
      Object.defineProperty(exports, "specifiedRules", {
        enumerable: true,
        get: function() {
          return _index4.specifiedRules;
        }
      });
      Object.defineProperty(exports, "specifiedScalarTypes", {
        enumerable: true,
        get: function() {
          return _index.specifiedScalarTypes;
        }
      });
      Object.defineProperty(exports, "stripIgnoredCharacters", {
        enumerable: true,
        get: function() {
          return _index6.stripIgnoredCharacters;
        }
      });
      Object.defineProperty(exports, "subscribe", {
        enumerable: true,
        get: function() {
          return _index3.subscribe;
        }
      });
      Object.defineProperty(exports, "syntaxError", {
        enumerable: true,
        get: function() {
          return _index5.syntaxError;
        }
      });
      Object.defineProperty(exports, "typeFromAST", {
        enumerable: true,
        get: function() {
          return _index6.typeFromAST;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function() {
          return _index4.validate;
        }
      });
      Object.defineProperty(exports, "validateSchema", {
        enumerable: true,
        get: function() {
          return _index.validateSchema;
        }
      });
      Object.defineProperty(exports, "valueFromAST", {
        enumerable: true,
        get: function() {
          return _index6.valueFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromASTUntyped", {
        enumerable: true,
        get: function() {
          return _index6.valueFromASTUntyped;
        }
      });
      Object.defineProperty(exports, "version", {
        enumerable: true,
        get: function() {
          return _version.version;
        }
      });
      Object.defineProperty(exports, "versionInfo", {
        enumerable: true,
        get: function() {
          return _version.versionInfo;
        }
      });
      Object.defineProperty(exports, "visit", {
        enumerable: true,
        get: function() {
          return _index2.visit;
        }
      });
      Object.defineProperty(exports, "visitInParallel", {
        enumerable: true,
        get: function() {
          return _index2.visitInParallel;
        }
      });
      Object.defineProperty(exports, "visitWithTypeInfo", {
        enumerable: true,
        get: function() {
          return _index6.visitWithTypeInfo;
        }
      });
      var _version = require_version();
      var _graphql = require_graphql();
      var _index = require_type();
      var _index2 = require_language();
      var _index3 = require_execution();
      var _index4 = require_validation();
      var _index5 = require_error();
      var _index6 = require_utilities();
    }
  });

  // node_modules/@wry/trie/lib/bundle.cjs
  var require_bundle = __commonJS({
    "node_modules/@wry/trie/lib/bundle.cjs"(exports) {
      "use strict";
      var defaultMakeData = function() {
        return /* @__PURE__ */ Object.create(null);
      };
      var _a = Array.prototype;
      var forEach = _a.forEach;
      var slice = _a.slice;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var Trie = (
        /** @class */
        function() {
          function Trie2(weakness, makeData) {
            if (weakness === void 0) {
              weakness = true;
            }
            if (makeData === void 0) {
              makeData = defaultMakeData;
            }
            this.weakness = weakness;
            this.makeData = makeData;
          }
          Trie2.prototype.lookup = function() {
            return this.lookupArray(arguments);
          };
          Trie2.prototype.lookupArray = function(array) {
            var node = this;
            forEach.call(array, function(key) {
              return node = node.getChildTrie(key);
            });
            return hasOwnProperty.call(node, "data") ? node.data : node.data = this.makeData(slice.call(array));
          };
          Trie2.prototype.peek = function() {
            return this.peekArray(arguments);
          };
          Trie2.prototype.peekArray = function(array) {
            var node = this;
            for (var i = 0, len = array.length; node && i < len; ++i) {
              var map = node.mapFor(array[i], false);
              node = map && map.get(array[i]);
            }
            return node && node.data;
          };
          Trie2.prototype.remove = function() {
            return this.removeArray(arguments);
          };
          Trie2.prototype.removeArray = function(array) {
            var data;
            if (array.length) {
              var head = array[0];
              var map = this.mapFor(head, false);
              var child = map && map.get(head);
              if (child) {
                data = child.removeArray(slice.call(array, 1));
                if (!child.data && !child.weak && !(child.strong && child.strong.size)) {
                  map.delete(head);
                }
              }
            } else {
              data = this.data;
              delete this.data;
            }
            return data;
          };
          Trie2.prototype.getChildTrie = function(key) {
            var map = this.mapFor(key, true);
            var child = map.get(key);
            if (!child)
              map.set(key, child = new Trie2(this.weakness, this.makeData));
            return child;
          };
          Trie2.prototype.mapFor = function(key, create) {
            return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (create ? this.strong = /* @__PURE__ */ new Map() : void 0);
          };
          return Trie2;
        }()
      );
      function isObjRef(value) {
        switch (typeof value) {
          case "object":
            if (value === null)
              break;
          // Fall through to return true...
          case "function":
            return true;
        }
        return false;
      }
      exports.Trie = Trie;
    }
  });

  // node_modules/@wry/caches/lib/bundle.cjs
  var require_bundle2 = __commonJS({
    "node_modules/@wry/caches/lib/bundle.cjs"(exports) {
      "use strict";
      function defaultDispose$1() {
      }
      var StrongCache = (
        /** @class */
        function() {
          function StrongCache2(max, dispose) {
            if (max === void 0) {
              max = Infinity;
            }
            if (dispose === void 0) {
              dispose = defaultDispose$1;
            }
            this.max = max;
            this.dispose = dispose;
            this.map = /* @__PURE__ */ new Map();
            this.newest = null;
            this.oldest = null;
          }
          StrongCache2.prototype.has = function(key) {
            return this.map.has(key);
          };
          StrongCache2.prototype.get = function(key) {
            var node = this.getNode(key);
            return node && node.value;
          };
          Object.defineProperty(StrongCache2.prototype, "size", {
            get: function() {
              return this.map.size;
            },
            enumerable: false,
            configurable: true
          });
          StrongCache2.prototype.getNode = function(key) {
            var node = this.map.get(key);
            if (node && node !== this.newest) {
              var older = node.older, newer = node.newer;
              if (newer) {
                newer.older = older;
              }
              if (older) {
                older.newer = newer;
              }
              node.older = this.newest;
              node.older.newer = node;
              node.newer = null;
              this.newest = node;
              if (node === this.oldest) {
                this.oldest = newer;
              }
            }
            return node;
          };
          StrongCache2.prototype.set = function(key, value) {
            var node = this.getNode(key);
            if (node) {
              return node.value = value;
            }
            node = {
              key,
              value,
              newer: null,
              older: this.newest
            };
            if (this.newest) {
              this.newest.newer = node;
            }
            this.newest = node;
            this.oldest = this.oldest || node;
            this.map.set(key, node);
            return node.value;
          };
          StrongCache2.prototype.clean = function() {
            while (this.oldest && this.map.size > this.max) {
              this.delete(this.oldest.key);
            }
          };
          StrongCache2.prototype.delete = function(key) {
            var node = this.map.get(key);
            if (node) {
              if (node === this.newest) {
                this.newest = node.older;
              }
              if (node === this.oldest) {
                this.oldest = node.newer;
              }
              if (node.newer) {
                node.newer.older = node.older;
              }
              if (node.older) {
                node.older.newer = node.newer;
              }
              this.map.delete(key);
              this.dispose(node.value, key);
              return true;
            }
            return false;
          };
          return StrongCache2;
        }()
      );
      function noop() {
      }
      var defaultDispose = noop;
      var _WeakRef = typeof WeakRef !== "undefined" ? WeakRef : function(value) {
        return { deref: function() {
          return value;
        } };
      };
      var _WeakMap = typeof WeakMap !== "undefined" ? WeakMap : Map;
      var _FinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : function() {
        return {
          register: noop,
          unregister: noop
        };
      };
      var finalizationBatchSize = 10024;
      var WeakCache = (
        /** @class */
        function() {
          function WeakCache2(max, dispose) {
            if (max === void 0) {
              max = Infinity;
            }
            if (dispose === void 0) {
              dispose = defaultDispose;
            }
            var _this = this;
            this.max = max;
            this.dispose = dispose;
            this.map = new _WeakMap();
            this.newest = null;
            this.oldest = null;
            this.unfinalizedNodes = /* @__PURE__ */ new Set();
            this.finalizationScheduled = false;
            this.size = 0;
            this.finalize = function() {
              var iterator = _this.unfinalizedNodes.values();
              for (var i = 0; i < finalizationBatchSize; i++) {
                var node = iterator.next().value;
                if (!node)
                  break;
                _this.unfinalizedNodes.delete(node);
                var key = node.key;
                delete node.key;
                node.keyRef = new _WeakRef(key);
                _this.registry.register(key, node, node);
              }
              if (_this.unfinalizedNodes.size > 0) {
                queueMicrotask(_this.finalize);
              } else {
                _this.finalizationScheduled = false;
              }
            };
            this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));
          }
          WeakCache2.prototype.has = function(key) {
            return this.map.has(key);
          };
          WeakCache2.prototype.get = function(key) {
            var node = this.getNode(key);
            return node && node.value;
          };
          WeakCache2.prototype.getNode = function(key) {
            var node = this.map.get(key);
            if (node && node !== this.newest) {
              var older = node.older, newer = node.newer;
              if (newer) {
                newer.older = older;
              }
              if (older) {
                older.newer = newer;
              }
              node.older = this.newest;
              node.older.newer = node;
              node.newer = null;
              this.newest = node;
              if (node === this.oldest) {
                this.oldest = newer;
              }
            }
            return node;
          };
          WeakCache2.prototype.set = function(key, value) {
            var node = this.getNode(key);
            if (node) {
              return node.value = value;
            }
            node = {
              key,
              value,
              newer: null,
              older: this.newest
            };
            if (this.newest) {
              this.newest.newer = node;
            }
            this.newest = node;
            this.oldest = this.oldest || node;
            this.scheduleFinalization(node);
            this.map.set(key, node);
            this.size++;
            return node.value;
          };
          WeakCache2.prototype.clean = function() {
            while (this.oldest && this.size > this.max) {
              this.deleteNode(this.oldest);
            }
          };
          WeakCache2.prototype.deleteNode = function(node) {
            if (node === this.newest) {
              this.newest = node.older;
            }
            if (node === this.oldest) {
              this.oldest = node.newer;
            }
            if (node.newer) {
              node.newer.older = node.older;
            }
            if (node.older) {
              node.older.newer = node.newer;
            }
            this.size--;
            var key = node.key || node.keyRef && node.keyRef.deref();
            this.dispose(node.value, key);
            if (!node.keyRef) {
              this.unfinalizedNodes.delete(node);
            } else {
              this.registry.unregister(node);
            }
            if (key)
              this.map.delete(key);
          };
          WeakCache2.prototype.delete = function(key) {
            var node = this.map.get(key);
            if (node) {
              this.deleteNode(node);
              return true;
            }
            return false;
          };
          WeakCache2.prototype.scheduleFinalization = function(node) {
            this.unfinalizedNodes.add(node);
            if (!this.finalizationScheduled) {
              this.finalizationScheduled = true;
              queueMicrotask(this.finalize);
            }
          };
          return WeakCache2;
        }()
      );
      exports.StrongCache = StrongCache;
      exports.WeakCache = WeakCache;
    }
  });

  // node_modules/@wry/context/lib/bundle.cjs
  var require_bundle3 = __commonJS({
    "node_modules/@wry/context/lib/bundle.cjs"(exports) {
      "use strict";
      var currentContext = null;
      var MISSING_VALUE = {};
      var idCounter = 1;
      var makeSlotClass = function() {
        return (
          /** @class */
          function() {
            function Slot2() {
              this.id = [
                "slot",
                idCounter++,
                Date.now(),
                Math.random().toString(36).slice(2)
              ].join(":");
            }
            Slot2.prototype.hasValue = function() {
              for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
                if (this.id in context_1.slots) {
                  var value = context_1.slots[this.id];
                  if (value === MISSING_VALUE)
                    break;
                  if (context_1 !== currentContext) {
                    currentContext.slots[this.id] = value;
                  }
                  return true;
                }
              }
              if (currentContext) {
                currentContext.slots[this.id] = MISSING_VALUE;
              }
              return false;
            };
            Slot2.prototype.getValue = function() {
              if (this.hasValue()) {
                return currentContext.slots[this.id];
              }
            };
            Slot2.prototype.withValue = function(value, callback, args, thisArg) {
              var _a;
              var slots = (_a = {
                __proto__: null
              }, _a[this.id] = value, _a);
              var parent = currentContext;
              currentContext = { parent, slots };
              try {
                return callback.apply(thisArg, args);
              } finally {
                currentContext = parent;
              }
            };
            Slot2.bind = function(callback) {
              var context2 = currentContext;
              return function() {
                var saved = currentContext;
                try {
                  currentContext = context2;
                  return callback.apply(this, arguments);
                } finally {
                  currentContext = saved;
                }
              };
            };
            Slot2.noContext = function(callback, args, thisArg) {
              if (currentContext) {
                var saved = currentContext;
                try {
                  currentContext = null;
                  return callback.apply(thisArg, args);
                } finally {
                  currentContext = saved;
                }
              } else {
                return callback.apply(thisArg, args);
              }
            };
            return Slot2;
          }()
        );
      };
      function maybe(fn) {
        try {
          return fn();
        } catch (ignored) {
        }
      }
      var globalKey = "@wry/context:Slot";
      var host = (
        // Prefer globalThis when available.
        // https://github.com/benjamn/wryware/issues/347
        maybe(function() {
          return globalThis;
        }) || // Fall back to global, which works in Node.js and may be converted by some
        // bundlers to the appropriate identifier (window, self, ...) depending on the
        // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
        maybe(function() {
          return global;
        }) || // Otherwise, use a dummy host that's local to this module. We used to fall
        // back to using the Array constructor as a namespace, but that was flagged in
        // https://github.com/benjamn/wryware/issues/347, and can be avoided.
        /* @__PURE__ */ Object.create(null)
      );
      var globalHost = host;
      var Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array
      // constructor, so we check there as well, to prevent Slot class duplication.
      Array[globalKey] || function(Slot2) {
        try {
          Object.defineProperty(globalHost, globalKey, {
            value: Slot2,
            enumerable: false,
            writable: false,
            // When it was possible for globalHost to be the Array constructor (a
            // legacy Slot dedup strategy), it was important for the property to be
            // configurable:true so it could be deleted. That does not seem to be as
            // important when globalHost is the global object, but I don't want to
            // cause similar problems again, and configurable:true seems safest.
            // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
            configurable: true
          });
        } finally {
          return Slot2;
        }
      }(makeSlotClass());
      var bind = Slot.bind;
      var noContext = Slot.noContext;
      function setTimeoutWithContext(callback, delay) {
        return setTimeout(bind(callback), delay);
      }
      function asyncFromGen(genFn) {
        return function() {
          var gen = genFn.apply(this, arguments);
          var boundNext = bind(gen.next);
          var boundThrow = bind(gen.throw);
          return new Promise(function(resolve, reject) {
            function invoke(method, argument) {
              try {
                var result = method.call(gen, argument);
              } catch (error) {
                return reject(error);
              }
              var next = result.done ? resolve : invokeNext;
              if (isPromiseLike(result.value)) {
                result.value.then(next, result.done ? reject : invokeThrow);
              } else {
                next(result.value);
              }
            }
            var invokeNext = function(value) {
              return invoke(boundNext, value);
            };
            var invokeThrow = function(error) {
              return invoke(boundThrow, error);
            };
            invokeNext();
          });
        };
      }
      function isPromiseLike(value) {
        return value && typeof value.then === "function";
      }
      var wrappedFibers = [];
      function wrapYieldingFiberMethods(Fiber) {
        if (wrappedFibers.indexOf(Fiber) < 0) {
          var wrap = function(obj, method) {
            var fn = obj[method];
            obj[method] = function() {
              return noContext(fn, arguments, this);
            };
          };
          wrap(Fiber, "yield");
          wrap(Fiber.prototype, "run");
          wrap(Fiber.prototype, "throwInto");
          wrappedFibers.push(Fiber);
        }
        return Fiber;
      }
      exports.Slot = Slot;
      exports.asyncFromGen = asyncFromGen;
      exports.bind = bind;
      exports.noContext = noContext;
      exports.setTimeout = setTimeoutWithContext;
      exports.wrapYieldingFiberMethods = wrapYieldingFiberMethods;
    }
  });

  // node_modules/optimism/lib/bundle.cjs
  var require_bundle4 = __commonJS({
    "node_modules/optimism/lib/bundle.cjs"(exports) {
      "use strict";
      var trie = require_bundle();
      var caches$1 = require_bundle2();
      var context2 = require_bundle3();
      var parentEntrySlot = new context2.Slot();
      function nonReactive(fn) {
        return parentEntrySlot.withValue(void 0, fn);
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var arrayFromSet = Array.from || function(set) {
        var array = [];
        set.forEach(function(item) {
          return array.push(item);
        });
        return array;
      };
      function maybeUnsubscribe(entryOrDep) {
        var unsubscribe = entryOrDep.unsubscribe;
        if (typeof unsubscribe === "function") {
          entryOrDep.unsubscribe = void 0;
          unsubscribe();
        }
      }
      var emptySetPool = [];
      var POOL_TARGET_SIZE = 100;
      function assert(condition, optionalMessage) {
        if (!condition) {
          throw new Error(optionalMessage || "assertion failure");
        }
      }
      function valueIs(a, b) {
        var len = a.length;
        return (
          // Unknown values are not equal to each other.
          len > 0 && // Both values must be ordinary (or both exceptional) to be equal.
          len === b.length && // The underlying value or exception must be the same.
          a[len - 1] === b[len - 1]
        );
      }
      function valueGet(value) {
        switch (value.length) {
          case 0:
            throw new Error("unknown value");
          case 1:
            return value[0];
          case 2:
            throw value[1];
        }
      }
      function valueCopy(value) {
        return value.slice(0);
      }
      var Entry = (
        /** @class */
        function() {
          function Entry2(fn) {
            this.fn = fn;
            this.parents = /* @__PURE__ */ new Set();
            this.childValues = /* @__PURE__ */ new Map();
            this.dirtyChildren = null;
            this.dirty = true;
            this.recomputing = false;
            this.value = [];
            this.deps = null;
            ++Entry2.count;
          }
          Entry2.prototype.peek = function() {
            if (this.value.length === 1 && !mightBeDirty(this)) {
              rememberParent(this);
              return this.value[0];
            }
          };
          Entry2.prototype.recompute = function(args) {
            assert(!this.recomputing, "already recomputing");
            rememberParent(this);
            return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
          };
          Entry2.prototype.setDirty = function() {
            if (this.dirty)
              return;
            this.dirty = true;
            reportDirty(this);
            maybeUnsubscribe(this);
          };
          Entry2.prototype.dispose = function() {
            var _this = this;
            this.setDirty();
            forgetChildren(this);
            eachParent(this, function(parent, child) {
              parent.setDirty();
              forgetChild(parent, _this);
            });
          };
          Entry2.prototype.forget = function() {
            this.dispose();
          };
          Entry2.prototype.dependOn = function(dep2) {
            dep2.add(this);
            if (!this.deps) {
              this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
            }
            this.deps.add(dep2);
          };
          Entry2.prototype.forgetDeps = function() {
            var _this = this;
            if (this.deps) {
              arrayFromSet(this.deps).forEach(function(dep2) {
                return dep2.delete(_this);
              });
              this.deps.clear();
              emptySetPool.push(this.deps);
              this.deps = null;
            }
          };
          Entry2.count = 0;
          return Entry2;
        }()
      );
      function rememberParent(child) {
        var parent = parentEntrySlot.getValue();
        if (parent) {
          child.parents.add(parent);
          if (!parent.childValues.has(child)) {
            parent.childValues.set(child, []);
          }
          if (mightBeDirty(child)) {
            reportDirtyChild(parent, child);
          } else {
            reportCleanChild(parent, child);
          }
          return parent;
        }
      }
      function reallyRecompute(entry, args) {
        forgetChildren(entry);
        parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
        if (maybeSubscribe(entry, args)) {
          setClean(entry);
        }
        return valueGet(entry.value);
      }
      function recomputeNewValue(entry, args) {
        entry.recomputing = true;
        var normalizeResult = entry.normalizeResult;
        var oldValueCopy;
        if (normalizeResult && entry.value.length === 1) {
          oldValueCopy = valueCopy(entry.value);
        }
        entry.value.length = 0;
        try {
          entry.value[0] = entry.fn.apply(null, args);
          if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {
            try {
              entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);
            } catch (_a) {
            }
          }
        } catch (e) {
          entry.value[1] = e;
        }
        entry.recomputing = false;
      }
      function mightBeDirty(entry) {
        return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
      }
      function setClean(entry) {
        entry.dirty = false;
        if (mightBeDirty(entry)) {
          return;
        }
        reportClean(entry);
      }
      function reportDirty(child) {
        eachParent(child, reportDirtyChild);
      }
      function reportClean(child) {
        eachParent(child, reportCleanChild);
      }
      function eachParent(child, callback) {
        var parentCount = child.parents.size;
        if (parentCount) {
          var parents = arrayFromSet(child.parents);
          for (var i = 0; i < parentCount; ++i) {
            callback(parents[i], child);
          }
        }
      }
      function reportDirtyChild(parent, child) {
        assert(parent.childValues.has(child));
        assert(mightBeDirty(child));
        var parentWasClean = !mightBeDirty(parent);
        if (!parent.dirtyChildren) {
          parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
        } else if (parent.dirtyChildren.has(child)) {
          return;
        }
        parent.dirtyChildren.add(child);
        if (parentWasClean) {
          reportDirty(parent);
        }
      }
      function reportCleanChild(parent, child) {
        assert(parent.childValues.has(child));
        assert(!mightBeDirty(child));
        var childValue = parent.childValues.get(child);
        if (childValue.length === 0) {
          parent.childValues.set(child, valueCopy(child.value));
        } else if (!valueIs(childValue, child.value)) {
          parent.setDirty();
        }
        removeDirtyChild(parent, child);
        if (mightBeDirty(parent)) {
          return;
        }
        reportClean(parent);
      }
      function removeDirtyChild(parent, child) {
        var dc = parent.dirtyChildren;
        if (dc) {
          dc.delete(child);
          if (dc.size === 0) {
            if (emptySetPool.length < POOL_TARGET_SIZE) {
              emptySetPool.push(dc);
            }
            parent.dirtyChildren = null;
          }
        }
      }
      function forgetChildren(parent) {
        if (parent.childValues.size > 0) {
          parent.childValues.forEach(function(_value, child) {
            forgetChild(parent, child);
          });
        }
        parent.forgetDeps();
        assert(parent.dirtyChildren === null);
      }
      function forgetChild(parent, child) {
        child.parents.delete(parent);
        parent.childValues.delete(child);
        removeDirtyChild(parent, child);
      }
      function maybeSubscribe(entry, args) {
        if (typeof entry.subscribe === "function") {
          try {
            maybeUnsubscribe(entry);
            entry.unsubscribe = entry.subscribe.apply(null, args);
          } catch (e) {
            entry.setDirty();
            return false;
          }
        }
        return true;
      }
      var EntryMethods = {
        setDirty: true,
        dispose: true,
        forget: true
        // Fully remove parent Entry from LRU cache and computation graph
      };
      function dep(options) {
        var depsByKey = /* @__PURE__ */ new Map();
        var subscribe = options && options.subscribe;
        function depend(key) {
          var parent = parentEntrySlot.getValue();
          if (parent) {
            var dep_1 = depsByKey.get(key);
            if (!dep_1) {
              depsByKey.set(key, dep_1 = /* @__PURE__ */ new Set());
            }
            parent.dependOn(dep_1);
            if (typeof subscribe === "function") {
              maybeUnsubscribe(dep_1);
              dep_1.unsubscribe = subscribe(key);
            }
          }
        }
        depend.dirty = function dirty(key, entryMethodName) {
          var dep2 = depsByKey.get(key);
          if (dep2) {
            var m_1 = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
            arrayFromSet(dep2).forEach(function(entry) {
              return entry[m_1]();
            });
            depsByKey.delete(key);
            maybeUnsubscribe(dep2);
          }
        };
        return depend;
      }
      var defaultKeyTrie;
      function defaultMakeCacheKey() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var trie$1 = defaultKeyTrie || (defaultKeyTrie = new trie.Trie(typeof WeakMap === "function"));
        return trie$1.lookupArray(args);
      }
      var caches = /* @__PURE__ */ new Set();
      function wrap(originalFunction, _a) {
        var _b = _a === void 0 ? /* @__PURE__ */ Object.create(null) : _a, _c = _b.max, max = _c === void 0 ? Math.pow(2, 16) : _c, keyArgs = _b.keyArgs, _d = _b.makeCacheKey, makeCacheKey = _d === void 0 ? defaultMakeCacheKey : _d, normalizeResult = _b.normalizeResult, subscribe = _b.subscribe, _e = _b.cache, cacheOption = _e === void 0 ? caches$1.StrongCache : _e;
        var cache = typeof cacheOption === "function" ? new cacheOption(max, function(entry) {
          return entry.dispose();
        }) : cacheOption;
        var optimistic = function() {
          var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
          if (key === void 0) {
            return originalFunction.apply(null, arguments);
          }
          var entry = cache.get(key);
          if (!entry) {
            cache.set(key, entry = new Entry(originalFunction));
            entry.normalizeResult = normalizeResult;
            entry.subscribe = subscribe;
            entry.forget = function() {
              return cache.delete(key);
            };
          }
          var value = entry.recompute(Array.prototype.slice.call(arguments));
          cache.set(key, entry);
          caches.add(cache);
          if (!parentEntrySlot.hasValue()) {
            caches.forEach(function(cache2) {
              return cache2.clean();
            });
            caches.clear();
          }
          return value;
        };
        Object.defineProperty(optimistic, "size", {
          get: function() {
            return cache.size;
          },
          configurable: false,
          enumerable: false
        });
        Object.freeze(optimistic.options = {
          max,
          keyArgs,
          makeCacheKey,
          normalizeResult,
          subscribe,
          cache
        });
        function dirtyKey(key) {
          var entry = key && cache.get(key);
          if (entry) {
            entry.setDirty();
          }
        }
        optimistic.dirtyKey = dirtyKey;
        optimistic.dirty = function dirty() {
          dirtyKey(makeCacheKey.apply(null, arguments));
        };
        function peekKey(key) {
          var entry = key && cache.get(key);
          if (entry) {
            return entry.peek();
          }
        }
        optimistic.peekKey = peekKey;
        optimistic.peek = function peek() {
          return peekKey(makeCacheKey.apply(null, arguments));
        };
        function forgetKey(key) {
          return key ? cache.delete(key) : false;
        }
        optimistic.forgetKey = forgetKey;
        optimistic.forget = function forget() {
          return forgetKey(makeCacheKey.apply(null, arguments));
        };
        optimistic.makeCacheKey = makeCacheKey;
        optimistic.getKey = keyArgs ? function getKey() {
          return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
        } : makeCacheKey;
        return Object.freeze(optimistic);
      }
      Object.defineProperty(exports, "KeyTrie", {
        enumerable: true,
        get: function() {
          return trie.Trie;
        }
      });
      Object.defineProperty(exports, "Slot", {
        enumerable: true,
        get: function() {
          return context2.Slot;
        }
      });
      Object.defineProperty(exports, "asyncFromGen", {
        enumerable: true,
        get: function() {
          return context2.asyncFromGen;
        }
      });
      Object.defineProperty(exports, "bindContext", {
        enumerable: true,
        get: function() {
          return context2.bind;
        }
      });
      Object.defineProperty(exports, "noContext", {
        enumerable: true,
        get: function() {
          return context2.noContext;
        }
      });
      Object.defineProperty(exports, "setTimeout", {
        enumerable: true,
        get: function() {
          return context2.setTimeout;
        }
      });
      exports.defaultMakeCacheKey = defaultMakeCacheKey;
      exports.dep = dep;
      exports.nonReactive = nonReactive;
      exports.wrap = wrap;
    }
  });

  // node_modules/zen-observable/lib/Observable.js
  var require_Observable = __commonJS({
    "node_modules/zen-observable/lib/Observable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Observable = void 0;
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var hasSymbols = function() {
        return typeof Symbol === "function";
      };
      var hasSymbol = function(name) {
        return hasSymbols() && Boolean(Symbol[name]);
      };
      var getSymbol = function(name) {
        return hasSymbol(name) ? Symbol[name] : "@@" + name;
      };
      if (hasSymbols() && !hasSymbol("observable")) {
        Symbol.observable = Symbol("observable");
      }
      var SymbolIterator = getSymbol("iterator");
      var SymbolObservable = getSymbol("observable");
      var SymbolSpecies = getSymbol("species");
      function getMethod(obj, key) {
        var value = obj[key];
        if (value == null) return void 0;
        if (typeof value !== "function") throw new TypeError(value + " is not a function");
        return value;
      }
      function getSpecies(obj) {
        var ctor = obj.constructor;
        if (ctor !== void 0) {
          ctor = ctor[SymbolSpecies];
          if (ctor === null) {
            ctor = void 0;
          }
        }
        return ctor !== void 0 ? ctor : Observable;
      }
      function isObservable(x) {
        return x instanceof Observable;
      }
      function hostReportError(e) {
        if (hostReportError.log) {
          hostReportError.log(e);
        } else {
          setTimeout(function() {
            throw e;
          });
        }
      }
      function enqueue(fn) {
        Promise.resolve().then(function() {
          try {
            fn();
          } catch (e) {
            hostReportError(e);
          }
        });
      }
      function cleanupSubscription(subscription) {
        var cleanup = subscription._cleanup;
        if (cleanup === void 0) return;
        subscription._cleanup = void 0;
        if (!cleanup) {
          return;
        }
        try {
          if (typeof cleanup === "function") {
            cleanup();
          } else {
            var unsubscribe = getMethod(cleanup, "unsubscribe");
            if (unsubscribe) {
              unsubscribe.call(cleanup);
            }
          }
        } catch (e) {
          hostReportError(e);
        }
      }
      function closeSubscription(subscription) {
        subscription._observer = void 0;
        subscription._queue = void 0;
        subscription._state = "closed";
      }
      function flushSubscription(subscription) {
        var queue = subscription._queue;
        if (!queue) {
          return;
        }
        subscription._queue = void 0;
        subscription._state = "ready";
        for (var i = 0; i < queue.length; ++i) {
          notifySubscription(subscription, queue[i].type, queue[i].value);
          if (subscription._state === "closed") break;
        }
      }
      function notifySubscription(subscription, type, value) {
        subscription._state = "running";
        var observer = subscription._observer;
        try {
          var m = getMethod(observer, type);
          switch (type) {
            case "next":
              if (m) m.call(observer, value);
              break;
            case "error":
              closeSubscription(subscription);
              if (m) m.call(observer, value);
              else throw value;
              break;
            case "complete":
              closeSubscription(subscription);
              if (m) m.call(observer);
              break;
          }
        } catch (e) {
          hostReportError(e);
        }
        if (subscription._state === "closed") cleanupSubscription(subscription);
        else if (subscription._state === "running") subscription._state = "ready";
      }
      function onNotify(subscription, type, value) {
        if (subscription._state === "closed") return;
        if (subscription._state === "buffering") {
          subscription._queue.push({
            type,
            value
          });
          return;
        }
        if (subscription._state !== "ready") {
          subscription._state = "buffering";
          subscription._queue = [{
            type,
            value
          }];
          enqueue(function() {
            return flushSubscription(subscription);
          });
          return;
        }
        notifySubscription(subscription, type, value);
      }
      var Subscription = /* @__PURE__ */ function() {
        function Subscription2(observer, subscriber) {
          _classCallCheck(this, Subscription2);
          this._cleanup = void 0;
          this._observer = observer;
          this._queue = void 0;
          this._state = "initializing";
          var subscriptionObserver = new SubscriptionObserver(this);
          try {
            this._cleanup = subscriber.call(void 0, subscriptionObserver);
          } catch (e) {
            subscriptionObserver.error(e);
          }
          if (this._state === "initializing") this._state = "ready";
        }
        _createClass(Subscription2, [{
          key: "unsubscribe",
          value: function unsubscribe() {
            if (this._state !== "closed") {
              closeSubscription(this);
              cleanupSubscription(this);
            }
          }
        }, {
          key: "closed",
          get: function() {
            return this._state === "closed";
          }
        }]);
        return Subscription2;
      }();
      var SubscriptionObserver = /* @__PURE__ */ function() {
        function SubscriptionObserver2(subscription) {
          _classCallCheck(this, SubscriptionObserver2);
          this._subscription = subscription;
        }
        _createClass(SubscriptionObserver2, [{
          key: "next",
          value: function next(value) {
            onNotify(this._subscription, "next", value);
          }
        }, {
          key: "error",
          value: function error(value) {
            onNotify(this._subscription, "error", value);
          }
        }, {
          key: "complete",
          value: function complete() {
            onNotify(this._subscription, "complete");
          }
        }, {
          key: "closed",
          get: function() {
            return this._subscription._state === "closed";
          }
        }]);
        return SubscriptionObserver2;
      }();
      var Observable = /* @__PURE__ */ function() {
        function Observable2(subscriber) {
          _classCallCheck(this, Observable2);
          if (!(this instanceof Observable2)) throw new TypeError("Observable cannot be called as a function");
          if (typeof subscriber !== "function") throw new TypeError("Observable initializer must be a function");
          this._subscriber = subscriber;
        }
        _createClass(Observable2, [{
          key: "subscribe",
          value: function subscribe(observer) {
            if (typeof observer !== "object" || observer === null) {
              observer = {
                next: observer,
                error: arguments[1],
                complete: arguments[2]
              };
            }
            return new Subscription(observer, this._subscriber);
          }
        }, {
          key: "forEach",
          value: function forEach(fn) {
            var _this = this;
            return new Promise(function(resolve, reject) {
              if (typeof fn !== "function") {
                reject(new TypeError(fn + " is not a function"));
                return;
              }
              function done() {
                subscription.unsubscribe();
                resolve();
              }
              var subscription = _this.subscribe({
                next: function(value) {
                  try {
                    fn(value, done);
                  } catch (e) {
                    reject(e);
                    subscription.unsubscribe();
                  }
                },
                error: reject,
                complete: resolve
              });
            });
          }
        }, {
          key: "map",
          value: function map(fn) {
            var _this2 = this;
            if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
            var C = getSpecies(this);
            return new C(function(observer) {
              return _this2.subscribe({
                next: function(value) {
                  try {
                    value = fn(value);
                  } catch (e) {
                    return observer.error(e);
                  }
                  observer.next(value);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  observer.complete();
                }
              });
            });
          }
        }, {
          key: "filter",
          value: function filter(fn) {
            var _this3 = this;
            if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
            var C = getSpecies(this);
            return new C(function(observer) {
              return _this3.subscribe({
                next: function(value) {
                  try {
                    if (!fn(value)) return;
                  } catch (e) {
                    return observer.error(e);
                  }
                  observer.next(value);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  observer.complete();
                }
              });
            });
          }
        }, {
          key: "reduce",
          value: function reduce(fn) {
            var _this4 = this;
            if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
            var C = getSpecies(this);
            var hasSeed = arguments.length > 1;
            var hasValue = false;
            var seed = arguments[1];
            var acc = seed;
            return new C(function(observer) {
              return _this4.subscribe({
                next: function(value) {
                  var first = !hasValue;
                  hasValue = true;
                  if (!first || hasSeed) {
                    try {
                      acc = fn(acc, value);
                    } catch (e) {
                      return observer.error(e);
                    }
                  } else {
                    acc = value;
                  }
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  if (!hasValue && !hasSeed) return observer.error(new TypeError("Cannot reduce an empty sequence"));
                  observer.next(acc);
                  observer.complete();
                }
              });
            });
          }
        }, {
          key: "concat",
          value: function concat() {
            var _this5 = this;
            for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
              sources[_key] = arguments[_key];
            }
            var C = getSpecies(this);
            return new C(function(observer) {
              var subscription;
              var index = 0;
              function startNext(next) {
                subscription = next.subscribe({
                  next: function(v) {
                    observer.next(v);
                  },
                  error: function(e) {
                    observer.error(e);
                  },
                  complete: function() {
                    if (index === sources.length) {
                      subscription = void 0;
                      observer.complete();
                    } else {
                      startNext(C.from(sources[index++]));
                    }
                  }
                });
              }
              startNext(_this5);
              return function() {
                if (subscription) {
                  subscription.unsubscribe();
                  subscription = void 0;
                }
              };
            });
          }
        }, {
          key: "flatMap",
          value: function flatMap(fn) {
            var _this6 = this;
            if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
            var C = getSpecies(this);
            return new C(function(observer) {
              var subscriptions = [];
              var outer = _this6.subscribe({
                next: function(value) {
                  if (fn) {
                    try {
                      value = fn(value);
                    } catch (e) {
                      return observer.error(e);
                    }
                  }
                  var inner = C.from(value).subscribe({
                    next: function(value2) {
                      observer.next(value2);
                    },
                    error: function(e) {
                      observer.error(e);
                    },
                    complete: function() {
                      var i = subscriptions.indexOf(inner);
                      if (i >= 0) subscriptions.splice(i, 1);
                      completeIfDone();
                    }
                  });
                  subscriptions.push(inner);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  completeIfDone();
                }
              });
              function completeIfDone() {
                if (outer.closed && subscriptions.length === 0) observer.complete();
              }
              return function() {
                subscriptions.forEach(function(s) {
                  return s.unsubscribe();
                });
                outer.unsubscribe();
              };
            });
          }
        }, {
          key: SymbolObservable,
          value: function() {
            return this;
          }
        }], [{
          key: "from",
          value: function from(x) {
            var C = typeof this === "function" ? this : Observable2;
            if (x == null) throw new TypeError(x + " is not an object");
            var method = getMethod(x, SymbolObservable);
            if (method) {
              var observable = method.call(x);
              if (Object(observable) !== observable) throw new TypeError(observable + " is not an object");
              if (isObservable(observable) && observable.constructor === C) return observable;
              return new C(function(observer) {
                return observable.subscribe(observer);
              });
            }
            if (hasSymbol("iterator")) {
              method = getMethod(x, SymbolIterator);
              if (method) {
                return new C(function(observer) {
                  enqueue(function() {
                    if (observer.closed) return;
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = void 0;
                    try {
                      for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _item = _step.value;
                        observer.next(_item);
                        if (observer.closed) return;
                      }
                    } catch (err) {
                      _didIteratorError = true;
                      _iteratorError = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                          _iterator.return();
                        }
                      } finally {
                        if (_didIteratorError) {
                          throw _iteratorError;
                        }
                      }
                    }
                    observer.complete();
                  });
                });
              }
            }
            if (Array.isArray(x)) {
              return new C(function(observer) {
                enqueue(function() {
                  if (observer.closed) return;
                  for (var i = 0; i < x.length; ++i) {
                    observer.next(x[i]);
                    if (observer.closed) return;
                  }
                  observer.complete();
                });
              });
            }
            throw new TypeError(x + " is not observable");
          }
        }, {
          key: "of",
          value: function of() {
            for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              items[_key2] = arguments[_key2];
            }
            var C = typeof this === "function" ? this : Observable2;
            return new C(function(observer) {
              enqueue(function() {
                if (observer.closed) return;
                for (var i = 0; i < items.length; ++i) {
                  observer.next(items[i]);
                  if (observer.closed) return;
                }
                observer.complete();
              });
            });
          }
        }, {
          key: SymbolSpecies,
          get: function() {
            return this;
          }
        }]);
        return Observable2;
      }();
      exports.Observable = Observable;
      if (hasSymbols()) {
        Object.defineProperty(Observable, Symbol("extensions"), {
          value: {
            symbol: SymbolObservable,
            hostReportError
          },
          configurable: true
        });
      }
    }
  });

  // node_modules/zen-observable/index.js
  var require_zen_observable = __commonJS({
    "node_modules/zen-observable/index.js"(exports, module) {
      module.exports = require_Observable().Observable;
    }
  });

  // node_modules/zen-observable-ts/index.cjs
  var require_zen_observable_ts = __commonJS({
    "node_modules/zen-observable-ts/index.cjs"(exports) {
      exports.Observable = require_zen_observable();
    }
  });

  // node_modules/symbol-observable/lib/ponyfill.js
  var require_ponyfill = __commonJS({
    "node_modules/symbol-observable/lib/ponyfill.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = symbolObservablePonyfill;
      function symbolObservablePonyfill(root) {
        var result;
        var _Symbol = root.Symbol;
        if (typeof _Symbol === "function") {
          if (_Symbol.observable) {
            result = _Symbol.observable;
          } else {
            if (typeof _Symbol["for"] === "function") {
              result = _Symbol["for"]("https://github.com/benlesh/symbol-observable");
            } else {
              result = _Symbol("https://github.com/benlesh/symbol-observable");
            }
            try {
              _Symbol.observable = result;
            } catch (err) {
            }
          }
        } else {
          result = "@@observable";
        }
        return result;
      }
    }
  });

  // node_modules/symbol-observable/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/symbol-observable/lib/index.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _ponyfill = require_ponyfill();
      var _ponyfill2 = _interopRequireDefault(_ponyfill);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var root;
      if (typeof self !== "undefined") {
        root = self;
      } else if (typeof window !== "undefined") {
        root = window;
      } else if (typeof global !== "undefined") {
        root = global;
      } else if (typeof module !== "undefined") {
        root = module;
      } else {
        root = Function("return this")();
      }
      var result = (0, _ponyfill2["default"])(root);
      exports["default"] = result;
    }
  });

  // node_modules/@apollo/client/utilities/utilities.cjs
  var require_utilities2 = __commonJS({
    "node_modules/@apollo/client/utilities/utilities.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var globals = require_globals();
      var graphql = require_graphql2();
      var trie = require_bundle();
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var caches = require_bundle2();
      var optimism = require_bundle4();
      var zenObservableTs = require_zen_observable_ts();
      require_lib2();
      function shouldInclude(_a, variables) {
        var directives = _a.directives;
        if (!directives || !directives.length) {
          return true;
        }
        return getInclusionDirectives(directives).every(function(_a2) {
          var directive = _a2.directive, ifArgument = _a2.ifArgument;
          var evaledValue = false;
          if (ifArgument.value.kind === "Variable") {
            evaledValue = variables && variables[ifArgument.value.name.value];
            globals.invariant(evaledValue !== void 0, 78, directive.name.value);
          } else {
            evaledValue = ifArgument.value.value;
          }
          return directive.name.value === "skip" ? !evaledValue : evaledValue;
        });
      }
      function getDirectiveNames(root) {
        var names = [];
        graphql.visit(root, {
          Directive: function(node) {
            names.push(node.name.value);
          }
        });
        return names;
      }
      var hasAnyDirectives = function(names, root) {
        return hasDirectives(names, root, false);
      };
      var hasAllDirectives = function(names, root) {
        return hasDirectives(names, root, true);
      };
      function hasDirectives(names, root, all) {
        var nameSet = new Set(names);
        var uniqueCount = nameSet.size;
        graphql.visit(root, {
          Directive: function(node) {
            if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
              return graphql.BREAK;
            }
          }
        });
        return all ? !nameSet.size : nameSet.size < uniqueCount;
      }
      function hasClientExports(document) {
        return document && hasDirectives(["client", "export"], document, true);
      }
      function isInclusionDirective(_a) {
        var value = _a.name.value;
        return value === "skip" || value === "include";
      }
      function getInclusionDirectives(directives) {
        var result = [];
        if (directives && directives.length) {
          directives.forEach(function(directive) {
            if (!isInclusionDirective(directive))
              return;
            var directiveArguments = directive.arguments;
            var directiveName = directive.name.value;
            globals.invariant(directiveArguments && directiveArguments.length === 1, 79, directiveName);
            var ifArgument = directiveArguments[0];
            globals.invariant(ifArgument.name && ifArgument.name.value === "if", 80, directiveName);
            var ifValue = ifArgument.value;
            globals.invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 81, directiveName);
            result.push({ directive, ifArgument });
          });
        }
        return result;
      }
      function getFragmentMaskMode(fragment) {
        var _a, _b;
        var directive = (_a = fragment.directives) === null || _a === void 0 ? void 0 : _a.find(function(_a2) {
          var name = _a2.name;
          return name.value === "unmask";
        });
        if (!directive) {
          return "mask";
        }
        var modeArg = (_b = directive.arguments) === null || _b === void 0 ? void 0 : _b.find(function(_a2) {
          var name = _a2.name;
          return name.value === "mode";
        });
        if (globalThis.__DEV__ !== false) {
          if (modeArg) {
            if (modeArg.value.kind === graphql.Kind.VARIABLE) {
              globalThis.__DEV__ !== false && globals.invariant.warn(82);
            } else if (modeArg.value.kind !== graphql.Kind.STRING) {
              globalThis.__DEV__ !== false && globals.invariant.warn(83);
            } else if (modeArg.value.value !== "migrate") {
              globalThis.__DEV__ !== false && globals.invariant.warn(84, modeArg.value.value);
            }
          }
        }
        if (modeArg && "value" in modeArg.value && modeArg.value.value === "migrate") {
          return "migrate";
        }
        return "unmask";
      }
      var isReactNative = globals.maybe(function() {
        return navigator.product;
      }) == "ReactNative";
      var canUseWeakMap = typeof WeakMap === "function" && !(isReactNative && !global.HermesInternal);
      var canUseWeakSet = typeof WeakSet === "function";
      var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
      var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
      var canUseDOM = typeof globals.maybe(function() {
        return window.document.createElement;
      }) === "function";
      var usingJSDOM = globals.maybe(function() {
        return navigator.userAgent.indexOf("jsdom") >= 0;
      }) || false;
      var canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM;
      function isNonNullObject(obj) {
        return obj !== null && typeof obj === "object";
      }
      function isPlainObject3(obj) {
        return obj !== null && typeof obj === "object" && (Object.getPrototypeOf(obj) === Object.prototype || Object.getPrototypeOf(obj) === null);
      }
      function getFragmentQueryDocument(document, fragmentName) {
        var actualFragmentName = fragmentName;
        var fragments = [];
        document.definitions.forEach(function(definition) {
          if (definition.kind === "OperationDefinition") {
            throw globals.newInvariantError(
              85,
              definition.operation,
              definition.name ? " named '".concat(definition.name.value, "'") : ""
            );
          }
          if (definition.kind === "FragmentDefinition") {
            fragments.push(definition);
          }
        });
        if (typeof actualFragmentName === "undefined") {
          globals.invariant(fragments.length === 1, 86, fragments.length);
          actualFragmentName = fragments[0].name.value;
        }
        var query = tslib.__assign(tslib.__assign({}, document), { definitions: tslib.__spreadArray([
          {
            kind: "OperationDefinition",
            operation: "query",
            selectionSet: {
              kind: "SelectionSet",
              selections: [
                {
                  kind: "FragmentSpread",
                  name: {
                    kind: "Name",
                    value: actualFragmentName
                  }
                }
              ]
            }
          }
        ], document.definitions, true) });
        return query;
      }
      function createFragmentMap(fragments) {
        if (fragments === void 0) {
          fragments = [];
        }
        var symTable = {};
        fragments.forEach(function(fragment) {
          symTable[fragment.name.value] = fragment;
        });
        return symTable;
      }
      function getFragmentFromSelection(selection, fragmentMap) {
        switch (selection.kind) {
          case "InlineFragment":
            return selection;
          case "FragmentSpread": {
            var fragmentName = selection.name.value;
            if (typeof fragmentMap === "function") {
              return fragmentMap(fragmentName);
            }
            var fragment = fragmentMap && fragmentMap[fragmentName];
            globals.invariant(fragment, 87, fragmentName);
            return fragment || null;
          }
          default:
            return null;
        }
      }
      function isFullyUnmaskedOperation(document) {
        var isUnmasked = true;
        graphql.visit(document, {
          FragmentSpread: function(node) {
            isUnmasked = !!node.directives && node.directives.some(function(directive) {
              return directive.name.value === "unmask";
            });
            if (!isUnmasked) {
              return graphql.BREAK;
            }
          }
        });
        return isUnmasked;
      }
      var scheduledCleanup = /* @__PURE__ */ new WeakSet();
      function schedule(cache) {
        if (cache.size <= (cache.max || -1)) {
          return;
        }
        if (!scheduledCleanup.has(cache)) {
          scheduledCleanup.add(cache);
          setTimeout(function() {
            cache.clean();
            scheduledCleanup.delete(cache);
          }, 100);
        }
      }
      var AutoCleanedWeakCache = function(max, dispose) {
        var cache = new caches.WeakCache(max, dispose);
        cache.set = function(key, value) {
          var ret = caches.WeakCache.prototype.set.call(this, key, value);
          schedule(this);
          return ret;
        };
        return cache;
      };
      var AutoCleanedStrongCache = function(max, dispose) {
        var cache = new caches.StrongCache(max, dispose);
        cache.set = function(key, value) {
          var ret = caches.StrongCache.prototype.set.call(this, key, value);
          schedule(this);
          return ret;
        };
        return cache;
      };
      var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
      var cacheSizes = tslib.__assign({}, globals.global[cacheSizeSymbol]);
      var globalCaches = {};
      function registerGlobalCache(name, getSize) {
        globalCaches[name] = getSize;
      }
      var canonicalStringify = Object.assign(function canonicalStringify2(value) {
        return JSON.stringify(value, stableObjectReplacer);
      }, {
        reset: function() {
          sortingMap = new AutoCleanedStrongCache(cacheSizes.canonicalStringify || 1e3);
        }
      });
      if (globalThis.__DEV__ !== false) {
        registerGlobalCache("canonicalStringify", function() {
          return sortingMap.size;
        });
      }
      var sortingMap;
      canonicalStringify.reset();
      function stableObjectReplacer(key, value) {
        if (value && typeof value === "object") {
          var proto = Object.getPrototypeOf(value);
          if (proto === Object.prototype || proto === null) {
            var keys = Object.keys(value);
            if (keys.every(everyKeyInOrder))
              return value;
            var unsortedKey = JSON.stringify(keys);
            var sortedKeys = sortingMap.get(unsortedKey);
            if (!sortedKeys) {
              keys.sort();
              var sortedKey = JSON.stringify(keys);
              sortedKeys = sortingMap.get(sortedKey) || keys;
              sortingMap.set(unsortedKey, sortedKeys);
              sortingMap.set(sortedKey, sortedKeys);
            }
            var sortedObject_1 = Object.create(proto);
            sortedKeys.forEach(function(key2) {
              sortedObject_1[key2] = value[key2];
            });
            return sortedObject_1;
          }
        }
        return value;
      }
      function everyKeyInOrder(key, i, keys) {
        return i === 0 || keys[i - 1] <= key;
      }
      function makeReference(id) {
        return { __ref: String(id) };
      }
      function isReference(obj) {
        return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
      }
      function isDocumentNode(value) {
        return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
      }
      function isStringValue(value) {
        return value.kind === "StringValue";
      }
      function isBooleanValue(value) {
        return value.kind === "BooleanValue";
      }
      function isIntValue(value) {
        return value.kind === "IntValue";
      }
      function isFloatValue(value) {
        return value.kind === "FloatValue";
      }
      function isVariable(value) {
        return value.kind === "Variable";
      }
      function isObjectValue(value) {
        return value.kind === "ObjectValue";
      }
      function isListValue(value) {
        return value.kind === "ListValue";
      }
      function isEnumValue(value) {
        return value.kind === "EnumValue";
      }
      function isNullValue(value) {
        return value.kind === "NullValue";
      }
      function valueToObjectRepresentation(argObj, name, value, variables) {
        if (isIntValue(value) || isFloatValue(value)) {
          argObj[name.value] = Number(value.value);
        } else if (isBooleanValue(value) || isStringValue(value)) {
          argObj[name.value] = value.value;
        } else if (isObjectValue(value)) {
          var nestedArgObj_1 = {};
          value.fields.map(function(obj) {
            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
          });
          argObj[name.value] = nestedArgObj_1;
        } else if (isVariable(value)) {
          var variableValue = (variables || {})[value.name.value];
          argObj[name.value] = variableValue;
        } else if (isListValue(value)) {
          argObj[name.value] = value.values.map(function(listValue) {
            var nestedArgArrayObj = {};
            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
            return nestedArgArrayObj[name.value];
          });
        } else if (isEnumValue(value)) {
          argObj[name.value] = value.value;
        } else if (isNullValue(value)) {
          argObj[name.value] = null;
        } else {
          throw globals.newInvariantError(96, name.value, value.kind);
        }
      }
      function storeKeyNameFromField(field, variables) {
        var directivesObj = null;
        if (field.directives) {
          directivesObj = {};
          field.directives.forEach(function(directive) {
            directivesObj[directive.name.value] = {};
            if (directive.arguments) {
              directive.arguments.forEach(function(_a) {
                var name = _a.name, value = _a.value;
                return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
              });
            }
          });
        }
        var argObj = null;
        if (field.arguments && field.arguments.length) {
          argObj = {};
          field.arguments.forEach(function(_a) {
            var name = _a.name, value = _a.value;
            return valueToObjectRepresentation(argObj, name, value, variables);
          });
        }
        return getStoreKeyName(field.name.value, argObj, directivesObj);
      }
      var KNOWN_DIRECTIVES = [
        "connection",
        "include",
        "skip",
        "client",
        "rest",
        "export",
        "nonreactive"
      ];
      var storeKeyNameStringify = canonicalStringify;
      var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
        if (args && directives && directives["connection"] && directives["connection"]["key"]) {
          if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
            var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
            filterKeys.sort();
            var filteredArgs_1 = {};
            filterKeys.forEach(function(key) {
              filteredArgs_1[key] = args[key];
            });
            return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify(filteredArgs_1), ")");
          } else {
            return directives["connection"]["key"];
          }
        }
        var completeFieldName = fieldName;
        if (args) {
          var stringifiedArgs = storeKeyNameStringify(args);
          completeFieldName += "(".concat(stringifiedArgs, ")");
        }
        if (directives) {
          Object.keys(directives).forEach(function(key) {
            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
              return;
            if (directives[key] && Object.keys(directives[key]).length) {
              completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify(directives[key]), ")");
            } else {
              completeFieldName += "@".concat(key);
            }
          });
        }
        return completeFieldName;
      }, {
        setStringify: function(s) {
          var previous = storeKeyNameStringify;
          storeKeyNameStringify = s;
          return previous;
        }
      });
      function argumentsObjectFromField(field, variables) {
        if (field.arguments && field.arguments.length) {
          var argObj_1 = {};
          field.arguments.forEach(function(_a) {
            var name = _a.name, value = _a.value;
            return valueToObjectRepresentation(argObj_1, name, value, variables);
          });
          return argObj_1;
        }
        return null;
      }
      function resultKeyNameFromField(field) {
        return field.alias ? field.alias.value : field.name.value;
      }
      function getTypenameFromResult(result, selectionSet, fragmentMap) {
        var fragments;
        for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
          var selection = _a[_i];
          if (isField(selection)) {
            if (selection.name.value === "__typename") {
              return result[resultKeyNameFromField(selection)];
            }
          } else if (fragments) {
            fragments.push(selection);
          } else {
            fragments = [selection];
          }
        }
        if (typeof result.__typename === "string") {
          return result.__typename;
        }
        if (fragments) {
          for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {
            var selection = fragments_1[_b];
            var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
            if (typeof typename === "string") {
              return typename;
            }
          }
        }
      }
      function isField(selection) {
        return selection.kind === "Field";
      }
      function isInlineFragment(selection) {
        return selection.kind === "InlineFragment";
      }
      function checkDocument(doc) {
        globals.invariant(doc && doc.kind === "Document", 88);
        var operations = doc.definitions.filter(function(d) {
          return d.kind !== "FragmentDefinition";
        }).map(function(definition) {
          if (definition.kind !== "OperationDefinition") {
            throw globals.newInvariantError(89, definition.kind);
          }
          return definition;
        });
        globals.invariant(operations.length <= 1, 90, operations.length);
        return doc;
      }
      function getOperationDefinition(doc) {
        checkDocument(doc);
        return doc.definitions.filter(function(definition) {
          return definition.kind === "OperationDefinition";
        })[0];
      }
      function getOperationName(doc) {
        return doc.definitions.filter(function(definition) {
          return definition.kind === "OperationDefinition" && !!definition.name;
        }).map(function(x) {
          return x.name.value;
        })[0] || null;
      }
      function getFragmentDefinitions(doc) {
        return doc.definitions.filter(function(definition) {
          return definition.kind === "FragmentDefinition";
        });
      }
      function getQueryDefinition(doc) {
        var queryDef = getOperationDefinition(doc);
        globals.invariant(queryDef && queryDef.operation === "query", 91);
        return queryDef;
      }
      function getFragmentDefinition(doc) {
        globals.invariant(doc.kind === "Document", 92);
        globals.invariant(doc.definitions.length <= 1, 93);
        var fragmentDef = doc.definitions[0];
        globals.invariant(fragmentDef.kind === "FragmentDefinition", 94);
        return fragmentDef;
      }
      function getMainDefinition(queryDoc) {
        checkDocument(queryDoc);
        var fragmentDefinition;
        for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
          var definition = _a[_i];
          if (definition.kind === "OperationDefinition") {
            var operation = definition.operation;
            if (operation === "query" || operation === "mutation" || operation === "subscription") {
              return definition;
            }
          }
          if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
            fragmentDefinition = definition;
          }
        }
        if (fragmentDefinition) {
          return fragmentDefinition;
        }
        throw globals.newInvariantError(95);
      }
      function getDefaultValues(definition) {
        var defaultValues = /* @__PURE__ */ Object.create(null);
        var defs = definition && definition.variableDefinitions;
        if (defs && defs.length) {
          defs.forEach(function(def) {
            if (def.defaultValue) {
              valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
            }
          });
        }
        return defaultValues;
      }
      function identity(document) {
        return document;
      }
      var DocumentTransform = function() {
        function DocumentTransform2(transform, options) {
          if (options === void 0) {
            options = /* @__PURE__ */ Object.create(null);
          }
          this.resultCache = canUseWeakSet ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
          this.transform = transform;
          if (options.getCacheKey) {
            this.getCacheKey = options.getCacheKey;
          }
          this.cached = options.cache !== false;
          this.resetCache();
        }
        DocumentTransform2.prototype.getCacheKey = function(document) {
          return [document];
        };
        DocumentTransform2.identity = function() {
          return new DocumentTransform2(identity, { cache: false });
        };
        DocumentTransform2.split = function(predicate, left, right) {
          if (right === void 0) {
            right = DocumentTransform2.identity();
          }
          return Object.assign(new DocumentTransform2(
            function(document) {
              var documentTransform = predicate(document) ? left : right;
              return documentTransform.transformDocument(document);
            },
            { cache: false }
          ), { left, right });
        };
        DocumentTransform2.prototype.resetCache = function() {
          var _this = this;
          if (this.cached) {
            var stableCacheKeys_1 = new trie.Trie(canUseWeakMap);
            this.performWork = optimism.wrap(DocumentTransform2.prototype.performWork.bind(this), {
              makeCacheKey: function(document) {
                var cacheKeys = _this.getCacheKey(document);
                if (cacheKeys) {
                  globals.invariant(Array.isArray(cacheKeys), 77);
                  return stableCacheKeys_1.lookupArray(cacheKeys);
                }
              },
              max: cacheSizes["documentTransform.cache"],
              cache: caches.WeakCache
            });
          }
        };
        DocumentTransform2.prototype.performWork = function(document) {
          checkDocument(document);
          return this.transform(document);
        };
        DocumentTransform2.prototype.transformDocument = function(document) {
          if (this.resultCache.has(document)) {
            return document;
          }
          var transformedDocument = this.performWork(document);
          this.resultCache.add(transformedDocument);
          return transformedDocument;
        };
        DocumentTransform2.prototype.concat = function(otherTransform) {
          var _this = this;
          return Object.assign(new DocumentTransform2(
            function(document) {
              return otherTransform.transformDocument(_this.transformDocument(document));
            },
            { cache: false }
          ), {
            left: this,
            right: otherTransform
          });
        };
        return DocumentTransform2;
      }();
      var printCache;
      var print = Object.assign(function(ast) {
        var result = printCache.get(ast);
        if (!result) {
          result = graphql.print(ast);
          printCache.set(ast, result);
        }
        return result;
      }, {
        reset: function() {
          printCache = new AutoCleanedWeakCache(cacheSizes.print || 2e3);
        }
      });
      print.reset();
      if (globalThis.__DEV__ !== false) {
        registerGlobalCache("print", function() {
          return printCache ? printCache.size : 0;
        });
      }
      var isArray = Array.isArray;
      function isNonEmptyArray(value) {
        return Array.isArray(value) && value.length > 0;
      }
      var TYPENAME_FIELD = {
        kind: graphql.Kind.FIELD,
        name: {
          kind: graphql.Kind.NAME,
          value: "__typename"
        }
      };
      function isEmpty(op, fragmentMap) {
        return !op || op.selectionSet.selections.every(function(selection) {
          return selection.kind === graphql.Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
        });
      }
      function nullIfDocIsEmpty(doc) {
        return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
      }
      function getDirectiveMatcher(configs) {
        var names = /* @__PURE__ */ new Map();
        var tests = /* @__PURE__ */ new Map();
        configs.forEach(function(directive) {
          if (directive) {
            if (directive.name) {
              names.set(directive.name, directive);
            } else if (directive.test) {
              tests.set(directive.test, directive);
            }
          }
        });
        return function(directive) {
          var config = names.get(directive.name.value);
          if (!config && tests.size) {
            tests.forEach(function(testConfig, test) {
              if (test(directive)) {
                config = testConfig;
              }
            });
          }
          return config;
        };
      }
      function makeInUseGetterFunction(defaultKey) {
        var map = /* @__PURE__ */ new Map();
        return function inUseGetterFunction(key) {
          if (key === void 0) {
            key = defaultKey;
          }
          var inUse = map.get(key);
          if (!inUse) {
            map.set(key, inUse = {
              variables: /* @__PURE__ */ new Set(),
              fragmentSpreads: /* @__PURE__ */ new Set()
            });
          }
          return inUse;
        };
      }
      function removeDirectivesFromDocument(directives, doc) {
        checkDocument(doc);
        var getInUseByOperationName = makeInUseGetterFunction("");
        var getInUseByFragmentName = makeInUseGetterFunction("");
        var getInUse = function(ancestors) {
          for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {
            if (isArray(ancestor))
              continue;
            if (ancestor.kind === graphql.Kind.OPERATION_DEFINITION) {
              return getInUseByOperationName(ancestor.name && ancestor.name.value);
            }
            if (ancestor.kind === graphql.Kind.FRAGMENT_DEFINITION) {
              return getInUseByFragmentName(ancestor.name.value);
            }
          }
          globalThis.__DEV__ !== false && globals.invariant.error(97);
          return null;
        };
        var operationCount = 0;
        for (var i = doc.definitions.length - 1; i >= 0; --i) {
          if (doc.definitions[i].kind === graphql.Kind.OPERATION_DEFINITION) {
            ++operationCount;
          }
        }
        var directiveMatcher = getDirectiveMatcher(directives);
        var shouldRemoveField = function(nodeDirectives) {
          return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
            return config && config.remove;
          });
        };
        var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
        var firstVisitMadeChanges = false;
        var fieldOrInlineFragmentVisitor = {
          enter: function(node) {
            if (shouldRemoveField(node.directives)) {
              firstVisitMadeChanges = true;
              return null;
            }
          }
        };
        var docWithoutDirectiveSubtrees = graphql.visit(doc, {
          Field: fieldOrInlineFragmentVisitor,
          InlineFragment: fieldOrInlineFragmentVisitor,
          VariableDefinition: {
            enter: function() {
              return false;
            }
          },
          Variable: {
            enter: function(node, _key, _parent, _path, ancestors) {
              var inUse = getInUse(ancestors);
              if (inUse) {
                inUse.variables.add(node.name.value);
              }
            }
          },
          FragmentSpread: {
            enter: function(node, _key, _parent, _path, ancestors) {
              if (shouldRemoveField(node.directives)) {
                firstVisitMadeChanges = true;
                return null;
              }
              var inUse = getInUse(ancestors);
              if (inUse) {
                inUse.fragmentSpreads.add(node.name.value);
              }
            }
          },
          FragmentDefinition: {
            enter: function(node, _key, _parent, path) {
              originalFragmentDefsByPath.set(JSON.stringify(path), node);
            },
            leave: function(node, _key, _parent, path) {
              var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
              if (node === originalNode) {
                return node;
              }
              if (operationCount > 0 && node.selectionSet.selections.every(function(selection) {
                return selection.kind === graphql.Kind.FIELD && selection.name.value === "__typename";
              })) {
                getInUseByFragmentName(node.name.value).removed = true;
                firstVisitMadeChanges = true;
                return null;
              }
            }
          },
          Directive: {
            leave: function(node) {
              if (directiveMatcher(node)) {
                firstVisitMadeChanges = true;
                return null;
              }
            }
          }
        });
        if (!firstVisitMadeChanges) {
          return doc;
        }
        var populateTransitiveVars = function(inUse) {
          if (!inUse.transitiveVars) {
            inUse.transitiveVars = new Set(inUse.variables);
            if (!inUse.removed) {
              inUse.fragmentSpreads.forEach(function(childFragmentName) {
                populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
                  inUse.transitiveVars.add(varName);
                });
              });
            }
          }
          return inUse;
        };
        var allFragmentNamesUsed = /* @__PURE__ */ new Set();
        docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
          if (def.kind === graphql.Kind.OPERATION_DEFINITION) {
            populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
              allFragmentNamesUsed.add(childFragmentName);
            });
          } else if (def.kind === graphql.Kind.FRAGMENT_DEFINITION && operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
            allFragmentNamesUsed.add(def.name.value);
          }
        });
        allFragmentNamesUsed.forEach(function(fragmentName) {
          populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
            allFragmentNamesUsed.add(childFragmentName);
          });
        });
        var fragmentWillBeRemoved = function(fragmentName) {
          return !!(!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
        };
        var enterVisitor = {
          enter: function(node) {
            if (fragmentWillBeRemoved(node.name.value)) {
              return null;
            }
          }
        };
        return nullIfDocIsEmpty(graphql.visit(docWithoutDirectiveSubtrees, {
          FragmentSpread: enterVisitor,
          FragmentDefinition: enterVisitor,
          OperationDefinition: {
            leave: function(node) {
              if (node.variableDefinitions) {
                var usedVariableNames_1 = populateTransitiveVars(
                  getInUseByOperationName(node.name && node.name.value)
                ).transitiveVars;
                if (usedVariableNames_1.size < node.variableDefinitions.length) {
                  return tslib.__assign(tslib.__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {
                    return usedVariableNames_1.has(varDef.variable.name.value);
                  }) });
                }
              }
            }
          }
        }));
      }
      var addTypenameToDocument = Object.assign(function(doc) {
        return graphql.visit(doc, {
          SelectionSet: {
            enter: function(node, _key, parent) {
              if (parent && parent.kind === graphql.Kind.OPERATION_DEFINITION) {
                return;
              }
              var selections = node.selections;
              if (!selections) {
                return;
              }
              var skip = selections.some(function(selection) {
                return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
              });
              if (skip) {
                return;
              }
              var field = parent;
              if (isField(field) && field.directives && field.directives.some(function(d) {
                return d.name.value === "export";
              })) {
                return;
              }
              return tslib.__assign(tslib.__assign({}, node), { selections: tslib.__spreadArray(tslib.__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
            }
          }
        });
      }, {
        added: function(field) {
          return field === TYPENAME_FIELD;
        }
      });
      var connectionRemoveConfig = {
        test: function(directive) {
          var willRemove = directive.name.value === "connection";
          if (willRemove) {
            if (!directive.arguments || !directive.arguments.some(function(arg) {
              return arg.name.value === "key";
            })) {
              globalThis.__DEV__ !== false && globals.invariant.warn(98);
            }
          }
          return willRemove;
        }
      };
      function removeConnectionDirectiveFromDocument(doc) {
        return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
      }
      function getArgumentMatcher(config) {
        return function argumentMatcher(argument) {
          return config.some(function(aConfig) {
            return argument.value && argument.value.kind === graphql.Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
          });
        };
      }
      function removeArgumentsFromDocument(config, doc) {
        var argMatcher = getArgumentMatcher(config);
        return nullIfDocIsEmpty(graphql.visit(doc, {
          OperationDefinition: {
            enter: function(node) {
              return tslib.__assign(tslib.__assign({}, node), {
                variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
                  return !config.some(function(arg) {
                    return arg.name === varDef.variable.name.value;
                  });
                }) : []
              });
            }
          },
          Field: {
            enter: function(node) {
              var shouldRemoveField = config.some(function(argConfig) {
                return argConfig.remove;
              });
              if (shouldRemoveField) {
                var argMatchCount_1 = 0;
                if (node.arguments) {
                  node.arguments.forEach(function(arg) {
                    if (argMatcher(arg)) {
                      argMatchCount_1 += 1;
                    }
                  });
                }
                if (argMatchCount_1 === 1) {
                  return null;
                }
              }
            }
          },
          Argument: {
            enter: function(node) {
              if (argMatcher(node)) {
                return null;
              }
            }
          }
        }));
      }
      function removeFragmentSpreadFromDocument(config, doc) {
        function enter(node) {
          if (config.some(function(def) {
            return def.name === node.name.value;
          })) {
            return null;
          }
        }
        return nullIfDocIsEmpty(graphql.visit(doc, {
          FragmentSpread: { enter },
          FragmentDefinition: { enter }
        }));
      }
      function buildQueryFromSelectionSet(document) {
        var definition = getMainDefinition(document);
        var definitionOperation = definition.operation;
        if (definitionOperation === "query") {
          return document;
        }
        var modifiedDoc = graphql.visit(document, {
          OperationDefinition: {
            enter: function(node) {
              return tslib.__assign(tslib.__assign({}, node), { operation: "query" });
            }
          }
        });
        return modifiedDoc;
      }
      function removeClientSetsFromDocument(document) {
        checkDocument(document);
        var modifiedDoc = removeDirectivesFromDocument([
          {
            test: function(directive) {
              return directive.name.value === "client";
            },
            remove: true
          }
        ], document);
        return modifiedDoc;
      }
      function addNonReactiveToNamedFragments(document) {
        checkDocument(document);
        return graphql.visit(document, {
          FragmentSpread: function(node) {
            var _a;
            if ((_a = node.directives) === null || _a === void 0 ? void 0 : _a.some(function(directive) {
              return directive.name.value === "unmask";
            })) {
              return;
            }
            return tslib.__assign(tslib.__assign({}, node), { directives: tslib.__spreadArray(tslib.__spreadArray([], node.directives || [], true), [
              {
                kind: graphql.Kind.DIRECTIVE,
                name: { kind: graphql.Kind.NAME, value: "nonreactive" }
              }
            ], false) });
          }
        });
      }
      function isOperation(document, operation) {
        var _a;
        return ((_a = getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation) === operation;
      }
      function isMutationOperation(document) {
        return isOperation(document, "mutation");
      }
      function isQueryOperation(document) {
        return isOperation(document, "query");
      }
      function isSubscriptionOperation(document) {
        return isOperation(document, "subscription");
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function mergeDeep2() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources[_i] = arguments[_i];
        }
        return mergeDeepArray(sources);
      }
      function mergeDeepArray(sources) {
        var target = sources[0] || {};
        var count = sources.length;
        if (count > 1) {
          var merger = new DeepMerger();
          for (var i = 1; i < count; ++i) {
            target = merger.merge(target, sources[i]);
          }
        }
        return target;
      }
      var defaultReconciler = function(target, source, property) {
        return this.merge(target[property], source[property]);
      };
      var DeepMerger = function() {
        function DeepMerger2(reconciler) {
          if (reconciler === void 0) {
            reconciler = defaultReconciler;
          }
          this.reconciler = reconciler;
          this.isObject = isNonNullObject;
          this.pastCopies = /* @__PURE__ */ new Set();
        }
        DeepMerger2.prototype.merge = function(target, source) {
          var _this = this;
          var context2 = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            context2[_i - 2] = arguments[_i];
          }
          if (isNonNullObject(source) && isNonNullObject(target)) {
            Object.keys(source).forEach(function(sourceKey) {
              if (hasOwnProperty.call(target, sourceKey)) {
                var targetValue = target[sourceKey];
                if (source[sourceKey] !== targetValue) {
                  var result = _this.reconciler.apply(_this, tslib.__spreadArray([
                    target,
                    source,
                    sourceKey
                  ], context2, false));
                  if (result !== targetValue) {
                    target = _this.shallowCopyForMerge(target);
                    target[sourceKey] = result;
                  }
                }
              } else {
                target = _this.shallowCopyForMerge(target);
                target[sourceKey] = source[sourceKey];
              }
            });
            return target;
          }
          return source;
        };
        DeepMerger2.prototype.shallowCopyForMerge = function(value) {
          if (isNonNullObject(value)) {
            if (!this.pastCopies.has(value)) {
              if (Array.isArray(value)) {
                value = value.slice(0);
              } else {
                value = tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
              }
              this.pastCopies.add(value);
            }
          }
          return value;
        };
        return DeepMerger2;
      }();
      function concatPagination(keyArgs) {
        if (keyArgs === void 0) {
          keyArgs = false;
        }
        return {
          keyArgs,
          merge: function(existing, incoming) {
            return existing ? tslib.__spreadArray(tslib.__spreadArray([], existing, true), incoming, true) : incoming;
          }
        };
      }
      function offsetLimitPagination(keyArgs) {
        if (keyArgs === void 0) {
          keyArgs = false;
        }
        return {
          keyArgs,
          merge: function(existing, incoming, _a) {
            var args = _a.args;
            var merged = existing ? existing.slice(0) : [];
            if (incoming) {
              if (args) {
                var _b = args.offset, offset = _b === void 0 ? 0 : _b;
                for (var i = 0; i < incoming.length; ++i) {
                  merged[offset + i] = incoming[i];
                }
              } else {
                merged.push.apply(merged, incoming);
              }
            }
            return merged;
          }
        };
      }
      function relayStylePagination(keyArgs) {
        if (keyArgs === void 0) {
          keyArgs = false;
        }
        return {
          keyArgs,
          read: function(existing, _a) {
            var canRead = _a.canRead, readField = _a.readField;
            if (!existing)
              return existing;
            var edges = [];
            var firstEdgeCursor = "";
            var lastEdgeCursor = "";
            existing.edges.forEach(function(edge) {
              if (canRead(readField("node", edge))) {
                edges.push(edge);
                if (edge.cursor) {
                  firstEdgeCursor = firstEdgeCursor || edge.cursor || "";
                  lastEdgeCursor = edge.cursor || lastEdgeCursor;
                }
              }
            });
            if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {
              firstEdgeCursor = "";
            }
            var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;
            return tslib.__assign(tslib.__assign({}, getExtras(existing)), { edges, pageInfo: tslib.__assign(tslib.__assign({}, existing.pageInfo), {
              startCursor: startCursor || firstEdgeCursor,
              endCursor: endCursor || lastEdgeCursor
            }) });
          },
          merge: function(existing, incoming, _a) {
            var args = _a.args, isReference2 = _a.isReference, readField = _a.readField;
            if (!existing) {
              existing = makeEmptyData();
            }
            if (!incoming) {
              return existing;
            }
            var incomingEdges = incoming.edges ? incoming.edges.map(function(edge) {
              if (isReference2(edge = tslib.__assign({}, edge))) {
                edge.cursor = readField("cursor", edge);
              }
              return edge;
            }) : [];
            if (incoming.pageInfo) {
              var pageInfo_1 = incoming.pageInfo;
              var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;
              var firstEdge = incomingEdges[0];
              var lastEdge = incomingEdges[incomingEdges.length - 1];
              if (firstEdge && startCursor) {
                firstEdge.cursor = startCursor;
              }
              if (lastEdge && endCursor) {
                lastEdge.cursor = endCursor;
              }
              var firstCursor = firstEdge && firstEdge.cursor;
              if (firstCursor && !startCursor) {
                incoming = mergeDeep2(incoming, {
                  pageInfo: {
                    startCursor: firstCursor
                  }
                });
              }
              var lastCursor = lastEdge && lastEdge.cursor;
              if (lastCursor && !endCursor) {
                incoming = mergeDeep2(incoming, {
                  pageInfo: {
                    endCursor: lastCursor
                  }
                });
              }
            }
            var prefix = existing.edges;
            var suffix = [];
            if (args && args.after) {
              var index = prefix.findIndex(function(edge) {
                return edge.cursor === args.after;
              });
              if (index >= 0) {
                prefix = prefix.slice(0, index + 1);
              }
            } else if (args && args.before) {
              var index = prefix.findIndex(function(edge) {
                return edge.cursor === args.before;
              });
              suffix = index < 0 ? prefix : prefix.slice(index);
              prefix = [];
            } else if (incoming.edges) {
              prefix = [];
            }
            var edges = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], prefix, true), incomingEdges, true), suffix, true);
            var pageInfo = tslib.__assign(tslib.__assign({}, incoming.pageInfo), existing.pageInfo);
            if (incoming.pageInfo) {
              var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras = tslib.__rest(_b, ["hasPreviousPage", "hasNextPage", "startCursor", "endCursor"]);
              Object.assign(pageInfo, extras);
              if (!prefix.length) {
                if (void 0 !== hasPreviousPage)
                  pageInfo.hasPreviousPage = hasPreviousPage;
                if (void 0 !== startCursor)
                  pageInfo.startCursor = startCursor;
              }
              if (!suffix.length) {
                if (void 0 !== hasNextPage)
                  pageInfo.hasNextPage = hasNextPage;
                if (void 0 !== endCursor)
                  pageInfo.endCursor = endCursor;
              }
            }
            return tslib.__assign(tslib.__assign(tslib.__assign({}, getExtras(existing)), getExtras(incoming)), { edges, pageInfo });
          }
        };
      }
      var getExtras = function(obj) {
        return tslib.__rest(obj, notExtras);
      };
      var notExtras = ["edges", "pageInfo"];
      function makeEmptyData() {
        return {
          edges: [],
          pageInfo: {
            hasPreviousPage: false,
            hasNextPage: true,
            startCursor: "",
            endCursor: ""
          }
        };
      }
      function createFulfilledPromise(value) {
        var promise = Promise.resolve(value);
        promise.status = "fulfilled";
        promise.value = value;
        return promise;
      }
      function createRejectedPromise(reason) {
        var promise = Promise.reject(reason);
        promise.catch(function() {
        });
        promise.status = "rejected";
        promise.reason = reason;
        return promise;
      }
      function isStatefulPromise(promise) {
        return "status" in promise;
      }
      function wrapPromiseWithState(promise) {
        if (isStatefulPromise(promise)) {
          return promise;
        }
        var pendingPromise = promise;
        pendingPromise.status = "pending";
        pendingPromise.then(function(value) {
          if (pendingPromise.status === "pending") {
            var fulfilledPromise = pendingPromise;
            fulfilledPromise.status = "fulfilled";
            fulfilledPromise.value = value;
          }
        }, function(reason) {
          if (pendingPromise.status === "pending") {
            var rejectedPromise = pendingPromise;
            rejectedPromise.status = "rejected";
            rejectedPromise.reason = reason;
          }
        });
        return promise;
      }
      function preventUnhandledRejection(promise) {
        promise.catch(function() {
        });
        return promise;
      }
      var toString = Object.prototype.toString;
      function cloneDeep(value) {
        return cloneDeepHelper(value);
      }
      function cloneDeepHelper(val, seen) {
        switch (toString.call(val)) {
          case "[object Array]": {
            seen = seen || /* @__PURE__ */ new Map();
            if (seen.has(val))
              return seen.get(val);
            var copy_1 = val.slice(0);
            seen.set(val, copy_1);
            copy_1.forEach(function(child, i) {
              copy_1[i] = cloneDeepHelper(child, seen);
            });
            return copy_1;
          }
          case "[object Object]": {
            seen = seen || /* @__PURE__ */ new Map();
            if (seen.has(val))
              return seen.get(val);
            var copy_2 = Object.create(Object.getPrototypeOf(val));
            seen.set(val, copy_2);
            Object.keys(val).forEach(function(key) {
              copy_2[key] = cloneDeepHelper(val[key], seen);
            });
            return copy_2;
          }
          default:
            return val;
        }
      }
      function deepFreeze(value) {
        var workSet = /* @__PURE__ */ new Set([value]);
        workSet.forEach(function(obj) {
          if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
            Object.getOwnPropertyNames(obj).forEach(function(name) {
              if (isNonNullObject(obj[name]))
                workSet.add(obj[name]);
            });
          }
        });
        return value;
      }
      function shallowFreeze(obj) {
        if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
          try {
            Object.freeze(obj);
          } catch (e) {
            if (e instanceof TypeError)
              return null;
            throw e;
          }
        }
        return obj;
      }
      function maybeDeepFreeze(obj) {
        if (globalThis.__DEV__ !== false) {
          deepFreeze(obj);
        }
        return obj;
      }
      function iterateObserversSafely(observers, method, argument) {
        var observersWithMethod = [];
        observers.forEach(function(obs) {
          return obs[method] && observersWithMethod.push(obs);
        });
        observersWithMethod.forEach(function(obs) {
          return obs[method](argument);
        });
      }
      function asyncMap(observable, mapFn, catchFn) {
        return new zenObservableTs.Observable(function(observer) {
          var promiseQueue = {
            then: function(callback) {
              return new Promise(function(resolve) {
                return resolve(callback());
              });
            }
          };
          function makeCallback(examiner, key) {
            return function(arg) {
              if (examiner) {
                var both = function() {
                  return observer.closed ? 0 : examiner(arg);
                };
                promiseQueue = promiseQueue.then(both, both).then(function(result) {
                  return observer.next(result);
                }, function(error) {
                  return observer.error(error);
                });
              } else {
                observer[key](arg);
              }
            };
          }
          var handler2 = {
            next: makeCallback(mapFn, "next"),
            error: makeCallback(catchFn, "error"),
            complete: function() {
              promiseQueue.then(function() {
                return observer.complete();
              });
            }
          };
          var sub = observable.subscribe(handler2);
          return function() {
            return sub.unsubscribe();
          };
        });
      }
      function fixObservableSubclass(subclass) {
        function set(key) {
          Object.defineProperty(subclass, key, { value: zenObservableTs.Observable });
        }
        if (canUseSymbol && Symbol.species) {
          set(Symbol.species);
        }
        set("@@species");
        return subclass;
      }
      function isPromiseLike(value) {
        return value && typeof value.then === "function";
      }
      var Concast = function(_super) {
        tslib.__extends(Concast2, _super);
        function Concast2(sources) {
          var _this = _super.call(this, function(observer) {
            _this.addObserver(observer);
            return function() {
              return _this.removeObserver(observer);
            };
          }) || this;
          _this.observers = /* @__PURE__ */ new Set();
          _this.promise = new Promise(function(resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
          });
          _this.handlers = {
            next: function(result) {
              if (_this.sub !== null) {
                _this.latest = ["next", result];
                _this.notify("next", result);
                iterateObserversSafely(_this.observers, "next", result);
              }
            },
            error: function(error) {
              var sub = _this.sub;
              if (sub !== null) {
                if (sub)
                  setTimeout(function() {
                    return sub.unsubscribe();
                  });
                _this.sub = null;
                _this.latest = ["error", error];
                _this.reject(error);
                _this.notify("error", error);
                iterateObserversSafely(_this.observers, "error", error);
              }
            },
            complete: function() {
              var _a = _this, sub = _a.sub, _b = _a.sources, sources2 = _b === void 0 ? [] : _b;
              if (sub !== null) {
                var value = sources2.shift();
                if (!value) {
                  if (sub)
                    setTimeout(function() {
                      return sub.unsubscribe();
                    });
                  _this.sub = null;
                  if (_this.latest && _this.latest[0] === "next") {
                    _this.resolve(_this.latest[1]);
                  } else {
                    _this.resolve();
                  }
                  _this.notify("complete");
                  iterateObserversSafely(_this.observers, "complete");
                } else if (isPromiseLike(value)) {
                  value.then(function(obs) {
                    return _this.sub = obs.subscribe(_this.handlers);
                  }, _this.handlers.error);
                } else {
                  _this.sub = value.subscribe(_this.handlers);
                }
              }
            }
          };
          _this.nextResultListeners = /* @__PURE__ */ new Set();
          _this.cancel = function(reason) {
            _this.reject(reason);
            _this.sources = [];
            _this.handlers.error(reason);
          };
          _this.promise.catch(function(_) {
          });
          if (typeof sources === "function") {
            sources = [new zenObservableTs.Observable(sources)];
          }
          if (isPromiseLike(sources)) {
            sources.then(function(iterable) {
              return _this.start(iterable);
            }, _this.handlers.error);
          } else {
            _this.start(sources);
          }
          return _this;
        }
        Concast2.prototype.start = function(sources) {
          if (this.sub !== void 0)
            return;
          this.sources = Array.from(sources);
          this.handlers.complete();
        };
        Concast2.prototype.deliverLastMessage = function(observer) {
          if (this.latest) {
            var nextOrError = this.latest[0];
            var method = observer[nextOrError];
            if (method) {
              method.call(observer, this.latest[1]);
            }
            if (this.sub === null && nextOrError === "next" && observer.complete) {
              observer.complete();
            }
          }
        };
        Concast2.prototype.addObserver = function(observer) {
          if (!this.observers.has(observer)) {
            this.deliverLastMessage(observer);
            this.observers.add(observer);
          }
        };
        Concast2.prototype.removeObserver = function(observer) {
          if (this.observers.delete(observer) && this.observers.size < 1) {
            this.handlers.complete();
          }
        };
        Concast2.prototype.notify = function(method, arg) {
          var nextResultListeners = this.nextResultListeners;
          if (nextResultListeners.size) {
            this.nextResultListeners = /* @__PURE__ */ new Set();
            nextResultListeners.forEach(function(listener) {
              return listener(method, arg);
            });
          }
        };
        Concast2.prototype.beforeNext = function(callback) {
          var called = false;
          this.nextResultListeners.add(function(method, arg) {
            if (!called) {
              called = true;
              callback(method, arg);
            }
          });
        };
        return Concast2;
      }(zenObservableTs.Observable);
      fixObservableSubclass(Concast);
      function isExecutionPatchIncrementalResult(value) {
        return "incremental" in value;
      }
      function isExecutionPatchInitialResult(value) {
        return "hasNext" in value && "data" in value;
      }
      function isExecutionPatchResult(value) {
        return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);
      }
      function isApolloPayloadResult(value) {
        return isNonNullObject(value) && "payload" in value;
      }
      function mergeIncrementalData(prevResult, result) {
        var mergedData = prevResult;
        var merger = new DeepMerger();
        if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
          result.incremental.forEach(function(_a) {
            var data = _a.data, path = _a.path;
            for (var i = path.length - 1; i >= 0; --i) {
              var key = path[i];
              var isNumericKey = !isNaN(+key);
              var parent_1 = isNumericKey ? [] : {};
              parent_1[key] = data;
              data = parent_1;
            }
            mergedData = merger.merge(mergedData, data);
          });
        }
        return mergedData;
      }
      function graphQLResultHasError(result) {
        var errors = getGraphQLErrorsFromResult(result);
        return isNonEmptyArray(errors);
      }
      function getGraphQLErrorsFromResult(result) {
        var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
        if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
          result.incremental.forEach(function(incrementalResult) {
            if (incrementalResult.errors) {
              graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
            }
          });
        }
        return graphQLErrors;
      }
      function compact() {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          objects[_i] = arguments[_i];
        }
        var result = /* @__PURE__ */ Object.create(null);
        objects.forEach(function(obj) {
          if (!obj)
            return;
          Object.keys(obj).forEach(function(key) {
            var value = obj[key];
            if (value !== void 0) {
              result[key] = value;
            }
          });
        });
        return result;
      }
      var prefixCounts = /* @__PURE__ */ new Map();
      function makeUniqueId(prefix) {
        var count = prefixCounts.get(prefix) || 1;
        prefixCounts.set(prefix, count + 1);
        return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
      }
      function stringifyForDisplay(value, space) {
        if (space === void 0) {
          space = 0;
        }
        var undefId = makeUniqueId("stringifyForDisplay");
        return JSON.stringify(value, function(key, value2) {
          return value2 === void 0 ? undefId : value2;
        }, space).split(JSON.stringify(undefId)).join("<undefined>");
      }
      function mergeOptions(defaults, options) {
        return compact(defaults, options, options.variables && {
          variables: compact(tslib.__assign(tslib.__assign({}, defaults && defaults.variables), options.variables))
        });
      }
      function omitDeep(value, key) {
        return __omitDeep(value, key);
      }
      function __omitDeep(value, key, known) {
        if (known === void 0) {
          known = /* @__PURE__ */ new Map();
        }
        if (known.has(value)) {
          return known.get(value);
        }
        var modified = false;
        if (Array.isArray(value)) {
          var array_1 = [];
          known.set(value, array_1);
          value.forEach(function(value2, index) {
            var result = __omitDeep(value2, key, known);
            modified || (modified = result !== value2);
            array_1[index] = result;
          });
          if (modified) {
            return array_1;
          }
        } else if (isPlainObject3(value)) {
          var obj_1 = Object.create(Object.getPrototypeOf(value));
          known.set(value, obj_1);
          Object.keys(value).forEach(function(k) {
            if (k === key) {
              modified = true;
              return;
            }
            var result = __omitDeep(value[k], key, known);
            modified || (modified = result !== value[k]);
            obj_1[k] = result;
          });
          if (modified) {
            return obj_1;
          }
        }
        return value;
      }
      function stripTypename(value) {
        return omitDeep(value, "__typename");
      }
      exports.DEV = globals.DEV;
      exports.maybe = globals.maybe;
      exports.Observable = zenObservableTs.Observable;
      exports.AutoCleanedStrongCache = AutoCleanedStrongCache;
      exports.AutoCleanedWeakCache = AutoCleanedWeakCache;
      exports.Concast = Concast;
      exports.DeepMerger = DeepMerger;
      exports.DocumentTransform = DocumentTransform;
      exports.addNonReactiveToNamedFragments = addNonReactiveToNamedFragments;
      exports.addTypenameToDocument = addTypenameToDocument;
      exports.argumentsObjectFromField = argumentsObjectFromField;
      exports.asyncMap = asyncMap;
      exports.buildQueryFromSelectionSet = buildQueryFromSelectionSet;
      exports.cacheSizes = cacheSizes;
      exports.canUseAsyncIteratorSymbol = canUseAsyncIteratorSymbol;
      exports.canUseDOM = canUseDOM;
      exports.canUseLayoutEffect = canUseLayoutEffect;
      exports.canUseSymbol = canUseSymbol;
      exports.canUseWeakMap = canUseWeakMap;
      exports.canUseWeakSet = canUseWeakSet;
      exports.canonicalStringify = canonicalStringify;
      exports.checkDocument = checkDocument;
      exports.cloneDeep = cloneDeep;
      exports.compact = compact;
      exports.concatPagination = concatPagination;
      exports.createFragmentMap = createFragmentMap;
      exports.createFulfilledPromise = createFulfilledPromise;
      exports.createRejectedPromise = createRejectedPromise;
      exports.fixObservableSubclass = fixObservableSubclass;
      exports.getDefaultValues = getDefaultValues;
      exports.getDirectiveNames = getDirectiveNames;
      exports.getFragmentDefinition = getFragmentDefinition;
      exports.getFragmentDefinitions = getFragmentDefinitions;
      exports.getFragmentFromSelection = getFragmentFromSelection;
      exports.getFragmentMaskMode = getFragmentMaskMode;
      exports.getFragmentQueryDocument = getFragmentQueryDocument;
      exports.getGraphQLErrorsFromResult = getGraphQLErrorsFromResult;
      exports.getInclusionDirectives = getInclusionDirectives;
      exports.getMainDefinition = getMainDefinition;
      exports.getOperationDefinition = getOperationDefinition;
      exports.getOperationName = getOperationName;
      exports.getQueryDefinition = getQueryDefinition;
      exports.getStoreKeyName = getStoreKeyName;
      exports.getTypenameFromResult = getTypenameFromResult;
      exports.graphQLResultHasError = graphQLResultHasError;
      exports.hasAllDirectives = hasAllDirectives;
      exports.hasAnyDirectives = hasAnyDirectives;
      exports.hasClientExports = hasClientExports;
      exports.hasDirectives = hasDirectives;
      exports.isApolloPayloadResult = isApolloPayloadResult;
      exports.isArray = isArray;
      exports.isDocumentNode = isDocumentNode;
      exports.isExecutionPatchIncrementalResult = isExecutionPatchIncrementalResult;
      exports.isExecutionPatchInitialResult = isExecutionPatchInitialResult;
      exports.isExecutionPatchResult = isExecutionPatchResult;
      exports.isField = isField;
      exports.isFullyUnmaskedOperation = isFullyUnmaskedOperation;
      exports.isInlineFragment = isInlineFragment;
      exports.isMutationOperation = isMutationOperation;
      exports.isNonEmptyArray = isNonEmptyArray;
      exports.isNonNullObject = isNonNullObject;
      exports.isPlainObject = isPlainObject3;
      exports.isQueryOperation = isQueryOperation;
      exports.isReference = isReference;
      exports.isStatefulPromise = isStatefulPromise;
      exports.isSubscriptionOperation = isSubscriptionOperation;
      exports.iterateObserversSafely = iterateObserversSafely;
      exports.makeReference = makeReference;
      exports.makeUniqueId = makeUniqueId;
      exports.maybeDeepFreeze = maybeDeepFreeze;
      exports.mergeDeep = mergeDeep2;
      exports.mergeDeepArray = mergeDeepArray;
      exports.mergeIncrementalData = mergeIncrementalData;
      exports.mergeOptions = mergeOptions;
      exports.offsetLimitPagination = offsetLimitPagination;
      exports.omitDeep = omitDeep;
      exports.preventUnhandledRejection = preventUnhandledRejection;
      exports.print = print;
      exports.relayStylePagination = relayStylePagination;
      exports.removeArgumentsFromDocument = removeArgumentsFromDocument;
      exports.removeClientSetsFromDocument = removeClientSetsFromDocument;
      exports.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument;
      exports.removeDirectivesFromDocument = removeDirectivesFromDocument;
      exports.removeFragmentSpreadFromDocument = removeFragmentSpreadFromDocument;
      exports.resultKeyNameFromField = resultKeyNameFromField;
      exports.shouldInclude = shouldInclude;
      exports.storeKeyNameFromField = storeKeyNameFromField;
      exports.stringifyForDisplay = stringifyForDisplay;
      exports.stripTypename = stripTypename;
      exports.valueToObjectRepresentation = valueToObjectRepresentation;
      exports.wrapPromiseWithState = wrapPromiseWithState;
    }
  });

  // node_modules/@apollo/client/link/utils/utils.cjs
  var require_utils5 = __commonJS({
    "node_modules/@apollo/client/link/utils/utils.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var globals = require_globals();
      var utilities = require_utilities2();
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var graphql = require_graphql2();
      function fromError(errorValue) {
        return new utilities.Observable(function(observer) {
          observer.error(errorValue);
        });
      }
      function toPromise(observable) {
        var completed = false;
        return new Promise(function(resolve, reject) {
          observable.subscribe({
            next: function(data) {
              if (completed) {
                globalThis.__DEV__ !== false && globals.invariant.warn(45);
              } else {
                completed = true;
                resolve(data);
              }
            },
            error: reject
          });
        });
      }
      function fromPromise(promise) {
        return new utilities.Observable(function(observer) {
          promise.then(function(value) {
            observer.next(value);
            observer.complete();
          }).catch(observer.error.bind(observer));
        });
      }
      var throwServerError = function(response, result, message) {
        var error = new Error(message);
        error.name = "ServerError";
        error.response = response;
        error.statusCode = response.status;
        error.result = result;
        throw error;
      };
      function validateOperation(operation) {
        var OPERATION_FIELDS = [
          "query",
          "operationName",
          "variables",
          "extensions",
          "context"
        ];
        for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
          var key = _a[_i];
          if (OPERATION_FIELDS.indexOf(key) < 0) {
            throw globals.newInvariantError(46, key);
          }
        }
        return operation;
      }
      function createOperation(starting, operation) {
        var context2 = tslib.__assign({}, starting);
        var setContext = function(next) {
          if (typeof next === "function") {
            context2 = tslib.__assign(tslib.__assign({}, context2), next(context2));
          } else {
            context2 = tslib.__assign(tslib.__assign({}, context2), next);
          }
        };
        var getContext = function() {
          return tslib.__assign({}, context2);
        };
        Object.defineProperty(operation, "setContext", {
          enumerable: false,
          value: setContext
        });
        Object.defineProperty(operation, "getContext", {
          enumerable: false,
          value: getContext
        });
        return operation;
      }
      function transformOperation(operation) {
        var transformedOperation = {
          variables: operation.variables || {},
          extensions: operation.extensions || {},
          operationName: operation.operationName,
          query: operation.query
        };
        if (!transformedOperation.operationName) {
          transformedOperation.operationName = typeof transformedOperation.query !== "string" ? utilities.getOperationName(transformedOperation.query) || void 0 : "";
        }
        return transformedOperation;
      }
      function filterOperationVariables(variables, query) {
        var result = tslib.__assign({}, variables);
        var unusedNames = new Set(Object.keys(variables));
        graphql.visit(query, {
          Variable: function(node, _key, parent) {
            if (parent && parent.kind !== "VariableDefinition") {
              unusedNames.delete(node.name.value);
            }
          }
        });
        unusedNames.forEach(function(name) {
          delete result[name];
        });
        return result;
      }
      exports.createOperation = createOperation;
      exports.filterOperationVariables = filterOperationVariables;
      exports.fromError = fromError;
      exports.fromPromise = fromPromise;
      exports.throwServerError = throwServerError;
      exports.toPromise = toPromise;
      exports.transformOperation = transformOperation;
      exports.validateOperation = validateOperation;
    }
  });

  // node_modules/@apollo/client/link/core/core.cjs
  var require_core2 = __commonJS({
    "node_modules/@apollo/client/link/core/core.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var globals = require_globals();
      var utilities = require_utilities2();
      var utils = require_utils5();
      function passthrough(op, forward) {
        return forward ? forward(op) : utilities.Observable.of();
      }
      function toLink(handler2) {
        return typeof handler2 === "function" ? new ApolloLink(handler2) : handler2;
      }
      function isTerminating(link) {
        return link.request.length <= 1;
      }
      var ApolloLink = function() {
        function ApolloLink2(request2) {
          if (request2)
            this.request = request2;
        }
        ApolloLink2.empty = function() {
          return new ApolloLink2(function() {
            return utilities.Observable.of();
          });
        };
        ApolloLink2.from = function(links) {
          if (links.length === 0)
            return ApolloLink2.empty();
          return links.map(toLink).reduce(function(x, y) {
            return x.concat(y);
          });
        };
        ApolloLink2.split = function(test, left, right) {
          var leftLink = toLink(left);
          var rightLink = toLink(right || new ApolloLink2(passthrough));
          var ret;
          if (isTerminating(leftLink) && isTerminating(rightLink)) {
            ret = new ApolloLink2(function(operation) {
              return test(operation) ? leftLink.request(operation) || utilities.Observable.of() : rightLink.request(operation) || utilities.Observable.of();
            });
          } else {
            ret = new ApolloLink2(function(operation, forward) {
              return test(operation) ? leftLink.request(operation, forward) || utilities.Observable.of() : rightLink.request(operation, forward) || utilities.Observable.of();
            });
          }
          return Object.assign(ret, { left: leftLink, right: rightLink });
        };
        ApolloLink2.execute = function(link, operation) {
          return link.request(utils.createOperation(operation.context, utils.transformOperation(utils.validateOperation(operation)))) || utilities.Observable.of();
        };
        ApolloLink2.concat = function(first, second) {
          var firstLink = toLink(first);
          if (isTerminating(firstLink)) {
            globalThis.__DEV__ !== false && globals.invariant.warn(38, firstLink);
            return firstLink;
          }
          var nextLink = toLink(second);
          var ret;
          if (isTerminating(nextLink)) {
            ret = new ApolloLink2(function(operation) {
              return firstLink.request(operation, function(op) {
                return nextLink.request(op) || utilities.Observable.of();
              }) || utilities.Observable.of();
            });
          } else {
            ret = new ApolloLink2(function(operation, forward) {
              return firstLink.request(operation, function(op) {
                return nextLink.request(op, forward) || utilities.Observable.of();
              }) || utilities.Observable.of();
            });
          }
          return Object.assign(ret, { left: firstLink, right: nextLink });
        };
        ApolloLink2.prototype.split = function(test, left, right) {
          return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
        };
        ApolloLink2.prototype.concat = function(next) {
          return ApolloLink2.concat(this, next);
        };
        ApolloLink2.prototype.request = function(operation, forward) {
          throw globals.newInvariantError(39);
        };
        ApolloLink2.prototype.onError = function(error, observer) {
          if (observer && observer.error) {
            observer.error(error);
            return false;
          }
          throw error;
        };
        ApolloLink2.prototype.setOnError = function(fn) {
          this.onError = fn;
          return this;
        };
        return ApolloLink2;
      }();
      var empty = ApolloLink.empty;
      var from = ApolloLink.from;
      var split = ApolloLink.split;
      var concat = ApolloLink.concat;
      var execute = ApolloLink.execute;
      exports.ApolloLink = ApolloLink;
      exports.concat = concat;
      exports.empty = empty;
      exports.execute = execute;
      exports.from = from;
      exports.split = split;
    }
  });

  // node_modules/@apollo/client/errors/errors.cjs
  var require_errors2 = __commonJS({
    "node_modules/@apollo/client/errors/errors.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      require_globals();
      var utilities = require_utilities2();
      var PROTOCOL_ERRORS_SYMBOL = Symbol();
      function graphQLResultHasProtocolErrors(result) {
        if (result.extensions) {
          return Array.isArray(result.extensions[PROTOCOL_ERRORS_SYMBOL]);
        }
        return false;
      }
      function isApolloError(err) {
        return err.hasOwnProperty("graphQLErrors");
      }
      var generateErrorMessage = function(err) {
        var errors = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
        if (err.networkError)
          errors.push(err.networkError);
        return errors.map(function(err2) {
          return utilities.isNonNullObject(err2) && err2.message || "Error message not found.";
        }).join("\n");
      };
      var ApolloError = function(_super) {
        tslib.__extends(ApolloError2, _super);
        function ApolloError2(_a) {
          var graphQLErrors = _a.graphQLErrors, protocolErrors = _a.protocolErrors, clientErrors = _a.clientErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
          var _this = _super.call(this, errorMessage) || this;
          _this.name = "ApolloError";
          _this.graphQLErrors = graphQLErrors || [];
          _this.protocolErrors = protocolErrors || [];
          _this.clientErrors = clientErrors || [];
          _this.networkError = networkError || null;
          _this.message = errorMessage || generateErrorMessage(_this);
          _this.extraInfo = extraInfo;
          _this.cause = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([
            networkError
          ], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function(e) {
            return !!e;
          }) || null;
          _this.__proto__ = ApolloError2.prototype;
          return _this;
        }
        return ApolloError2;
      }(Error);
      exports.ApolloError = ApolloError;
      exports.PROTOCOL_ERRORS_SYMBOL = PROTOCOL_ERRORS_SYMBOL;
      exports.graphQLResultHasProtocolErrors = graphQLResultHasProtocolErrors;
      exports.isApolloError = isApolloError;
    }
  });

  // node_modules/@apollo/client/link/http/http.cjs
  var require_http = __commonJS({
    "node_modules/@apollo/client/link/http/http.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var globals = require_globals();
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var utilities = require_utilities2();
      var utils = require_utils5();
      var errors = require_errors2();
      var core2 = require_core2();
      function asyncIterator(source) {
        var _a;
        var iterator = source[Symbol.asyncIterator]();
        return _a = {
          next: function() {
            return iterator.next();
          }
        }, _a[Symbol.asyncIterator] = function() {
          return this;
        }, _a;
      }
      function nodeStreamIterator(stream) {
        var cleanup = null;
        var error = null;
        var done = false;
        var data = [];
        var waiting = [];
        function onData(chunk) {
          if (error)
            return;
          if (waiting.length) {
            var shiftedArr = waiting.shift();
            if (Array.isArray(shiftedArr) && shiftedArr[0]) {
              return shiftedArr[0]({ value: chunk, done: false });
            }
          }
          data.push(chunk);
        }
        function onError(err) {
          error = err;
          var all = waiting.slice();
          all.forEach(function(pair) {
            pair[1](err);
          });
          !cleanup || cleanup();
        }
        function onEnd() {
          done = true;
          var all = waiting.slice();
          all.forEach(function(pair) {
            pair[0]({ value: void 0, done: true });
          });
          !cleanup || cleanup();
        }
        cleanup = function() {
          cleanup = null;
          stream.removeListener("data", onData);
          stream.removeListener("error", onError);
          stream.removeListener("end", onEnd);
          stream.removeListener("finish", onEnd);
          stream.removeListener("close", onEnd);
        };
        stream.on("data", onData);
        stream.on("error", onError);
        stream.on("end", onEnd);
        stream.on("finish", onEnd);
        stream.on("close", onEnd);
        function getNext() {
          return new Promise(function(resolve, reject) {
            if (error)
              return reject(error);
            if (data.length)
              return resolve({ value: data.shift(), done: false });
            if (done)
              return resolve({ value: void 0, done: true });
            waiting.push([resolve, reject]);
          });
        }
        var iterator = {
          next: function() {
            return getNext();
          }
        };
        if (utilities.canUseAsyncIteratorSymbol) {
          iterator[Symbol.asyncIterator] = function() {
            return this;
          };
        }
        return iterator;
      }
      function promiseIterator(promise) {
        var resolved = false;
        var iterator = {
          next: function() {
            if (resolved)
              return Promise.resolve({
                value: void 0,
                done: true
              });
            resolved = true;
            return new Promise(function(resolve, reject) {
              promise.then(function(value) {
                resolve({ value, done: false });
              }).catch(reject);
            });
          }
        };
        if (utilities.canUseAsyncIteratorSymbol) {
          iterator[Symbol.asyncIterator] = function() {
            return this;
          };
        }
        return iterator;
      }
      function readerIterator(reader) {
        var iterator = {
          next: function() {
            return reader.read();
          }
        };
        if (utilities.canUseAsyncIteratorSymbol) {
          iterator[Symbol.asyncIterator] = function() {
            return this;
          };
        }
        return iterator;
      }
      function isNodeResponse(value) {
        return !!value.body;
      }
      function isReadableStream(value) {
        return !!value.getReader;
      }
      function isAsyncIterableIterator(value) {
        return !!(utilities.canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
      }
      function isStreamableBlob(value) {
        return !!value.stream;
      }
      function isBlob(value) {
        return !!value.arrayBuffer;
      }
      function isNodeReadableStream(value) {
        return !!value.pipe;
      }
      function responseIterator(response) {
        var body = response;
        if (isNodeResponse(response))
          body = response.body;
        if (isAsyncIterableIterator(body))
          return asyncIterator(body);
        if (isReadableStream(body))
          return readerIterator(body.getReader());
        if (isStreamableBlob(body)) {
          return readerIterator(body.stream().getReader());
        }
        if (isBlob(body))
          return promiseIterator(body.arrayBuffer());
        if (isNodeReadableStream(body))
          return nodeStreamIterator(body);
        throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
      }
      function isNonNullObject(obj) {
        return obj !== null && typeof obj === "object";
      }
      function isApolloPayloadResult(value) {
        return isNonNullObject(value) && "payload" in value;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function readMultipartBody(response, nextValue) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next;
          var _b, _c;
          var _d;
          return tslib.__generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                if (TextDecoder === void 0) {
                  throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
                }
                decoder = new TextDecoder("utf-8");
                contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
                delimiter = "boundary=";
                boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
                boundary = "\r\n--".concat(boundaryVal);
                buffer = "";
                iterator = responseIterator(response);
                running = true;
                _e.label = 1;
              case 1:
                if (!running) return [3, 3];
                return [4, iterator.next()];
              case 2:
                _a = _e.sent(), value = _a.value, done = _a.done;
                chunk = typeof value === "string" ? value : decoder.decode(value);
                searchFrom = buffer.length - boundary.length + 1;
                running = !done;
                buffer += chunk;
                bi = buffer.indexOf(boundary, searchFrom);
                while (bi > -1) {
                  message = void 0;
                  _b = [
                    buffer.slice(0, bi),
                    buffer.slice(bi + boundary.length)
                  ], message = _b[0], buffer = _b[1];
                  i = message.indexOf("\r\n\r\n");
                  headers = parseHeaders(message.slice(0, i));
                  contentType_1 = headers["content-type"];
                  if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
                    throw new Error("Unsupported patch content type: application/json is required.");
                  }
                  body = message.slice(i);
                  if (body) {
                    result = parseJsonBody(response, body);
                    if (Object.keys(result).length > 1 || "data" in result || "incremental" in result || "errors" in result || "payload" in result) {
                      if (isApolloPayloadResult(result)) {
                        next = {};
                        if ("payload" in result) {
                          if (Object.keys(result).length === 1 && result.payload === null) {
                            return [2];
                          }
                          next = tslib.__assign({}, result.payload);
                        }
                        if ("errors" in result) {
                          next = tslib.__assign(tslib.__assign({}, next), { extensions: tslib.__assign(tslib.__assign({}, "extensions" in next ? next.extensions : null), (_c = {}, _c[errors.PROTOCOL_ERRORS_SYMBOL] = result.errors, _c)) });
                        }
                        nextValue(next);
                      } else {
                        nextValue(result);
                      }
                    } else if (Object.keys(result).length === 1 && "hasNext" in result && !result.hasNext) {
                      return [2];
                    }
                  }
                  bi = buffer.indexOf(boundary);
                }
                return [3, 1];
              case 3:
                return [2];
            }
          });
        });
      }
      function parseHeaders(headerText) {
        var headersInit = {};
        headerText.split("\n").forEach(function(line) {
          var i = line.indexOf(":");
          if (i > -1) {
            var name_1 = line.slice(0, i).trim().toLowerCase();
            var value = line.slice(i + 1).trim();
            headersInit[name_1] = value;
          }
        });
        return headersInit;
      }
      function parseJsonBody(response, bodyText) {
        if (response.status >= 300) {
          var getResult = function() {
            try {
              return JSON.parse(bodyText);
            } catch (err) {
              return bodyText;
            }
          };
          utils.throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
        }
        try {
          return JSON.parse(bodyText);
        } catch (err) {
          var parseError = err;
          parseError.name = "ServerParseError";
          parseError.response = response;
          parseError.statusCode = response.status;
          parseError.bodyText = bodyText;
          throw parseError;
        }
      }
      function handleError(err, observer) {
        if (err.result && err.result.errors && err.result.data) {
          observer.next(err.result);
        }
        observer.error(err);
      }
      function parseAndCheckHttpResponse(operations) {
        return function(response) {
          return response.text().then(function(bodyText) {
            return parseJsonBody(response, bodyText);
          }).then(function(result) {
            if (!Array.isArray(result) && !hasOwnProperty.call(result, "data") && !hasOwnProperty.call(result, "errors")) {
              utils.throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
                return op.operationName;
              }) : operations.operationName, "'."));
            }
            return result;
          });
        };
      }
      var serializeFetchParameter = function(p, label) {
        var serialized;
        try {
          serialized = JSON.stringify(p);
        } catch (e) {
          var parseError = globals.newInvariantError(42, label, e.message);
          parseError.parseError = e;
          throw parseError;
        }
        return serialized;
      };
      var defaultHttpOptions = {
        includeQuery: true,
        includeExtensions: false,
        preserveHeaderCase: false
      };
      var defaultHeaders = {
        accept: "*/*",
        "content-type": "application/json"
      };
      var defaultOptions = {
        method: "POST"
      };
      var fallbackHttpConfig = {
        http: defaultHttpOptions,
        headers: defaultHeaders,
        options: defaultOptions
      };
      var defaultPrinter = function(ast, printer) {
        return printer(ast);
      };
      function selectHttpOptionsAndBody(operation, fallbackConfig) {
        var configs = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          configs[_i - 2] = arguments[_i];
        }
        configs.unshift(fallbackConfig);
        return selectHttpOptionsAndBodyInternal.apply(void 0, tslib.__spreadArray([
          operation,
          defaultPrinter
        ], configs, false));
      }
      function selectHttpOptionsAndBodyInternal(operation, printer) {
        var configs = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          configs[_i - 2] = arguments[_i];
        }
        var options = {};
        var http = {};
        configs.forEach(function(config) {
          options = tslib.__assign(tslib.__assign(tslib.__assign({}, options), config.options), { headers: tslib.__assign(tslib.__assign({}, options.headers), config.headers) });
          if (config.credentials) {
            options.credentials = config.credentials;
          }
          http = tslib.__assign(tslib.__assign({}, http), config.http);
        });
        if (options.headers) {
          options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);
        }
        var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
        var body = { operationName, variables };
        if (http.includeExtensions)
          body.extensions = extensions;
        if (http.includeQuery)
          body.query = printer(query, utilities.print);
        return {
          options,
          body
        };
      }
      function removeDuplicateHeaders(headers, preserveHeaderCase) {
        if (!preserveHeaderCase) {
          var normalizedHeaders_1 = {};
          Object.keys(Object(headers)).forEach(function(name) {
            normalizedHeaders_1[name.toLowerCase()] = headers[name];
          });
          return normalizedHeaders_1;
        }
        var headerData = {};
        Object.keys(Object(headers)).forEach(function(name) {
          headerData[name.toLowerCase()] = {
            originalName: name,
            value: headers[name]
          };
        });
        var normalizedHeaders = {};
        Object.keys(headerData).forEach(function(name) {
          normalizedHeaders[headerData[name].originalName] = headerData[name].value;
        });
        return normalizedHeaders;
      }
      var checkFetcher = function(fetcher) {
        if (!fetcher && typeof fetch === "undefined") {
          throw globals.newInvariantError(40);
        }
      };
      var createSignalIfSupported = function() {
        if (typeof AbortController === "undefined")
          return { controller: false, signal: false };
        var controller = new AbortController();
        var signal = controller.signal;
        return { controller, signal };
      };
      var selectURI = function(operation, fallbackURI) {
        var context2 = operation.getContext();
        var contextURI = context2.uri;
        if (contextURI) {
          return contextURI;
        } else if (typeof fallbackURI === "function") {
          return fallbackURI(operation);
        } else {
          return fallbackURI || "/graphql";
        }
      };
      function rewriteURIForGET(chosenURI, body) {
        var queryParams = [];
        var addQueryParam = function(key, value) {
          queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
        };
        if ("query" in body) {
          addQueryParam("query", body.query);
        }
        if (body.operationName) {
          addQueryParam("operationName", body.operationName);
        }
        if (body.variables) {
          var serializedVariables = void 0;
          try {
            serializedVariables = serializeFetchParameter(body.variables, "Variables map");
          } catch (parseError) {
            return { parseError };
          }
          addQueryParam("variables", serializedVariables);
        }
        if (body.extensions) {
          var serializedExtensions = void 0;
          try {
            serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
          } catch (parseError) {
            return { parseError };
          }
          addQueryParam("extensions", serializedExtensions);
        }
        var fragment = "", preFragment = chosenURI;
        var fragmentStart = chosenURI.indexOf("#");
        if (fragmentStart !== -1) {
          fragment = chosenURI.substr(fragmentStart);
          preFragment = chosenURI.substr(0, fragmentStart);
        }
        var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
        var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
        return { newURI };
      }
      var backupFetch = utilities.maybe(function() {
        return fetch;
      });
      var createHttpLink = function(linkOptions) {
        if (linkOptions === void 0) {
          linkOptions = {};
        }
        var _a = linkOptions.uri, uri = _a === void 0 ? "/graphql" : _a, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = tslib.__rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
        if (globalThis.__DEV__ !== false) {
          checkFetcher(preferredFetch || backupFetch);
        }
        var linkConfig = {
          http: { includeExtensions, preserveHeaderCase },
          options: requestOptions.fetchOptions,
          credentials: requestOptions.credentials,
          headers: requestOptions.headers
        };
        return new core2.ApolloLink(function(operation) {
          var chosenURI = selectURI(operation, uri);
          var context2 = operation.getContext();
          var clientAwarenessHeaders = {};
          if (context2.clientAwareness) {
            var _a2 = context2.clientAwareness, name_1 = _a2.name, version = _a2.version;
            if (name_1) {
              clientAwarenessHeaders["apollographql-client-name"] = name_1;
            }
            if (version) {
              clientAwarenessHeaders["apollographql-client-version"] = version;
            }
          }
          var contextHeaders = tslib.__assign(tslib.__assign({}, clientAwarenessHeaders), context2.headers);
          var contextConfig = {
            http: context2.http,
            options: context2.fetchOptions,
            credentials: context2.credentials,
            headers: contextHeaders
          };
          if (utilities.hasDirectives(["client"], operation.query)) {
            var transformedQuery = utilities.removeClientSetsFromDocument(operation.query);
            if (!transformedQuery) {
              return utils.fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
            }
            operation.query = transformedQuery;
          }
          var _b2 = selectHttpOptionsAndBodyInternal(operation, print, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
          if (body.variables && !includeUnusedVariables) {
            body.variables = utils.filterOperationVariables(body.variables, operation.query);
          }
          var controller;
          if (!options.signal && typeof AbortController !== "undefined") {
            controller = new AbortController();
            options.signal = controller.signal;
          }
          var definitionIsMutation = function(d) {
            return d.kind === "OperationDefinition" && d.operation === "mutation";
          };
          var definitionIsSubscription = function(d) {
            return d.kind === "OperationDefinition" && d.operation === "subscription";
          };
          var isSubscription = definitionIsSubscription(utilities.getMainDefinition(operation.query));
          var hasDefer = utilities.hasDirectives(["defer"], operation.query);
          if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
            options.method = "GET";
          }
          if (hasDefer || isSubscription) {
            options.headers = options.headers || {};
            var acceptHeader = "multipart/mixed;";
            if (isSubscription && hasDefer) {
              globalThis.__DEV__ !== false && globals.invariant.warn(41);
            }
            if (isSubscription) {
              acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
            } else if (hasDefer) {
              acceptHeader += "deferSpec=20220824,application/json";
            }
            options.headers.accept = acceptHeader;
          }
          if (options.method === "GET") {
            var _c2 = rewriteURIForGET(chosenURI, body), newURI = _c2.newURI, parseError = _c2.parseError;
            if (parseError) {
              return utils.fromError(parseError);
            }
            chosenURI = newURI;
          } else {
            try {
              options.body = serializeFetchParameter(body, "Payload");
            } catch (parseError2) {
              return utils.fromError(parseError2);
            }
          }
          return new utilities.Observable(function(observer) {
            var currentFetch = preferredFetch || utilities.maybe(function() {
              return fetch;
            }) || backupFetch;
            var observerNext = observer.next.bind(observer);
            currentFetch(chosenURI, options).then(function(response) {
              var _a3;
              operation.setContext({ response });
              var ctype = (_a3 = response.headers) === null || _a3 === void 0 ? void 0 : _a3.get("content-type");
              if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
                return readMultipartBody(response, observerNext);
              } else {
                return parseAndCheckHttpResponse(operation)(response).then(observerNext);
              }
            }).then(function() {
              controller = void 0;
              observer.complete();
            }).catch(function(err) {
              controller = void 0;
              handleError(err, observer);
            });
            return function() {
              if (controller)
                controller.abort();
            };
          });
        });
      };
      var HttpLink = function(_super) {
        tslib.__extends(HttpLink2, _super);
        function HttpLink2(options) {
          if (options === void 0) {
            options = {};
          }
          var _this = _super.call(this, createHttpLink(options).request) || this;
          _this.options = options;
          return _this;
        }
        return HttpLink2;
      }(core2.ApolloLink);
      exports.HttpLink = HttpLink;
      exports.checkFetcher = checkFetcher;
      exports.createHttpLink = createHttpLink;
      exports.createSignalIfSupported = createSignalIfSupported;
      exports.defaultPrinter = defaultPrinter;
      exports.fallbackHttpConfig = fallbackHttpConfig;
      exports.parseAndCheckHttpResponse = parseAndCheckHttpResponse;
      exports.rewriteURIForGET = rewriteURIForGET;
      exports.selectHttpOptionsAndBody = selectHttpOptionsAndBody;
      exports.selectHttpOptionsAndBodyInternal = selectHttpOptionsAndBodyInternal;
      exports.selectURI = selectURI;
      exports.serializeFetchParameter = serializeFetchParameter;
    }
  });

  // node_modules/@wry/equality/lib/bundle.cjs
  var require_bundle5 = __commonJS({
    "node_modules/@wry/equality/lib/bundle.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var { toString, hasOwnProperty } = Object.prototype;
      var fnToStr = Function.prototype.toString;
      var previousComparisons = /* @__PURE__ */ new Map();
      function equal(a, b) {
        try {
          return check(a, b);
        } finally {
          previousComparisons.clear();
        }
      }
      function check(a, b) {
        if (a === b) {
          return true;
        }
        const aTag = toString.call(a);
        const bTag = toString.call(b);
        if (aTag !== bTag) {
          return false;
        }
        switch (aTag) {
          case "[object Array]":
            if (a.length !== b.length)
              return false;
          // Fall through to object case...
          case "[object Object]": {
            if (previouslyCompared(a, b))
              return true;
            const aKeys = definedKeys(a);
            const bKeys = definedKeys(b);
            const keyCount = aKeys.length;
            if (keyCount !== bKeys.length)
              return false;
            for (let k = 0; k < keyCount; ++k) {
              if (!hasOwnProperty.call(b, aKeys[k])) {
                return false;
              }
            }
            for (let k = 0; k < keyCount; ++k) {
              const key = aKeys[k];
              if (!check(a[key], b[key])) {
                return false;
              }
            }
            return true;
          }
          case "[object Error]":
            return a.name === b.name && a.message === b.message;
          case "[object Number]":
            if (a !== a)
              return b !== b;
          // Fall through to shared +a === +b case...
          case "[object Boolean]":
          case "[object Date]":
            return +a === +b;
          case "[object RegExp]":
          case "[object String]":
            return a == `${b}`;
          case "[object Map]":
          case "[object Set]": {
            if (a.size !== b.size)
              return false;
            if (previouslyCompared(a, b))
              return true;
            const aIterator = a.entries();
            const isMap = aTag === "[object Map]";
            while (true) {
              const info = aIterator.next();
              if (info.done)
                break;
              const [aKey, aValue] = info.value;
              if (!b.has(aKey)) {
                return false;
              }
              if (isMap && !check(aValue, b.get(aKey))) {
                return false;
              }
            }
            return true;
          }
          case "[object Uint16Array]":
          case "[object Uint8Array]":
          // Buffer, in Node.js.
          case "[object Uint32Array]":
          case "[object Int32Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object ArrayBuffer]":
            a = new Uint8Array(a);
            b = new Uint8Array(b);
          // Fall through...
          case "[object DataView]": {
            let len = a.byteLength;
            if (len === b.byteLength) {
              while (len-- && a[len] === b[len]) {
              }
            }
            return len === -1;
          }
          case "[object AsyncFunction]":
          case "[object GeneratorFunction]":
          case "[object AsyncGeneratorFunction]":
          case "[object Function]": {
            const aCode = fnToStr.call(a);
            if (aCode !== fnToStr.call(b)) {
              return false;
            }
            return !endsWith(aCode, nativeCodeSuffix);
          }
        }
        return false;
      }
      function definedKeys(obj) {
        return Object.keys(obj).filter(isDefinedKey, obj);
      }
      function isDefinedKey(key) {
        return this[key] !== void 0;
      }
      var nativeCodeSuffix = "{ [native code] }";
      function endsWith(full, suffix) {
        const fromIndex = full.length - suffix.length;
        return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
      }
      function previouslyCompared(a, b) {
        let bSet = previousComparisons.get(a);
        if (bSet) {
          if (bSet.has(b))
            return true;
        } else {
          previousComparisons.set(a, bSet = /* @__PURE__ */ new Set());
        }
        bSet.add(b);
        return false;
      }
      exports.default = equal;
      exports.equal = equal;
    }
  });

  // node_modules/@apollo/client/masking/masking.cjs
  var require_masking = __commonJS({
    "node_modules/@apollo/client/masking/masking.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var optimism = require_bundle4();
      var globals = require_globals();
      var utilities = require_utilities2();
      var graphql = require_graphql2();
      var equal = require_bundle5();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e["default"] : e;
      }
      var equal__default = /* @__PURE__ */ _interopDefaultLegacy(equal);
      var MapImpl = utilities.canUseWeakMap ? WeakMap : Map;
      var SetImpl = utilities.canUseWeakSet ? WeakSet : Set;
      var disableWarningsSlot = new optimism.Slot();
      var issuedWarning = false;
      function warnOnImproperCacheImplementation() {
        if (!issuedWarning) {
          issuedWarning = true;
          globalThis.__DEV__ !== false && globals.invariant.warn(52);
        }
      }
      function maskDefinition(data, selectionSet, context2) {
        return disableWarningsSlot.withValue(true, function() {
          var masked = maskSelectionSet(data, selectionSet, context2, false);
          if (Object.isFrozen(data)) {
            utilities.maybeDeepFreeze(masked);
          }
          return masked;
        });
      }
      function getMutableTarget(data, mutableTargets) {
        if (mutableTargets.has(data)) {
          return mutableTargets.get(data);
        }
        var mutableTarget = Array.isArray(data) ? [] : /* @__PURE__ */ Object.create(null);
        mutableTargets.set(data, mutableTarget);
        return mutableTarget;
      }
      function maskSelectionSet(data, selectionSet, context2, migration, path) {
        var _a;
        var knownChanged = context2.knownChanged;
        var memo = getMutableTarget(data, context2.mutableTargets);
        if (Array.isArray(data)) {
          for (var _i = 0, _b = Array.from(data.entries()); _i < _b.length; _i++) {
            var _c = _b[_i], index = _c[0], item = _c[1];
            if (item === null) {
              memo[index] = null;
              continue;
            }
            var masked = maskSelectionSet(item, selectionSet, context2, migration, globalThis.__DEV__ !== false ? "".concat(path || "", "[").concat(index, "]") : void 0);
            if (knownChanged.has(masked)) {
              knownChanged.add(memo);
            }
            memo[index] = masked;
          }
          return knownChanged.has(memo) ? memo : data;
        }
        for (var _d = 0, _e = selectionSet.selections; _d < _e.length; _d++) {
          var selection = _e[_d];
          var value = void 0;
          if (migration) {
            knownChanged.add(memo);
          }
          if (selection.kind === graphql.Kind.FIELD) {
            var keyName = utilities.resultKeyNameFromField(selection);
            var childSelectionSet = selection.selectionSet;
            value = memo[keyName] || data[keyName];
            if (value === void 0) {
              continue;
            }
            if (childSelectionSet && value !== null) {
              var masked = maskSelectionSet(data[keyName], childSelectionSet, context2, migration, globalThis.__DEV__ !== false ? "".concat(path || "", ".").concat(keyName) : void 0);
              if (knownChanged.has(masked)) {
                value = masked;
              }
            }
            if (!(globalThis.__DEV__ !== false)) {
              memo[keyName] = value;
            }
            if (globalThis.__DEV__ !== false) {
              if (migration && keyName !== "__typename" && !((_a = Object.getOwnPropertyDescriptor(memo, keyName)) === null || _a === void 0 ? void 0 : _a.value)) {
                Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || "", context2.operationName, context2.operationType));
              } else {
                delete memo[keyName];
                memo[keyName] = value;
              }
            }
          }
          if (selection.kind === graphql.Kind.INLINE_FRAGMENT && (!selection.typeCondition || context2.cache.fragmentMatches(selection, data.__typename))) {
            value = maskSelectionSet(data, selection.selectionSet, context2, migration, path);
          }
          if (selection.kind === graphql.Kind.FRAGMENT_SPREAD) {
            var fragmentName = selection.name.value;
            var fragment = context2.fragmentMap[fragmentName] || (context2.fragmentMap[fragmentName] = context2.cache.lookupFragment(fragmentName));
            globals.invariant(fragment, 47, fragmentName);
            var mode = utilities.getFragmentMaskMode(selection);
            if (mode !== "mask") {
              value = maskSelectionSet(data, fragment.selectionSet, context2, mode === "migrate", path);
            }
          }
          if (knownChanged.has(value)) {
            knownChanged.add(memo);
          }
        }
        if ("__typename" in data && !("__typename" in memo)) {
          memo.__typename = data.__typename;
        }
        if (Object.keys(memo).length !== Object.keys(data).length) {
          knownChanged.add(memo);
        }
        return knownChanged.has(memo) ? memo : data;
      }
      function getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {
        var getValue = function() {
          if (disableWarningsSlot.getValue()) {
            return value;
          }
          globalThis.__DEV__ !== false && globals.invariant.warn(48, operationName ? "".concat(operationType, " '").concat(operationName, "'") : "anonymous ".concat(operationType), "".concat(path, ".").concat(fieldName).replace(/^\./, ""));
          getValue = function() {
            return value;
          };
          return value;
        };
        return {
          get: function() {
            return getValue();
          },
          set: function(newValue) {
            getValue = function() {
              return newValue;
            };
          },
          enumerable: true,
          configurable: true
        };
      }
      function maskFragment(data, document, cache, fragmentName) {
        if (!cache.fragmentMatches) {
          if (globalThis.__DEV__ !== false) {
            warnOnImproperCacheImplementation();
          }
          return data;
        }
        var fragments = document.definitions.filter(function(node) {
          return node.kind === graphql.Kind.FRAGMENT_DEFINITION;
        });
        if (typeof fragmentName === "undefined") {
          globals.invariant(fragments.length === 1, 49, fragments.length);
          fragmentName = fragments[0].name.value;
        }
        var fragment = fragments.find(function(fragment2) {
          return fragment2.name.value === fragmentName;
        });
        globals.invariant(!!fragment, 50, fragmentName);
        if (data == null) {
          return data;
        }
        if (equal__default(data, {})) {
          return data;
        }
        return maskDefinition(data, fragment.selectionSet, {
          operationType: "fragment",
          operationName: fragment.name.value,
          fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(document)),
          cache,
          mutableTargets: new MapImpl(),
          knownChanged: new SetImpl()
        });
      }
      function maskOperation(data, document, cache) {
        var _a;
        if (!cache.fragmentMatches) {
          if (globalThis.__DEV__ !== false) {
            warnOnImproperCacheImplementation();
          }
          return data;
        }
        var definition = utilities.getOperationDefinition(document);
        globals.invariant(definition, 51);
        if (data == null) {
          return data;
        }
        return maskDefinition(data, definition.selectionSet, {
          operationType: definition.operation,
          operationName: (_a = definition.name) === null || _a === void 0 ? void 0 : _a.value,
          fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(document)),
          cache,
          mutableTargets: new MapImpl(),
          knownChanged: new SetImpl()
        });
      }
      exports.disableWarningsSlot = disableWarningsSlot;
      exports.maskFragment = maskFragment;
      exports.maskOperation = maskOperation;
    }
  });

  // node_modules/@apollo/client/cache/cache.cjs
  var require_cache2 = __commonJS({
    "node_modules/@apollo/client/cache/cache.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var globals = require_globals();
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var optimism = require_bundle4();
      var utilities = require_utilities2();
      var caches = require_bundle2();
      var equal = require_bundle5();
      var masking = require_masking();
      var trie = require_bundle();
      var graphql = require_graphql2();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e["default"] : e;
      }
      var equal__default = /* @__PURE__ */ _interopDefaultLegacy(equal);
      var getInMemoryCacheMemoryInternals = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals : void 0;
      var getApolloCacheMemoryInternals = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals : void 0;
      function _getApolloCacheMemoryInternals() {
        return {
          cache: {
            fragmentQueryDocuments: getWrapperInformation(this["getFragmentDoc"])
          }
        };
      }
      function _getInMemoryCacheMemoryInternals() {
        var fragments = this.config.fragments;
        return tslib.__assign(tslib.__assign({}, _getApolloCacheMemoryInternals.apply(this)), { addTypenameDocumentTransform: transformInfo(this["addTypenameTransform"]), inMemoryCache: {
          executeSelectionSet: getWrapperInformation(this["storeReader"]["executeSelectionSet"]),
          executeSubSelectedArray: getWrapperInformation(this["storeReader"]["executeSubSelectedArray"]),
          maybeBroadcastWatch: getWrapperInformation(this["maybeBroadcastWatch"])
        }, fragmentRegistry: {
          findFragmentSpreads: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
          lookup: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
          transform: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
        } });
      }
      function isWrapper(f) {
        return !!f && "dirtyKey" in f;
      }
      function getWrapperInformation(f) {
        return isWrapper(f) ? f.size : void 0;
      }
      function isDefined2(value) {
        return value != null;
      }
      function transformInfo(transform) {
        return recurseTransformInfo(transform).map(function(cache) {
          return { cache };
        });
      }
      function recurseTransformInfo(transform) {
        return transform ? tslib.__spreadArray(tslib.__spreadArray([
          getWrapperInformation(transform === null || transform === void 0 ? void 0 : transform["performWork"])
        ], recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined2) : [];
      }
      function equalByQuery(query, _a, _b, variables) {
        var aData = _a.data, aRest = tslib.__rest(_a, ["data"]);
        var bData = _b.data, bRest = tslib.__rest(_b, ["data"]);
        return equal__default(aRest, bRest) && equalBySelectionSet(utilities.getMainDefinition(query).selectionSet, aData, bData, {
          fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
          variables
        });
      }
      function equalBySelectionSet(selectionSet, aResult, bResult, context2) {
        if (aResult === bResult) {
          return true;
        }
        var seenSelections = /* @__PURE__ */ new Set();
        return selectionSet.selections.every(function(selection) {
          if (seenSelections.has(selection))
            return true;
          seenSelections.add(selection);
          if (!utilities.shouldInclude(selection, context2.variables))
            return true;
          if (selectionHasNonreactiveDirective(selection))
            return true;
          if (utilities.isField(selection)) {
            var resultKey = utilities.resultKeyNameFromField(selection);
            var aResultChild = aResult && aResult[resultKey];
            var bResultChild = bResult && bResult[resultKey];
            var childSelectionSet = selection.selectionSet;
            if (!childSelectionSet) {
              return equal__default(aResultChild, bResultChild);
            }
            var aChildIsArray = Array.isArray(aResultChild);
            var bChildIsArray = Array.isArray(bResultChild);
            if (aChildIsArray !== bChildIsArray)
              return false;
            if (aChildIsArray && bChildIsArray) {
              var length_1 = aResultChild.length;
              if (bResultChild.length !== length_1) {
                return false;
              }
              for (var i = 0; i < length_1; ++i) {
                if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context2)) {
                  return false;
                }
              }
              return true;
            }
            return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context2);
          } else {
            var fragment = utilities.getFragmentFromSelection(selection, context2.fragmentMap);
            if (fragment) {
              if (selectionHasNonreactiveDirective(fragment))
                return true;
              return equalBySelectionSet(
                fragment.selectionSet,
                aResult,
                bResult,
                context2
              );
            }
          }
        });
      }
      function selectionHasNonreactiveDirective(selection) {
        return !!selection.directives && selection.directives.some(directiveIsNonreactive);
      }
      function directiveIsNonreactive(dir) {
        return dir.name.value === "nonreactive";
      }
      var ApolloCache = function() {
        function ApolloCache2() {
          this.assumeImmutableResults = false;
          this.getFragmentDoc = optimism.wrap(utilities.getFragmentQueryDocument, {
            max: utilities.cacheSizes["cache.fragmentQueryDocuments"] || 1e3,
            cache: caches.WeakCache
          });
        }
        ApolloCache2.prototype.lookupFragment = function(fragmentName) {
          return null;
        };
        ApolloCache2.prototype.batch = function(options) {
          var _this = this;
          var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
          var updateResult;
          this.performTransaction(function() {
            return updateResult = options.update(_this);
          }, optimisticId);
          return updateResult;
        };
        ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
          this.performTransaction(transaction, optimisticId);
        };
        ApolloCache2.prototype.transformDocument = function(document) {
          return document;
        };
        ApolloCache2.prototype.transformForLink = function(document) {
          return document;
        };
        ApolloCache2.prototype.identify = function(object) {
          return;
        };
        ApolloCache2.prototype.gc = function() {
          return [];
        };
        ApolloCache2.prototype.modify = function(options) {
          return false;
        };
        ApolloCache2.prototype.readQuery = function(options, optimistic) {
          if (optimistic === void 0) {
            optimistic = !!options.optimistic;
          }
          return this.read(tslib.__assign(tslib.__assign({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
        };
        ApolloCache2.prototype.watchFragment = function(options) {
          var _this = this;
          var fragment = options.fragment, fragmentName = options.fragmentName, from = options.from, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, otherOptions = tslib.__rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
          var query = this.getFragmentDoc(fragment, fragmentName);
          var id = typeof from === "undefined" || typeof from === "string" ? from : this.identify(from);
          var dataMasking = !!options[Symbol.for("apollo.dataMasking")];
          if (globalThis.__DEV__ !== false) {
            var actualFragmentName = fragmentName || utilities.getFragmentDefinition(fragment).name.value;
            if (!id) {
              globalThis.__DEV__ !== false && globals.invariant.warn(1, actualFragmentName);
            }
          }
          var diffOptions = tslib.__assign(tslib.__assign({}, otherOptions), { returnPartialData: true, id, query, optimistic });
          var latestDiff;
          return new utilities.Observable(function(observer) {
            return _this.watch(tslib.__assign(tslib.__assign({}, diffOptions), { immediate: true, callback: function(diff) {
              var data = dataMasking ? masking.maskFragment(diff.result, fragment, _this, fragmentName) : diff.result;
              if (latestDiff && equalByQuery(query, { data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result }, { data })) {
                return;
              }
              var result = {
                data,
                complete: !!diff.complete
              };
              if (diff.missing) {
                result.missing = utilities.mergeDeepArray(diff.missing.map(function(error) {
                  return error.missing;
                }));
              }
              latestDiff = tslib.__assign(tslib.__assign({}, diff), { result: data });
              observer.next(result);
            } }));
          });
        };
        ApolloCache2.prototype.readFragment = function(options, optimistic) {
          if (optimistic === void 0) {
            optimistic = !!options.optimistic;
          }
          return this.read(tslib.__assign(tslib.__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
        };
        ApolloCache2.prototype.writeQuery = function(_a) {
          var id = _a.id, data = _a.data, options = tslib.__rest(_a, ["id", "data"]);
          return this.write(Object.assign(options, {
            dataId: id || "ROOT_QUERY",
            result: data
          }));
        };
        ApolloCache2.prototype.writeFragment = function(_a) {
          var id = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options = tslib.__rest(_a, ["id", "data", "fragment", "fragmentName"]);
          return this.write(Object.assign(options, {
            query: this.getFragmentDoc(fragment, fragmentName),
            dataId: id,
            result: data
          }));
        };
        ApolloCache2.prototype.updateQuery = function(options, update2) {
          return this.batch({
            update: function(cache) {
              var value = cache.readQuery(options);
              var data = update2(value);
              if (data === void 0 || data === null)
                return value;
              cache.writeQuery(tslib.__assign(tslib.__assign({}, options), { data }));
              return data;
            }
          });
        };
        ApolloCache2.prototype.updateFragment = function(options, update2) {
          return this.batch({
            update: function(cache) {
              var value = cache.readFragment(options);
              var data = update2(value);
              if (data === void 0 || data === null)
                return value;
              cache.writeFragment(tslib.__assign(tslib.__assign({}, options), { data }));
              return data;
            }
          });
        };
        return ApolloCache2;
      }();
      if (globalThis.__DEV__ !== false) {
        ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;
      }
      exports.Cache = void 0;
      /* @__PURE__ */ (function(Cache) {
      })(exports.Cache || (exports.Cache = {}));
      var MissingFieldError = function(_super) {
        tslib.__extends(MissingFieldError2, _super);
        function MissingFieldError2(message, path, query, variables) {
          var _a;
          var _this = _super.call(this, message) || this;
          _this.message = message;
          _this.path = path;
          _this.query = query;
          _this.variables = variables;
          if (Array.isArray(_this.path)) {
            _this.missing = _this.message;
            for (var i = _this.path.length - 1; i >= 0; --i) {
              _this.missing = (_a = {}, _a[_this.path[i]] = _this.missing, _a);
            }
          } else {
            _this.missing = _this.path;
          }
          _this.__proto__ = MissingFieldError2.prototype;
          return _this;
        }
        return MissingFieldError2;
      }(Error);
      var hasOwn = Object.prototype.hasOwnProperty;
      function isNullish(value) {
        return value === null || value === void 0;
      }
      function defaultDataIdFromObject(_a, context2) {
        var __typename = _a.__typename, id = _a.id, _id = _a._id;
        if (typeof __typename === "string") {
          if (context2) {
            context2.keyObject = !isNullish(id) ? { id } : !isNullish(_id) ? { _id } : void 0;
          }
          if (isNullish(id) && !isNullish(_id)) {
            id = _id;
          }
          if (!isNullish(id)) {
            return "".concat(__typename, ":").concat(typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
          }
        }
      }
      var defaultConfig = {
        dataIdFromObject: defaultDataIdFromObject,
        addTypename: true,
        resultCaching: true,
        canonizeResults: false
      };
      function normalizeConfig(config) {
        return utilities.compact(defaultConfig, config);
      }
      function shouldCanonizeResults(config) {
        var value = config.canonizeResults;
        return value === void 0 ? defaultConfig.canonizeResults : value;
      }
      function getTypenameFromStoreObject(store, objectOrReference) {
        return utilities.isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
      }
      var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
      function fieldNameFromStoreName(storeFieldName) {
        var match = storeFieldName.match(TypeOrFieldNameRegExp);
        return match ? match[0] : storeFieldName;
      }
      function selectionSetMatchesResult(selectionSet, result, variables) {
        if (utilities.isNonNullObject(result)) {
          return utilities.isArray(result) ? result.every(function(item) {
            return selectionSetMatchesResult(selectionSet, item, variables);
          }) : selectionSet.selections.every(function(field) {
            if (utilities.isField(field) && utilities.shouldInclude(field, variables)) {
              var key = utilities.resultKeyNameFromField(field);
              return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
            }
            return true;
          });
        }
        return false;
      }
      function storeValueIsStoreObject(value) {
        return utilities.isNonNullObject(value) && !utilities.isReference(value) && !utilities.isArray(value);
      }
      function makeProcessedFieldsMerger() {
        return new utilities.DeepMerger();
      }
      function extractFragmentContext(document, fragments) {
        var fragmentMap = utilities.createFragmentMap(utilities.getFragmentDefinitions(document));
        return {
          fragmentMap,
          lookupFragment: function(name) {
            var def = fragmentMap[name];
            if (!def && fragments) {
              def = fragments.lookup(name);
            }
            return def || null;
          }
        };
      }
      var DELETE = /* @__PURE__ */ Object.create(null);
      var delModifier = function() {
        return DELETE;
      };
      var INVALIDATE = /* @__PURE__ */ Object.create(null);
      exports.EntityStore = function() {
        function EntityStore(policies, group) {
          var _this = this;
          this.policies = policies;
          this.group = group;
          this.data = /* @__PURE__ */ Object.create(null);
          this.rootIds = /* @__PURE__ */ Object.create(null);
          this.refs = /* @__PURE__ */ Object.create(null);
          this.getFieldValue = function(objectOrReference, storeFieldName) {
            return utilities.maybeDeepFreeze(utilities.isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
          };
          this.canRead = function(objOrRef) {
            return utilities.isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
          };
          this.toReference = function(objOrIdOrRef, mergeIntoStore) {
            if (typeof objOrIdOrRef === "string") {
              return utilities.makeReference(objOrIdOrRef);
            }
            if (utilities.isReference(objOrIdOrRef)) {
              return objOrIdOrRef;
            }
            var id = _this.policies.identify(objOrIdOrRef)[0];
            if (id) {
              var ref = utilities.makeReference(id);
              if (mergeIntoStore) {
                _this.merge(id, objOrIdOrRef);
              }
              return ref;
            }
          };
        }
        EntityStore.prototype.toObject = function() {
          return tslib.__assign({}, this.data);
        };
        EntityStore.prototype.has = function(dataId) {
          return this.lookup(dataId, true) !== void 0;
        };
        EntityStore.prototype.get = function(dataId, fieldName) {
          this.group.depend(dataId, fieldName);
          if (hasOwn.call(this.data, dataId)) {
            var storeObject = this.data[dataId];
            if (storeObject && hasOwn.call(storeObject, fieldName)) {
              return storeObject[fieldName];
            }
          }
          if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
            return this.policies.rootTypenamesById[dataId];
          }
          if (this instanceof Layer) {
            return this.parent.get(dataId, fieldName);
          }
        };
        EntityStore.prototype.lookup = function(dataId, dependOnExistence) {
          if (dependOnExistence)
            this.group.depend(dataId, "__exists");
          if (hasOwn.call(this.data, dataId)) {
            return this.data[dataId];
          }
          if (this instanceof Layer) {
            return this.parent.lookup(dataId, dependOnExistence);
          }
          if (this.policies.rootTypenamesById[dataId]) {
            return /* @__PURE__ */ Object.create(null);
          }
        };
        EntityStore.prototype.merge = function(older, newer) {
          var _this = this;
          var dataId;
          if (utilities.isReference(older))
            older = older.__ref;
          if (utilities.isReference(newer))
            newer = newer.__ref;
          var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
          var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
          if (!incoming)
            return;
          globals.invariant(typeof dataId === "string", 2);
          var merged = new utilities.DeepMerger(storeObjectReconciler).merge(existing, incoming);
          this.data[dataId] = merged;
          if (merged !== existing) {
            delete this.refs[dataId];
            if (this.group.caching) {
              var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
              if (!existing)
                fieldsToDirty_1.__exists = 1;
              Object.keys(incoming).forEach(function(storeFieldName) {
                if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                  fieldsToDirty_1[storeFieldName] = 1;
                  var fieldName = fieldNameFromStoreName(storeFieldName);
                  if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                    fieldsToDirty_1[fieldName] = 1;
                  }
                  if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                    delete merged[storeFieldName];
                  }
                }
              });
              if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
                delete fieldsToDirty_1.__typename;
              }
              Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
                return _this.group.dirty(dataId, fieldName);
              });
            }
          }
        };
        EntityStore.prototype.modify = function(dataId, fields) {
          var _this = this;
          var storeObject = this.lookup(dataId);
          if (storeObject) {
            var changedFields_1 = /* @__PURE__ */ Object.create(null);
            var needToMerge_1 = false;
            var allDeleted_1 = true;
            var sharedDetails_1 = {
              DELETE,
              INVALIDATE,
              isReference: utilities.isReference,
              toReference: this.toReference,
              canRead: this.canRead,
              readField: function(fieldNameOrOptions, from) {
                return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                  fieldName: fieldNameOrOptions,
                  from: from || utilities.makeReference(dataId)
                } : fieldNameOrOptions, { store: _this });
              }
            };
            Object.keys(storeObject).forEach(function(storeFieldName) {
              var fieldName = fieldNameFromStoreName(storeFieldName);
              var fieldValue = storeObject[storeFieldName];
              if (fieldValue === void 0)
                return;
              var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
              if (modify) {
                var newValue = modify === delModifier ? DELETE : modify(utilities.maybeDeepFreeze(fieldValue), tslib.__assign(tslib.__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
                if (newValue === INVALIDATE) {
                  _this.group.dirty(dataId, storeFieldName);
                } else {
                  if (newValue === DELETE)
                    newValue = void 0;
                  if (newValue !== fieldValue) {
                    changedFields_1[storeFieldName] = newValue;
                    needToMerge_1 = true;
                    fieldValue = newValue;
                    if (globalThis.__DEV__ !== false) {
                      var checkReference = function(ref) {
                        if (_this.lookup(ref.__ref) === void 0) {
                          globalThis.__DEV__ !== false && globals.invariant.warn(3, ref);
                          return true;
                        }
                      };
                      if (utilities.isReference(newValue)) {
                        checkReference(newValue);
                      } else if (Array.isArray(newValue)) {
                        var seenReference = false;
                        var someNonReference = void 0;
                        for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {
                          var value = newValue_1[_i];
                          if (utilities.isReference(value)) {
                            seenReference = true;
                            if (checkReference(value))
                              break;
                          } else {
                            if (typeof value === "object" && !!value) {
                              var id = _this.policies.identify(value)[0];
                              if (id) {
                                someNonReference = value;
                              }
                            }
                          }
                          if (seenReference && someNonReference !== void 0) {
                            globalThis.__DEV__ !== false && globals.invariant.warn(4, someNonReference);
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (fieldValue !== void 0) {
                allDeleted_1 = false;
              }
            });
            if (needToMerge_1) {
              this.merge(dataId, changedFields_1);
              if (allDeleted_1) {
                if (this instanceof Layer) {
                  this.data[dataId] = void 0;
                } else {
                  delete this.data[dataId];
                }
                this.group.dirty(dataId, "__exists");
              }
              return true;
            }
          }
          return false;
        };
        EntityStore.prototype.delete = function(dataId, fieldName, args) {
          var _a;
          var storeObject = this.lookup(dataId);
          if (storeObject) {
            var typename = this.getFieldValue(storeObject, "__typename");
            var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
            return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);
          }
          return false;
        };
        EntityStore.prototype.evict = function(options, limit) {
          var evicted = false;
          if (options.id) {
            if (hasOwn.call(this.data, options.id)) {
              evicted = this.delete(options.id, options.fieldName, options.args);
            }
            if (this instanceof Layer && this !== limit) {
              evicted = this.parent.evict(options, limit) || evicted;
            }
            if (options.fieldName || evicted) {
              this.group.dirty(options.id, options.fieldName || "__exists");
            }
          }
          return evicted;
        };
        EntityStore.prototype.clear = function() {
          this.replace(null);
        };
        EntityStore.prototype.extract = function() {
          var _this = this;
          var obj = this.toObject();
          var extraRootIds = [];
          this.getRootIdSet().forEach(function(id) {
            if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
              extraRootIds.push(id);
            }
          });
          if (extraRootIds.length) {
            obj.__META = { extraRootIds: extraRootIds.sort() };
          }
          return obj;
        };
        EntityStore.prototype.replace = function(newData) {
          var _this = this;
          Object.keys(this.data).forEach(function(dataId) {
            if (!(newData && hasOwn.call(newData, dataId))) {
              _this.delete(dataId);
            }
          });
          if (newData) {
            var __META = newData.__META, rest_1 = tslib.__rest(newData, ["__META"]);
            Object.keys(rest_1).forEach(function(dataId) {
              _this.merge(dataId, rest_1[dataId]);
            });
            if (__META) {
              __META.extraRootIds.forEach(this.retain, this);
            }
          }
        };
        EntityStore.prototype.retain = function(rootId) {
          return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
        };
        EntityStore.prototype.release = function(rootId) {
          if (this.rootIds[rootId] > 0) {
            var count = --this.rootIds[rootId];
            if (!count)
              delete this.rootIds[rootId];
            return count;
          }
          return 0;
        };
        EntityStore.prototype.getRootIdSet = function(ids) {
          if (ids === void 0) {
            ids = /* @__PURE__ */ new Set();
          }
          Object.keys(this.rootIds).forEach(ids.add, ids);
          if (this instanceof Layer) {
            this.parent.getRootIdSet(ids);
          } else {
            Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
          }
          return ids;
        };
        EntityStore.prototype.gc = function() {
          var _this = this;
          var ids = this.getRootIdSet();
          var snapshot = this.toObject();
          ids.forEach(function(id) {
            if (hasOwn.call(snapshot, id)) {
              Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
              delete snapshot[id];
            }
          });
          var idsToRemove = Object.keys(snapshot);
          if (idsToRemove.length) {
            var root_1 = this;
            while (root_1 instanceof Layer)
              root_1 = root_1.parent;
            idsToRemove.forEach(function(id) {
              return root_1.delete(id);
            });
          }
          return idsToRemove;
        };
        EntityStore.prototype.findChildRefIds = function(dataId) {
          if (!hasOwn.call(this.refs, dataId)) {
            var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
            var root = this.data[dataId];
            if (!root)
              return found_1;
            var workSet_1 = /* @__PURE__ */ new Set([root]);
            workSet_1.forEach(function(obj) {
              if (utilities.isReference(obj)) {
                found_1[obj.__ref] = true;
              }
              if (utilities.isNonNullObject(obj)) {
                Object.keys(obj).forEach(function(key) {
                  var child = obj[key];
                  if (utilities.isNonNullObject(child)) {
                    workSet_1.add(child);
                  }
                });
              }
            });
          }
          return this.refs[dataId];
        };
        EntityStore.prototype.makeCacheKey = function() {
          return this.group.keyMaker.lookupArray(arguments);
        };
        return EntityStore;
      }();
      var CacheGroup = function() {
        function CacheGroup2(caching, parent) {
          if (parent === void 0) {
            parent = null;
          }
          this.caching = caching;
          this.parent = parent;
          this.d = null;
          this.resetCaching();
        }
        CacheGroup2.prototype.resetCaching = function() {
          this.d = this.caching ? optimism.dep() : null;
          this.keyMaker = new trie.Trie(utilities.canUseWeakMap);
        };
        CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
          if (this.d) {
            this.d(makeDepKey(dataId, storeFieldName));
            var fieldName = fieldNameFromStoreName(storeFieldName);
            if (fieldName !== storeFieldName) {
              this.d(makeDepKey(dataId, fieldName));
            }
            if (this.parent) {
              this.parent.depend(dataId, storeFieldName);
            }
          }
        };
        CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
          if (this.d) {
            this.d.dirty(
              makeDepKey(dataId, storeFieldName),
              storeFieldName === "__exists" ? "forget" : "setDirty"
            );
          }
        };
        return CacheGroup2;
      }();
      function makeDepKey(dataId, storeFieldName) {
        return storeFieldName + "#" + dataId;
      }
      function maybeDependOnExistenceOfEntity(store, entityId) {
        if (supportsResultCaching(store)) {
          store.group.depend(entityId, "__exists");
        }
      }
      (function(EntityStore) {
        var Root = function(_super) {
          tslib.__extends(Root2, _super);
          function Root2(_a) {
            var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;
            var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
            _this.stump = new Stump(_this);
            _this.storageTrie = new trie.Trie(utilities.canUseWeakMap);
            if (seed)
              _this.replace(seed);
            return _this;
          }
          Root2.prototype.addLayer = function(layerId, replay) {
            return this.stump.addLayer(layerId, replay);
          };
          Root2.prototype.removeLayer = function() {
            return this;
          };
          Root2.prototype.getStorage = function() {
            return this.storageTrie.lookupArray(arguments);
          };
          return Root2;
        }(EntityStore);
        EntityStore.Root = Root;
      })(exports.EntityStore || (exports.EntityStore = {}));
      var Layer = function(_super) {
        tslib.__extends(Layer2, _super);
        function Layer2(id, parent, replay, group) {
          var _this = _super.call(this, parent.policies, group) || this;
          _this.id = id;
          _this.parent = parent;
          _this.replay = replay;
          _this.group = group;
          replay(_this);
          return _this;
        }
        Layer2.prototype.addLayer = function(layerId, replay) {
          return new Layer2(layerId, this, replay, this.group);
        };
        Layer2.prototype.removeLayer = function(layerId) {
          var _this = this;
          var parent = this.parent.removeLayer(layerId);
          if (layerId === this.id) {
            if (this.group.caching) {
              Object.keys(this.data).forEach(function(dataId) {
                var ownStoreObject = _this.data[dataId];
                var parentStoreObject = parent["lookup"](dataId);
                if (!parentStoreObject) {
                  _this.delete(dataId);
                } else if (!ownStoreObject) {
                  _this.group.dirty(dataId, "__exists");
                  Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                    _this.group.dirty(dataId, storeFieldName);
                  });
                } else if (ownStoreObject !== parentStoreObject) {
                  Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                    if (!equal.equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                      _this.group.dirty(dataId, storeFieldName);
                    }
                  });
                }
              });
            }
            return parent;
          }
          if (parent === this.parent)
            return this;
          return parent.addLayer(this.id, this.replay);
        };
        Layer2.prototype.toObject = function() {
          return tslib.__assign(tslib.__assign({}, this.parent.toObject()), this.data);
        };
        Layer2.prototype.findChildRefIds = function(dataId) {
          var fromParent = this.parent.findChildRefIds(dataId);
          return hasOwn.call(this.data, dataId) ? tslib.__assign(tslib.__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
        };
        Layer2.prototype.getStorage = function() {
          var p = this.parent;
          while (p.parent)
            p = p.parent;
          return p.getStorage.apply(
            p,
            arguments
          );
        };
        return Layer2;
      }(exports.EntityStore);
      var Stump = function(_super) {
        tslib.__extends(Stump2, _super);
        function Stump2(root) {
          return _super.call(this, "EntityStore.Stump", root, function() {
          }, new CacheGroup(root.group.caching, root.group)) || this;
        }
        Stump2.prototype.removeLayer = function() {
          return this;
        };
        Stump2.prototype.merge = function(older, newer) {
          return this.parent.merge(older, newer);
        };
        return Stump2;
      }(Layer);
      function storeObjectReconciler(existingObject, incomingObject, property) {
        var existingValue = existingObject[property];
        var incomingValue = incomingObject[property];
        return equal.equal(existingValue, incomingValue) ? existingValue : incomingValue;
      }
      function supportsResultCaching(store) {
        return !!(store instanceof exports.EntityStore && store.group.caching);
      }
      function shallowCopy(value) {
        if (utilities.isNonNullObject(value)) {
          return utilities.isArray(value) ? value.slice(0) : tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
        }
        return value;
      }
      var ObjectCanon = function() {
        function ObjectCanon2() {
          this.known = new (utilities.canUseWeakSet ? WeakSet : Set)();
          this.pool = new trie.Trie(utilities.canUseWeakMap);
          this.passes = /* @__PURE__ */ new WeakMap();
          this.keysByJSON = /* @__PURE__ */ new Map();
          this.empty = this.admit({});
        }
        ObjectCanon2.prototype.isKnown = function(value) {
          return utilities.isNonNullObject(value) && this.known.has(value);
        };
        ObjectCanon2.prototype.pass = function(value) {
          if (utilities.isNonNullObject(value)) {
            var copy = shallowCopy(value);
            this.passes.set(copy, value);
            return copy;
          }
          return value;
        };
        ObjectCanon2.prototype.admit = function(value) {
          var _this = this;
          if (utilities.isNonNullObject(value)) {
            var original = this.passes.get(value);
            if (original)
              return original;
            var proto = Object.getPrototypeOf(value);
            switch (proto) {
              case Array.prototype: {
                if (this.known.has(value))
                  return value;
                var array = value.map(this.admit, this);
                var node = this.pool.lookupArray(array);
                if (!node.array) {
                  this.known.add(node.array = array);
                  if (globalThis.__DEV__ !== false) {
                    Object.freeze(array);
                  }
                }
                return node.array;
              }
              case null:
              case Object.prototype: {
                if (this.known.has(value))
                  return value;
                var proto_1 = Object.getPrototypeOf(value);
                var array_1 = [proto_1];
                var keys = this.sortedKeys(value);
                array_1.push(keys.json);
                var firstValueIndex_1 = array_1.length;
                keys.sorted.forEach(function(key) {
                  array_1.push(_this.admit(value[key]));
                });
                var node = this.pool.lookupArray(array_1);
                if (!node.object) {
                  var obj_1 = node.object = Object.create(proto_1);
                  this.known.add(obj_1);
                  keys.sorted.forEach(function(key, i) {
                    obj_1[key] = array_1[firstValueIndex_1 + i];
                  });
                  if (globalThis.__DEV__ !== false) {
                    Object.freeze(obj_1);
                  }
                }
                return node.object;
              }
            }
          }
          return value;
        };
        ObjectCanon2.prototype.sortedKeys = function(obj) {
          var keys = Object.keys(obj);
          var node = this.pool.lookupArray(keys);
          if (!node.keys) {
            keys.sort();
            var json = JSON.stringify(keys);
            if (!(node.keys = this.keysByJSON.get(json))) {
              this.keysByJSON.set(json, node.keys = { sorted: keys, json });
            }
          }
          return node.keys;
        };
        return ObjectCanon2;
      }();
      function execSelectionSetKeyArgs(options) {
        return [
          options.selectionSet,
          options.objectOrReference,
          options.context,
          options.context.canonizeResults
        ];
      }
      var StoreReader = function() {
        function StoreReader2(config) {
          var _this = this;
          this.knownResults = new (utilities.canUseWeakMap ? WeakMap : Map)();
          this.config = utilities.compact(config, {
            addTypename: config.addTypename !== false,
            canonizeResults: shouldCanonizeResults(config)
          });
          this.canon = config.canon || new ObjectCanon();
          this.executeSelectionSet = optimism.wrap(function(options) {
            var _a;
            var canonizeResults = options.context.canonizeResults;
            var peekArgs = execSelectionSetKeyArgs(options);
            peekArgs[3] = !canonizeResults;
            var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);
            if (other) {
              if (canonizeResults) {
                return tslib.__assign(tslib.__assign({}, other), {
                  result: _this.canon.admit(other.result)
                });
              }
              return other;
            }
            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
            return _this.execSelectionSetImpl(options);
          }, {
            max: this.config.resultCacheMaxSize || utilities.cacheSizes["inMemoryCache.executeSelectionSet"] || 5e4,
            keyArgs: execSelectionSetKeyArgs,
            makeCacheKey: function(selectionSet, parent, context2, canonizeResults) {
              if (supportsResultCaching(context2.store)) {
                return context2.store.makeCacheKey(selectionSet, utilities.isReference(parent) ? parent.__ref : parent, context2.varString, canonizeResults);
              }
            }
          });
          this.executeSubSelectedArray = optimism.wrap(function(options) {
            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
            return _this.execSubSelectedArrayImpl(options);
          }, {
            max: this.config.resultCacheMaxSize || utilities.cacheSizes["inMemoryCache.executeSubSelectedArray"] || 1e4,
            makeCacheKey: function(_a) {
              var field = _a.field, array = _a.array, context2 = _a.context;
              if (supportsResultCaching(context2.store)) {
                return context2.store.makeCacheKey(field, array, context2.varString);
              }
            }
          });
        }
        StoreReader2.prototype.resetCanon = function() {
          this.canon = new ObjectCanon();
        };
        StoreReader2.prototype.diffQueryAgainstStore = function(_a) {
          var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
          var policies = this.config.cache.policies;
          variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(utilities.getQueryDefinition(query))), variables);
          var rootRef = utilities.makeReference(rootId);
          var execResult = this.executeSelectionSet({
            selectionSet: utilities.getMainDefinition(query).selectionSet,
            objectOrReference: rootRef,
            enclosingRef: rootRef,
            context: tslib.__assign({ store, query, policies, variables, varString: utilities.canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
          });
          var missing;
          if (execResult.missing) {
            missing = [
              new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)
            ];
            if (!returnPartialData) {
              throw missing[0];
            }
          }
          return {
            result: execResult.result,
            complete: !missing,
            missing
          };
        };
        StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context2) {
          if (supportsResultCaching(context2.store) && this.knownResults.get(result) === selectionSet) {
            var latest = this.executeSelectionSet.peek(
              selectionSet,
              parent,
              context2,
              this.canon.isKnown(result)
            );
            if (latest && result === latest.result) {
              return true;
            }
          }
          return false;
        };
        StoreReader2.prototype.execSelectionSetImpl = function(_a) {
          var _this = this;
          var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context2 = _a.context;
          if (utilities.isReference(objectOrReference) && !context2.policies.rootTypenamesById[objectOrReference.__ref] && !context2.store.has(objectOrReference.__ref)) {
            return {
              result: this.canon.empty,
              missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
            };
          }
          var variables = context2.variables, policies = context2.policies, store = context2.store;
          var typename = store.getFieldValue(objectOrReference, "__typename");
          var objectsToMerge = [];
          var missing;
          var missingMerger = new utilities.DeepMerger();
          if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
            objectsToMerge.push({ __typename: typename });
          }
          function handleMissing(result2, resultName) {
            var _a2;
            if (result2.missing) {
              missing = missingMerger.merge(missing, (_a2 = {}, _a2[resultName] = result2.missing, _a2));
            }
            return result2.result;
          }
          var workSet = new Set(selectionSet.selections);
          workSet.forEach(function(selection) {
            var _a2, _b;
            if (!utilities.shouldInclude(selection, variables))
              return;
            if (utilities.isField(selection)) {
              var fieldValue = policies.readField({
                fieldName: selection.name.value,
                field: selection,
                variables: context2.variables,
                from: objectOrReference
              }, context2);
              var resultName = utilities.resultKeyNameFromField(selection);
              if (fieldValue === void 0) {
                if (!utilities.addTypenameToDocument.added(selection)) {
                  missing = missingMerger.merge(missing, (_a2 = {}, _a2[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(utilities.isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a2));
                }
              } else if (utilities.isArray(fieldValue)) {
                if (fieldValue.length > 0) {
                  fieldValue = handleMissing(_this.executeSubSelectedArray({
                    field: selection,
                    array: fieldValue,
                    enclosingRef,
                    context: context2
                  }), resultName);
                }
              } else if (!selection.selectionSet) {
                if (context2.canonizeResults) {
                  fieldValue = _this.canon.pass(fieldValue);
                }
              } else if (fieldValue != null) {
                fieldValue = handleMissing(_this.executeSelectionSet({
                  selectionSet: selection.selectionSet,
                  objectOrReference: fieldValue,
                  enclosingRef: utilities.isReference(fieldValue) ? fieldValue : enclosingRef,
                  context: context2
                }), resultName);
              }
              if (fieldValue !== void 0) {
                objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
              }
            } else {
              var fragment = utilities.getFragmentFromSelection(selection, context2.lookupFragment);
              if (!fragment && selection.kind === graphql.Kind.FRAGMENT_SPREAD) {
                throw globals.newInvariantError(10, selection.name.value);
              }
              if (fragment && policies.fragmentMatches(fragment, typename)) {
                fragment.selectionSet.selections.forEach(workSet.add, workSet);
              }
            }
          });
          var result = utilities.mergeDeepArray(objectsToMerge);
          var finalResult = { result, missing };
          var frozen = context2.canonizeResults ? this.canon.admit(finalResult) : utilities.maybeDeepFreeze(finalResult);
          if (frozen.result) {
            this.knownResults.set(frozen.result, selectionSet);
          }
          return frozen;
        };
        StoreReader2.prototype.execSubSelectedArrayImpl = function(_a) {
          var _this = this;
          var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context2 = _a.context;
          var missing;
          var missingMerger = new utilities.DeepMerger();
          function handleMissing(childResult, i) {
            var _a2;
            if (childResult.missing) {
              missing = missingMerger.merge(missing, (_a2 = {}, _a2[i] = childResult.missing, _a2));
            }
            return childResult.result;
          }
          if (field.selectionSet) {
            array = array.filter(context2.store.canRead);
          }
          array = array.map(function(item, i) {
            if (item === null) {
              return null;
            }
            if (utilities.isArray(item)) {
              return handleMissing(_this.executeSubSelectedArray({
                field,
                array: item,
                enclosingRef,
                context: context2
              }), i);
            }
            if (field.selectionSet) {
              return handleMissing(_this.executeSelectionSet({
                selectionSet: field.selectionSet,
                objectOrReference: item,
                enclosingRef: utilities.isReference(item) ? item : enclosingRef,
                context: context2
              }), i);
            }
            if (globalThis.__DEV__ !== false) {
              assertSelectionSetForIdValue(context2.store, field, item);
            }
            return item;
          });
          return {
            result: context2.canonizeResults ? this.canon.admit(array) : array,
            missing
          };
        };
        return StoreReader2;
      }();
      function firstMissing(tree) {
        try {
          JSON.stringify(tree, function(_, value) {
            if (typeof value === "string")
              throw value;
            return value;
          });
        } catch (result) {
          return result;
        }
      }
      function assertSelectionSetForIdValue(store, field, fieldValue) {
        if (!field.selectionSet) {
          var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
          workSet_1.forEach(function(value) {
            if (utilities.isNonNullObject(value)) {
              globals.invariant(
                !utilities.isReference(value),
                11,
                getTypenameFromStoreObject(store, value),
                field.name.value
              );
              Object.values(value).forEach(workSet_1.add, workSet_1);
            }
          });
        }
      }
      var cacheSlot = new optimism.Slot();
      var cacheInfoMap = /* @__PURE__ */ new WeakMap();
      function getCacheInfo(cache) {
        var info = cacheInfoMap.get(cache);
        if (!info) {
          cacheInfoMap.set(cache, info = {
            vars: /* @__PURE__ */ new Set(),
            dep: optimism.dep()
          });
        }
        return info;
      }
      function forgetCache(cache) {
        getCacheInfo(cache).vars.forEach(function(rv) {
          return rv.forgetCache(cache);
        });
      }
      function recallCache(cache) {
        getCacheInfo(cache).vars.forEach(function(rv) {
          return rv.attachCache(cache);
        });
      }
      function makeVar(value) {
        var caches2 = /* @__PURE__ */ new Set();
        var listeners = /* @__PURE__ */ new Set();
        var rv = function(newValue) {
          if (arguments.length > 0) {
            if (value !== newValue) {
              value = newValue;
              caches2.forEach(function(cache2) {
                getCacheInfo(cache2).dep.dirty(rv);
                broadcast(cache2);
              });
              var oldListeners = Array.from(listeners);
              listeners.clear();
              oldListeners.forEach(function(listener) {
                return listener(value);
              });
            }
          } else {
            var cache = cacheSlot.getValue();
            if (cache) {
              attach(cache);
              getCacheInfo(cache).dep(rv);
            }
          }
          return value;
        };
        rv.onNextChange = function(listener) {
          listeners.add(listener);
          return function() {
            listeners.delete(listener);
          };
        };
        var attach = rv.attachCache = function(cache) {
          caches2.add(cache);
          getCacheInfo(cache).vars.add(rv);
          return rv;
        };
        rv.forgetCache = function(cache) {
          return caches2.delete(cache);
        };
        return rv;
      }
      function broadcast(cache) {
        if (cache.broadcastWatches) {
          cache.broadcastWatches();
        }
      }
      var specifierInfoCache = /* @__PURE__ */ Object.create(null);
      function lookupSpecifierInfo(spec) {
        var cacheKey = JSON.stringify(spec);
        return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
      }
      function keyFieldsFnFromSpecifier(specifier) {
        var info = lookupSpecifierInfo(specifier);
        return info.keyFieldsFn || (info.keyFieldsFn = function(object, context2) {
          var extract = function(from, key) {
            return context2.readField(key, from);
          };
          var keyObject = context2.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
            var extracted = extractKeyPath(
              context2.storeObject,
              schemaKeyPath,
              extract
            );
            if (extracted === void 0 && object !== context2.storeObject && hasOwn.call(object, schemaKeyPath[0])) {
              extracted = extractKeyPath(object, schemaKeyPath, extractKey);
            }
            globals.invariant(extracted !== void 0, 5, schemaKeyPath.join("."), object);
            return extracted;
          });
          return "".concat(context2.typename, ":").concat(JSON.stringify(keyObject));
        });
      }
      function keyArgsFnFromSpecifier(specifier) {
        var info = lookupSpecifierInfo(specifier);
        return info.keyArgsFn || (info.keyArgsFn = function(args, _a) {
          var field = _a.field, variables = _a.variables, fieldName = _a.fieldName;
          var collected = collectSpecifierPaths(specifier, function(keyPath) {
            var firstKey = keyPath[0];
            var firstChar = firstKey.charAt(0);
            if (firstChar === "@") {
              if (field && utilities.isNonEmptyArray(field.directives)) {
                var directiveName_1 = firstKey.slice(1);
                var d = field.directives.find(function(d2) {
                  return d2.name.value === directiveName_1;
                });
                var directiveArgs = d && utilities.argumentsObjectFromField(d, variables);
                return directiveArgs && extractKeyPath(
                  directiveArgs,
                  keyPath.slice(1)
                );
              }
              return;
            }
            if (firstChar === "$") {
              var variableName = firstKey.slice(1);
              if (variables && hasOwn.call(variables, variableName)) {
                var varKeyPath = keyPath.slice(0);
                varKeyPath[0] = variableName;
                return extractKeyPath(variables, varKeyPath);
              }
              return;
            }
            if (args) {
              return extractKeyPath(args, keyPath);
            }
          });
          var suffix = JSON.stringify(collected);
          if (args || suffix !== "{}") {
            fieldName += ":" + suffix;
          }
          return fieldName;
        });
      }
      function collectSpecifierPaths(specifier, extractor) {
        var merger = new utilities.DeepMerger();
        return getSpecifierPaths(specifier).reduce(function(collected, path) {
          var _a;
          var toMerge = extractor(path);
          if (toMerge !== void 0) {
            for (var i = path.length - 1; i >= 0; --i) {
              toMerge = (_a = {}, _a[path[i]] = toMerge, _a);
            }
            collected = merger.merge(collected, toMerge);
          }
          return collected;
        }, /* @__PURE__ */ Object.create(null));
      }
      function getSpecifierPaths(spec) {
        var info = lookupSpecifierInfo(spec);
        if (!info.paths) {
          var paths_1 = info.paths = [];
          var currentPath_1 = [];
          spec.forEach(function(s, i) {
            if (utilities.isArray(s)) {
              getSpecifierPaths(s).forEach(function(p) {
                return paths_1.push(currentPath_1.concat(p));
              });
              currentPath_1.length = 0;
            } else {
              currentPath_1.push(s);
              if (!utilities.isArray(spec[i + 1])) {
                paths_1.push(currentPath_1.slice(0));
                currentPath_1.length = 0;
              }
            }
          });
        }
        return info.paths;
      }
      function extractKey(object, key) {
        return object[key];
      }
      function extractKeyPath(object, path, extract) {
        extract = extract || extractKey;
        return normalize(path.reduce(function reducer(obj, key) {
          return utilities.isArray(obj) ? obj.map(function(child) {
            return reducer(child, key);
          }) : obj && extract(obj, key);
        }, object));
      }
      function normalize(value) {
        if (utilities.isNonNullObject(value)) {
          if (utilities.isArray(value)) {
            return value.map(normalize);
          }
          return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
            return extractKeyPath(value, path);
          });
        }
        return value;
      }
      function argsFromFieldSpecifier(spec) {
        return spec.args !== void 0 ? spec.args : spec.field ? utilities.argumentsObjectFromField(spec.field, spec.variables) : null;
      }
      var nullKeyFieldsFn = function() {
        return void 0;
      };
      var simpleKeyArgsFn = function(_args, context2) {
        return context2.fieldName;
      };
      var mergeTrueFn = function(existing, incoming, _a) {
        var mergeObjects = _a.mergeObjects;
        return mergeObjects(existing, incoming);
      };
      var mergeFalseFn = function(_, incoming) {
        return incoming;
      };
      var Policies = function() {
        function Policies2(config) {
          this.config = config;
          this.typePolicies = /* @__PURE__ */ Object.create(null);
          this.toBeAdded = /* @__PURE__ */ Object.create(null);
          this.supertypeMap = /* @__PURE__ */ new Map();
          this.fuzzySubtypes = /* @__PURE__ */ new Map();
          this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
          this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
          this.usingPossibleTypes = false;
          this.config = tslib.__assign({ dataIdFromObject: defaultDataIdFromObject }, config);
          this.cache = this.config.cache;
          this.setRootTypename("Query");
          this.setRootTypename("Mutation");
          this.setRootTypename("Subscription");
          if (config.possibleTypes) {
            this.addPossibleTypes(config.possibleTypes);
          }
          if (config.typePolicies) {
            this.addTypePolicies(config.typePolicies);
          }
        }
        Policies2.prototype.identify = function(object, partialContext) {
          var _a;
          var policies = this;
          var typename = partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;
          if (typename === this.rootTypenamesById.ROOT_QUERY) {
            return ["ROOT_QUERY"];
          }
          var storeObject = partialContext && partialContext.storeObject || object;
          var context2 = tslib.__assign(tslib.__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
            var options = normalizeReadFieldOptions(arguments, storeObject);
            return policies.readField(options, {
              store: policies.cache["data"],
              variables: options.variables
            });
          } });
          var id;
          var policy = typename && this.getTypePolicy(typename);
          var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
          masking.disableWarningsSlot.withValue(true, function() {
            while (keyFn) {
              var specifierOrId = keyFn(tslib.__assign(tslib.__assign({}, object), storeObject), context2);
              if (utilities.isArray(specifierOrId)) {
                keyFn = keyFieldsFnFromSpecifier(specifierOrId);
              } else {
                id = specifierOrId;
                break;
              }
            }
          });
          id = id ? String(id) : void 0;
          return context2.keyObject ? [id, context2.keyObject] : [id];
        };
        Policies2.prototype.addTypePolicies = function(typePolicies) {
          var _this = this;
          Object.keys(typePolicies).forEach(function(typename) {
            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = tslib.__rest(_a, ["queryType", "mutationType", "subscriptionType"]);
            if (queryType)
              _this.setRootTypename("Query", typename);
            if (mutationType)
              _this.setRootTypename("Mutation", typename);
            if (subscriptionType)
              _this.setRootTypename("Subscription", typename);
            if (hasOwn.call(_this.toBeAdded, typename)) {
              _this.toBeAdded[typename].push(incoming);
            } else {
              _this.toBeAdded[typename] = [incoming];
            }
          });
        };
        Policies2.prototype.updateTypePolicy = function(typename, incoming) {
          var _this = this;
          var existing = this.getTypePolicy(typename);
          var keyFields = incoming.keyFields, fields = incoming.fields;
          function setMerge(existing2, merge2) {
            existing2.merge = typeof merge2 === "function" ? merge2 : merge2 === true ? mergeTrueFn : merge2 === false ? mergeFalseFn : existing2.merge;
          }
          setMerge(existing, incoming.merge);
          existing.keyFn = keyFields === false ? nullKeyFieldsFn : utilities.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
          if (fields) {
            Object.keys(fields).forEach(function(fieldName) {
              var existing2 = _this.getFieldPolicy(typename, fieldName, true);
              var incoming2 = fields[fieldName];
              if (typeof incoming2 === "function") {
                existing2.read = incoming2;
              } else {
                var keyArgs = incoming2.keyArgs, read = incoming2.read, merge2 = incoming2.merge;
                existing2.keyFn = keyArgs === false ? simpleKeyArgsFn : utilities.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
                if (typeof read === "function") {
                  existing2.read = read;
                }
                setMerge(existing2, merge2);
              }
              if (existing2.read && existing2.merge) {
                existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
              }
            });
          }
        };
        Policies2.prototype.setRootTypename = function(which, typename) {
          if (typename === void 0) {
            typename = which;
          }
          var rootId = "ROOT_" + which.toUpperCase();
          var old = this.rootTypenamesById[rootId];
          if (typename !== old) {
            globals.invariant(!old || old === which, 6, which);
            if (old)
              delete this.rootIdsByTypename[old];
            this.rootIdsByTypename[typename] = rootId;
            this.rootTypenamesById[rootId] = typename;
          }
        };
        Policies2.prototype.addPossibleTypes = function(possibleTypes) {
          var _this = this;
          this.usingPossibleTypes = true;
          Object.keys(possibleTypes).forEach(function(supertype) {
            _this.getSupertypeSet(supertype, true);
            possibleTypes[supertype].forEach(function(subtype) {
              _this.getSupertypeSet(subtype, true).add(supertype);
              var match = subtype.match(TypeOrFieldNameRegExp);
              if (!match || match[0] !== subtype) {
                _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
              }
            });
          });
        };
        Policies2.prototype.getTypePolicy = function(typename) {
          var _this = this;
          if (!hasOwn.call(this.typePolicies, typename)) {
            var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
            policy_1.fields = /* @__PURE__ */ Object.create(null);
            var supertypes_1 = this.supertypeMap.get(typename);
            if (!supertypes_1 && this.fuzzySubtypes.size) {
              supertypes_1 = this.getSupertypeSet(typename, true);
              this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
                if (regExp.test(typename)) {
                  var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
                  if (fuzzySupertypes) {
                    fuzzySupertypes.forEach(function(supertype) {
                      return supertypes_1.add(supertype);
                    });
                  }
                }
              });
            }
            if (supertypes_1 && supertypes_1.size) {
              supertypes_1.forEach(function(supertype) {
                var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = tslib.__rest(_a, ["fields"]);
                Object.assign(policy_1, rest);
                Object.assign(policy_1.fields, fields);
              });
            }
          }
          var inbox = this.toBeAdded[typename];
          if (inbox && inbox.length) {
            inbox.splice(0).forEach(function(policy) {
              _this.updateTypePolicy(typename, policy);
            });
          }
          return this.typePolicies[typename];
        };
        Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
          if (typename) {
            var fieldPolicies = this.getTypePolicy(typename).fields;
            return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
          }
        };
        Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
          var supertypeSet = this.supertypeMap.get(subtype);
          if (!supertypeSet && createIfMissing) {
            this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
          }
          return supertypeSet;
        };
        Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
          var _this = this;
          if (!fragment.typeCondition)
            return true;
          if (!typename)
            return false;
          var supertype = fragment.typeCondition.name.value;
          if (typename === supertype)
            return true;
          if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
            var typenameSupertypeSet = this.getSupertypeSet(typename, true);
            var workQueue_1 = [typenameSupertypeSet];
            var maybeEnqueue_1 = function(subtype) {
              var supertypeSet2 = _this.getSupertypeSet(subtype, false);
              if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
                workQueue_1.push(supertypeSet2);
              }
            };
            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
            var checkingFuzzySubtypes = false;
            for (var i = 0; i < workQueue_1.length; ++i) {
              var supertypeSet = workQueue_1[i];
              if (supertypeSet.has(supertype)) {
                if (!typenameSupertypeSet.has(supertype)) {
                  if (checkingFuzzySubtypes) {
                    globalThis.__DEV__ !== false && globals.invariant.warn(7, typename, supertype);
                  }
                  typenameSupertypeSet.add(supertype);
                }
                return true;
              }
              supertypeSet.forEach(maybeEnqueue_1);
              if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
                needToCheckFuzzySubtypes = false;
                checkingFuzzySubtypes = true;
                this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
                  var match = typename.match(regExp);
                  if (match && match[0] === typename) {
                    maybeEnqueue_1(fuzzyString);
                  }
                });
              }
            }
          }
          return false;
        };
        Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
          var policy = this.getFieldPolicy(typename, fieldName, false);
          return !!(policy && policy.keyFn);
        };
        Policies2.prototype.getStoreFieldName = function(fieldSpec) {
          var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
          var policy = this.getFieldPolicy(typename, fieldName, false);
          var storeFieldName;
          var keyFn = policy && policy.keyFn;
          if (keyFn && typename) {
            var context2 = {
              typename,
              fieldName,
              field: fieldSpec.field || null,
              variables: fieldSpec.variables
            };
            var args = argsFromFieldSpecifier(fieldSpec);
            while (keyFn) {
              var specifierOrString = keyFn(args, context2);
              if (utilities.isArray(specifierOrString)) {
                keyFn = keyArgsFnFromSpecifier(specifierOrString);
              } else {
                storeFieldName = specifierOrString || fieldName;
                break;
              }
            }
          }
          if (storeFieldName === void 0) {
            storeFieldName = fieldSpec.field ? utilities.storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : utilities.getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
          }
          if (storeFieldName === false) {
            return fieldName;
          }
          return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
        };
        Policies2.prototype.readField = function(options, context2) {
          var objectOrReference = options.from;
          if (!objectOrReference)
            return;
          var nameOrField = options.field || options.fieldName;
          if (!nameOrField)
            return;
          if (options.typename === void 0) {
            var typename = context2.store.getFieldValue(objectOrReference, "__typename");
            if (typename)
              options.typename = typename;
          }
          var storeFieldName = this.getStoreFieldName(options);
          var fieldName = fieldNameFromStoreName(storeFieldName);
          var existing = context2.store.getFieldValue(objectOrReference, storeFieldName);
          var policy = this.getFieldPolicy(options.typename, fieldName, false);
          var read = policy && policy.read;
          if (read) {
            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context2, context2.store.getStorage(utilities.isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
            return cacheSlot.withValue(this.cache, read, [
              existing,
              readOptions
            ]);
          }
          return existing;
        };
        Policies2.prototype.getReadFunction = function(typename, fieldName) {
          var policy = this.getFieldPolicy(typename, fieldName, false);
          return policy && policy.read;
        };
        Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
          var policy = this.getFieldPolicy(parentTypename, fieldName, false);
          var merge2 = policy && policy.merge;
          if (!merge2 && childTypename) {
            policy = this.getTypePolicy(childTypename);
            merge2 = policy && policy.merge;
          }
          return merge2;
        };
        Policies2.prototype.runMergeFunction = function(existing, incoming, _a, context2, storage) {
          var field = _a.field, typename = _a.typename, merge2 = _a.merge;
          if (merge2 === mergeTrueFn) {
            return makeMergeObjectsFunction(context2.store)(existing, incoming);
          }
          if (merge2 === mergeFalseFn) {
            return incoming;
          }
          if (context2.overwrite) {
            existing = void 0;
          }
          return merge2(existing, incoming, makeFieldFunctionOptions(
            this,
            void 0,
            {
              typename,
              fieldName: field.name.value,
              field,
              variables: context2.variables
            },
            context2,
            storage || /* @__PURE__ */ Object.create(null)
          ));
        };
        return Policies2;
      }();
      function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context2, storage) {
        var storeFieldName = policies.getStoreFieldName(fieldSpec);
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var variables = fieldSpec.variables || context2.variables;
        var _a = context2.store, toReference = _a.toReference, canRead = _a.canRead;
        return {
          args: argsFromFieldSpecifier(fieldSpec),
          field: fieldSpec.field || null,
          fieldName,
          storeFieldName,
          variables,
          isReference: utilities.isReference,
          toReference,
          storage,
          cache: policies.cache,
          canRead,
          readField: function() {
            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context2);
          },
          mergeObjects: makeMergeObjectsFunction(context2.store)
        };
      }
      function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
        var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;
        var options;
        if (typeof fieldNameOrOptions === "string") {
          options = {
            fieldName: fieldNameOrOptions,
            from: argc > 1 ? from : objectOrReference
          };
        } else {
          options = tslib.__assign({}, fieldNameOrOptions);
          if (!hasOwn.call(options, "from")) {
            options.from = objectOrReference;
          }
        }
        if (globalThis.__DEV__ !== false && options.from === void 0) {
          globalThis.__DEV__ !== false && globals.invariant.warn(8, utilities.stringifyForDisplay(Array.from(readFieldArgs)));
        }
        if (void 0 === options.variables) {
          options.variables = variables;
        }
        return options;
      }
      function makeMergeObjectsFunction(store) {
        return function mergeObjects(existing, incoming) {
          if (utilities.isArray(existing) || utilities.isArray(incoming)) {
            throw globals.newInvariantError(9);
          }
          if (utilities.isNonNullObject(existing) && utilities.isNonNullObject(incoming)) {
            var eType = store.getFieldValue(existing, "__typename");
            var iType = store.getFieldValue(incoming, "__typename");
            var typesDiffer = eType && iType && eType !== iType;
            if (typesDiffer) {
              return incoming;
            }
            if (utilities.isReference(existing) && storeValueIsStoreObject(incoming)) {
              store.merge(existing.__ref, incoming);
              return existing;
            }
            if (storeValueIsStoreObject(existing) && utilities.isReference(incoming)) {
              store.merge(existing, incoming.__ref);
              return incoming;
            }
            if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
              return tslib.__assign(tslib.__assign({}, existing), incoming);
            }
          }
          return incoming;
        };
      }
      function getContextFlavor(context2, clientOnly, deferred) {
        var key = "".concat(clientOnly).concat(deferred);
        var flavored = context2.flavors.get(key);
        if (!flavored) {
          context2.flavors.set(key, flavored = context2.clientOnly === clientOnly && context2.deferred === deferred ? context2 : tslib.__assign(tslib.__assign({}, context2), { clientOnly, deferred }));
        }
        return flavored;
      }
      var StoreWriter = function() {
        function StoreWriter2(cache, reader, fragments) {
          this.cache = cache;
          this.reader = reader;
          this.fragments = fragments;
        }
        StoreWriter2.prototype.writeToStore = function(store, _a) {
          var _this = this;
          var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;
          var operationDefinition = utilities.getOperationDefinition(query);
          var merger = makeProcessedFieldsMerger();
          variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(operationDefinition)), variables);
          var context2 = tslib.__assign(tslib.__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
            return merger.merge(existing, incoming);
          }, variables, varString: utilities.canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
          var ref = this.processSelectionSet({
            result: result || /* @__PURE__ */ Object.create(null),
            dataId,
            selectionSet: operationDefinition.selectionSet,
            mergeTree: { map: /* @__PURE__ */ new Map() },
            context: context2
          });
          if (!utilities.isReference(ref)) {
            throw globals.newInvariantError(12, result);
          }
          context2.incomingById.forEach(function(_a2, dataId2) {
            var storeObject = _a2.storeObject, mergeTree = _a2.mergeTree, fieldNodeSet = _a2.fieldNodeSet;
            var entityRef = utilities.makeReference(dataId2);
            if (mergeTree && mergeTree.map.size) {
              var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context2);
              if (utilities.isReference(applied)) {
                return;
              }
              storeObject = applied;
            }
            if (globalThis.__DEV__ !== false && !context2.overwrite) {
              var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
              fieldNodeSet.forEach(function(field) {
                if (field.selectionSet) {
                  fieldsWithSelectionSets_1[field.name.value] = true;
                }
              });
              var hasSelectionSet_1 = function(storeFieldName) {
                return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
              };
              var hasMergeFunction_1 = function(storeFieldName) {
                var childTree = mergeTree && mergeTree.map.get(storeFieldName);
                return Boolean(childTree && childTree.info && childTree.info.merge);
              };
              Object.keys(storeObject).forEach(function(storeFieldName) {
                if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
                  warnAboutDataLoss(entityRef, storeObject, storeFieldName, context2.store);
                }
              });
            }
            store.merge(dataId2, storeObject);
          });
          store.retain(ref.__ref);
          return ref;
        };
        StoreWriter2.prototype.processSelectionSet = function(_a) {
          var _this = this;
          var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context2 = _a.context, mergeTree = _a.mergeTree;
          var policies = this.cache.policies;
          var incoming = /* @__PURE__ */ Object.create(null);
          var typename = dataId && policies.rootTypenamesById[dataId] || utilities.getTypenameFromResult(result, selectionSet, context2.fragmentMap) || dataId && context2.store.get(dataId, "__typename");
          if ("string" === typeof typename) {
            incoming.__typename = typename;
          }
          var readField = function() {
            var options = normalizeReadFieldOptions(arguments, incoming, context2.variables);
            if (utilities.isReference(options.from)) {
              var info = context2.incomingById.get(options.from.__ref);
              if (info) {
                var result_1 = policies.readField(tslib.__assign(tslib.__assign({}, options), { from: info.storeObject }), context2);
                if (result_1 !== void 0) {
                  return result_1;
                }
              }
            }
            return policies.readField(options, context2);
          };
          var fieldNodeSet = /* @__PURE__ */ new Set();
          this.flattenFields(
            selectionSet,
            result,
            context2,
            typename
          ).forEach(function(context3, field) {
            var _a2;
            var resultFieldKey = utilities.resultKeyNameFromField(field);
            var value = result[resultFieldKey];
            fieldNodeSet.add(field);
            if (value !== void 0) {
              var storeFieldName = policies.getStoreFieldName({
                typename,
                fieldName: field.name.value,
                field,
                variables: context3.variables
              });
              var childTree = getChildMergeTree(mergeTree, storeFieldName);
              var incomingValue = _this.processFieldValue(
                value,
                field,
                field.selectionSet ? getContextFlavor(context3, false, false) : context3,
                childTree
              );
              var childTypename = void 0;
              if (field.selectionSet && (utilities.isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
                childTypename = readField("__typename", incomingValue);
              }
              var merge2 = policies.getMergeFunction(typename, field.name.value, childTypename);
              if (merge2) {
                childTree.info = {
                  field,
                  typename,
                  merge: merge2
                };
              } else {
                maybeRecycleChildMergeTree(mergeTree, storeFieldName);
              }
              incoming = context3.merge(incoming, (_a2 = {}, _a2[storeFieldName] = incomingValue, _a2));
            } else if (globalThis.__DEV__ !== false && !context3.clientOnly && !context3.deferred && !utilities.addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {
              globalThis.__DEV__ !== false && globals.invariant.error(13, utilities.resultKeyNameFromField(field), result);
            }
          });
          try {
            var _b = policies.identify(result, {
              typename,
              selectionSet,
              fragmentMap: context2.fragmentMap,
              storeObject: incoming,
              readField
            }), id = _b[0], keyObject = _b[1];
            dataId = dataId || id;
            if (keyObject) {
              incoming = context2.merge(incoming, keyObject);
            }
          } catch (e) {
            if (!dataId)
              throw e;
          }
          if ("string" === typeof dataId) {
            var dataRef = utilities.makeReference(dataId);
            var sets = context2.written[dataId] || (context2.written[dataId] = []);
            if (sets.indexOf(selectionSet) >= 0)
              return dataRef;
            sets.push(selectionSet);
            if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context2)) {
              return dataRef;
            }
            var previous_1 = context2.incomingById.get(dataId);
            if (previous_1) {
              previous_1.storeObject = context2.merge(previous_1.storeObject, incoming);
              previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
              fieldNodeSet.forEach(function(field) {
                return previous_1.fieldNodeSet.add(field);
              });
            } else {
              context2.incomingById.set(dataId, {
                storeObject: incoming,
                mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
                fieldNodeSet
              });
            }
            return dataRef;
          }
          return incoming;
        };
        StoreWriter2.prototype.processFieldValue = function(value, field, context2, mergeTree) {
          var _this = this;
          if (!field.selectionSet || value === null) {
            return globalThis.__DEV__ !== false ? utilities.cloneDeep(value) : value;
          }
          if (utilities.isArray(value)) {
            return value.map(function(item, i) {
              var value2 = _this.processFieldValue(item, field, context2, getChildMergeTree(mergeTree, i));
              maybeRecycleChildMergeTree(mergeTree, i);
              return value2;
            });
          }
          return this.processSelectionSet({
            result: value,
            selectionSet: field.selectionSet,
            context: context2,
            mergeTree
          });
        };
        StoreWriter2.prototype.flattenFields = function(selectionSet, result, context2, typename) {
          if (typename === void 0) {
            typename = utilities.getTypenameFromResult(result, selectionSet, context2.fragmentMap);
          }
          var fieldMap = /* @__PURE__ */ new Map();
          var policies = this.cache.policies;
          var limitingTrie = new trie.Trie(false);
          (function flatten(selectionSet2, inheritedContext) {
            var visitedNode = limitingTrie.lookup(
              selectionSet2,
              inheritedContext.clientOnly,
              inheritedContext.deferred
            );
            if (visitedNode.visited)
              return;
            visitedNode.visited = true;
            selectionSet2.selections.forEach(function(selection) {
              if (!utilities.shouldInclude(selection, context2.variables))
                return;
              var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
              if (!(clientOnly && deferred) && utilities.isNonEmptyArray(selection.directives)) {
                selection.directives.forEach(function(dir) {
                  var name = dir.name.value;
                  if (name === "client")
                    clientOnly = true;
                  if (name === "defer") {
                    var args = utilities.argumentsObjectFromField(dir, context2.variables);
                    if (!args || args.if !== false) {
                      deferred = true;
                    }
                  }
                });
              }
              if (utilities.isField(selection)) {
                var existing = fieldMap.get(selection);
                if (existing) {
                  clientOnly = clientOnly && existing.clientOnly;
                  deferred = deferred && existing.deferred;
                }
                fieldMap.set(selection, getContextFlavor(context2, clientOnly, deferred));
              } else {
                var fragment = utilities.getFragmentFromSelection(selection, context2.lookupFragment);
                if (!fragment && selection.kind === graphql.Kind.FRAGMENT_SPREAD) {
                  throw globals.newInvariantError(14, selection.name.value);
                }
                if (fragment && policies.fragmentMatches(fragment, typename, result, context2.variables)) {
                  flatten(fragment.selectionSet, getContextFlavor(context2, clientOnly, deferred));
                }
              }
            });
          })(selectionSet, context2);
          return fieldMap;
        };
        StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context2, getStorageArgs) {
          var _a;
          var _this = this;
          if (mergeTree.map.size && !utilities.isReference(incoming)) {
            var e_1 = !utilities.isArray(incoming) && (utilities.isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;
            var i_1 = incoming;
            if (e_1 && !getStorageArgs) {
              getStorageArgs = [utilities.isReference(e_1) ? e_1.__ref : e_1];
            }
            var changedFields_1;
            var getValue_1 = function(from, name) {
              return utilities.isArray(from) ? typeof name === "number" ? from[name] : void 0 : context2.store.getFieldValue(from, String(name));
            };
            mergeTree.map.forEach(function(childTree, storeFieldName) {
              var eVal = getValue_1(e_1, storeFieldName);
              var iVal = getValue_1(i_1, storeFieldName);
              if (void 0 === iVal)
                return;
              if (getStorageArgs) {
                getStorageArgs.push(storeFieldName);
              }
              var aVal = _this.applyMerges(childTree, eVal, iVal, context2, getStorageArgs);
              if (aVal !== iVal) {
                changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
                changedFields_1.set(storeFieldName, aVal);
              }
              if (getStorageArgs) {
                globals.invariant(getStorageArgs.pop() === storeFieldName);
              }
            });
            if (changedFields_1) {
              incoming = utilities.isArray(i_1) ? i_1.slice(0) : tslib.__assign({}, i_1);
              changedFields_1.forEach(function(value, name) {
                incoming[name] = value;
              });
            }
          }
          if (mergeTree.info) {
            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context2, getStorageArgs && (_a = context2.store).getStorage.apply(_a, getStorageArgs));
          }
          return incoming;
        };
        return StoreWriter2;
      }();
      var emptyMergeTreePool = [];
      function getChildMergeTree(_a, name) {
        var map = _a.map;
        if (!map.has(name)) {
          map.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
        }
        return map.get(name);
      }
      function mergeMergeTrees(left, right) {
        if (left === right || !right || mergeTreeIsEmpty(right))
          return left;
        if (!left || mergeTreeIsEmpty(left))
          return right;
        var info = left.info && right.info ? tslib.__assign(tslib.__assign({}, left.info), right.info) : left.info || right.info;
        var needToMergeMaps = left.map.size && right.map.size;
        var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
        var merged = { info, map };
        if (needToMergeMaps) {
          var remainingRightKeys_1 = new Set(right.map.keys());
          left.map.forEach(function(leftTree, key) {
            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
            remainingRightKeys_1.delete(key);
          });
          remainingRightKeys_1.forEach(function(key) {
            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
          });
        }
        return merged;
      }
      function mergeTreeIsEmpty(tree) {
        return !tree || !(tree.info || tree.map.size);
      }
      function maybeRecycleChildMergeTree(_a, name) {
        var map = _a.map;
        var childTree = map.get(name);
        if (childTree && mergeTreeIsEmpty(childTree)) {
          emptyMergeTreePool.push(childTree);
          map.delete(name);
        }
      }
      var warnings = /* @__PURE__ */ new Set();
      function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
        var getChild = function(objOrRef) {
          var child = store.getFieldValue(objOrRef, storeFieldName);
          return typeof child === "object" && child;
        };
        var existing = getChild(existingRef);
        if (!existing)
          return;
        var incoming = getChild(incomingObj);
        if (!incoming)
          return;
        if (utilities.isReference(existing))
          return;
        if (equal.equal(existing, incoming))
          return;
        if (Object.keys(existing).every(function(key) {
          return store.getFieldValue(incoming, key) !== void 0;
        })) {
          return;
        }
        var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var typeDotName = "".concat(parentType, ".").concat(fieldName);
        if (warnings.has(typeDotName))
          return;
        warnings.add(typeDotName);
        var childTypenames = [];
        if (!utilities.isArray(existing) && !utilities.isArray(incoming)) {
          [existing, incoming].forEach(function(child) {
            var typename = store.getFieldValue(child, "__typename");
            if (typeof typename === "string" && !childTypenames.includes(typename)) {
              childTypenames.push(typename);
            }
          });
        }
        globalThis.__DEV__ !== false && globals.invariant.warn(15, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, tslib.__assign({}, existing), tslib.__assign({}, incoming));
      }
      var InMemoryCache = function(_super) {
        tslib.__extends(InMemoryCache2, _super);
        function InMemoryCache2(config) {
          if (config === void 0) {
            config = {};
          }
          var _this = _super.call(this) || this;
          _this.watches = /* @__PURE__ */ new Set();
          _this.addTypenameTransform = new utilities.DocumentTransform(utilities.addTypenameToDocument);
          _this.assumeImmutableResults = true;
          _this.makeVar = makeVar;
          _this.txCount = 0;
          _this.config = normalizeConfig(config);
          _this.addTypename = !!_this.config.addTypename;
          _this.policies = new Policies({
            cache: _this,
            dataIdFromObject: _this.config.dataIdFromObject,
            possibleTypes: _this.config.possibleTypes,
            typePolicies: _this.config.typePolicies
          });
          _this.init();
          return _this;
        }
        InMemoryCache2.prototype.init = function() {
          var rootStore = this.data = new exports.EntityStore.Root({
            policies: this.policies,
            resultCaching: this.config.resultCaching
          });
          this.optimisticData = rootStore.stump;
          this.resetResultCache();
        };
        InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
          var _this = this;
          var previousReader = this.storeReader;
          var fragments = this.config.fragments;
          this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
            cache: this,
            addTypename: this.addTypename,
            resultCacheMaxSize: this.config.resultCacheMaxSize,
            canonizeResults: shouldCanonizeResults(this.config),
            canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
            fragments
          }), fragments);
          this.maybeBroadcastWatch = optimism.wrap(function(c, options) {
            return _this.broadcastWatch(c, options);
          }, {
            max: this.config.resultCacheMaxSize || utilities.cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5e3,
            makeCacheKey: function(c) {
              var store = c.optimistic ? _this.optimisticData : _this.data;
              if (supportsResultCaching(store)) {
                var optimistic = c.optimistic, id = c.id, variables = c.variables;
                return store.makeCacheKey(
                  c.query,
                  c.callback,
                  utilities.canonicalStringify({ optimistic, id, variables })
                );
              }
            }
          });
          (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
            return group.resetCaching();
          });
        };
        InMemoryCache2.prototype.restore = function(data) {
          this.init();
          if (data)
            this.data.replace(data);
          return this;
        };
        InMemoryCache2.prototype.extract = function(optimistic) {
          if (optimistic === void 0) {
            optimistic = false;
          }
          return (optimistic ? this.optimisticData : this.data).extract();
        };
        InMemoryCache2.prototype.read = function(options) {
          var _a = options.returnPartialData, returnPartialData = _a === void 0 ? false : _a;
          try {
            return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
          } catch (e) {
            if (e instanceof MissingFieldError) {
              return null;
            }
            throw e;
          }
        };
        InMemoryCache2.prototype.write = function(options) {
          try {
            ++this.txCount;
            return this.storeWriter.writeToStore(this.data, options);
          } finally {
            if (!--this.txCount && options.broadcast !== false) {
              this.broadcastWatches();
            }
          }
        };
        InMemoryCache2.prototype.modify = function(options) {
          if (hasOwn.call(options, "id") && !options.id) {
            return false;
          }
          var store = options.optimistic ? this.optimisticData : this.data;
          try {
            ++this.txCount;
            return store.modify(options.id || "ROOT_QUERY", options.fields);
          } finally {
            if (!--this.txCount && options.broadcast !== false) {
              this.broadcastWatches();
            }
          }
        };
        InMemoryCache2.prototype.diff = function(options) {
          return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
        };
        InMemoryCache2.prototype.watch = function(watch) {
          var _this = this;
          if (!this.watches.size) {
            recallCache(this);
          }
          this.watches.add(watch);
          if (watch.immediate) {
            this.maybeBroadcastWatch(watch);
          }
          return function() {
            if (_this.watches.delete(watch) && !_this.watches.size) {
              forgetCache(_this);
            }
            _this.maybeBroadcastWatch.forget(watch);
          };
        };
        InMemoryCache2.prototype.gc = function(options) {
          var _a;
          utilities.canonicalStringify.reset();
          utilities.print.reset();
          this.addTypenameTransform.resetCache();
          (_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.resetCaches();
          var ids = this.optimisticData.gc();
          if (options && !this.txCount) {
            if (options.resetResultCache) {
              this.resetResultCache(options.resetResultIdentities);
            } else if (options.resetResultIdentities) {
              this.storeReader.resetCanon();
            }
          }
          return ids;
        };
        InMemoryCache2.prototype.retain = function(rootId, optimistic) {
          return (optimistic ? this.optimisticData : this.data).retain(rootId);
        };
        InMemoryCache2.prototype.release = function(rootId, optimistic) {
          return (optimistic ? this.optimisticData : this.data).release(rootId);
        };
        InMemoryCache2.prototype.identify = function(object) {
          if (utilities.isReference(object))
            return object.__ref;
          try {
            return this.policies.identify(object)[0];
          } catch (e) {
            globalThis.__DEV__ !== false && globals.invariant.warn(e);
          }
        };
        InMemoryCache2.prototype.evict = function(options) {
          if (!options.id) {
            if (hasOwn.call(options, "id")) {
              return false;
            }
            options = tslib.__assign(tslib.__assign({}, options), { id: "ROOT_QUERY" });
          }
          try {
            ++this.txCount;
            return this.optimisticData.evict(options, this.data);
          } finally {
            if (!--this.txCount && options.broadcast !== false) {
              this.broadcastWatches();
            }
          }
        };
        InMemoryCache2.prototype.reset = function(options) {
          var _this = this;
          this.init();
          utilities.canonicalStringify.reset();
          if (options && options.discardWatches) {
            this.watches.forEach(function(watch) {
              return _this.maybeBroadcastWatch.forget(watch);
            });
            this.watches.clear();
            forgetCache(this);
          } else {
            this.broadcastWatches();
          }
          return Promise.resolve();
        };
        InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
          var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
          if (newOptimisticData !== this.optimisticData) {
            this.optimisticData = newOptimisticData;
            this.broadcastWatches();
          }
        };
        InMemoryCache2.prototype.batch = function(options) {
          var _this = this;
          var update2 = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
          var updateResult;
          var perform = function(layer) {
            var _a2 = _this, data = _a2.data, optimisticData = _a2.optimisticData;
            ++_this.txCount;
            if (layer) {
              _this.data = _this.optimisticData = layer;
            }
            try {
              return updateResult = update2(_this);
            } finally {
              --_this.txCount;
              _this.data = data;
              _this.optimisticData = optimisticData;
            }
          };
          var alreadyDirty = /* @__PURE__ */ new Set();
          if (onWatchUpdated && !this.txCount) {
            this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function(watch) {
              alreadyDirty.add(watch);
              return false;
            } }));
          }
          if (typeof optimistic === "string") {
            this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
          } else if (optimistic === false) {
            perform(this.data);
          } else {
            perform();
          }
          if (typeof removeOptimistic === "string") {
            this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
          }
          if (onWatchUpdated && alreadyDirty.size) {
            this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function(watch, diff) {
              var result = onWatchUpdated.call(this, watch, diff);
              if (result !== false) {
                alreadyDirty.delete(watch);
              }
              return result;
            } }));
            if (alreadyDirty.size) {
              alreadyDirty.forEach(function(watch) {
                return _this.maybeBroadcastWatch.dirty(watch);
              });
            }
          } else {
            this.broadcastWatches(options);
          }
          return updateResult;
        };
        InMemoryCache2.prototype.performTransaction = function(update2, optimisticId) {
          return this.batch({
            update: update2,
            optimistic: optimisticId || optimisticId !== null
          });
        };
        InMemoryCache2.prototype.transformDocument = function(document) {
          return this.addTypenameToDocument(this.addFragmentsToDocument(document));
        };
        InMemoryCache2.prototype.fragmentMatches = function(fragment, typename) {
          return this.policies.fragmentMatches(fragment, typename);
        };
        InMemoryCache2.prototype.lookupFragment = function(fragmentName) {
          var _a;
          return ((_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.lookup(fragmentName)) || null;
        };
        InMemoryCache2.prototype.broadcastWatches = function(options) {
          var _this = this;
          if (!this.txCount) {
            this.watches.forEach(function(c) {
              return _this.maybeBroadcastWatch(c, options);
            });
          }
        };
        InMemoryCache2.prototype.addFragmentsToDocument = function(document) {
          var fragments = this.config.fragments;
          return fragments ? fragments.transform(document) : document;
        };
        InMemoryCache2.prototype.addTypenameToDocument = function(document) {
          if (this.addTypename) {
            return this.addTypenameTransform.transformDocument(document);
          }
          return document;
        };
        InMemoryCache2.prototype.broadcastWatch = function(c, options) {
          var lastDiff = c.lastDiff;
          var diff = this.diff(c);
          if (options) {
            if (c.optimistic && typeof options.optimistic === "string") {
              diff.fromOptimisticTransaction = true;
            }
            if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
              return;
            }
          }
          if (!lastDiff || !equal.equal(lastDiff.result, diff.result)) {
            c.callback(c.lastDiff = diff, lastDiff);
          }
        };
        return InMemoryCache2;
      }(ApolloCache);
      if (globalThis.__DEV__ !== false) {
        InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;
      }
      function createFragmentRegistry() {
        var fragments = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fragments[_i] = arguments[_i];
        }
        return new (FragmentRegistry.bind.apply(FragmentRegistry, tslib.__spreadArray([void 0], fragments, false)))();
      }
      var FragmentRegistry = function() {
        function FragmentRegistry2() {
          var fragments = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            fragments[_i] = arguments[_i];
          }
          this.registry = /* @__PURE__ */ Object.create(null);
          this.resetCaches();
          if (fragments.length) {
            this.register.apply(this, fragments);
          }
        }
        FragmentRegistry2.prototype.register = function() {
          var _this = this;
          var fragments = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            fragments[_i] = arguments[_i];
          }
          var definitions = /* @__PURE__ */ new Map();
          fragments.forEach(function(doc) {
            utilities.getFragmentDefinitions(doc).forEach(function(node) {
              definitions.set(node.name.value, node);
            });
          });
          definitions.forEach(function(node, name) {
            if (node !== _this.registry[name]) {
              _this.registry[name] = node;
              _this.invalidate(name);
            }
          });
          return this;
        };
        FragmentRegistry2.prototype.invalidate = function(name) {
        };
        FragmentRegistry2.prototype.resetCaches = function() {
          var proto = FragmentRegistry2.prototype;
          this.invalidate = (this.lookup = optimism.wrap(proto.lookup.bind(this), {
            makeCacheKey: function(arg) {
              return arg;
            },
            max: utilities.cacheSizes["fragmentRegistry.lookup"] || 1e3
          })).dirty;
          this.transform = optimism.wrap(proto.transform.bind(this), {
            cache: caches.WeakCache,
            max: utilities.cacheSizes["fragmentRegistry.transform"] || 2e3
          });
          this.findFragmentSpreads = optimism.wrap(proto.findFragmentSpreads.bind(this), {
            cache: caches.WeakCache,
            max: utilities.cacheSizes["fragmentRegistry.findFragmentSpreads"] || 4e3
          });
        };
        FragmentRegistry2.prototype.lookup = function(fragmentName) {
          return this.registry[fragmentName] || null;
        };
        FragmentRegistry2.prototype.transform = function(document) {
          var _this = this;
          var defined = /* @__PURE__ */ new Map();
          utilities.getFragmentDefinitions(document).forEach(function(def) {
            defined.set(def.name.value, def);
          });
          var unbound = /* @__PURE__ */ new Set();
          var enqueue = function(spreadName) {
            if (!defined.has(spreadName)) {
              unbound.add(spreadName);
            }
          };
          var enqueueChildSpreads = function(node) {
            return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue);
          };
          enqueueChildSpreads(document);
          var missing = [];
          var map = /* @__PURE__ */ Object.create(null);
          unbound.forEach(function(fragmentName) {
            var knownFragmentDef = defined.get(fragmentName);
            if (knownFragmentDef) {
              enqueueChildSpreads(map[fragmentName] = knownFragmentDef);
            } else {
              missing.push(fragmentName);
              var def = _this.lookup(fragmentName);
              if (def) {
                enqueueChildSpreads(map[fragmentName] = def);
              }
            }
          });
          if (missing.length) {
            var defsToAppend_1 = [];
            missing.forEach(function(name) {
              var def = map[name];
              if (def) {
                defsToAppend_1.push(def);
              }
            });
            if (defsToAppend_1.length) {
              document = tslib.__assign(tslib.__assign({}, document), { definitions: document.definitions.concat(defsToAppend_1) });
            }
          }
          return document;
        };
        FragmentRegistry2.prototype.findFragmentSpreads = function(root) {
          var spreads = /* @__PURE__ */ Object.create(null);
          graphql.visit(root, {
            FragmentSpread: function(node) {
              spreads[node.name.value] = node;
            }
          });
          return spreads;
        };
        return FragmentRegistry2;
      }();
      exports.canonicalStringify = utilities.canonicalStringify;
      exports.isReference = utilities.isReference;
      exports.makeReference = utilities.makeReference;
      exports.ApolloCache = ApolloCache;
      exports.InMemoryCache = InMemoryCache;
      exports.MissingFieldError = MissingFieldError;
      exports.Policies = Policies;
      exports.cacheSlot = cacheSlot;
      exports.createFragmentRegistry = createFragmentRegistry;
      exports.defaultDataIdFromObject = defaultDataIdFromObject;
      exports.fieldNameFromStoreName = fieldNameFromStoreName;
      exports.makeVar = makeVar;
    }
  });

  // node_modules/graphql-tag/lib/graphql-tag.umd.js
  var require_graphql_tag_umd = __commonJS({
    "node_modules/graphql-tag/lib/graphql-tag.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), require_graphql2()) : typeof define === "function" && define.amd ? define(["exports", "tslib", "graphql"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["graphql-tag"] = {}, global2.tslib, global2.graphql));
      })(exports, function(exports2, tslib, graphql) {
        "use strict";
        var docCache = /* @__PURE__ */ new Map();
        var fragmentSourceMap = /* @__PURE__ */ new Map();
        var printFragmentWarnings = true;
        var experimentalFragmentVariables = false;
        function normalize(string) {
          return string.replace(/[\s,]+/g, " ").trim();
        }
        function cacheKeyFromLoc(loc) {
          return normalize(loc.source.body.substring(loc.start, loc.end));
        }
        function processFragments(ast) {
          var seenKeys = /* @__PURE__ */ new Set();
          var definitions = [];
          ast.definitions.forEach(function(fragmentDefinition) {
            if (fragmentDefinition.kind === "FragmentDefinition") {
              var fragmentName = fragmentDefinition.name.value;
              var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
              var sourceKeySet = fragmentSourceMap.get(fragmentName);
              if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
                if (printFragmentWarnings) {
                  console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
                }
              } else if (!sourceKeySet) {
                fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
              }
              sourceKeySet.add(sourceKey);
              if (!seenKeys.has(sourceKey)) {
                seenKeys.add(sourceKey);
                definitions.push(fragmentDefinition);
              }
            } else {
              definitions.push(fragmentDefinition);
            }
          });
          return tslib.__assign(tslib.__assign({}, ast), { definitions });
        }
        function stripLoc(doc) {
          var workSet = new Set(doc.definitions);
          workSet.forEach(function(node) {
            if (node.loc)
              delete node.loc;
            Object.keys(node).forEach(function(key) {
              var value = node[key];
              if (value && typeof value === "object") {
                workSet.add(value);
              }
            });
          });
          var loc = doc.loc;
          if (loc) {
            delete loc.startToken;
            delete loc.endToken;
          }
          return doc;
        }
        function parseDocument(source) {
          var cacheKey = normalize(source);
          if (!docCache.has(cacheKey)) {
            var parsed = graphql.parse(source, {
              experimentalFragmentVariables,
              allowLegacyFragmentVariables: experimentalFragmentVariables
            });
            if (!parsed || parsed.kind !== "Document") {
              throw new Error("Not a valid GraphQL document.");
            }
            docCache.set(cacheKey, stripLoc(processFragments(parsed)));
          }
          return docCache.get(cacheKey);
        }
        function gql(literals) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          if (typeof literals === "string") {
            literals = [literals];
          }
          var result = literals[0];
          args.forEach(function(arg, i) {
            if (arg && arg.kind === "Document") {
              result += arg.loc.source.body;
            } else {
              result += arg;
            }
            result += literals[i + 1];
          });
          return parseDocument(result);
        }
        function resetCaches() {
          docCache.clear();
          fragmentSourceMap.clear();
        }
        function disableFragmentWarnings() {
          printFragmentWarnings = false;
        }
        function enableExperimentalFragmentVariables() {
          experimentalFragmentVariables = true;
        }
        function disableExperimentalFragmentVariables() {
          experimentalFragmentVariables = false;
        }
        var extras = {
          gql,
          resetCaches,
          disableFragmentWarnings,
          enableExperimentalFragmentVariables,
          disableExperimentalFragmentVariables
        };
        (function(gql_1) {
          gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
        })(gql || (gql = {}));
        gql["default"] = gql;
        var gql$1 = gql;
        exports2.default = gql$1;
        exports2.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;
        exports2.disableFragmentWarnings = disableFragmentWarnings;
        exports2.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
        exports2.gql = gql;
        exports2.resetCaches = resetCaches;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/graphql-tag/main.js
  var require_main2 = __commonJS({
    "node_modules/graphql-tag/main.js"(exports, module) {
      module.exports = require_graphql_tag_umd().gql;
    }
  });

  // node_modules/@apollo/client/core/core.cjs
  var require_core3 = __commonJS({
    "node_modules/@apollo/client/core/core.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var globals = require_globals();
      var core2 = require_core2();
      var http = require_http();
      var equal = require_bundle5();
      var utilities = require_utilities2();
      var cache = require_cache2();
      var errors = require_errors2();
      var trie = require_bundle();
      var masking = require_masking();
      var graphql = require_graphql2();
      var utils = require_utils5();
      var tsInvariant = require_invariant();
      var graphqlTag = require_main2();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e["default"] : e;
      }
      var equal__default = /* @__PURE__ */ _interopDefaultLegacy(equal);
      var version = "3.12.7";
      function isNonNullObject(obj) {
        return obj !== null && typeof obj === "object";
      }
      function isNonEmptyArray(value) {
        return Array.isArray(value) && value.length > 0;
      }
      var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
      var defaultReconciler = function(target, source, property) {
        return this.merge(target[property], source[property]);
      };
      var DeepMerger = function() {
        function DeepMerger2(reconciler) {
          if (reconciler === void 0) {
            reconciler = defaultReconciler;
          }
          this.reconciler = reconciler;
          this.isObject = isNonNullObject;
          this.pastCopies = /* @__PURE__ */ new Set();
        }
        DeepMerger2.prototype.merge = function(target, source) {
          var _this = this;
          var context2 = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            context2[_i - 2] = arguments[_i];
          }
          if (isNonNullObject(source) && isNonNullObject(target)) {
            Object.keys(source).forEach(function(sourceKey) {
              if (hasOwnProperty$2.call(target, sourceKey)) {
                var targetValue = target[sourceKey];
                if (source[sourceKey] !== targetValue) {
                  var result = _this.reconciler.apply(_this, tslib.__spreadArray([
                    target,
                    source,
                    sourceKey
                  ], context2, false));
                  if (result !== targetValue) {
                    target = _this.shallowCopyForMerge(target);
                    target[sourceKey] = result;
                  }
                }
              } else {
                target = _this.shallowCopyForMerge(target);
                target[sourceKey] = source[sourceKey];
              }
            });
            return target;
          }
          return source;
        };
        DeepMerger2.prototype.shallowCopyForMerge = function(value) {
          if (isNonNullObject(value)) {
            if (!this.pastCopies.has(value)) {
              if (Array.isArray(value)) {
                value = value.slice(0);
              } else {
                value = tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
              }
              this.pastCopies.add(value);
            }
          }
          return value;
        };
        return DeepMerger2;
      }();
      function isExecutionPatchIncrementalResult(value) {
        return "incremental" in value;
      }
      function mergeIncrementalData(prevResult, result) {
        var mergedData = prevResult;
        var merger = new DeepMerger();
        if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
          result.incremental.forEach(function(_a) {
            var data = _a.data, path = _a.path;
            for (var i = path.length - 1; i >= 0; --i) {
              var key = path[i];
              var isNumericKey = !isNaN(+key);
              var parent_1 = isNumericKey ? [] : {};
              parent_1[key] = data;
              data = parent_1;
            }
            mergedData = merger.merge(mergedData, data);
          });
        }
        return mergedData;
      }
      exports.NetworkStatus = void 0;
      (function(NetworkStatus) {
        NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
        NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
        NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
        NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
        NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
        NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
        NetworkStatus[NetworkStatus["error"] = 8] = "error";
      })(exports.NetworkStatus || (exports.NetworkStatus = {}));
      function isNetworkRequestInFlight(networkStatus) {
        return networkStatus ? networkStatus < 7 : false;
      }
      function isNetworkRequestSettled(networkStatus) {
        return networkStatus === 7 || networkStatus === 8;
      }
      function equalByQuery(query, _a, _b, variables) {
        var aData = _a.data, aRest = tslib.__rest(_a, ["data"]);
        var bData = _b.data, bRest = tslib.__rest(_b, ["data"]);
        return equal__default(aRest, bRest) && equalBySelectionSet(utilities.getMainDefinition(query).selectionSet, aData, bData, {
          fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
          variables
        });
      }
      function equalBySelectionSet(selectionSet, aResult, bResult, context2) {
        if (aResult === bResult) {
          return true;
        }
        var seenSelections = /* @__PURE__ */ new Set();
        return selectionSet.selections.every(function(selection) {
          if (seenSelections.has(selection))
            return true;
          seenSelections.add(selection);
          if (!utilities.shouldInclude(selection, context2.variables))
            return true;
          if (selectionHasNonreactiveDirective(selection))
            return true;
          if (utilities.isField(selection)) {
            var resultKey = utilities.resultKeyNameFromField(selection);
            var aResultChild = aResult && aResult[resultKey];
            var bResultChild = bResult && bResult[resultKey];
            var childSelectionSet = selection.selectionSet;
            if (!childSelectionSet) {
              return equal__default(aResultChild, bResultChild);
            }
            var aChildIsArray = Array.isArray(aResultChild);
            var bChildIsArray = Array.isArray(bResultChild);
            if (aChildIsArray !== bChildIsArray)
              return false;
            if (aChildIsArray && bChildIsArray) {
              var length_1 = aResultChild.length;
              if (bResultChild.length !== length_1) {
                return false;
              }
              for (var i = 0; i < length_1; ++i) {
                if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context2)) {
                  return false;
                }
              }
              return true;
            }
            return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context2);
          } else {
            var fragment = utilities.getFragmentFromSelection(selection, context2.fragmentMap);
            if (fragment) {
              if (selectionHasNonreactiveDirective(fragment))
                return true;
              return equalBySelectionSet(
                fragment.selectionSet,
                aResult,
                bResult,
                context2
              );
            }
          }
        });
      }
      function selectionHasNonreactiveDirective(selection) {
        return !!selection.directives && selection.directives.some(directiveIsNonreactive);
      }
      function directiveIsNonreactive(dir) {
        return dir.name.value === "nonreactive";
      }
      var assign = Object.assign;
      var hasOwnProperty$1 = Object.hasOwnProperty;
      var ObservableQuery = function(_super) {
        tslib.__extends(ObservableQuery2, _super);
        function ObservableQuery2(_a) {
          var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;
          var _this = _super.call(this, function(observer) {
            try {
              var subObserver = observer._subscription._observer;
              if (subObserver && !subObserver.error) {
                subObserver.error = defaultSubscriptionObserverErrorCallback;
              }
            } catch (_a2) {
            }
            var first = !_this.observers.size;
            _this.observers.add(observer);
            var last = _this.last;
            if (last && last.error) {
              observer.error && observer.error(last.error);
            } else if (last && last.result) {
              observer.next && observer.next(_this.maskResult(last.result));
            }
            if (first) {
              _this.reobserve().catch(function() {
              });
            }
            return function() {
              if (_this.observers.delete(observer) && !_this.observers.size) {
                _this.tearDownQuery();
              }
            };
          }) || this;
          _this.observers = /* @__PURE__ */ new Set();
          _this.subscriptions = /* @__PURE__ */ new Set();
          _this.queryInfo = queryInfo;
          _this.queryManager = queryManager;
          _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);
          _this.isTornDown = false;
          _this.subscribeToMore = _this.subscribeToMore.bind(_this);
          _this.maskResult = _this.maskResult.bind(_this);
          var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
          var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
          _this.options = tslib.__assign(tslib.__assign({}, options), {
            initialFetchPolicy,
            fetchPolicy
          });
          _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
          var opDef = utilities.getOperationDefinition(_this.query);
          _this.queryName = opDef && opDef.name && opDef.name.value;
          return _this;
        }
        Object.defineProperty(ObservableQuery2.prototype, "query", {
          get: function() {
            return this.lastQuery || this.options.query;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ObservableQuery2.prototype, "variables", {
          get: function() {
            return this.options.variables;
          },
          enumerable: false,
          configurable: true
        });
        ObservableQuery2.prototype.result = function() {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var observer = {
              next: function(result) {
                resolve(result);
                _this.observers.delete(observer);
                if (!_this.observers.size) {
                  _this.queryManager.removeQuery(_this.queryId);
                }
                setTimeout(function() {
                  subscription.unsubscribe();
                }, 0);
              },
              error: reject
            };
            var subscription = _this.subscribe(observer);
          });
        };
        ObservableQuery2.prototype.resetDiff = function() {
          this.queryInfo.resetDiff();
        };
        ObservableQuery2.prototype.getCurrentFullResult = function(saveAsLastResult) {
          if (saveAsLastResult === void 0) {
            saveAsLastResult = true;
          }
          var lastResult = this.getLastResult(true);
          var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || exports.NetworkStatus.ready;
          var result = tslib.__assign(tslib.__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
          var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a;
          if (skipCacheDataFor(fetchPolicy) || this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) ;
          else if (this.waitForOwnResult) {
            this.queryInfo["updateWatch"]();
          } else {
            var diff = this.queryInfo.getDiff();
            if (diff.complete || this.options.returnPartialData) {
              result.data = diff.result;
            }
            if (equal.equal(result.data, {})) {
              result.data = void 0;
            }
            if (diff.complete) {
              delete result.partial;
              if (diff.complete && result.networkStatus === exports.NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
                result.networkStatus = exports.NetworkStatus.ready;
                result.loading = false;
              }
            } else {
              result.partial = true;
            }
            if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
              logMissingFieldErrors(diff.missing);
            }
          }
          if (saveAsLastResult) {
            this.updateLastResult(result);
          }
          return result;
        };
        ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
          if (saveAsLastResult === void 0) {
            saveAsLastResult = true;
          }
          return this.maskResult(this.getCurrentFullResult(saveAsLastResult));
        };
        ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
          if (!this.last) {
            return true;
          }
          var documentInfo = this.queryManager.getDocumentInfo(this.query);
          var dataMasking = this.queryManager.dataMasking;
          var query = dataMasking ? documentInfo.nonReactiveQuery : this.query;
          var resultIsDifferent = dataMasking || documentInfo.hasNonreactiveDirective ? !equalByQuery(query, this.last.result, newResult, this.variables) : !equal.equal(this.last.result, newResult);
          return resultIsDifferent || variables && !equal.equal(this.last.variables, variables);
        };
        ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
          var last = this.last;
          if (last && last[key] && (!variablesMustMatch || equal.equal(last.variables, this.variables))) {
            return last[key];
          }
        };
        ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
          return this.getLast("result", variablesMustMatch);
        };
        ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
          return this.getLast("error", variablesMustMatch);
        };
        ObservableQuery2.prototype.resetLastResults = function() {
          delete this.last;
          this.isTornDown = false;
        };
        ObservableQuery2.prototype.resetQueryStoreErrors = function() {
          this.queryManager.resetErrors(this.queryId);
        };
        ObservableQuery2.prototype.refetch = function(variables) {
          var _a;
          var reobserveOptions = {
            pollInterval: 0
          };
          var fetchPolicy = this.options.fetchPolicy;
          if (fetchPolicy === "cache-and-network") {
            reobserveOptions.fetchPolicy = fetchPolicy;
          } else if (fetchPolicy === "no-cache") {
            reobserveOptions.fetchPolicy = "no-cache";
          } else {
            reobserveOptions.fetchPolicy = "network-only";
          }
          if (globalThis.__DEV__ !== false && variables && hasOwnProperty$1.call(variables, "variables")) {
            var queryDef = utilities.getQueryDefinition(this.query);
            var vars = queryDef.variableDefinitions;
            if (!vars || !vars.some(function(v) {
              return v.variable.name.value === "variables";
            })) {
              globalThis.__DEV__ !== false && globals.invariant.warn(
                21,
                variables,
                ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef
              );
            }
          }
          if (variables && !equal.equal(this.options.variables, variables)) {
            reobserveOptions.variables = this.options.variables = tslib.__assign(tslib.__assign({}, this.options.variables), variables);
          }
          this.queryInfo.resetLastWrite();
          return this.reobserve(reobserveOptions, exports.NetworkStatus.refetch);
        };
        ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
          var _this = this;
          var combinedOptions = tslib.__assign(tslib.__assign({}, fetchMoreOptions.query ? fetchMoreOptions : tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: tslib.__assign(tslib.__assign({}, this.options.variables), fetchMoreOptions.variables) })), {
            fetchPolicy: "no-cache"
          });
          combinedOptions.query = this.transformDocument(combinedOptions.query);
          var qid = this.queryManager.generateQueryId();
          this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
          var queryInfo = this.queryInfo;
          var originalNetworkStatus = queryInfo.networkStatus;
          queryInfo.networkStatus = exports.NetworkStatus.fetchMore;
          if (combinedOptions.notifyOnNetworkStatusChange) {
            this.observe();
          }
          var updatedQuerySet = /* @__PURE__ */ new Set();
          var updateQuery = fetchMoreOptions === null || fetchMoreOptions === void 0 ? void 0 : fetchMoreOptions.updateQuery;
          var isCached = this.options.fetchPolicy !== "no-cache";
          if (!isCached) {
            globals.invariant(updateQuery, 22);
          }
          return this.queryManager.fetchQuery(qid, combinedOptions, exports.NetworkStatus.fetchMore).then(function(fetchMoreResult) {
            _this.queryManager.removeQuery(qid);
            if (queryInfo.networkStatus === exports.NetworkStatus.fetchMore) {
              queryInfo.networkStatus = originalNetworkStatus;
            }
            if (isCached) {
              _this.queryManager.cache.batch({
                update: function(cache2) {
                  var updateQuery2 = fetchMoreOptions.updateQuery;
                  if (updateQuery2) {
                    cache2.updateQuery({
                      query: _this.query,
                      variables: _this.variables,
                      returnPartialData: true,
                      optimistic: false
                    }, function(previous) {
                      return updateQuery2(previous, {
                        fetchMoreResult: fetchMoreResult.data,
                        variables: combinedOptions.variables
                      });
                    });
                  } else {
                    cache2.writeQuery({
                      query: combinedOptions.query,
                      variables: combinedOptions.variables,
                      data: fetchMoreResult.data
                    });
                  }
                },
                onWatchUpdated: function(watch) {
                  updatedQuerySet.add(watch.query);
                }
              });
            } else {
              var lastResult = _this.getLast("result");
              var data = updateQuery(lastResult.data, {
                fetchMoreResult: fetchMoreResult.data,
                variables: combinedOptions.variables
              });
              _this.reportResult(tslib.__assign(tslib.__assign({}, lastResult), { data }), _this.variables);
            }
            return _this.maskResult(fetchMoreResult);
          }).finally(function() {
            if (isCached && !updatedQuerySet.has(_this.query)) {
              reobserveCacheFirst(_this);
            }
          });
        };
        ObservableQuery2.prototype.subscribeToMore = function(options) {
          var _this = this;
          var subscription = this.queryManager.startGraphQLSubscription({
            query: options.document,
            variables: options.variables,
            context: options.context
          }).subscribe({
            next: function(subscriptionData) {
              var updateQuery = options.updateQuery;
              if (updateQuery) {
                _this.updateQuery(function(previous, _a) {
                  var variables = _a.variables;
                  return updateQuery(previous, {
                    subscriptionData,
                    variables
                  });
                });
              }
            },
            error: function(err) {
              if (options.onError) {
                options.onError(err);
                return;
              }
              globalThis.__DEV__ !== false && globals.invariant.error(23, err);
            }
          });
          this.subscriptions.add(subscription);
          return function() {
            if (_this.subscriptions.delete(subscription)) {
              subscription.unsubscribe();
            }
          };
        };
        ObservableQuery2.prototype.setOptions = function(newOptions) {
          return this.reobserve(newOptions);
        };
        ObservableQuery2.prototype.silentSetOptions = function(newOptions) {
          var mergedOptions = utilities.compact(this.options, newOptions || {});
          assign(this.options, mergedOptions);
        };
        ObservableQuery2.prototype.setVariables = function(variables) {
          if (equal.equal(this.variables, variables)) {
            return this.observers.size ? this.result() : Promise.resolve();
          }
          this.options.variables = variables;
          if (!this.observers.size) {
            return Promise.resolve();
          }
          return this.reobserve({
            fetchPolicy: this.options.initialFetchPolicy,
            variables
          }, exports.NetworkStatus.setVariables);
        };
        ObservableQuery2.prototype.updateQuery = function(mapFn) {
          var queryManager = this.queryManager;
          var result = queryManager.cache.diff({
            query: this.options.query,
            variables: this.variables,
            returnPartialData: true,
            optimistic: false
          }).result;
          var newResult = mapFn(result, {
            variables: this.variables
          });
          if (newResult) {
            queryManager.cache.writeQuery({
              query: this.options.query,
              data: newResult,
              variables: this.variables
            });
            queryManager.broadcastQueries();
          }
        };
        ObservableQuery2.prototype.startPolling = function(pollInterval) {
          this.options.pollInterval = pollInterval;
          this.updatePolling();
        };
        ObservableQuery2.prototype.stopPolling = function() {
          this.options.pollInterval = 0;
          this.updatePolling();
        };
        ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
          if (options.nextFetchPolicy) {
            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
            if (fetchPolicy === "standby") ;
            else if (typeof options.nextFetchPolicy === "function") {
              options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
                reason,
                options,
                observable: this,
                initialFetchPolicy
              });
            } else if (reason === "variables-changed") {
              options.fetchPolicy = initialFetchPolicy;
            } else {
              options.fetchPolicy = options.nextFetchPolicy;
            }
          }
          return options.fetchPolicy;
        };
        ObservableQuery2.prototype.fetch = function(options, newNetworkStatus, query) {
          this.queryManager.setObservableQuery(this);
          return this.queryManager["fetchConcastWithInfo"](this.queryId, options, newNetworkStatus, query);
        };
        ObservableQuery2.prototype.updatePolling = function() {
          var _this = this;
          if (this.queryManager.ssrMode) {
            return;
          }
          var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;
          if (!pollInterval || !this.hasObservers()) {
            if (pollingInfo) {
              clearTimeout(pollingInfo.timeout);
              delete this.pollingInfo;
            }
            return;
          }
          if (pollingInfo && pollingInfo.interval === pollInterval) {
            return;
          }
          globals.invariant(pollInterval, 24);
          var info = pollingInfo || (this.pollingInfo = {});
          info.interval = pollInterval;
          var maybeFetch = function() {
            var _a2, _b;
            if (_this.pollingInfo) {
              if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b = (_a2 = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a2))) {
                _this.reobserve({
                  fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
                }, exports.NetworkStatus.poll).then(poll, poll);
              } else {
                poll();
              }
            }
          };
          var poll = function() {
            var info2 = _this.pollingInfo;
            if (info2) {
              clearTimeout(info2.timeout);
              info2.timeout = setTimeout(maybeFetch, info2.interval);
            }
          };
          poll();
        };
        ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
          if (variables === void 0) {
            variables = this.variables;
          }
          var error = this.getLastError();
          if (error && this.last && !equal.equal(variables, this.last.variables)) {
            error = void 0;
          }
          return this.last = tslib.__assign({ result: this.queryManager.assumeImmutableResults ? newResult : utilities.cloneDeep(newResult), variables }, error ? { error } : null);
        };
        ObservableQuery2.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
          var _this = this;
          this.isTornDown = false;
          var useDisposableConcast = newNetworkStatus === exports.NetworkStatus.refetch || newNetworkStatus === exports.NetworkStatus.fetchMore || newNetworkStatus === exports.NetworkStatus.poll;
          var oldVariables = this.options.variables;
          var oldFetchPolicy = this.options.fetchPolicy;
          var mergedOptions = utilities.compact(this.options, newOptions || {});
          var options = useDisposableConcast ? mergedOptions : assign(this.options, mergedOptions);
          var query = this.transformDocument(options.query);
          this.lastQuery = query;
          if (!useDisposableConcast) {
            this.updatePolling();
            if (newOptions && newOptions.variables && !equal.equal(newOptions.variables, oldVariables) && options.fetchPolicy !== "standby" && (options.fetchPolicy === oldFetchPolicy || typeof options.nextFetchPolicy === "function")) {
              this.applyNextFetchPolicy("variables-changed", options);
              if (newNetworkStatus === void 0) {
                newNetworkStatus = exports.NetworkStatus.setVariables;
              }
            }
          }
          this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));
          var finishWaitingForOwnResult = function() {
            if (_this.concast === concast) {
              _this.waitForOwnResult = false;
            }
          };
          var variables = options.variables && tslib.__assign({}, options.variables);
          var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;
          var observer = {
            next: function(result) {
              if (equal.equal(_this.variables, variables)) {
                finishWaitingForOwnResult();
                _this.reportResult(result, variables);
              }
            },
            error: function(error) {
              if (equal.equal(_this.variables, variables)) {
                if (!errors.isApolloError(error)) {
                  error = new errors.ApolloError({ networkError: error });
                }
                finishWaitingForOwnResult();
                _this.reportError(error, variables);
              }
            }
          };
          if (!useDisposableConcast && (fromLink || !this.concast)) {
            if (this.concast && this.observer) {
              this.concast.removeObserver(this.observer);
            }
            this.concast = concast;
            this.observer = observer;
          }
          concast.addObserver(observer);
          return concast;
        };
        ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
          return utilities.preventUnhandledRejection(this.reobserveAsConcast(newOptions, newNetworkStatus).promise.then(this.maskResult));
        };
        ObservableQuery2.prototype.resubscribeAfterError = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var last = this.last;
          this.resetLastResults();
          var subscription = this.subscribe.apply(this, args);
          this.last = last;
          return subscription;
        };
        ObservableQuery2.prototype.observe = function() {
          this.reportResult(
            this.getCurrentFullResult(false),
            this.variables
          );
        };
        ObservableQuery2.prototype.reportResult = function(result, variables) {
          var lastError = this.getLastError();
          var isDifferent = this.isDifferentFromLastResult(result, variables);
          if (lastError || !result.partial || this.options.returnPartialData) {
            this.updateLastResult(result, variables);
          }
          if (lastError || isDifferent) {
            utilities.iterateObserversSafely(this.observers, "next", this.maskResult(result));
          }
        };
        ObservableQuery2.prototype.reportError = function(error, variables) {
          var errorResult = tslib.__assign(tslib.__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: exports.NetworkStatus.error, loading: false });
          this.updateLastResult(errorResult, variables);
          utilities.iterateObserversSafely(this.observers, "error", this.last.error = error);
        };
        ObservableQuery2.prototype.hasObservers = function() {
          return this.observers.size > 0;
        };
        ObservableQuery2.prototype.tearDownQuery = function() {
          if (this.isTornDown)
            return;
          if (this.concast && this.observer) {
            this.concast.removeObserver(this.observer);
            delete this.concast;
            delete this.observer;
          }
          this.stopPolling();
          this.subscriptions.forEach(function(sub) {
            return sub.unsubscribe();
          });
          this.subscriptions.clear();
          this.queryManager.stopQuery(this.queryId);
          this.observers.clear();
          this.isTornDown = true;
        };
        ObservableQuery2.prototype.transformDocument = function(document) {
          return this.queryManager.transform(document);
        };
        ObservableQuery2.prototype.maskResult = function(result) {
          return result && "data" in result ? tslib.__assign(tslib.__assign({}, result), { data: this.queryManager.maskOperation({
            document: this.query,
            data: result.data,
            fetchPolicy: this.options.fetchPolicy,
            id: this.queryId
          }) }) : result;
        };
        return ObservableQuery2;
      }(utilities.Observable);
      utilities.fixObservableSubclass(ObservableQuery);
      function reobserveCacheFirst(obsQuery) {
        var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;
        if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
          return obsQuery.reobserve({
            fetchPolicy: "cache-first",
            nextFetchPolicy: function(currentFetchPolicy, context2) {
              this.nextFetchPolicy = nextFetchPolicy;
              if (typeof this.nextFetchPolicy === "function") {
                return this.nextFetchPolicy(currentFetchPolicy, context2);
              }
              return fetchPolicy;
            }
          });
        }
        return obsQuery.reobserve();
      }
      function defaultSubscriptionObserverErrorCallback(error) {
        globalThis.__DEV__ !== false && globals.invariant.error(25, error.message, error.stack);
      }
      function logMissingFieldErrors(missing) {
        if (globalThis.__DEV__ !== false && missing) {
          globalThis.__DEV__ !== false && globals.invariant.debug(26, missing);
        }
      }
      function skipCacheDataFor(fetchPolicy) {
        return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
      }
      var destructiveMethodCounts = new (utilities.canUseWeakMap ? WeakMap : Map)();
      function wrapDestructiveCacheMethod(cache2, methodName) {
        var original = cache2[methodName];
        if (typeof original === "function") {
          cache2[methodName] = function() {
            destructiveMethodCounts.set(
              cache2,
              (destructiveMethodCounts.get(cache2) + 1) % 1e15
            );
            return original.apply(this, arguments);
          };
        }
      }
      function cancelNotifyTimeout(info) {
        if (info["notifyTimeout"]) {
          clearTimeout(info["notifyTimeout"]);
          info["notifyTimeout"] = void 0;
        }
      }
      var QueryInfo = function() {
        function QueryInfo2(queryManager, queryId) {
          if (queryId === void 0) {
            queryId = queryManager.generateQueryId();
          }
          this.queryId = queryId;
          this.listeners = /* @__PURE__ */ new Set();
          this.document = null;
          this.lastRequestId = 1;
          this.stopped = false;
          this.dirty = false;
          this.observableQuery = null;
          var cache2 = this.cache = queryManager.cache;
          if (!destructiveMethodCounts.has(cache2)) {
            destructiveMethodCounts.set(cache2, 0);
            wrapDestructiveCacheMethod(cache2, "evict");
            wrapDestructiveCacheMethod(cache2, "modify");
            wrapDestructiveCacheMethod(cache2, "reset");
          }
        }
        QueryInfo2.prototype.init = function(query) {
          var networkStatus = query.networkStatus || exports.NetworkStatus.loading;
          if (this.variables && this.networkStatus !== exports.NetworkStatus.loading && !equal.equal(this.variables, query.variables)) {
            networkStatus = exports.NetworkStatus.setVariables;
          }
          if (!equal.equal(query.variables, this.variables)) {
            this.lastDiff = void 0;
          }
          Object.assign(this, {
            document: query.document,
            variables: query.variables,
            networkError: null,
            graphQLErrors: this.graphQLErrors || [],
            networkStatus
          });
          if (query.observableQuery) {
            this.setObservableQuery(query.observableQuery);
          }
          if (query.lastRequestId) {
            this.lastRequestId = query.lastRequestId;
          }
          return this;
        };
        QueryInfo2.prototype.reset = function() {
          cancelNotifyTimeout(this);
          this.dirty = false;
        };
        QueryInfo2.prototype.resetDiff = function() {
          this.lastDiff = void 0;
        };
        QueryInfo2.prototype.getDiff = function() {
          var options = this.getDiffOptions();
          if (this.lastDiff && equal.equal(options, this.lastDiff.options)) {
            return this.lastDiff.diff;
          }
          this.updateWatch(this.variables);
          var oq = this.observableQuery;
          if (oq && oq.options.fetchPolicy === "no-cache") {
            return { complete: false };
          }
          var diff = this.cache.diff(options);
          this.updateLastDiff(diff, options);
          return diff;
        };
        QueryInfo2.prototype.updateLastDiff = function(diff, options) {
          this.lastDiff = diff ? {
            diff,
            options: options || this.getDiffOptions()
          } : void 0;
        };
        QueryInfo2.prototype.getDiffOptions = function(variables) {
          var _a;
          if (variables === void 0) {
            variables = this.variables;
          }
          return {
            query: this.document,
            variables,
            returnPartialData: true,
            optimistic: true,
            canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults
          };
        };
        QueryInfo2.prototype.setDiff = function(diff) {
          var _this = this;
          var _a;
          var oldDiff = this.lastDiff && this.lastDiff.diff;
          if (diff && !diff.complete && ((_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.getLastError())) {
            return;
          }
          this.updateLastDiff(diff);
          if (!this.dirty && !equal.equal(oldDiff && oldDiff.result, diff && diff.result)) {
            this.dirty = true;
            if (!this.notifyTimeout) {
              this.notifyTimeout = setTimeout(function() {
                return _this.notify();
              }, 0);
            }
          }
        };
        QueryInfo2.prototype.setObservableQuery = function(oq) {
          var _this = this;
          if (oq === this.observableQuery)
            return;
          if (this.oqListener) {
            this.listeners.delete(this.oqListener);
          }
          this.observableQuery = oq;
          if (oq) {
            oq["queryInfo"] = this;
            this.listeners.add(this.oqListener = function() {
              var diff = _this.getDiff();
              if (diff.fromOptimisticTransaction) {
                oq["observe"]();
              } else {
                reobserveCacheFirst(oq);
              }
            });
          } else {
            delete this.oqListener;
          }
        };
        QueryInfo2.prototype.notify = function() {
          var _this = this;
          cancelNotifyTimeout(this);
          if (this.shouldNotify()) {
            this.listeners.forEach(function(listener) {
              return listener(_this);
            });
          }
          this.dirty = false;
        };
        QueryInfo2.prototype.shouldNotify = function() {
          if (!this.dirty || !this.listeners.size) {
            return false;
          }
          if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
            var fetchPolicy = this.observableQuery.options.fetchPolicy;
            if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
              return false;
            }
          }
          return true;
        };
        QueryInfo2.prototype.stop = function() {
          if (!this.stopped) {
            this.stopped = true;
            this.reset();
            this.cancel();
            this.cancel = QueryInfo2.prototype.cancel;
            var oq = this.observableQuery;
            if (oq)
              oq.stopPolling();
          }
        };
        QueryInfo2.prototype.cancel = function() {
        };
        QueryInfo2.prototype.updateWatch = function(variables) {
          var _this = this;
          if (variables === void 0) {
            variables = this.variables;
          }
          var oq = this.observableQuery;
          if (oq && oq.options.fetchPolicy === "no-cache") {
            return;
          }
          var watchOptions = tslib.__assign(tslib.__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
            return _this.setDiff(diff);
          } });
          if (!this.lastWatch || !equal.equal(watchOptions, this.lastWatch)) {
            this.cancel();
            this.cancel = this.cache.watch(this.lastWatch = watchOptions);
          }
        };
        QueryInfo2.prototype.resetLastWrite = function() {
          this.lastWrite = void 0;
        };
        QueryInfo2.prototype.shouldWrite = function(result, variables) {
          var lastWrite = this.lastWrite;
          return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal.equal(variables, lastWrite.variables) && equal.equal(result.data, lastWrite.result.data));
        };
        QueryInfo2.prototype.markResult = function(result, document, options, cacheWriteBehavior) {
          var _this = this;
          var merger = new utilities.DeepMerger();
          var graphQLErrors = utilities.isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
          this.reset();
          if ("incremental" in result && utilities.isNonEmptyArray(result.incremental)) {
            var mergedData = utilities.mergeIncrementalData(this.getDiff().result, result);
            result.data = mergedData;
          } else if ("hasNext" in result && result.hasNext) {
            var diff = this.getDiff();
            result.data = merger.merge(diff.result, result.data);
          }
          this.graphQLErrors = graphQLErrors;
          if (options.fetchPolicy === "no-cache") {
            this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));
          } else if (cacheWriteBehavior !== 0) {
            if (shouldWriteResult(result, options.errorPolicy)) {
              this.cache.performTransaction(function(cache2) {
                if (_this.shouldWrite(result, options.variables)) {
                  cache2.writeQuery({
                    query: document,
                    data: result.data,
                    variables: options.variables,
                    overwrite: cacheWriteBehavior === 1
                  });
                  _this.lastWrite = {
                    result,
                    variables: options.variables,
                    dmCount: destructiveMethodCounts.get(_this.cache)
                  };
                } else {
                  if (_this.lastDiff && _this.lastDiff.diff.complete) {
                    result.data = _this.lastDiff.diff.result;
                    return;
                  }
                }
                var diffOptions = _this.getDiffOptions(options.variables);
                var diff2 = cache2.diff(diffOptions);
                if (!_this.stopped && equal.equal(_this.variables, options.variables)) {
                  _this.updateWatch(options.variables);
                }
                _this.updateLastDiff(diff2, diffOptions);
                if (diff2.complete) {
                  result.data = diff2.result;
                }
              });
            } else {
              this.lastWrite = void 0;
            }
          }
        };
        QueryInfo2.prototype.markReady = function() {
          this.networkError = null;
          return this.networkStatus = exports.NetworkStatus.ready;
        };
        QueryInfo2.prototype.markError = function(error) {
          this.networkStatus = exports.NetworkStatus.error;
          this.lastWrite = void 0;
          this.reset();
          if (error.graphQLErrors) {
            this.graphQLErrors = error.graphQLErrors;
          }
          if (error.networkError) {
            this.networkError = error.networkError;
          }
          return error;
        };
        return QueryInfo2;
      }();
      function shouldWriteResult(result, errorPolicy) {
        if (errorPolicy === void 0) {
          errorPolicy = "none";
        }
        var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
        var writeWithErrors = !utilities.graphQLResultHasError(result);
        if (!writeWithErrors && ignoreErrors && result.data) {
          writeWithErrors = true;
        }
        return writeWithErrors;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var IGNORE = /* @__PURE__ */ Object.create(null);
      var QueryManager = function() {
        function QueryManager2(options) {
          var _this = this;
          this.clientAwareness = {};
          this.queries = /* @__PURE__ */ new Map();
          this.fetchCancelFns = /* @__PURE__ */ new Map();
          this.transformCache = new utilities.AutoCleanedWeakCache(utilities.cacheSizes["queryManager.getDocumentInfo"] || 2e3);
          this.queryIdCounter = 1;
          this.requestIdCounter = 1;
          this.mutationIdCounter = 1;
          this.inFlightLinkObservables = new trie.Trie(false);
          this.noCacheWarningsByQueryId = /* @__PURE__ */ new Set();
          var defaultDocumentTransform = new utilities.DocumentTransform(
            function(document) {
              return _this.cache.transformDocument(document);
            },
            { cache: false }
          );
          this.cache = options.cache;
          this.link = options.link;
          this.defaultOptions = options.defaultOptions;
          this.queryDeduplication = options.queryDeduplication;
          this.clientAwareness = options.clientAwareness;
          this.localState = options.localState;
          this.ssrMode = options.ssrMode;
          this.assumeImmutableResults = options.assumeImmutableResults;
          this.dataMasking = options.dataMasking;
          var documentTransform = options.documentTransform;
          this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
          this.defaultContext = options.defaultContext || /* @__PURE__ */ Object.create(null);
          if (this.onBroadcast = options.onBroadcast) {
            this.mutationStore = /* @__PURE__ */ Object.create(null);
          }
        }
        QueryManager2.prototype.stop = function() {
          var _this = this;
          this.queries.forEach(function(_info, queryId) {
            _this.stopQueryNoBroadcast(queryId);
          });
          this.cancelPendingFetches(globals.newInvariantError(27));
        };
        QueryManager2.prototype.cancelPendingFetches = function(error) {
          this.fetchCancelFns.forEach(function(cancel) {
            return cancel(error);
          });
          this.fetchCancelFns.clear();
        };
        QueryManager2.prototype.mutate = function(_a) {
          return tslib.__awaiter(this, arguments, void 0, function(_b) {
            var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self2;
            var _c, _d;
            var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || "network-only" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b.keepRootFields, context2 = _b.context;
            return tslib.__generator(this, function(_j) {
              switch (_j.label) {
                case 0:
                  globals.invariant(mutation, 28);
                  globals.invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 29);
                  mutationId = this.generateMutationId();
                  mutation = this.cache.transformForLink(this.transform(mutation));
                  hasClientExports = this.getDocumentInfo(mutation).hasClientExports;
                  variables = this.getVariables(mutation, variables);
                  if (!hasClientExports) return [3, 2];
                  return [4, this.localState.addExportedVariables(mutation, variables, context2)];
                case 1:
                  variables = _j.sent();
                  _j.label = 2;
                case 2:
                  mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                    mutation,
                    variables,
                    loading: true,
                    error: null
                  });
                  isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                    mutationId,
                    document: mutation,
                    variables,
                    fetchPolicy,
                    errorPolicy,
                    context: context2,
                    updateQueries,
                    update: updateWithProxyFn,
                    keepRootFields
                  });
                  this.broadcastQueries();
                  self2 = this;
                  return [2, new Promise(function(resolve, reject) {
                    return utilities.asyncMap(self2.getObservableFromLink(mutation, tslib.__assign(tslib.__assign({}, context2), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function(result) {
                      if (utilities.graphQLResultHasError(result) && errorPolicy === "none") {
                        throw new errors.ApolloError({
                          graphQLErrors: utilities.getGraphQLErrorsFromResult(result)
                        });
                      }
                      if (mutationStoreValue) {
                        mutationStoreValue.loading = false;
                        mutationStoreValue.error = null;
                      }
                      var storeResult = tslib.__assign({}, result);
                      if (typeof refetchQueries === "function") {
                        refetchQueries = refetchQueries(storeResult);
                      }
                      if (errorPolicy === "ignore" && utilities.graphQLResultHasError(storeResult)) {
                        delete storeResult.errors;
                      }
                      return self2.markMutationResult({
                        mutationId,
                        result: storeResult,
                        document: mutation,
                        variables,
                        fetchPolicy,
                        errorPolicy,
                        context: context2,
                        update: updateWithProxyFn,
                        updateQueries,
                        awaitRefetchQueries,
                        refetchQueries,
                        removeOptimistic: isOptimistic ? mutationId : void 0,
                        onQueryUpdated,
                        keepRootFields
                      });
                    }).subscribe({
                      next: function(storeResult) {
                        self2.broadcastQueries();
                        if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                          resolve(tslib.__assign(tslib.__assign({}, storeResult), { data: self2.maskOperation({
                            document: mutation,
                            data: storeResult.data,
                            fetchPolicy,
                            id: mutationId
                          }) }));
                        }
                      },
                      error: function(err) {
                        if (mutationStoreValue) {
                          mutationStoreValue.loading = false;
                          mutationStoreValue.error = err;
                        }
                        if (isOptimistic) {
                          self2.cache.removeOptimistic(mutationId);
                        }
                        self2.broadcastQueries();
                        reject(err instanceof errors.ApolloError ? err : new errors.ApolloError({
                          networkError: err
                        }));
                      }
                    });
                  })];
              }
            });
          });
        };
        QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
          var _this = this;
          if (cache2 === void 0) {
            cache2 = this.cache;
          }
          var result = mutation.result;
          var cacheWrites = [];
          var skipCache = mutation.fetchPolicy === "no-cache";
          if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
            if (!utilities.isExecutionPatchIncrementalResult(result)) {
              cacheWrites.push({
                result: result.data,
                dataId: "ROOT_MUTATION",
                query: mutation.document,
                variables: mutation.variables
              });
            }
            if (utilities.isExecutionPatchIncrementalResult(result) && utilities.isNonEmptyArray(result.incremental)) {
              var diff = cache2.diff({
                id: "ROOT_MUTATION",
                query: this.getDocumentInfo(mutation.document).asQuery,
                variables: mutation.variables,
                optimistic: false,
                returnPartialData: true
              });
              var mergedData = void 0;
              if (diff.result) {
                mergedData = mergeIncrementalData(diff.result, result);
              }
              if (typeof mergedData !== "undefined") {
                result.data = mergedData;
                cacheWrites.push({
                  result: mergedData,
                  dataId: "ROOT_MUTATION",
                  query: mutation.document,
                  variables: mutation.variables
                });
              }
            }
            var updateQueries_1 = mutation.updateQueries;
            if (updateQueries_1) {
              this.queries.forEach(function(_a, queryId) {
                var observableQuery = _a.observableQuery;
                var queryName = observableQuery && observableQuery.queryName;
                if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {
                  return;
                }
                var updater = updateQueries_1[queryName];
                var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;
                var _c = cache2.diff({
                  query: document,
                  variables,
                  returnPartialData: true,
                  optimistic: false
                }), currentQueryResult = _c.result, complete = _c.complete;
                if (complete && currentQueryResult) {
                  var nextQueryResult = updater(currentQueryResult, {
                    mutationResult: result,
                    queryName: document && utilities.getOperationName(document) || void 0,
                    queryVariables: variables
                  });
                  if (nextQueryResult) {
                    cacheWrites.push({
                      result: nextQueryResult,
                      dataId: "ROOT_QUERY",
                      query: document,
                      variables
                    });
                  }
                }
              });
            }
          }
          if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
            var results_1 = [];
            this.refetchQueries({
              updateCache: function(cache3) {
                if (!skipCache) {
                  cacheWrites.forEach(function(write) {
                    return cache3.write(write);
                  });
                }
                var update2 = mutation.update;
                var isFinalResult = !utilities.isExecutionPatchResult(result) || utilities.isExecutionPatchIncrementalResult(result) && !result.hasNext;
                if (update2) {
                  if (!skipCache) {
                    var diff2 = cache3.diff({
                      id: "ROOT_MUTATION",
                      query: _this.getDocumentInfo(mutation.document).asQuery,
                      variables: mutation.variables,
                      optimistic: false,
                      returnPartialData: true
                    });
                    if (diff2.complete) {
                      result = tslib.__assign(tslib.__assign({}, result), { data: diff2.result });
                      if ("incremental" in result) {
                        delete result.incremental;
                      }
                      if ("hasNext" in result) {
                        delete result.hasNext;
                      }
                    }
                  }
                  if (isFinalResult) {
                    update2(cache3, result, {
                      context: mutation.context,
                      variables: mutation.variables
                    });
                  }
                }
                if (!skipCache && !mutation.keepRootFields && isFinalResult) {
                  cache3.modify({
                    id: "ROOT_MUTATION",
                    fields: function(value, _a) {
                      var fieldName = _a.fieldName, DELETE = _a.DELETE;
                      return fieldName === "__typename" ? value : DELETE;
                    }
                  });
                }
              },
              include: mutation.refetchQueries,
              optimistic: false,
              removeOptimistic: mutation.removeOptimistic,
              onQueryUpdated: mutation.onQueryUpdated || null
            }).forEach(function(result2) {
              return results_1.push(result2);
            });
            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
              return Promise.all(results_1).then(function() {
                return result;
              });
            }
          }
          return Promise.resolve(result);
        };
        QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
          var _this = this;
          var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE }) : optimisticResponse;
          if (data === IGNORE) {
            return false;
          }
          this.cache.recordOptimisticTransaction(function(cache2) {
            try {
              _this.markMutationResult(tslib.__assign(tslib.__assign({}, mutation), { result: { data } }), cache2);
            } catch (error) {
              globalThis.__DEV__ !== false && globals.invariant.error(error);
            }
          }, mutation.mutationId);
          return true;
        };
        QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
          return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;
        };
        QueryManager2.prototype.getQueryStore = function() {
          var store = /* @__PURE__ */ Object.create(null);
          this.queries.forEach(function(info, queryId) {
            store[queryId] = {
              variables: info.variables,
              networkStatus: info.networkStatus,
              networkError: info.networkError,
              graphQLErrors: info.graphQLErrors
            };
          });
          return store;
        };
        QueryManager2.prototype.resetErrors = function(queryId) {
          var queryInfo = this.queries.get(queryId);
          if (queryInfo) {
            queryInfo.networkError = void 0;
            queryInfo.graphQLErrors = [];
          }
        };
        QueryManager2.prototype.transform = function(document) {
          return this.documentTransform.transformDocument(document);
        };
        QueryManager2.prototype.getDocumentInfo = function(document) {
          var transformCache = this.transformCache;
          if (!transformCache.has(document)) {
            var cacheEntry = {
              hasClientExports: utilities.hasClientExports(document),
              hasForcedResolvers: this.localState.shouldForceResolvers(document),
              hasNonreactiveDirective: utilities.hasDirectives(["nonreactive"], document),
              nonReactiveQuery: utilities.addNonReactiveToNamedFragments(document),
              clientQuery: this.localState.clientQuery(document),
              serverQuery: utilities.removeDirectivesFromDocument([
                { name: "client", remove: true },
                { name: "connection" },
                { name: "nonreactive" },
                { name: "unmask" }
              ], document),
              defaultVars: utilities.getDefaultValues(utilities.getOperationDefinition(document)),
              asQuery: tslib.__assign(tslib.__assign({}, document), { definitions: document.definitions.map(function(def) {
                if (def.kind === "OperationDefinition" && def.operation !== "query") {
                  return tslib.__assign(tslib.__assign({}, def), { operation: "query" });
                }
                return def;
              }) })
            };
            transformCache.set(document, cacheEntry);
          }
          return transformCache.get(document);
        };
        QueryManager2.prototype.getVariables = function(document, variables) {
          return tslib.__assign(tslib.__assign({}, this.getDocumentInfo(document).defaultVars), variables);
        };
        QueryManager2.prototype.watchQuery = function(options) {
          var query = this.transform(options.query);
          options = tslib.__assign(tslib.__assign({}, options), { variables: this.getVariables(query, options.variables) });
          if (typeof options.notifyOnNetworkStatusChange === "undefined") {
            options.notifyOnNetworkStatusChange = false;
          }
          var queryInfo = new QueryInfo(this);
          var observable = new ObservableQuery({
            queryManager: this,
            queryInfo,
            options
          });
          observable["lastQuery"] = query;
          this.queries.set(observable.queryId, queryInfo);
          queryInfo.init({
            document: query,
            observableQuery: observable,
            variables: observable.variables
          });
          return observable;
        };
        QueryManager2.prototype.query = function(options, queryId) {
          var _this = this;
          if (queryId === void 0) {
            queryId = this.generateQueryId();
          }
          globals.invariant(options.query, 30);
          globals.invariant(options.query.kind === "Document", 31);
          globals.invariant(!options.returnPartialData, 32);
          globals.invariant(!options.pollInterval, 33);
          var query = this.transform(options.query);
          return this.fetchQuery(queryId, tslib.__assign(tslib.__assign({}, options), { query })).then(function(result) {
            return result && tslib.__assign(tslib.__assign({}, result), { data: _this.maskOperation({
              document: query,
              data: result.data,
              fetchPolicy: options.fetchPolicy,
              id: queryId
            }) });
          }).finally(function() {
            return _this.stopQuery(queryId);
          });
        };
        QueryManager2.prototype.generateQueryId = function() {
          return String(this.queryIdCounter++);
        };
        QueryManager2.prototype.generateRequestId = function() {
          return this.requestIdCounter++;
        };
        QueryManager2.prototype.generateMutationId = function() {
          return String(this.mutationIdCounter++);
        };
        QueryManager2.prototype.stopQueryInStore = function(queryId) {
          this.stopQueryInStoreNoBroadcast(queryId);
          this.broadcastQueries();
        };
        QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
          var queryInfo = this.queries.get(queryId);
          if (queryInfo)
            queryInfo.stop();
        };
        QueryManager2.prototype.clearStore = function(options) {
          if (options === void 0) {
            options = {
              discardWatches: true
            };
          }
          this.cancelPendingFetches(globals.newInvariantError(34));
          this.queries.forEach(function(queryInfo) {
            if (queryInfo.observableQuery) {
              queryInfo.networkStatus = exports.NetworkStatus.loading;
            } else {
              queryInfo.stop();
            }
          });
          if (this.mutationStore) {
            this.mutationStore = /* @__PURE__ */ Object.create(null);
          }
          return this.cache.reset(options);
        };
        QueryManager2.prototype.getObservableQueries = function(include) {
          var _this = this;
          if (include === void 0) {
            include = "active";
          }
          var queries = /* @__PURE__ */ new Map();
          var queryNames = /* @__PURE__ */ new Map();
          var queryNamesAndQueryStrings = /* @__PURE__ */ new Map();
          var legacyQueryOptions = /* @__PURE__ */ new Set();
          if (Array.isArray(include)) {
            include.forEach(function(desc) {
              if (typeof desc === "string") {
                queryNames.set(desc, desc);
                queryNamesAndQueryStrings.set(desc, false);
              } else if (utilities.isDocumentNode(desc)) {
                var queryString = utilities.print(_this.transform(desc));
                queryNames.set(queryString, utilities.getOperationName(desc));
                queryNamesAndQueryStrings.set(queryString, false);
              } else if (utilities.isNonNullObject(desc) && desc.query) {
                legacyQueryOptions.add(desc);
              }
            });
          }
          this.queries.forEach(function(_a, queryId) {
            var oq = _a.observableQuery, document = _a.document;
            if (oq) {
              if (include === "all") {
                queries.set(queryId, oq);
                return;
              }
              var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
              if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
                return;
              }
              if (include === "active" || queryName && queryNamesAndQueryStrings.has(queryName) || document && queryNamesAndQueryStrings.has(utilities.print(document))) {
                queries.set(queryId, oq);
                if (queryName)
                  queryNamesAndQueryStrings.set(queryName, true);
                if (document)
                  queryNamesAndQueryStrings.set(utilities.print(document), true);
              }
            }
          });
          if (legacyQueryOptions.size) {
            legacyQueryOptions.forEach(function(options) {
              var queryId = utilities.makeUniqueId("legacyOneTimeQuery");
              var queryInfo = _this.getQuery(queryId).init({
                document: options.query,
                variables: options.variables
              });
              var oq = new ObservableQuery({
                queryManager: _this,
                queryInfo,
                options: tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "network-only" })
              });
              globals.invariant(oq.queryId === queryId);
              queryInfo.setObservableQuery(oq);
              queries.set(queryId, oq);
            });
          }
          if (globalThis.__DEV__ !== false && queryNamesAndQueryStrings.size) {
            queryNamesAndQueryStrings.forEach(function(included, nameOrQueryString) {
              if (!included) {
                var queryName = queryNames.get(nameOrQueryString);
                if (queryName) {
                  globalThis.__DEV__ !== false && globals.invariant.warn(35, queryName);
                } else {
                  globalThis.__DEV__ !== false && globals.invariant.warn(36);
                }
              }
            });
          }
          return queries;
        };
        QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
          var _this = this;
          if (includeStandby === void 0) {
            includeStandby = false;
          }
          var observableQueryPromises = [];
          this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
            var fetchPolicy = observableQuery.options.fetchPolicy;
            observableQuery.resetLastResults();
            if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
              observableQueryPromises.push(observableQuery.refetch());
            }
            _this.getQuery(queryId).setDiff(null);
          });
          this.broadcastQueries();
          return Promise.all(observableQueryPromises);
        };
        QueryManager2.prototype.setObservableQuery = function(observableQuery) {
          this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
        };
        QueryManager2.prototype.startGraphQLSubscription = function(options) {
          var _this = this;
          var query = options.query, variables = options.variables;
          var fetchPolicy = options.fetchPolicy, _a = options.errorPolicy, errorPolicy = _a === void 0 ? "none" : _a, _b = options.context, context2 = _b === void 0 ? {} : _b, _c = options.extensions, extensions = _c === void 0 ? {} : _c;
          query = this.transform(query);
          variables = this.getVariables(query, variables);
          var makeObservable = function(variables2) {
            return _this.getObservableFromLink(query, context2, variables2, extensions).map(function(result) {
              if (fetchPolicy !== "no-cache") {
                if (shouldWriteResult(result, errorPolicy)) {
                  _this.cache.write({
                    query,
                    result: result.data,
                    dataId: "ROOT_SUBSCRIPTION",
                    variables: variables2
                  });
                }
                _this.broadcastQueries();
              }
              var hasErrors = utilities.graphQLResultHasError(result);
              var hasProtocolErrors = errors.graphQLResultHasProtocolErrors(result);
              if (hasErrors || hasProtocolErrors) {
                var errors$1 = {};
                if (hasErrors) {
                  errors$1.graphQLErrors = result.errors;
                }
                if (hasProtocolErrors) {
                  errors$1.protocolErrors = result.extensions[errors.PROTOCOL_ERRORS_SYMBOL];
                }
                if (errorPolicy === "none" || hasProtocolErrors) {
                  throw new errors.ApolloError(errors$1);
                }
              }
              if (errorPolicy === "ignore") {
                delete result.errors;
              }
              return result;
            });
          };
          if (this.getDocumentInfo(query).hasClientExports) {
            var observablePromise_1 = this.localState.addExportedVariables(query, variables, context2).then(makeObservable);
            return new utilities.Observable(function(observer) {
              var sub = null;
              observablePromise_1.then(function(observable) {
                return sub = observable.subscribe(observer);
              }, observer.error);
              return function() {
                return sub && sub.unsubscribe();
              };
            });
          }
          return makeObservable(variables);
        };
        QueryManager2.prototype.stopQuery = function(queryId) {
          this.stopQueryNoBroadcast(queryId);
          this.broadcastQueries();
        };
        QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
          this.stopQueryInStoreNoBroadcast(queryId);
          this.removeQuery(queryId);
        };
        QueryManager2.prototype.removeQuery = function(queryId) {
          this.fetchCancelFns.delete(queryId);
          if (this.queries.has(queryId)) {
            this.getQuery(queryId).stop();
            this.queries.delete(queryId);
          }
        };
        QueryManager2.prototype.broadcastQueries = function() {
          if (this.onBroadcast)
            this.onBroadcast();
          this.queries.forEach(function(info) {
            return info.notify();
          });
        };
        QueryManager2.prototype.getLocalState = function() {
          return this.localState;
        };
        QueryManager2.prototype.getObservableFromLink = function(query, context2, variables, extensions, deduplication) {
          var _this = this;
          var _a;
          if (deduplication === void 0) {
            deduplication = (_a = context2 === null || context2 === void 0 ? void 0 : context2.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;
          }
          var observable;
          var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;
          if (serverQuery) {
            var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;
            var operation = {
              query: serverQuery,
              variables,
              operationName: utilities.getOperationName(serverQuery) || void 0,
              context: this.prepareContext(tslib.__assign(tslib.__assign({}, context2), { forceFetch: !deduplication })),
              extensions
            };
            context2 = operation.context;
            if (deduplication) {
              var printedServerQuery_1 = utilities.print(serverQuery);
              var varJson_1 = cache.canonicalStringify(variables);
              var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
              observable = entry.observable;
              if (!observable) {
                var concast = new utilities.Concast([
                  core2.execute(link, operation)
                ]);
                observable = entry.observable = concast;
                concast.beforeNext(function() {
                  inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
                });
              }
            } else {
              observable = new utilities.Concast([
                core2.execute(link, operation)
              ]);
            }
          } else {
            observable = new utilities.Concast([utilities.Observable.of({ data: {} })]);
            context2 = this.prepareContext(context2);
          }
          if (clientQuery) {
            observable = utilities.asyncMap(observable, function(result) {
              return _this.localState.runResolvers({
                document: clientQuery,
                remoteResult: result,
                context: context2,
                variables
              });
            });
          }
          return observable;
        };
        QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
          var requestId = queryInfo.lastRequestId = this.generateRequestId();
          var linkDocument = this.cache.transformForLink(options.query);
          return utilities.asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result) {
            var graphQLErrors = utilities.getGraphQLErrorsFromResult(result);
            var hasErrors = graphQLErrors.length > 0;
            var errorPolicy = options.errorPolicy;
            if (requestId >= queryInfo.lastRequestId) {
              if (hasErrors && errorPolicy === "none") {
                throw queryInfo.markError(new errors.ApolloError({
                  graphQLErrors
                }));
              }
              queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);
              queryInfo.markReady();
            }
            var aqr = {
              data: result.data,
              loading: false,
              networkStatus: exports.NetworkStatus.ready
            };
            if (hasErrors && errorPolicy === "none") {
              aqr.data = void 0;
            }
            if (hasErrors && errorPolicy !== "ignore") {
              aqr.errors = graphQLErrors;
              aqr.networkStatus = exports.NetworkStatus.error;
            }
            return aqr;
          }, function(networkError) {
            var error = errors.isApolloError(networkError) ? networkError : new errors.ApolloError({ networkError });
            if (requestId >= queryInfo.lastRequestId) {
              queryInfo.markError(error);
            }
            throw error;
          });
        };
        QueryManager2.prototype.fetchConcastWithInfo = function(queryId, options, networkStatus, query) {
          var _this = this;
          if (networkStatus === void 0) {
            networkStatus = exports.NetworkStatus.loading;
          }
          if (query === void 0) {
            query = options.query;
          }
          var variables = this.getVariables(query, options.variables);
          var queryInfo = this.getQuery(queryId);
          var defaults = this.defaultOptions.watchQuery;
          var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context2 = _e === void 0 ? {} : _e;
          var normalized = Object.assign({}, options, {
            query,
            variables,
            fetchPolicy,
            errorPolicy,
            returnPartialData,
            notifyOnNetworkStatusChange,
            context: context2
          });
          var fromVariables = function(variables2) {
            normalized.variables = variables2;
            var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
            if (normalized.fetchPolicy !== "standby" && sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery) {
              queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
            }
            return sourcesWithInfo2;
          };
          var cleanupCancelFn = function() {
            return _this.fetchCancelFns.delete(queryId);
          };
          this.fetchCancelFns.set(queryId, function(reason) {
            cleanupCancelFn();
            setTimeout(function() {
              return concast.cancel(reason);
            });
          });
          var concast, containsDataFromLink;
          if (this.getDocumentInfo(normalized.query).hasClientExports) {
            concast = new utilities.Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
              return sourcesWithInfo2.sources;
            }));
            containsDataFromLink = true;
          } else {
            var sourcesWithInfo = fromVariables(normalized.variables);
            containsDataFromLink = sourcesWithInfo.fromLink;
            concast = new utilities.Concast(sourcesWithInfo.sources);
          }
          concast.promise.then(cleanupCancelFn, cleanupCancelFn);
          return {
            concast,
            fromLink: containsDataFromLink
          };
        };
        QueryManager2.prototype.refetchQueries = function(_a) {
          var _this = this;
          var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? utilities.makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;
          var includedQueriesById = /* @__PURE__ */ new Map();
          if (include) {
            this.getObservableQueries(include).forEach(function(oq, queryId) {
              includedQueriesById.set(queryId, {
                oq,
                lastDiff: _this.getQuery(queryId).getDiff()
              });
            });
          }
          var results = /* @__PURE__ */ new Map();
          if (updateCache) {
            this.cache.batch({
              update: updateCache,
              optimistic: optimistic && removeOptimistic || false,
              removeOptimistic,
              onWatchUpdated: function(watch, diff, lastDiff) {
                var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
                if (oq) {
                  if (onQueryUpdated) {
                    includedQueriesById.delete(oq.queryId);
                    var result = onQueryUpdated(oq, diff, lastDiff);
                    if (result === true) {
                      result = oq.refetch();
                    }
                    if (result !== false) {
                      results.set(oq, result);
                    }
                    return result;
                  }
                  if (onQueryUpdated !== null) {
                    includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
                  }
                }
              }
            });
          }
          if (includedQueriesById.size) {
            includedQueriesById.forEach(function(_a2, queryId) {
              var oq = _a2.oq, lastDiff = _a2.lastDiff, diff = _a2.diff;
              var result;
              if (onQueryUpdated) {
                if (!diff) {
                  var info = oq["queryInfo"];
                  info.reset();
                  diff = info.getDiff();
                }
                result = onQueryUpdated(oq, diff, lastDiff);
              }
              if (!onQueryUpdated || result === true) {
                result = oq.refetch();
              }
              if (result !== false) {
                results.set(oq, result);
              }
              if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
                _this.stopQueryNoBroadcast(queryId);
              }
            });
          }
          if (removeOptimistic) {
            this.cache.removeOptimistic(removeOptimistic);
          }
          return results;
        };
        QueryManager2.prototype.maskOperation = function(options) {
          var _a, _b, _c;
          var document = options.document, data = options.data;
          if (globalThis.__DEV__ !== false) {
            var fetchPolicy = options.fetchPolicy, id = options.id;
            var operationType = (_a = utilities.getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation;
            var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : "o") + id;
            if (this.dataMasking && fetchPolicy === "no-cache" && !utilities.isFullyUnmaskedOperation(document) && !this.noCacheWarningsByQueryId.has(operationId)) {
              this.noCacheWarningsByQueryId.add(operationId);
              globalThis.__DEV__ !== false && globals.invariant.warn(
                37,
                (_c = utilities.getOperationName(document)) !== null && _c !== void 0 ? _c : "Unnamed ".concat(operationType !== null && operationType !== void 0 ? operationType : "operation")
              );
            }
          }
          return this.dataMasking ? masking.maskOperation(data, document, this.cache) : data;
        };
        QueryManager2.prototype.maskFragment = function(options) {
          var data = options.data, fragment = options.fragment, fragmentName = options.fragmentName;
          return this.dataMasking ? masking.maskFragment(data, fragment, this.cache, fragmentName) : data;
        };
        QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a, networkStatus) {
          var _this = this;
          var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context2 = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;
          var oldNetworkStatus = queryInfo.networkStatus;
          queryInfo.init({
            document: query,
            variables,
            networkStatus
          });
          var readCache = function() {
            return queryInfo.getDiff();
          };
          var resultsFromCache = function(diff2, networkStatus2) {
            if (networkStatus2 === void 0) {
              networkStatus2 = queryInfo.networkStatus || exports.NetworkStatus.loading;
            }
            var data = diff2.result;
            if (globalThis.__DEV__ !== false && !returnPartialData && !equal.equal(data, {})) {
              logMissingFieldErrors(diff2.missing);
            }
            var fromData = function(data2) {
              return utilities.Observable.of(tslib.__assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
            };
            if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
              return _this.localState.runResolvers({
                document: query,
                remoteResult: { data },
                context: context2,
                variables,
                onlyRunForcedResolvers: true
              }).then(function(resolved) {
                return fromData(resolved.data || void 0);
              });
            }
            if (errorPolicy === "none" && networkStatus2 === exports.NetworkStatus.refetch && Array.isArray(diff2.missing)) {
              return fromData(void 0);
            }
            return fromData(data);
          };
          var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === exports.NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
          var resultsFromLink = function() {
            return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
              query,
              variables,
              context: context2,
              fetchPolicy,
              errorPolicy
            });
          };
          var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
          switch (fetchPolicy) {
            default:
            case "cache-first": {
              var diff = readCache();
              if (diff.complete) {
                return {
                  fromLink: false,
                  sources: [resultsFromCache(diff, queryInfo.markReady())]
                };
              }
              if (returnPartialData || shouldNotify) {
                return {
                  fromLink: true,
                  sources: [resultsFromCache(diff), resultsFromLink()]
                };
              }
              return { fromLink: true, sources: [resultsFromLink()] };
            }
            case "cache-and-network": {
              var diff = readCache();
              if (diff.complete || returnPartialData || shouldNotify) {
                return {
                  fromLink: true,
                  sources: [resultsFromCache(diff), resultsFromLink()]
                };
              }
              return { fromLink: true, sources: [resultsFromLink()] };
            }
            case "cache-only":
              return {
                fromLink: false,
                sources: [resultsFromCache(readCache(), queryInfo.markReady())]
              };
            case "network-only":
              if (shouldNotify) {
                return {
                  fromLink: true,
                  sources: [resultsFromCache(readCache()), resultsFromLink()]
                };
              }
              return { fromLink: true, sources: [resultsFromLink()] };
            case "no-cache":
              if (shouldNotify) {
                return {
                  fromLink: true,
                  sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
                };
              }
              return { fromLink: true, sources: [resultsFromLink()] };
            case "standby":
              return { fromLink: false, sources: [] };
          }
        };
        QueryManager2.prototype.getQuery = function(queryId) {
          if (queryId && !this.queries.has(queryId)) {
            this.queries.set(queryId, new QueryInfo(this, queryId));
          }
          return this.queries.get(queryId);
        };
        QueryManager2.prototype.prepareContext = function(context2) {
          if (context2 === void 0) {
            context2 = {};
          }
          var newContext = this.localState.prepareContext(context2);
          return tslib.__assign(tslib.__assign(tslib.__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });
        };
        return QueryManager2;
      }();
      var LocalState = function() {
        function LocalState2(_a) {
          var cache2 = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
          this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
          this.cache = cache2;
          if (client) {
            this.client = client;
          }
          if (resolvers) {
            this.addResolvers(resolvers);
          }
          if (fragmentMatcher) {
            this.setFragmentMatcher(fragmentMatcher);
          }
        }
        LocalState2.prototype.addResolvers = function(resolvers) {
          var _this = this;
          this.resolvers = this.resolvers || {};
          if (Array.isArray(resolvers)) {
            resolvers.forEach(function(resolverGroup) {
              _this.resolvers = utilities.mergeDeep(_this.resolvers, resolverGroup);
            });
          } else {
            this.resolvers = utilities.mergeDeep(this.resolvers, resolvers);
          }
        };
        LocalState2.prototype.setResolvers = function(resolvers) {
          this.resolvers = {};
          this.addResolvers(resolvers);
        };
        LocalState2.prototype.getResolvers = function() {
          return this.resolvers || {};
        };
        LocalState2.prototype.runResolvers = function(_a) {
          return tslib.__awaiter(this, arguments, void 0, function(_b) {
            var document = _b.document, remoteResult = _b.remoteResult, context2 = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;
            return tslib.__generator(this, function(_d) {
              if (document) {
                return [2, this.resolveDocument(document, remoteResult.data, context2, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
                  return tslib.__assign(tslib.__assign({}, remoteResult), { data: localResult.result });
                })];
              }
              return [2, remoteResult];
            });
          });
        };
        LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
          this.fragmentMatcher = fragmentMatcher;
        };
        LocalState2.prototype.getFragmentMatcher = function() {
          return this.fragmentMatcher;
        };
        LocalState2.prototype.clientQuery = function(document) {
          if (utilities.hasDirectives(["client"], document)) {
            if (this.resolvers) {
              return document;
            }
          }
          return null;
        };
        LocalState2.prototype.serverQuery = function(document) {
          return utilities.removeClientSetsFromDocument(document);
        };
        LocalState2.prototype.prepareContext = function(context2) {
          var cache2 = this.cache;
          return tslib.__assign(tslib.__assign({}, context2), {
            cache: cache2,
            getCacheKey: function(obj) {
              return cache2.identify(obj);
            }
          });
        };
        LocalState2.prototype.addExportedVariables = function(document_1) {
          return tslib.__awaiter(this, arguments, void 0, function(document, variables, context2) {
            if (variables === void 0) {
              variables = {};
            }
            if (context2 === void 0) {
              context2 = {};
            }
            return tslib.__generator(this, function(_a) {
              if (document) {
                return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context2), variables).then(function(data) {
                  return tslib.__assign(tslib.__assign({}, variables), data.exportedVariables);
                })];
              }
              return [2, tslib.__assign({}, variables)];
            });
          });
        };
        LocalState2.prototype.shouldForceResolvers = function(document) {
          var forceResolvers = false;
          graphql.visit(document, {
            Directive: {
              enter: function(node) {
                if (node.name.value === "client" && node.arguments) {
                  forceResolvers = node.arguments.some(function(arg) {
                    return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
                  });
                  if (forceResolvers) {
                    return graphql.BREAK;
                  }
                }
              }
            }
          });
          return forceResolvers;
        };
        LocalState2.prototype.buildRootValueFromCache = function(document, variables) {
          return this.cache.diff({
            query: utilities.buildQueryFromSelectionSet(document),
            variables,
            returnPartialData: true,
            optimistic: false
          }).result;
        };
        LocalState2.prototype.resolveDocument = function(document_1, rootValue_1) {
          return tslib.__awaiter(this, arguments, void 0, function(document, rootValue, context2, variables, fragmentMatcher, onlyRunForcedResolvers) {
            var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache2, client, execContext, isClientFieldDescendant;
            if (context2 === void 0) {
              context2 = {};
            }
            if (variables === void 0) {
              variables = {};
            }
            if (fragmentMatcher === void 0) {
              fragmentMatcher = function() {
                return true;
              };
            }
            if (onlyRunForcedResolvers === void 0) {
              onlyRunForcedResolvers = false;
            }
            return tslib.__generator(this, function(_b) {
              mainDefinition = utilities.getMainDefinition(document);
              fragments = utilities.getFragmentDefinitions(document);
              fragmentMap = utilities.createFragmentMap(fragments);
              selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
              definitionOperation = mainDefinition.operation;
              defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
              _a = this, cache2 = _a.cache, client = _a.client;
              execContext = {
                fragmentMap,
                context: tslib.__assign(tslib.__assign({}, context2), { cache: cache2, client }),
                variables,
                fragmentMatcher,
                defaultOperationType,
                exportedVariables: {},
                selectionsToResolve,
                onlyRunForcedResolvers
              };
              isClientFieldDescendant = false;
              return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result) {
                return {
                  result,
                  exportedVariables: execContext.exportedVariables
                };
              })];
            });
          });
        };
        LocalState2.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var fragmentMap, context2, variables, resultsToMerge, execute;
            var _this = this;
            return tslib.__generator(this, function(_a) {
              fragmentMap = execContext.fragmentMap, context2 = execContext.context, variables = execContext.variables;
              resultsToMerge = [rootValue];
              execute = function(selection) {
                return tslib.__awaiter(_this, void 0, void 0, function() {
                  var fragment, typeCondition;
                  return tslib.__generator(this, function(_a2) {
                    if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                      return [2];
                    }
                    if (!utilities.shouldInclude(selection, variables)) {
                      return [2];
                    }
                    if (utilities.isField(selection)) {
                      return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                        var _a3;
                        if (typeof fieldResult !== "undefined") {
                          resultsToMerge.push((_a3 = {}, _a3[utilities.resultKeyNameFromField(selection)] = fieldResult, _a3));
                        }
                      })];
                    }
                    if (utilities.isInlineFragment(selection)) {
                      fragment = selection;
                    } else {
                      fragment = fragmentMap[selection.name.value];
                      globals.invariant(fragment, 19, selection.name.value);
                    }
                    if (fragment && fragment.typeCondition) {
                      typeCondition = fragment.typeCondition.name.value;
                      if (execContext.fragmentMatcher(rootValue, typeCondition, context2)) {
                        return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                          resultsToMerge.push(fragmentResult);
                        })];
                      }
                    }
                    return [2];
                  });
                });
              };
              return [2, Promise.all(selectionSet.selections.map(execute)).then(function() {
                return utilities.mergeDeepArray(resultsToMerge);
              })];
            });
          });
        };
        LocalState2.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
            var _this = this;
            return tslib.__generator(this, function(_a) {
              if (!rootValue) {
                return [2, null];
              }
              variables = execContext.variables;
              fieldName = field.name.value;
              aliasedFieldName = utilities.resultKeyNameFromField(field);
              aliasUsed = fieldName !== aliasedFieldName;
              defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
              resultPromise = Promise.resolve(defaultResult);
              if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
                resolverType = rootValue.__typename || execContext.defaultOperationType;
                resolverMap = this.resolvers && this.resolvers[resolverType];
                if (resolverMap) {
                  resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                  if (resolve) {
                    resultPromise = Promise.resolve(
                      cache.cacheSlot.withValue(this.cache, resolve, [
                        rootValue,
                        utilities.argumentsObjectFromField(field, variables),
                        execContext.context,
                        { field, fragmentMap: execContext.fragmentMap }
                      ])
                    );
                  }
                }
              }
              return [2, resultPromise.then(function(result) {
                var _a2, _b;
                if (result === void 0) {
                  result = defaultResult;
                }
                if (field.directives) {
                  field.directives.forEach(function(directive) {
                    if (directive.name.value === "export" && directive.arguments) {
                      directive.arguments.forEach(function(arg) {
                        if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                          execContext.exportedVariables[arg.value.value] = result;
                        }
                      });
                    }
                  });
                }
                if (!field.selectionSet) {
                  return result;
                }
                if (result == null) {
                  return result;
                }
                var isClientField = (_b = (_a2 = field.directives) === null || _a2 === void 0 ? void 0 : _a2.some(function(d) {
                  return d.name.value === "client";
                })) !== null && _b !== void 0 ? _b : false;
                if (Array.isArray(result)) {
                  return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);
                }
                if (field.selectionSet) {
                  return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);
                }
              })];
            });
          });
        };
        LocalState2.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result, execContext) {
          var _this = this;
          return Promise.all(result.map(function(item) {
            if (item === null) {
              return null;
            }
            if (Array.isArray(item)) {
              return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
            }
            if (field.selectionSet) {
              return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
            }
          }));
        };
        LocalState2.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
          var isSingleASTNode = function(node) {
            return !Array.isArray(node);
          };
          var selectionsToResolveCache = this.selectionsToResolveCache;
          function collectByDefinition(definitionNode) {
            if (!selectionsToResolveCache.has(definitionNode)) {
              var matches_1 = /* @__PURE__ */ new Set();
              selectionsToResolveCache.set(definitionNode, matches_1);
              graphql.visit(definitionNode, {
                Directive: function(node, _, __, ___, ancestors) {
                  if (node.name.value === "client") {
                    ancestors.forEach(function(node2) {
                      if (isSingleASTNode(node2) && graphql.isSelectionNode(node2)) {
                        matches_1.add(node2);
                      }
                    });
                  }
                },
                FragmentSpread: function(spread, _, __, ___, ancestors) {
                  var fragment = fragmentMap[spread.name.value];
                  globals.invariant(fragment, 20, spread.name.value);
                  var fragmentSelections = collectByDefinition(fragment);
                  if (fragmentSelections.size > 0) {
                    ancestors.forEach(function(node) {
                      if (isSingleASTNode(node) && graphql.isSelectionNode(node)) {
                        matches_1.add(node);
                      }
                    });
                    matches_1.add(spread);
                    fragmentSelections.forEach(function(selection) {
                      matches_1.add(selection);
                    });
                  }
                }
              });
            }
            return selectionsToResolveCache.get(definitionNode);
          }
          return collectByDefinition(mainDefinition);
        };
        return LocalState2;
      }();
      var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
      var cacheSizes = tslib.__assign({}, globals.global[cacheSizeSymbol]);
      var globalCaches = {};
      var getApolloClientMemoryInternals = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals : void 0;
      function getCurrentCacheSizes() {
        var defaults = {
          parser: 1e3,
          canonicalStringify: 1e3,
          print: 2e3,
          "documentTransform.cache": 2e3,
          "queryManager.getDocumentInfo": 2e3,
          "PersistedQueryLink.persistedQueryHashes": 2e3,
          "fragmentRegistry.transform": 2e3,
          "fragmentRegistry.lookup": 1e3,
          "fragmentRegistry.findFragmentSpreads": 4e3,
          "cache.fragmentQueryDocuments": 1e3,
          "removeTypenameFromVariables.getVariableDefinitions": 2e3,
          "inMemoryCache.maybeBroadcastWatch": 5e3,
          "inMemoryCache.executeSelectionSet": 5e4,
          "inMemoryCache.executeSubSelectedArray": 1e4
        };
        return Object.fromEntries(Object.entries(defaults).map(function(_a) {
          var k2 = _a[0], v = _a[1];
          return [
            k2,
            cacheSizes[k2] || v
          ];
        }));
      }
      function _getApolloClientMemoryInternals() {
        var _a, _b, _c, _d, _e;
        if (!(globalThis.__DEV__ !== false))
          throw new Error("only supported in development mode");
        return {
          limits: getCurrentCacheSizes(),
          sizes: tslib.__assign({ print: (_a = globalCaches.print) === null || _a === void 0 ? void 0 : _a.call(globalCaches), parser: (_b = globalCaches.parser) === null || _b === void 0 ? void 0 : _b.call(globalCaches), canonicalStringify: (_c = globalCaches.canonicalStringify) === null || _c === void 0 ? void 0 : _c.call(globalCaches), links: linkInfo(this.link), queryManager: {
            getDocumentInfo: this["queryManager"]["transformCache"].size,
            documentTransforms: transformInfo(this["queryManager"].documentTransform)
          } }, (_e = (_d = this.cache).getMemoryInternals) === null || _e === void 0 ? void 0 : _e.call(_d))
        };
      }
      function isWrapper(f) {
        return !!f && "dirtyKey" in f;
      }
      function getWrapperInformation(f) {
        return isWrapper(f) ? f.size : void 0;
      }
      function isDefined2(value) {
        return value != null;
      }
      function transformInfo(transform) {
        return recurseTransformInfo(transform).map(function(cache2) {
          return { cache: cache2 };
        });
      }
      function recurseTransformInfo(transform) {
        return transform ? tslib.__spreadArray(tslib.__spreadArray([
          getWrapperInformation(transform === null || transform === void 0 ? void 0 : transform["performWork"])
        ], recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined2) : [];
      }
      function linkInfo(link) {
        var _a;
        return link ? tslib.__spreadArray(tslib.__spreadArray([
          (_a = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a === void 0 ? void 0 : _a.call(link)
        ], linkInfo(link === null || link === void 0 ? void 0 : link.left), true), linkInfo(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined2) : [];
      }
      var hasSuggestedDevtools = false;
      var ApolloClient = function() {
        function ApolloClient2(options) {
          var _this = this;
          var _a;
          this.resetStoreCallbacks = [];
          this.clearStoreCallbacks = [];
          if (!options.cache) {
            throw globals.newInvariantError(16);
          }
          var uri = options.uri, credentials = options.credentials, headers = options.headers, cache2 = options.cache, documentTransform = options.documentTransform, _b = options.ssrMode, ssrMode = _b === void 0 ? false : _b, _c = options.ssrForceFetchDelay, ssrForceFetchDelay = _c === void 0 ? 0 : _c, connectToDevTools = options.connectToDevTools, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options.defaultOptions, defaultContext = options.defaultContext, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? cache2.assumeImmutableResults : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version, devtools = options.devtools, dataMasking = options.dataMasking;
          var link = options.link;
          if (!link) {
            link = uri ? new http.HttpLink({ uri, credentials, headers }) : core2.ApolloLink.empty();
          }
          this.link = link;
          this.cache = cache2;
          this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
          this.queryDeduplication = queryDeduplication;
          this.defaultOptions = defaultOptions || /* @__PURE__ */ Object.create(null);
          this.typeDefs = typeDefs;
          this.devtoolsConfig = tslib.__assign(tslib.__assign({}, devtools), { enabled: (_a = devtools === null || devtools === void 0 ? void 0 : devtools.enabled) !== null && _a !== void 0 ? _a : connectToDevTools });
          if (this.devtoolsConfig.enabled === void 0) {
            this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
          }
          if (ssrForceFetchDelay) {
            setTimeout(function() {
              return _this.disableNetworkFetches = false;
            }, ssrForceFetchDelay);
          }
          this.watchQuery = this.watchQuery.bind(this);
          this.query = this.query.bind(this);
          this.mutate = this.mutate.bind(this);
          this.watchFragment = this.watchFragment.bind(this);
          this.resetStore = this.resetStore.bind(this);
          this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
          this.version = version;
          this.localState = new LocalState({
            cache: cache2,
            client: this,
            resolvers,
            fragmentMatcher
          });
          this.queryManager = new QueryManager({
            cache: this.cache,
            link: this.link,
            defaultOptions: this.defaultOptions,
            defaultContext,
            documentTransform,
            queryDeduplication,
            ssrMode,
            dataMasking: !!dataMasking,
            clientAwareness: {
              name: clientAwarenessName,
              version: clientAwarenessVersion
            },
            localState: this.localState,
            assumeImmutableResults,
            onBroadcast: this.devtoolsConfig.enabled ? function() {
              if (_this.devToolsHookCb) {
                _this.devToolsHookCb({
                  action: {},
                  state: {
                    queries: _this.queryManager.getQueryStore(),
                    mutations: _this.queryManager.mutationStore || {}
                  },
                  dataWithOptimisticResults: _this.cache.extract(true)
                });
              }
            } : void 0
          });
          if (this.devtoolsConfig.enabled)
            this.connectToDevTools();
        }
        ApolloClient2.prototype.connectToDevTools = function() {
          if (typeof window === "undefined") {
            return;
          }
          var windowWithDevTools = window;
          var devtoolsSymbol = Symbol.for("apollo.devtools");
          (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
          windowWithDevTools.__APOLLO_CLIENT__ = this;
          if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {
            hasSuggestedDevtools = true;
            if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
              setTimeout(function() {
                if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
                  var nav = window.navigator;
                  var ua = nav && nav.userAgent;
                  var url = void 0;
                  if (typeof ua === "string") {
                    if (ua.indexOf("Chrome/") > -1) {
                      url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                    } else if (ua.indexOf("Firefox/") > -1) {
                      url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                    }
                  }
                  if (url) {
                    globalThis.__DEV__ !== false && globals.invariant.log("Download the Apollo DevTools for a better development experience: %s", url);
                  }
                }
              }, 1e4);
            }
          }
        };
        Object.defineProperty(ApolloClient2.prototype, "documentTransform", {
          get: function() {
            return this.queryManager.documentTransform;
          },
          enumerable: false,
          configurable: true
        });
        ApolloClient2.prototype.stop = function() {
          this.queryManager.stop();
        };
        ApolloClient2.prototype.watchQuery = function(options) {
          if (this.defaultOptions.watchQuery) {
            options = utilities.mergeOptions(this.defaultOptions.watchQuery, options);
          }
          if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
            options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "cache-first" });
          }
          return this.queryManager.watchQuery(options);
        };
        ApolloClient2.prototype.query = function(options) {
          if (this.defaultOptions.query) {
            options = utilities.mergeOptions(this.defaultOptions.query, options);
          }
          globals.invariant(options.fetchPolicy !== "cache-and-network", 17);
          if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
            options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "cache-first" });
          }
          return this.queryManager.query(options);
        };
        ApolloClient2.prototype.mutate = function(options) {
          if (this.defaultOptions.mutate) {
            options = utilities.mergeOptions(this.defaultOptions.mutate, options);
          }
          return this.queryManager.mutate(options);
        };
        ApolloClient2.prototype.subscribe = function(options) {
          var _this = this;
          var id = this.queryManager.generateQueryId();
          return this.queryManager.startGraphQLSubscription(options).map(function(result) {
            return tslib.__assign(tslib.__assign({}, result), { data: _this.queryManager.maskOperation({
              document: options.query,
              data: result.data,
              fetchPolicy: options.fetchPolicy,
              id
            }) });
          });
        };
        ApolloClient2.prototype.readQuery = function(options, optimistic) {
          if (optimistic === void 0) {
            optimistic = false;
          }
          return this.cache.readQuery(options, optimistic);
        };
        ApolloClient2.prototype.watchFragment = function(options) {
          var _a;
          return this.cache.watchFragment(tslib.__assign(tslib.__assign({}, options), (_a = {}, _a[Symbol.for("apollo.dataMasking")] = this.queryManager.dataMasking, _a)));
        };
        ApolloClient2.prototype.readFragment = function(options, optimistic) {
          if (optimistic === void 0) {
            optimistic = false;
          }
          return this.cache.readFragment(options, optimistic);
        };
        ApolloClient2.prototype.writeQuery = function(options) {
          var ref = this.cache.writeQuery(options);
          if (options.broadcast !== false) {
            this.queryManager.broadcastQueries();
          }
          return ref;
        };
        ApolloClient2.prototype.writeFragment = function(options) {
          var ref = this.cache.writeFragment(options);
          if (options.broadcast !== false) {
            this.queryManager.broadcastQueries();
          }
          return ref;
        };
        ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
          this.devToolsHookCb = cb;
        };
        ApolloClient2.prototype.__requestRaw = function(payload) {
          return core2.execute(this.link, payload);
        };
        ApolloClient2.prototype.resetStore = function() {
          var _this = this;
          return Promise.resolve().then(function() {
            return _this.queryManager.clearStore({
              discardWatches: false
            });
          }).then(function() {
            return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
              return fn();
            }));
          }).then(function() {
            return _this.reFetchObservableQueries();
          });
        };
        ApolloClient2.prototype.clearStore = function() {
          var _this = this;
          return Promise.resolve().then(function() {
            return _this.queryManager.clearStore({
              discardWatches: true
            });
          }).then(function() {
            return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
              return fn();
            }));
          });
        };
        ApolloClient2.prototype.onResetStore = function(cb) {
          var _this = this;
          this.resetStoreCallbacks.push(cb);
          return function() {
            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
              return c !== cb;
            });
          };
        };
        ApolloClient2.prototype.onClearStore = function(cb) {
          var _this = this;
          this.clearStoreCallbacks.push(cb);
          return function() {
            _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
              return c !== cb;
            });
          };
        };
        ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
          return this.queryManager.reFetchObservableQueries(includeStandby);
        };
        ApolloClient2.prototype.refetchQueries = function(options) {
          var map = this.queryManager.refetchQueries(options);
          var queries = [];
          var results = [];
          map.forEach(function(result2, obsQuery) {
            queries.push(obsQuery);
            results.push(result2);
          });
          var result = Promise.all(results);
          result.queries = queries;
          result.results = results;
          result.catch(function(error) {
            globalThis.__DEV__ !== false && globals.invariant.debug(18, error);
          });
          return result;
        };
        ApolloClient2.prototype.getObservableQueries = function(include) {
          if (include === void 0) {
            include = "active";
          }
          return this.queryManager.getObservableQueries(include);
        };
        ApolloClient2.prototype.extract = function(optimistic) {
          return this.cache.extract(optimistic);
        };
        ApolloClient2.prototype.restore = function(serializedState) {
          return this.cache.restore(serializedState);
        };
        ApolloClient2.prototype.addResolvers = function(resolvers) {
          this.localState.addResolvers(resolvers);
        };
        ApolloClient2.prototype.setResolvers = function(resolvers) {
          this.localState.setResolvers(resolvers);
        };
        ApolloClient2.prototype.getResolvers = function() {
          return this.localState.getResolvers();
        };
        ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
          this.localState.setFragmentMatcher(fragmentMatcher);
        };
        ApolloClient2.prototype.setLink = function(newLink) {
          this.link = this.queryManager.link = newLink;
        };
        Object.defineProperty(ApolloClient2.prototype, "defaultContext", {
          get: function() {
            return this.queryManager.defaultContext;
          },
          enumerable: false,
          configurable: true
        });
        return ApolloClient2;
      }();
      if (globalThis.__DEV__ !== false) {
        ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;
      }
      tsInvariant.setVerbosity(globalThis.__DEV__ !== false ? "log" : "silent");
      exports.DocumentTransform = utilities.DocumentTransform;
      exports.Observable = utilities.Observable;
      exports.isReference = utilities.isReference;
      exports.makeReference = utilities.makeReference;
      exports.mergeOptions = utilities.mergeOptions;
      exports.ApolloCache = cache.ApolloCache;
      exports.Cache = cache.Cache;
      exports.InMemoryCache = cache.InMemoryCache;
      exports.MissingFieldError = cache.MissingFieldError;
      exports.defaultDataIdFromObject = cache.defaultDataIdFromObject;
      exports.makeVar = cache.makeVar;
      exports.ApolloError = errors.ApolloError;
      exports.isApolloError = errors.isApolloError;
      exports.fromError = utils.fromError;
      exports.fromPromise = utils.fromPromise;
      exports.throwServerError = utils.throwServerError;
      exports.toPromise = utils.toPromise;
      exports.setLogVerbosity = tsInvariant.setVerbosity;
      exports.disableExperimentalFragmentVariables = graphqlTag.disableExperimentalFragmentVariables;
      exports.disableFragmentWarnings = graphqlTag.disableFragmentWarnings;
      exports.enableExperimentalFragmentVariables = graphqlTag.enableExperimentalFragmentVariables;
      exports.gql = graphqlTag.gql;
      exports.resetCaches = graphqlTag.resetCaches;
      exports.ApolloClient = ApolloClient;
      exports.ObservableQuery = ObservableQuery;
      exports.isNetworkRequestSettled = isNetworkRequestSettled;
      for (k in core2) {
        if (k !== "default" && !exports.hasOwnProperty(k)) exports[k] = core2[k];
      }
      var k;
      for (k in http) {
        if (k !== "default" && !exports.hasOwnProperty(k)) exports[k] = http[k];
      }
      var k;
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component(props, context2, updater) {
          this.props = props;
          this.context = context2;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context2, updater) {
          this.props = props;
          this.context = context2;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function isValidElementType(type) {
          return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId) ? true : false;
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign({}, props, { value: prevLog }),
              info: assign({}, props, { value: prevInfo }),
              warn: assign({}, props, { value: prevWarn }),
              error: assign({}, props, { value: prevError }),
              group: assign({}, props, { value: prevGroup }),
              groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
              suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher = null;
          previousDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        var control = x;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeUnknownElementTypeFrameInDEV(type) {
          if (null == type) return "";
          if ("function" === typeof type) {
            var prototype = type.prototype;
            return describeNativeComponentFrame(
              type,
              !(!prototype || !prototype.isReactComponent)
            );
          }
          if ("string" === typeof type) return describeBuiltInComponentFrame(type);
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if ("object" === typeof type)
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return type = describeNativeComponentFrame(type.render, false), type;
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type);
              case REACT_LAZY_TYPE:
                prototype = type._payload;
                type = type._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(type(prototype));
                } catch (x) {
                }
            }
          return "";
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, self2, source, owner2, props) {
          self2 = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner2
          };
          null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            void 0,
            void 0,
            oldElement._owner,
            oldElement.props
          );
          newKey._store.validated = oldElement._store.validated;
          return newKey;
        }
        function validateChildKeys(node, parentType) {
          if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
            if (isArrayImpl(node))
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                isValidElement(child) && validateExplicitKey(child, parentType);
              }
            else if (isValidElement(node))
              node._store && (node._store.validated = 1);
            else if (i = getIteratorFn(node), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node))
              for (; !(node = i.next()).done; )
                isValidElement(node.value) && validateExplicitKey(node.value, parentType);
          }
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function validateExplicitKey(element, parentType) {
          if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
            ownerHasKeyUseWarning[parentType] = true;
            var childOwner = "";
            element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
            var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = function() {
              var stack = describeUnknownElementTypeFrameInDEV(element.type);
              prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
              return stack;
            };
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              parentType,
              childOwner
            );
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
          }
        }
        function getCurrentComponentErrorInfo(parentType) {
          var info = "", owner2 = getOwner();
          owner2 && (owner2 = getComponentNameFromType(owner2.type)) && (info = "\n\nCheck the render method of `" + owner2 + "`.");
          info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
          return info;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
          });
        }
        function getElementKey(element, index) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
        }
        function noop$1() {
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if ("undefined" === type || "boolean" === type) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
              return c;
            })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i = 0; i < children.length; i++)
              nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if (i = getIteratorFn(children), "function" === typeof i)
            for (i === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if ("object" === type) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context2) {
          if (null == children) return children;
          var result = [], count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context2, child, count++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ctor = payload._result;
            ctor = ctor();
            ctor.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status)
                  payload._status = 1, payload._result = moduleObject;
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status)
                  payload._status = 2, payload._result = error;
              }
            );
            -1 === payload._status && (payload._status = 0, payload._result = ctor);
          }
          if (1 === payload._status)
            return ctor = payload._result, void 0 === ctor && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ctor
            ), "default" in ctor || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ctor
            ), ctor.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function noop() {
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module && module[requireString]).call(
                module,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (; i < queue.length; i++) {
                var callback = queue[i];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i] = callback;
                      queue.splice(0, i);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        Symbol.for("react.provider");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        }, fnName;
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign(deprecatedAPIs, Component.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          actQueue: null,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null
        }, hasOwnProperty = Object.prototype.hasOwnProperty, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var ownerHasKeyUseWarning = {}, didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        exports.Children = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject
                          );
                        });
                      } catch (error$2) {
                        ReactSharedInternals.thrownErrors.push(error$2);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports.cloneElement = function(element, config, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign({}, element.props), key = element.key, owner2 = element._owner;
          if (null != config) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner2 = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for (propName in config)
              !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i = 0; i < propName; i++)
              JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(element.type, key, void 0, void 0, owner2, props);
          for (key = 2; key < arguments.length; key++)
            validateChildKeys(arguments[key], props.type);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type, config, children) {
          if (isValidElementType(type))
            for (var i = 2; i < arguments.length; i++)
              validateChildKeys(arguments[i], type);
          else {
            i = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
              i += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            if (null === type) var typeString = "null";
            else
              isArrayImpl(type) ? typeString = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", i = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type;
            console.error(
              "React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
              typeString,
              i
            );
          }
          var propName;
          i = {};
          typeString = null;
          if (null != config)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config) && (checkKeyStringCoercion(config.key), typeString = "" + config.key), config)
              hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
          }
          if (type && type.defaultProps)
            for (propName in childrenLength = type.defaultProps, childrenLength)
              void 0 === i[propName] && (i[propName] = childrenLength[propName]);
          typeString && defineKeyPropWarningGetter(
            i,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          return ReactElement(type, typeString, void 0, void 0, getOwner(), i);
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render) {
          null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render ? "null" : typeof render
          ) : 0 !== render.length && 2 !== render.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render && null != render.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
            }
          });
          return elementType;
        };
        exports.isValidElement = isValidElement;
        exports.lazy = function(ctor) {
          return {
            $$typeof: REACT_LAZY_TYPE,
            _payload: { _status: -1, _result: ctor },
            _init: lazyInitializer
          };
        };
        exports.memo = function(type, compare) {
          isValidElementType(type) || console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type ? "null" : typeof type
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports.useContext = function(Context) {
          var dispatcher = resolveDispatcher();
          Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create, deps) {
          return resolveDispatcher().useEffect(create, deps);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create, deps);
        };
        exports.useInsertionEffect = function(create, deps) {
          return resolveDispatcher().useInsertionEffect(create, deps);
        };
        exports.useLayoutEffect = function(create, deps) {
          return resolveDispatcher().useLayoutEffect(create, deps);
        };
        exports.useMemo = function(create, deps) {
          return resolveDispatcher().useMemo(create, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.0.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/rehackt/index.js
  var require_rehackt = __commonJS({
    "node_modules/rehackt/index.js"(exports, module) {
      "use strict";
      if (0) {
        module.exports = null;
      }
      module.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = void 0;
      module.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0;
      module.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0;
      Object.assign(module.exports, require_react());
    }
  });

  // node_modules/@apollo/client/react/context/context.cjs
  var require_context2 = __commonJS({
    "node_modules/@apollo/client/react/context/context.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var globals = require_globals();
      var React = require_rehackt();
      var utilities = require_utilities2();
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          for (var k in e) {
            n[k] = e[k];
          }
        }
        n["default"] = e;
        return Object.freeze(n);
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React);
      var contextKey = utilities.canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
      function getApolloContext() {
        globals.invariant("createContext" in React__namespace, 54);
        var context2 = React__namespace.createContext[contextKey];
        if (!context2) {
          Object.defineProperty(React__namespace.createContext, contextKey, {
            value: context2 = React__namespace.createContext({}),
            enumerable: false,
            writable: false,
            configurable: true
          });
          context2.displayName = "ApolloContext";
        }
        return context2;
      }
      var resetApolloContext = getApolloContext;
      var ApolloConsumer = function(props) {
        var ApolloContext = getApolloContext();
        return React__namespace.createElement(ApolloContext.Consumer, null, function(context2) {
          globals.invariant(context2 && context2.client, 53);
          return props.children(context2.client);
        });
      };
      var ApolloProvider = function(_a) {
        var client = _a.client, children = _a.children;
        var ApolloContext = getApolloContext();
        var parentContext = React__namespace.useContext(ApolloContext);
        var context2 = React__namespace.useMemo(function() {
          return tslib.__assign(tslib.__assign({}, parentContext), { client: client || parentContext.client });
        }, [parentContext, client]);
        globals.invariant(context2.client, 55);
        return React__namespace.createElement(ApolloContext.Provider, { value: context2 }, children);
      };
      exports.ApolloConsumer = ApolloConsumer;
      exports.ApolloProvider = ApolloProvider;
      exports.getApolloContext = getApolloContext;
      exports.resetApolloContext = resetApolloContext;
    }
  });

  // node_modules/@apollo/client/react/parser/parser.cjs
  var require_parser2 = __commonJS({
    "node_modules/@apollo/client/react/parser/parser.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var globals = require_globals();
      var utilities = require_utilities2();
      init_tslib_es6();
      var globalCaches = {};
      function registerGlobalCache(name, getSize) {
        globalCaches[name] = getSize;
      }
      exports.DocumentType = void 0;
      (function(DocumentType) {
        DocumentType[DocumentType["Query"] = 0] = "Query";
        DocumentType[DocumentType["Mutation"] = 1] = "Mutation";
        DocumentType[DocumentType["Subscription"] = 2] = "Subscription";
      })(exports.DocumentType || (exports.DocumentType = {}));
      var cache;
      function operationName(type) {
        var name;
        switch (type) {
          case exports.DocumentType.Query:
            name = "Query";
            break;
          case exports.DocumentType.Mutation:
            name = "Mutation";
            break;
          case exports.DocumentType.Subscription:
            name = "Subscription";
            break;
        }
        return name;
      }
      function parser(document) {
        if (!cache) {
          cache = new utilities.AutoCleanedWeakCache(utilities.cacheSizes.parser || 1e3);
        }
        var cached = cache.get(document);
        if (cached)
          return cached;
        var variables, type, name;
        globals.invariant(!!document && !!document.kind, 70, document);
        var fragments = [];
        var queries = [];
        var mutations = [];
        var subscriptions = [];
        for (var _i = 0, _a = document.definitions; _i < _a.length; _i++) {
          var x = _a[_i];
          if (x.kind === "FragmentDefinition") {
            fragments.push(x);
            continue;
          }
          if (x.kind === "OperationDefinition") {
            switch (x.operation) {
              case "query":
                queries.push(x);
                break;
              case "mutation":
                mutations.push(x);
                break;
              case "subscription":
                subscriptions.push(x);
                break;
            }
          }
        }
        globals.invariant(!fragments.length || queries.length || mutations.length || subscriptions.length, 71);
        globals.invariant(
          queries.length + mutations.length + subscriptions.length <= 1,
          72,
          document,
          queries.length,
          subscriptions.length,
          mutations.length
        );
        type = queries.length ? exports.DocumentType.Query : exports.DocumentType.Mutation;
        if (!queries.length && !mutations.length)
          type = exports.DocumentType.Subscription;
        var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
        globals.invariant(definitions.length === 1, 73, document, definitions.length);
        var definition = definitions[0];
        variables = definition.variableDefinitions || [];
        if (definition.name && definition.name.kind === "Name") {
          name = definition.name.value;
        } else {
          name = "data";
        }
        var payload = { name, type, variables };
        cache.set(document, payload);
        return payload;
      }
      parser.resetCache = function() {
        cache = void 0;
      };
      if (globalThis.__DEV__ !== false) {
        registerGlobalCache("parser", function() {
          return cache ? cache.size : 0;
        });
      }
      function verifyDocumentType(document, type) {
        var operation = parser(document);
        var requiredOperationName = operationName(type);
        var usedOperationName = operationName(operation.type);
        globals.invariant(
          operation.type === type,
          74,
          requiredOperationName,
          requiredOperationName,
          usedOperationName
        );
      }
      exports.operationName = operationName;
      exports.parser = parser;
      exports.verifyDocumentType = verifyDocumentType;
    }
  });

  // node_modules/@apollo/client/react/internal/internal.cjs
  var require_internal = __commonJS({
    "node_modules/@apollo/client/react/internal/internal.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var trie = require_bundle();
      var utilities = require_utilities2();
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var equality = require_bundle5();
      var tsInvariant = require_invariant();
      var version = "3.12.7";
      function maybe(thunk) {
        try {
          return thunk();
        } catch (_a) {
        }
      }
      var global$1 = maybe(function() {
        return globalThis;
      }) || maybe(function() {
        return window;
      }) || maybe(function() {
        return self;
      }) || maybe(function() {
        return global;
      }) || maybe(function() {
        return maybe.constructor("return this")();
      });
      var prefixCounts = /* @__PURE__ */ new Map();
      function makeUniqueId(prefix) {
        var count = prefixCounts.get(prefix) || 1;
        prefixCounts.set(prefix, count + 1);
        return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
      }
      function stringifyForDisplay(value, space) {
        if (space === void 0) {
          space = 0;
        }
        var undefId = makeUniqueId("stringifyForDisplay");
        return JSON.stringify(value, function(key, value2) {
          return value2 === void 0 ? undefId : value2;
        }, space).split(JSON.stringify(undefId)).join("<undefined>");
      }
      function wrap(fn) {
        return function(message) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          if (typeof message === "number") {
            var arg0 = message;
            message = getHandledErrorMsg(arg0);
            if (!message) {
              message = getFallbackErrorMsg(arg0, args);
              args = [];
            }
          }
          fn.apply(void 0, [message].concat(args));
        };
      }
      var invariant = Object.assign(function invariant2(condition, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        if (!condition) {
          tsInvariant.invariant(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));
        }
      }, {
        debug: wrap(tsInvariant.invariant.debug),
        log: wrap(tsInvariant.invariant.log),
        warn: wrap(tsInvariant.invariant.warn),
        error: wrap(tsInvariant.invariant.error)
      });
      var ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version);
      function stringify(arg) {
        if (typeof arg == "string") {
          return arg;
        }
        try {
          return stringifyForDisplay(arg, 2).slice(0, 1e3);
        } catch (_a) {
          return "<non-serializable>";
        }
      }
      function getHandledErrorMsg(message, messageArgs) {
        if (messageArgs === void 0) {
          messageArgs = [];
        }
        if (!message)
          return;
        return global$1[ApolloErrorMessageHandler] && global$1[ApolloErrorMessageHandler](message, messageArgs.map(stringify));
      }
      function getFallbackErrorMsg(message, messageArgs) {
        if (messageArgs === void 0) {
          messageArgs = [];
        }
        if (!message)
          return;
        return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
          version,
          message,
          args: messageArgs.map(stringify)
        })));
      }
      var QUERY_REFERENCE_SYMBOL = Symbol();
      var PROMISE_SYMBOL = Symbol();
      function wrapQueryRef(internalQueryRef) {
        var _a;
        var ref = (_a = {
          toPromise: function() {
            return getWrappedPromise(ref).then(function() {
              return ref;
            });
          }
        }, _a[QUERY_REFERENCE_SYMBOL] = internalQueryRef, _a[PROMISE_SYMBOL] = internalQueryRef.promise, _a);
        return ref;
      }
      function assertWrappedQueryRef(queryRef) {
        invariant(!queryRef || QUERY_REFERENCE_SYMBOL in queryRef, 69);
      }
      function getWrappedPromise(queryRef) {
        var internalQueryRef = unwrapQueryRef(queryRef);
        return internalQueryRef.promise.status === "fulfilled" ? internalQueryRef.promise : queryRef[PROMISE_SYMBOL];
      }
      function unwrapQueryRef(queryRef) {
        return queryRef[QUERY_REFERENCE_SYMBOL];
      }
      function updateWrappedQueryRef(queryRef, promise) {
        queryRef[PROMISE_SYMBOL] = promise;
      }
      var OBSERVED_CHANGED_OPTIONS = [
        "canonizeResults",
        "context",
        "errorPolicy",
        "fetchPolicy",
        "refetchWritePolicy",
        "returnPartialData"
      ];
      var InternalQueryReference = function() {
        function InternalQueryReference2(observable, options) {
          var _this = this;
          this.key = {};
          this.listeners = /* @__PURE__ */ new Set();
          this.references = 0;
          this.softReferences = 0;
          this.handleNext = this.handleNext.bind(this);
          this.handleError = this.handleError.bind(this);
          this.dispose = this.dispose.bind(this);
          this.observable = observable;
          if (options.onDispose) {
            this.onDispose = options.onDispose;
          }
          this.setResult();
          this.subscribeToQuery();
          var startDisposeTimer = function() {
            var _a;
            if (!_this.references) {
              _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 3e4);
            }
          };
          this.promise.then(startDisposeTimer, startDisposeTimer);
        }
        Object.defineProperty(InternalQueryReference2.prototype, "disposed", {
          get: function() {
            return this.subscription.closed;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(InternalQueryReference2.prototype, "watchQueryOptions", {
          get: function() {
            return this.observable.options;
          },
          enumerable: false,
          configurable: true
        });
        InternalQueryReference2.prototype.reinitialize = function() {
          var observable = this.observable;
          var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;
          var avoidNetworkRequests = originalFetchPolicy === "no-cache" || originalFetchPolicy === "standby";
          try {
            if (avoidNetworkRequests) {
              observable.silentSetOptions({ fetchPolicy: "standby" });
            } else {
              observable.resetLastResults();
              observable.silentSetOptions({ fetchPolicy: "cache-first" });
            }
            this.subscribeToQuery();
            if (avoidNetworkRequests) {
              return;
            }
            observable.resetDiff();
            this.setResult();
          } finally {
            observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });
          }
        };
        InternalQueryReference2.prototype.retain = function() {
          var _this = this;
          this.references++;
          clearTimeout(this.autoDisposeTimeoutId);
          var disposed = false;
          return function() {
            if (disposed) {
              return;
            }
            disposed = true;
            _this.references--;
            setTimeout(function() {
              if (!_this.references) {
                _this.dispose();
              }
            });
          };
        };
        InternalQueryReference2.prototype.softRetain = function() {
          var _this = this;
          this.softReferences++;
          var disposed = false;
          return function() {
            if (disposed) {
              return;
            }
            disposed = true;
            _this.softReferences--;
            setTimeout(function() {
              if (!_this.softReferences && !_this.references) {
                _this.dispose();
              }
            });
          };
        };
        InternalQueryReference2.prototype.didChangeOptions = function(watchQueryOptions) {
          var _this = this;
          return OBSERVED_CHANGED_OPTIONS.some(function(option) {
            return option in watchQueryOptions && !equality.equal(_this.watchQueryOptions[option], watchQueryOptions[option]);
          });
        };
        InternalQueryReference2.prototype.applyOptions = function(watchQueryOptions) {
          var _a = this.watchQueryOptions, currentFetchPolicy = _a.fetchPolicy, currentCanonizeResults = _a.canonizeResults;
          if (currentFetchPolicy === "standby" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {
            this.initiateFetch(this.observable.reobserve(watchQueryOptions));
          } else {
            this.observable.silentSetOptions(watchQueryOptions);
            if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {
              this.result = tslib.__assign(tslib.__assign({}, this.result), this.observable.getCurrentResult());
              this.promise = utilities.createFulfilledPromise(this.result);
            }
          }
          return this.promise;
        };
        InternalQueryReference2.prototype.listen = function(listener) {
          var _this = this;
          this.listeners.add(listener);
          return function() {
            _this.listeners.delete(listener);
          };
        };
        InternalQueryReference2.prototype.refetch = function(variables) {
          return this.initiateFetch(this.observable.refetch(variables));
        };
        InternalQueryReference2.prototype.fetchMore = function(options) {
          return this.initiateFetch(this.observable.fetchMore(options));
        };
        InternalQueryReference2.prototype.dispose = function() {
          this.subscription.unsubscribe();
          this.onDispose();
        };
        InternalQueryReference2.prototype.onDispose = function() {
        };
        InternalQueryReference2.prototype.handleNext = function(result) {
          var _a;
          switch (this.promise.status) {
            case "pending": {
              if (result.data === void 0) {
                result.data = this.result.data;
              }
              this.result = result;
              (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result);
              break;
            }
            default: {
              if (result.data === this.result.data && result.networkStatus === this.result.networkStatus) {
                return;
              }
              if (result.data === void 0) {
                result.data = this.result.data;
              }
              this.result = result;
              this.promise = utilities.createFulfilledPromise(result);
              this.deliver(this.promise);
              break;
            }
          }
        };
        InternalQueryReference2.prototype.handleError = function(error) {
          var _a;
          this.subscription.unsubscribe();
          this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);
          switch (this.promise.status) {
            case "pending": {
              (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);
              break;
            }
            default: {
              this.promise = utilities.createRejectedPromise(error);
              this.deliver(this.promise);
            }
          }
        };
        InternalQueryReference2.prototype.deliver = function(promise) {
          this.listeners.forEach(function(listener) {
            return listener(promise);
          });
        };
        InternalQueryReference2.prototype.initiateFetch = function(returnedPromise) {
          var _this = this;
          this.promise = this.createPendingPromise();
          this.promise.catch(function() {
          });
          returnedPromise.then(function() {
            setTimeout(function() {
              var _a;
              if (_this.promise.status === "pending") {
                _this.result = _this.observable.getCurrentResult();
                (_a = _this.resolve) === null || _a === void 0 ? void 0 : _a.call(_this, _this.result);
              }
            });
          }).catch(function(error) {
            var _a;
            return (_a = _this.reject) === null || _a === void 0 ? void 0 : _a.call(_this, error);
          });
          return returnedPromise;
        };
        InternalQueryReference2.prototype.subscribeToQuery = function() {
          var _this = this;
          this.subscription = this.observable.filter(function(result) {
            return !equality.equal(result.data, {}) && !equality.equal(result, _this.result);
          }).subscribe(this.handleNext, this.handleError);
        };
        InternalQueryReference2.prototype.setResult = function() {
          var result = this.observable.getCurrentResult(false);
          if (equality.equal(result, this.result)) {
            return;
          }
          this.result = result;
          this.promise = result.data && (!result.partial || this.watchQueryOptions.returnPartialData) ? utilities.createFulfilledPromise(result) : this.createPendingPromise();
        };
        InternalQueryReference2.prototype.createPendingPromise = function() {
          var _this = this;
          return utilities.wrapPromiseWithState(new Promise(function(resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
          }));
        };
        return InternalQueryReference2;
      }();
      var SuspenseCache = function() {
        function SuspenseCache2(options) {
          if (options === void 0) {
            options = /* @__PURE__ */ Object.create(null);
          }
          this.queryRefs = new trie.Trie(utilities.canUseWeakMap);
          this.options = options;
        }
        SuspenseCache2.prototype.getQueryRef = function(cacheKey, createObservable) {
          var ref = this.queryRefs.lookupArray(cacheKey);
          if (!ref.current) {
            ref.current = new InternalQueryReference(createObservable(), {
              autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,
              onDispose: function() {
                delete ref.current;
              }
            });
          }
          return ref.current;
        };
        SuspenseCache2.prototype.add = function(cacheKey, queryRef) {
          var ref = this.queryRefs.lookupArray(cacheKey);
          ref.current = queryRef;
        };
        return SuspenseCache2;
      }();
      var suspenseCacheSymbol = Symbol.for("apollo.suspenseCache");
      function getSuspenseCache(client) {
        var _a;
        if (!client[suspenseCacheSymbol]) {
          client[suspenseCacheSymbol] = new SuspenseCache((_a = client.defaultOptions.react) === null || _a === void 0 ? void 0 : _a.suspense);
        }
        return client[suspenseCacheSymbol];
      }
      exports.InternalQueryReference = InternalQueryReference;
      exports.assertWrappedQueryRef = assertWrappedQueryRef;
      exports.getSuspenseCache = getSuspenseCache;
      exports.getWrappedPromise = getWrappedPromise;
      exports.unwrapQueryRef = unwrapQueryRef;
      exports.updateWrappedQueryRef = updateWrappedQueryRef;
      exports.wrapQueryRef = wrapQueryRef;
    }
  });

  // node_modules/@apollo/client/react/hooks/hooks.cjs
  var require_hooks = __commonJS({
    "node_modules/@apollo/client/react/hooks/hooks.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var globals = require_globals();
      var React = require_rehackt();
      var context2 = require_context2();
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var utilities = require_utilities2();
      var equal = require_bundle5();
      var errors = require_errors2();
      var core2 = require_core3();
      var parser = require_parser2();
      var internal = require_internal();
      var cache = require_cache2();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e["default"] : e;
      }
      function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          for (var k in e) {
            n[k] = e[k];
          }
        }
        n["default"] = e;
        return Object.freeze(n);
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React);
      var equal__default = /* @__PURE__ */ _interopDefaultLegacy(equal);
      function useApolloClient(override) {
        var context$1 = React__namespace.useContext(context2.getApolloContext());
        var client = override || context$1.client;
        globals.invariant(!!client, 58);
        return client;
      }
      var didWarnUncachedGetSnapshot = false;
      var uSESKey = "useSyncExternalStore";
      var realHook$1 = React__namespace[uSESKey];
      var useSyncExternalStore = realHook$1 || function(subscribe, getSnapshot, getServerSnapshot) {
        var value = getSnapshot();
        if (globalThis.__DEV__ !== false && !didWarnUncachedGetSnapshot && value !== getSnapshot()) {
          didWarnUncachedGetSnapshot = true;
          globalThis.__DEV__ !== false && globals.invariant.error(68);
        }
        var _a = React__namespace.useState({
          inst: { value, getSnapshot }
        }), inst = _a[0].inst, forceUpdate = _a[1];
        if (utilities.canUseLayoutEffect) {
          React__namespace.useLayoutEffect(function() {
            Object.assign(inst, { value, getSnapshot });
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({ inst });
            }
          }, [subscribe, value, getSnapshot]);
        } else {
          Object.assign(inst, { value, getSnapshot });
        }
        React__namespace.useEffect(function() {
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({ inst });
          }
          return subscribe(function handleStoreChange() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({ inst });
            }
          });
        }, [subscribe]);
        return value;
      };
      function checkIfSnapshotChanged(_a) {
        var value = _a.value, getSnapshot = _a.getSnapshot;
        try {
          return value !== getSnapshot();
        } catch (_b) {
          return true;
        }
      }
      function useDeepMemo(memoFn, deps) {
        var ref = React__namespace.useRef(void 0);
        if (!ref.current || !equal.equal(ref.current.deps, deps)) {
          ref.current = { value: memoFn(), deps };
        }
        return ref.current.value;
      }
      var useIsomorphicLayoutEffect = utilities.canUseDOM ? React__namespace.useLayoutEffect : React__namespace.useEffect;
      var Ctx;
      function noop$1() {
      }
      function useRenderGuard() {
        if (!Ctx) {
          Ctx = React__namespace.createContext(null);
        }
        return React__namespace.useCallback(
          function() {
            var orig = console.error;
            try {
              console.error = noop$1;
              React__namespace["useContext"](Ctx);
              return true;
            } catch (e) {
              return false;
            } finally {
              console.error = orig;
            }
          },
          []
        );
      }
      var useKey = "use";
      var realHook = React__namespace[useKey];
      var __use = realHook || function __use2(promise) {
        var statefulPromise = utilities.wrapPromiseWithState(promise);
        switch (statefulPromise.status) {
          case "pending":
            throw statefulPromise;
          case "rejected":
            throw statefulPromise.reason;
          case "fulfilled":
            return statefulPromise.value;
        }
      };
      var wrapperSymbol = Symbol.for("apollo.hook.wrappers");
      function wrapHook(hookName, useHook, clientOrObsQuery) {
        var queryManager = clientOrObsQuery["queryManager"];
        var wrappers = queryManager && queryManager[wrapperSymbol];
        var wrapper = wrappers && wrappers[hookName];
        return wrapper ? wrapper(useHook) : useHook;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function noop() {
      }
      var lastWatchOptions = Symbol();
      function useQuery(query, options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        return wrapHook(
          "useQuery",
          useQuery_,
          useApolloClient(options && options.client)
        )(query, options);
      }
      function useQuery_(query, options) {
        var _a = useQueryInternals(query, options), result = _a.result, obsQueryFields = _a.obsQueryFields;
        return React__namespace.useMemo(function() {
          return tslib.__assign(tslib.__assign({}, result), obsQueryFields);
        }, [result, obsQueryFields]);
      }
      function useInternalState(client, query, options, renderPromises, makeWatchQueryOptions) {
        function createInternalState(previous) {
          var _a2;
          parser.verifyDocumentType(query, parser.DocumentType.Query);
          var internalState2 = {
            client,
            query,
            observable: renderPromises && renderPromises.getSSRObservable(makeWatchQueryOptions()) || client.watchQuery(getObsQueryOptions(void 0, client, options, makeWatchQueryOptions())),
            resultData: {
              previousData: (_a2 = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a2 === void 0 ? void 0 : _a2.data
            }
          };
          return internalState2;
        }
        var _a = React__namespace.useState(createInternalState), internalState = _a[0], updateInternalState = _a[1];
        function onQueryExecuted(watchQueryOptions) {
          var _a2;
          var _b;
          Object.assign(internalState.observable, (_a2 = {}, _a2[lastWatchOptions] = watchQueryOptions, _a2));
          var resultData = internalState.resultData;
          updateInternalState(tslib.__assign(tslib.__assign({}, internalState), {
            query: watchQueryOptions.query,
            resultData: Object.assign(resultData, {
              previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,
              current: void 0
            })
          }));
        }
        if (client !== internalState.client || query !== internalState.query) {
          var newInternalState = createInternalState(internalState);
          updateInternalState(newInternalState);
          return [newInternalState, onQueryExecuted];
        }
        return [internalState, onQueryExecuted];
      }
      function useQueryInternals(query, options) {
        var client = useApolloClient(options.client);
        var renderPromises = React__namespace.useContext(context2.getApolloContext()).renderPromises;
        var isSyncSSR = !!renderPromises;
        var disableNetworkFetches = client.disableNetworkFetches;
        var ssrAllowed = options.ssr !== false && !options.skip;
        var partialRefetch = options.partialRefetch;
        var makeWatchQueryOptions = createMakeWatchQueryOptions(client, query, options, isSyncSSR);
        var _a = useInternalState(client, query, options, renderPromises, makeWatchQueryOptions), _b = _a[0], observable = _b.observable, resultData = _b.resultData, onQueryExecuted = _a[1];
        var watchQueryOptions = makeWatchQueryOptions(observable);
        useResubscribeIfNecessary(
          resultData,
          observable,
          client,
          options,
          watchQueryOptions
        );
        var obsQueryFields = React__namespace.useMemo(function() {
          return bindObservableMethods(observable);
        }, [observable]);
        useRegisterSSRObservable(observable, renderPromises, ssrAllowed);
        var result = useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {
          onCompleted: options.onCompleted || noop,
          onError: options.onError || noop
        });
        return {
          result,
          obsQueryFields,
          observable,
          resultData,
          client,
          onQueryExecuted
        };
      }
      function useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {
        var callbackRef = React__namespace.useRef(callbacks);
        React__namespace.useEffect(function() {
          callbackRef.current = callbacks;
        });
        var resultOverride = (isSyncSSR || disableNetworkFetches) && options.ssr === false && !options.skip ? ssrDisabledResult : options.skip || watchQueryOptions.fetchPolicy === "standby" ? skipStandbyResult : void 0;
        var previousData = resultData.previousData;
        var currentResultOverride = React__namespace.useMemo(function() {
          return resultOverride && toQueryResult(resultOverride, previousData, observable, client);
        }, [client, observable, resultOverride, previousData]);
        return useSyncExternalStore(React__namespace.useCallback(function(handleStoreChange) {
          if (isSyncSSR) {
            return function() {
            };
          }
          var onNext = function() {
            var previousResult = resultData.current;
            var result = observable.getCurrentResult();
            if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal.equal(previousResult.data, result.data)) {
              return;
            }
            setResult(result, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
          };
          var onError = function(error) {
            subscription.current.unsubscribe();
            subscription.current = observable.resubscribeAfterError(onNext, onError);
            if (!hasOwnProperty.call(error, "graphQLErrors")) {
              throw error;
            }
            var previousResult = resultData.current;
            if (!previousResult || previousResult && previousResult.loading || !equal.equal(error, previousResult.error)) {
              setResult({
                data: previousResult && previousResult.data,
                error,
                loading: false,
                networkStatus: core2.NetworkStatus.error
              }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
            }
          };
          var subscription = { current: observable.subscribe(onNext, onError) };
          return function() {
            setTimeout(function() {
              return subscription.current.unsubscribe();
            });
          };
        }, [
          disableNetworkFetches,
          isSyncSSR,
          observable,
          resultData,
          partialRefetch,
          client
        ]), function() {
          return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);
        }, function() {
          return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);
        });
      }
      function useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {
        if (renderPromises && ssrAllowed) {
          renderPromises.registerSSRObservable(observable);
          if (observable.getCurrentResult().loading) {
            renderPromises.addObservableQueryPromise(observable);
          }
        }
      }
      function useResubscribeIfNecessary(resultData, observable, client, options, watchQueryOptions) {
        var _a;
        if (observable[lastWatchOptions] && !equal.equal(observable[lastWatchOptions], watchQueryOptions)) {
          observable.reobserve(getObsQueryOptions(observable, client, options, watchQueryOptions));
          resultData.previousData = ((_a = resultData.current) === null || _a === void 0 ? void 0 : _a.data) || resultData.previousData;
          resultData.current = void 0;
        }
        observable[lastWatchOptions] = watchQueryOptions;
      }
      function createMakeWatchQueryOptions(client, query, _a, isSyncSSR) {
        if (_a === void 0) {
          _a = {};
        }
        var skip = _a.skip;
        _a.ssr;
        _a.onCompleted;
        _a.onError;
        var defaultOptions = _a.defaultOptions, otherOptions = tslib.__rest(_a, ["skip", "ssr", "onCompleted", "onError", "defaultOptions"]);
        return function(observable) {
          var watchQueryOptions = Object.assign(otherOptions, { query });
          if (isSyncSSR && (watchQueryOptions.fetchPolicy === "network-only" || watchQueryOptions.fetchPolicy === "cache-and-network")) {
            watchQueryOptions.fetchPolicy = "cache-first";
          }
          if (!watchQueryOptions.variables) {
            watchQueryOptions.variables = {};
          }
          if (skip) {
            watchQueryOptions.initialFetchPolicy = watchQueryOptions.initialFetchPolicy || watchQueryOptions.fetchPolicy || getDefaultFetchPolicy(defaultOptions, client.defaultOptions);
            watchQueryOptions.fetchPolicy = "standby";
          } else if (!watchQueryOptions.fetchPolicy) {
            watchQueryOptions.fetchPolicy = (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) || getDefaultFetchPolicy(defaultOptions, client.defaultOptions);
          }
          return watchQueryOptions;
        };
      }
      function getObsQueryOptions(observable, client, queryHookOptions, watchQueryOptions) {
        var toMerge = [];
        var globalDefaults = client.defaultOptions.watchQuery;
        if (globalDefaults)
          toMerge.push(globalDefaults);
        if (queryHookOptions.defaultOptions) {
          toMerge.push(queryHookOptions.defaultOptions);
        }
        toMerge.push(utilities.compact(observable && observable.options, watchQueryOptions));
        return toMerge.reduce(utilities.mergeOptions);
      }
      function setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {
        var previousResult = resultData.current;
        if (previousResult && previousResult.data) {
          resultData.previousData = previousResult.data;
        }
        if (!nextResult.error && utilities.isNonEmptyArray(nextResult.errors)) {
          nextResult.error = new errors.ApolloError({ graphQLErrors: nextResult.errors });
        }
        resultData.current = toQueryResult(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);
        forceUpdate();
        handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);
      }
      function handleErrorOrCompleted(result, previousNetworkStatus, callbacks) {
        if (!result.loading) {
          var error_1 = toApolloError$1(result);
          Promise.resolve().then(function() {
            if (error_1) {
              callbacks.onError(error_1);
            } else if (result.data && previousNetworkStatus !== result.networkStatus && result.networkStatus === core2.NetworkStatus.ready) {
              callbacks.onCompleted(result.data);
            }
          }).catch(function(error) {
            globalThis.__DEV__ !== false && globals.invariant.warn(error);
          });
        }
      }
      function getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {
        if (!resultData.current) {
          setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function() {
          }, callbacks);
        }
        return resultData.current;
      }
      function getDefaultFetchPolicy(queryHookDefaultOptions, clientDefaultOptions) {
        var _a;
        return (queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) || ((_a = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || "cache-first";
      }
      function toApolloError$1(result) {
        return utilities.isNonEmptyArray(result.errors) ? new errors.ApolloError({ graphQLErrors: result.errors }) : result.error;
      }
      function toQueryResult(result, previousData, observable, client) {
        var data = result.data;
        result.partial;
        var resultWithoutPartial = tslib.__rest(result, ["data", "partial"]);
        var queryResult = tslib.__assign(tslib.__assign({ data }, resultWithoutPartial), { client, observable, variables: observable.variables, called: result !== ssrDisabledResult && result !== skipStandbyResult, previousData });
        return queryResult;
      }
      function unsafeHandlePartialRefetch(result, observable, partialRefetch) {
        if (result.partial && partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && observable.options.fetchPolicy !== "cache-only") {
          observable.refetch();
          return tslib.__assign(tslib.__assign({}, result), { loading: true, networkStatus: core2.NetworkStatus.refetch });
        }
        return result;
      }
      var ssrDisabledResult = utilities.maybeDeepFreeze({
        loading: true,
        data: void 0,
        error: void 0,
        networkStatus: core2.NetworkStatus.loading
      });
      var skipStandbyResult = utilities.maybeDeepFreeze({
        loading: false,
        data: void 0,
        error: void 0,
        networkStatus: core2.NetworkStatus.ready
      });
      function bindObservableMethods(observable) {
        return {
          refetch: observable.refetch.bind(observable),
          reobserve: observable.reobserve.bind(observable),
          fetchMore: observable.fetchMore.bind(observable),
          updateQuery: observable.updateQuery.bind(observable),
          startPolling: observable.startPolling.bind(observable),
          stopPolling: observable.stopPolling.bind(observable),
          subscribeToMore: observable.subscribeToMore.bind(observable)
        };
      }
      var EAGER_METHODS = [
        "refetch",
        "reobserve",
        "fetchMore",
        "updateQuery",
        "startPolling",
        "stopPolling",
        "subscribeToMore"
      ];
      function useLazyQuery(query, options) {
        var _a;
        var execOptionsRef = React__namespace.useRef(void 0);
        var optionsRef = React__namespace.useRef(void 0);
        var queryRef = React__namespace.useRef(void 0);
        var merged = utilities.mergeOptions(options, execOptionsRef.current || {});
        var document = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query;
        optionsRef.current = options;
        queryRef.current = document;
        var queryHookOptions = tslib.__assign(tslib.__assign({}, merged), { skip: !execOptionsRef.current });
        var _b = useQueryInternals(document, queryHookOptions), obsQueryFields = _b.obsQueryFields, useQueryResult = _b.result, client = _b.client, resultData = _b.resultData, observable = _b.observable, onQueryExecuted = _b.onQueryExecuted;
        var initialFetchPolicy = observable.options.initialFetchPolicy || getDefaultFetchPolicy(queryHookOptions.defaultOptions, client.defaultOptions);
        var forceUpdateState = React__namespace.useReducer(function(tick) {
          return tick + 1;
        }, 0)[1];
        var eagerMethods = React__namespace.useMemo(function() {
          var eagerMethods2 = {};
          var _loop_1 = function(key2) {
            var method = obsQueryFields[key2];
            eagerMethods2[key2] = function() {
              if (!execOptionsRef.current) {
                execOptionsRef.current = /* @__PURE__ */ Object.create(null);
                forceUpdateState();
              }
              return method.apply(this, arguments);
            };
          };
          for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {
            var key = EAGER_METHODS_1[_i];
            _loop_1(key);
          }
          return eagerMethods2;
        }, [forceUpdateState, obsQueryFields]);
        var called = !!execOptionsRef.current;
        var result = React__namespace.useMemo(function() {
          return tslib.__assign(tslib.__assign(tslib.__assign({}, useQueryResult), eagerMethods), { called });
        }, [useQueryResult, eagerMethods, called]);
        var execute = React__namespace.useCallback(function(executeOptions) {
          execOptionsRef.current = executeOptions ? tslib.__assign(tslib.__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {
            fetchPolicy: initialFetchPolicy
          };
          var options2 = utilities.mergeOptions(optionsRef.current, tslib.__assign({ query: queryRef.current }, execOptionsRef.current));
          var promise = executeQuery(resultData, observable, client, document, tslib.__assign(tslib.__assign({}, options2), { skip: false }), onQueryExecuted).then(function(queryResult) {
            return Object.assign(queryResult, eagerMethods);
          });
          promise.catch(function() {
          });
          return promise;
        }, [
          client,
          document,
          eagerMethods,
          initialFetchPolicy,
          observable,
          resultData,
          onQueryExecuted
        ]);
        var executeRef = React__namespace.useRef(execute);
        useIsomorphicLayoutEffect(function() {
          executeRef.current = execute;
        });
        var stableExecute = React__namespace.useCallback(function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return executeRef.current.apply(executeRef, args);
        }, []);
        return [stableExecute, result];
      }
      function executeQuery(resultData, observable, client, currentQuery, options, onQueryExecuted) {
        var query = options.query || currentQuery;
        var watchQueryOptions = createMakeWatchQueryOptions(client, query, options, false)(observable);
        var concast = observable.reobserveAsConcast(getObsQueryOptions(observable, client, options, watchQueryOptions));
        onQueryExecuted(watchQueryOptions);
        return new Promise(function(resolve) {
          var result;
          concast.subscribe({
            next: function(value) {
              result = value;
            },
            error: function() {
              resolve(toQueryResult(observable.getCurrentResult(), resultData.previousData, observable, client));
            },
            complete: function() {
              resolve(toQueryResult(observable["maskResult"](result), resultData.previousData, observable, client));
            }
          });
        });
      }
      function useMutation(mutation, options) {
        var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
        parser.verifyDocumentType(mutation, parser.DocumentType.Mutation);
        var _a = React__namespace.useState({
          called: false,
          loading: false,
          client
        }), result = _a[0], setResult2 = _a[1];
        var ref = React__namespace.useRef({
          result,
          mutationId: 0,
          isMounted: true,
          client,
          mutation,
          options
        });
        useIsomorphicLayoutEffect(function() {
          Object.assign(ref.current, { client, options, mutation });
        });
        var execute = React__namespace.useCallback(function(executeOptions) {
          if (executeOptions === void 0) {
            executeOptions = {};
          }
          var _a2 = ref.current, options2 = _a2.options, mutation2 = _a2.mutation;
          var baseOptions = tslib.__assign(tslib.__assign({}, options2), { mutation: mutation2 });
          var client2 = executeOptions.client || ref.current.client;
          if (!ref.current.result.loading && !baseOptions.ignoreResults && ref.current.isMounted) {
            setResult2(ref.current.result = {
              loading: true,
              error: void 0,
              data: void 0,
              called: true,
              client: client2
            });
          }
          var mutationId = ++ref.current.mutationId;
          var clientOptions = utilities.mergeOptions(baseOptions, executeOptions);
          return client2.mutate(clientOptions).then(function(response) {
            var _a3, _b;
            var data = response.data, errors$1 = response.errors;
            var error = errors$1 && errors$1.length > 0 ? new errors.ApolloError({ graphQLErrors: errors$1 }) : void 0;
            var onError = executeOptions.onError || ((_a3 = ref.current.options) === null || _a3 === void 0 ? void 0 : _a3.onError);
            if (error && onError) {
              onError(error, clientOptions);
            }
            if (mutationId === ref.current.mutationId && !clientOptions.ignoreResults) {
              var result_1 = {
                called: true,
                loading: false,
                data,
                error,
                client: client2
              };
              if (ref.current.isMounted && !equal.equal(ref.current.result, result_1)) {
                setResult2(ref.current.result = result_1);
              }
            }
            var onCompleted = executeOptions.onCompleted || ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onCompleted);
            if (!error) {
              onCompleted === null || onCompleted === void 0 ? void 0 : onCompleted(response.data, clientOptions);
            }
            return response;
          }).catch(function(error) {
            var _a3;
            if (mutationId === ref.current.mutationId && ref.current.isMounted) {
              var result_2 = {
                loading: false,
                error,
                data: void 0,
                called: true,
                client: client2
              };
              if (!equal.equal(ref.current.result, result_2)) {
                setResult2(ref.current.result = result_2);
              }
            }
            var onError = executeOptions.onError || ((_a3 = ref.current.options) === null || _a3 === void 0 ? void 0 : _a3.onError);
            if (onError) {
              onError(error, clientOptions);
              return { data: void 0, errors: error };
            }
            throw error;
          });
        }, []);
        var reset = React__namespace.useCallback(function() {
          if (ref.current.isMounted) {
            var result_3 = {
              called: false,
              loading: false,
              client: ref.current.client
            };
            Object.assign(ref.current, { mutationId: 0, result: result_3 });
            setResult2(result_3);
          }
        }, []);
        React__namespace.useEffect(function() {
          var current = ref.current;
          current.isMounted = true;
          return function() {
            current.isMounted = false;
          };
        }, []);
        return [execute, tslib.__assign({ reset }, result)];
      }
      function useSubscription(subscription, options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        var hasIssuedDeprecationWarningRef = React__namespace.useRef(false);
        var client = useApolloClient(options.client);
        parser.verifyDocumentType(subscription, parser.DocumentType.Subscription);
        if (!hasIssuedDeprecationWarningRef.current) {
          hasIssuedDeprecationWarningRef.current = true;
          if (options.onSubscriptionData) {
            globalThis.__DEV__ !== false && globals.invariant.warn(options.onData ? 61 : 62);
          }
          if (options.onSubscriptionComplete) {
            globalThis.__DEV__ !== false && globals.invariant.warn(options.onComplete ? 63 : 64);
          }
        }
        var skip = options.skip, fetchPolicy = options.fetchPolicy, errorPolicy = options.errorPolicy, shouldResubscribe = options.shouldResubscribe, context3 = options.context, extensions = options.extensions, ignoreResults = options.ignoreResults;
        var variables = useDeepMemo(function() {
          return options.variables;
        }, [options.variables]);
        var recreate = function() {
          return createSubscription(client, subscription, variables, fetchPolicy, errorPolicy, context3, extensions);
        };
        var _a = React__namespace.useState(options.skip ? null : recreate), observable = _a[0], setObservable = _a[1];
        var recreateRef = React__namespace.useRef(recreate);
        useIsomorphicLayoutEffect(function() {
          recreateRef.current = recreate;
        });
        if (skip) {
          if (observable) {
            setObservable(observable = null);
          }
        } else if (!observable || (client !== observable.__.client || subscription !== observable.__.query || fetchPolicy !== observable.__.fetchPolicy || errorPolicy !== observable.__.errorPolicy || !equal.equal(variables, observable.__.variables)) && (typeof shouldResubscribe === "function" ? !!shouldResubscribe(options) : shouldResubscribe) !== false) {
          setObservable(observable = recreate());
        }
        var optionsRef = React__namespace.useRef(options);
        React__namespace.useEffect(function() {
          optionsRef.current = options;
        });
        var fallbackLoading = !skip && !ignoreResults;
        var fallbackResult = React__namespace.useMemo(function() {
          return {
            loading: fallbackLoading,
            error: void 0,
            data: void 0,
            variables
          };
        }, [fallbackLoading, variables]);
        var ignoreResultsRef = React__namespace.useRef(ignoreResults);
        useIsomorphicLayoutEffect(function() {
          ignoreResultsRef.current = ignoreResults;
        });
        var ret = useSyncExternalStore(React__namespace.useCallback(function(update2) {
          if (!observable) {
            return function() {
            };
          }
          var subscriptionStopped = false;
          var variables2 = observable.__.variables;
          var client2 = observable.__.client;
          var subscription2 = observable.subscribe({
            next: function(fetchResult) {
              var _a2, _b;
              if (subscriptionStopped) {
                return;
              }
              var result = {
                loading: false,
                data: fetchResult.data,
                error: toApolloError$1(fetchResult),
                variables: variables2
              };
              observable.__.setResult(result);
              if (!ignoreResultsRef.current)
                update2();
              if (result.error) {
                (_b = (_a2 = optionsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a2, result.error);
              } else if (optionsRef.current.onData) {
                optionsRef.current.onData({
                  client: client2,
                  data: result
                });
              } else if (optionsRef.current.onSubscriptionData) {
                optionsRef.current.onSubscriptionData({
                  client: client2,
                  subscriptionData: result
                });
              }
            },
            error: function(error) {
              var _a2, _b;
              error = error instanceof core2.ApolloError ? error : new core2.ApolloError({ protocolErrors: [error] });
              if (!subscriptionStopped) {
                observable.__.setResult({
                  loading: false,
                  data: void 0,
                  error,
                  variables: variables2
                });
                if (!ignoreResultsRef.current)
                  update2();
                (_b = (_a2 = optionsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a2, error);
              }
            },
            complete: function() {
              if (!subscriptionStopped) {
                if (optionsRef.current.onComplete) {
                  optionsRef.current.onComplete();
                } else if (optionsRef.current.onSubscriptionComplete) {
                  optionsRef.current.onSubscriptionComplete();
                }
              }
            }
          });
          return function() {
            subscriptionStopped = true;
            setTimeout(function() {
              subscription2.unsubscribe();
            });
          };
        }, [observable]), function() {
          return observable && !skip && !ignoreResults ? observable.__.result : fallbackResult;
        }, function() {
          return fallbackResult;
        });
        var restart = React__namespace.useCallback(function() {
          globals.invariant(!optionsRef.current.skip, 65);
          setObservable(recreateRef.current());
        }, [optionsRef, recreateRef]);
        return React__namespace.useMemo(function() {
          return tslib.__assign(tslib.__assign({}, ret), { restart });
        }, [ret, restart]);
      }
      function createSubscription(client, query, variables, fetchPolicy, errorPolicy, context3, extensions) {
        var options = {
          query,
          variables,
          fetchPolicy,
          errorPolicy,
          context: context3,
          extensions
        };
        var __ = tslib.__assign(tslib.__assign({}, options), { client, result: {
          loading: true,
          data: void 0,
          error: void 0,
          variables
        }, setResult: function(result) {
          __.result = result;
        } });
        var observable = null;
        return Object.assign(new core2.Observable(function(observer) {
          if (!observable) {
            observable = client.subscribe(options);
          }
          var sub = observable.subscribe(observer);
          return function() {
            return sub.unsubscribe();
          };
        }), {
          __
        });
      }
      function useReactiveVar(rv) {
        return useSyncExternalStore(React__namespace.useCallback(function(update2) {
          return rv.onNextChange(function onNext() {
            update2();
            rv.onNextChange(onNext);
          });
        }, [rv]), rv, rv);
      }
      function useFragment(options) {
        return wrapHook(
          "useFragment",
          useFragment_,
          useApolloClient(options.client)
        )(options);
      }
      function useFragment_(options) {
        var client = useApolloClient(options.client);
        var cache2 = client.cache;
        var from = options.from, rest = tslib.__rest(options, ["from"]);
        var id = React__namespace.useMemo(function() {
          return typeof from === "string" ? from : from === null ? null : cache2.identify(from);
        }, [cache2, from]);
        var stableOptions = useDeepMemo(function() {
          return tslib.__assign(tslib.__assign({}, rest), { from: id });
        }, [rest, id]);
        var diff = React__namespace.useMemo(function() {
          var fragment = stableOptions.fragment, fragmentName = stableOptions.fragmentName, from2 = stableOptions.from, _a = stableOptions.optimistic, optimistic = _a === void 0 ? true : _a;
          if (from2 === null) {
            return {
              result: diffToResult({
                result: {},
                complete: false
              })
            };
          }
          var cache3 = client.cache;
          var diff2 = cache3.diff(tslib.__assign(tslib.__assign({}, stableOptions), { returnPartialData: true, id: from2, query: cache3["getFragmentDoc"](fragment, fragmentName), optimistic }));
          return {
            result: diffToResult(tslib.__assign(tslib.__assign({}, diff2), { result: client["queryManager"].maskFragment({
              fragment,
              fragmentName,
              data: diff2.result
            }) }))
          };
        }, [client, stableOptions]);
        var getSnapshot = React__namespace.useCallback(function() {
          return diff.result;
        }, [diff]);
        return useSyncExternalStore(React__namespace.useCallback(function(forceUpdate) {
          var lastTimeout = 0;
          var subscription = stableOptions.from === null ? null : client.watchFragment(stableOptions).subscribe({
            next: function(result) {
              if (equal__default(result, diff.result))
                return;
              diff.result = result;
              clearTimeout(lastTimeout);
              lastTimeout = setTimeout(forceUpdate);
            }
          });
          return function() {
            subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
            clearTimeout(lastTimeout);
          };
        }, [client, stableOptions, diff]), getSnapshot, getSnapshot);
      }
      function diffToResult(diff) {
        var result = {
          data: diff.result,
          complete: !!diff.complete
        };
        if (diff.missing) {
          result.missing = utilities.mergeDeepArray(diff.missing.map(function(error) {
            return error.missing;
          }));
        }
        return result;
      }
      var skipToken = Symbol.for("apollo.skipToken");
      function useSuspenseQuery(query, options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        return wrapHook(
          "useSuspenseQuery",
          useSuspenseQuery_,
          useApolloClient(typeof options === "object" ? options.client : void 0)
        )(query, options);
      }
      function useSuspenseQuery_(query, options) {
        var client = useApolloClient(options.client);
        var suspenseCache = internal.getSuspenseCache(client);
        var watchQueryOptions = useWatchQueryOptions({
          client,
          query,
          options
        });
        var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;
        var _a = options.queryKey, queryKey = _a === void 0 ? [] : _a;
        var cacheKey = tslib.__spreadArray([
          query,
          cache.canonicalStringify(variables)
        ], [].concat(queryKey), true);
        var queryRef = suspenseCache.getQueryRef(cacheKey, function() {
          return client.watchQuery(watchQueryOptions);
        });
        var _b = React__namespace.useState([queryRef.key, queryRef.promise]), current = _b[0], setPromise = _b[1];
        if (current[0] !== queryRef.key) {
          current[0] = queryRef.key;
          current[1] = queryRef.promise;
        }
        var promise = current[1];
        if (queryRef.didChangeOptions(watchQueryOptions)) {
          current[1] = promise = queryRef.applyOptions(watchQueryOptions);
        }
        React__namespace.useEffect(function() {
          var dispose = queryRef.retain();
          var removeListener = queryRef.listen(function(promise2) {
            setPromise([queryRef.key, promise2]);
          });
          return function() {
            removeListener();
            dispose();
          };
        }, [queryRef]);
        var skipResult = React__namespace.useMemo(function() {
          var error = toApolloError(queryRef.result);
          return {
            loading: false,
            data: queryRef.result.data,
            networkStatus: error ? core2.NetworkStatus.error : core2.NetworkStatus.ready,
            error
          };
        }, [queryRef.result]);
        var result = fetchPolicy === "standby" ? skipResult : __use(promise);
        var fetchMore = React__namespace.useCallback(function(options2) {
          var promise2 = queryRef.fetchMore(options2);
          setPromise([queryRef.key, queryRef.promise]);
          return promise2;
        }, [queryRef]);
        var refetch = React__namespace.useCallback(function(variables2) {
          var promise2 = queryRef.refetch(variables2);
          setPromise([queryRef.key, queryRef.promise]);
          return promise2;
        }, [queryRef]);
        var subscribeToMore = queryRef.observable.subscribeToMore;
        return React__namespace.useMemo(function() {
          return {
            client,
            data: result.data,
            error: toApolloError(result),
            networkStatus: result.networkStatus,
            fetchMore,
            refetch,
            subscribeToMore
          };
        }, [client, fetchMore, refetch, result, subscribeToMore]);
      }
      function validateOptions(options) {
        var query = options.query, fetchPolicy = options.fetchPolicy, returnPartialData = options.returnPartialData;
        parser.verifyDocumentType(query, parser.DocumentType.Query);
        validateFetchPolicy(fetchPolicy);
        validatePartialDataReturn(fetchPolicy, returnPartialData);
      }
      function validateFetchPolicy(fetchPolicy) {
        if (fetchPolicy === void 0) {
          fetchPolicy = "cache-first";
        }
        var supportedFetchPolicies = [
          "cache-first",
          "network-only",
          "no-cache",
          "cache-and-network"
        ];
        globals.invariant(supportedFetchPolicies.includes(fetchPolicy), 66, fetchPolicy);
      }
      function validatePartialDataReturn(fetchPolicy, returnPartialData) {
        if (fetchPolicy === "no-cache" && returnPartialData) {
          globalThis.__DEV__ !== false && globals.invariant.warn(67);
        }
      }
      function toApolloError(result) {
        return utilities.isNonEmptyArray(result.errors) ? new core2.ApolloError({ graphQLErrors: result.errors }) : result.error;
      }
      function useWatchQueryOptions(_a) {
        var client = _a.client, query = _a.query, options = _a.options;
        return useDeepMemo(function() {
          var _a2;
          if (options === skipToken) {
            return { query, fetchPolicy: "standby" };
          }
          var fetchPolicy = options.fetchPolicy || ((_a2 = client.defaultOptions.watchQuery) === null || _a2 === void 0 ? void 0 : _a2.fetchPolicy) || "cache-first";
          var watchQueryOptions = tslib.__assign(tslib.__assign({}, options), { fetchPolicy, query, notifyOnNetworkStatusChange: false, nextFetchPolicy: void 0 });
          if (globalThis.__DEV__ !== false) {
            validateOptions(watchQueryOptions);
          }
          if (options.skip) {
            watchQueryOptions.fetchPolicy = "standby";
          }
          return watchQueryOptions;
        }, [client, options, query]);
      }
      function useBackgroundQuery(query, options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        return wrapHook(
          "useBackgroundQuery",
          useBackgroundQuery_,
          useApolloClient(typeof options === "object" ? options.client : void 0)
        )(query, options);
      }
      function useBackgroundQuery_(query, options) {
        var client = useApolloClient(options.client);
        var suspenseCache = internal.getSuspenseCache(client);
        var watchQueryOptions = useWatchQueryOptions({ client, query, options });
        var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;
        var _a = options.queryKey, queryKey = _a === void 0 ? [] : _a;
        var didFetchResult = React__namespace.useRef(fetchPolicy !== "standby");
        didFetchResult.current || (didFetchResult.current = fetchPolicy !== "standby");
        var cacheKey = tslib.__spreadArray([
          query,
          cache.canonicalStringify(variables)
        ], [].concat(queryKey), true);
        var queryRef = suspenseCache.getQueryRef(cacheKey, function() {
          return client.watchQuery(watchQueryOptions);
        });
        var _b = React__namespace.useState(internal.wrapQueryRef(queryRef)), wrappedQueryRef = _b[0], setWrappedQueryRef = _b[1];
        if (internal.unwrapQueryRef(wrappedQueryRef) !== queryRef) {
          setWrappedQueryRef(internal.wrapQueryRef(queryRef));
        }
        if (queryRef.didChangeOptions(watchQueryOptions)) {
          var promise = queryRef.applyOptions(watchQueryOptions);
          internal.updateWrappedQueryRef(wrappedQueryRef, promise);
        }
        React__namespace.useEffect(function() {
          var id = setTimeout(function() {
            if (queryRef.disposed) {
              suspenseCache.add(cacheKey, queryRef);
            }
          });
          return function() {
            return clearTimeout(id);
          };
        });
        var fetchMore = React__namespace.useCallback(function(options2) {
          var promise2 = queryRef.fetchMore(options2);
          setWrappedQueryRef(internal.wrapQueryRef(queryRef));
          return promise2;
        }, [queryRef]);
        var refetch = React__namespace.useCallback(function(variables2) {
          var promise2 = queryRef.refetch(variables2);
          setWrappedQueryRef(internal.wrapQueryRef(queryRef));
          return promise2;
        }, [queryRef]);
        React__namespace.useEffect(function() {
          return queryRef.softRetain();
        }, [queryRef]);
        return [
          didFetchResult.current ? wrappedQueryRef : void 0,
          {
            fetchMore,
            refetch,
            subscribeToMore: queryRef.observable.subscribeToMore
          }
        ];
      }
      function useLoadableQuery(query, options) {
        if (options === void 0) {
          options = /* @__PURE__ */ Object.create(null);
        }
        var client = useApolloClient(options.client);
        var suspenseCache = internal.getSuspenseCache(client);
        var watchQueryOptions = useWatchQueryOptions({ client, query, options });
        var _a = options.queryKey, queryKey = _a === void 0 ? [] : _a;
        var _b = React__namespace.useState(null), queryRef = _b[0], setQueryRef = _b[1];
        internal.assertWrappedQueryRef(queryRef);
        var internalQueryRef = queryRef && internal.unwrapQueryRef(queryRef);
        if (queryRef && (internalQueryRef === null || internalQueryRef === void 0 ? void 0 : internalQueryRef.didChangeOptions(watchQueryOptions))) {
          var promise = internalQueryRef.applyOptions(watchQueryOptions);
          internal.updateWrappedQueryRef(queryRef, promise);
        }
        var calledDuringRender = useRenderGuard();
        var fetchMore = React__namespace.useCallback(function(options2) {
          if (!internalQueryRef) {
            throw new Error("The query has not been loaded. Please load the query.");
          }
          var promise2 = internalQueryRef.fetchMore(options2);
          setQueryRef(internal.wrapQueryRef(internalQueryRef));
          return promise2;
        }, [internalQueryRef]);
        var refetch = React__namespace.useCallback(function(options2) {
          if (!internalQueryRef) {
            throw new Error("The query has not been loaded. Please load the query.");
          }
          var promise2 = internalQueryRef.refetch(options2);
          setQueryRef(internal.wrapQueryRef(internalQueryRef));
          return promise2;
        }, [internalQueryRef]);
        var loadQuery = React__namespace.useCallback(function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          globals.invariant(!calledDuringRender(), 59);
          var variables = args[0];
          var cacheKey = tslib.__spreadArray([
            query,
            cache.canonicalStringify(variables)
          ], [].concat(queryKey), true);
          var queryRef2 = suspenseCache.getQueryRef(cacheKey, function() {
            return client.watchQuery(tslib.__assign(tslib.__assign({}, watchQueryOptions), { variables }));
          });
          setQueryRef(internal.wrapQueryRef(queryRef2));
        }, [
          query,
          queryKey,
          suspenseCache,
          watchQueryOptions,
          calledDuringRender,
          client
        ]);
        var subscribeToMore = React__namespace.useCallback(function(options2) {
          globals.invariant(internalQueryRef, 60);
          return internalQueryRef.observable.subscribeToMore(options2);
        }, [internalQueryRef]);
        var reset = React__namespace.useCallback(function() {
          setQueryRef(null);
        }, []);
        return [loadQuery, queryRef, { fetchMore, refetch, reset, subscribeToMore }];
      }
      function useQueryRefHandlers(queryRef) {
        var unwrapped = internal.unwrapQueryRef(queryRef);
        return wrapHook("useQueryRefHandlers", useQueryRefHandlers_, unwrapped ? unwrapped["observable"] : useApolloClient())(queryRef);
      }
      function useQueryRefHandlers_(queryRef) {
        internal.assertWrappedQueryRef(queryRef);
        var _a = React__namespace.useState(queryRef), previousQueryRef = _a[0], setPreviousQueryRef = _a[1];
        var _b = React__namespace.useState(queryRef), wrappedQueryRef = _b[0], setWrappedQueryRef = _b[1];
        var internalQueryRef = internal.unwrapQueryRef(queryRef);
        if (previousQueryRef !== queryRef) {
          setPreviousQueryRef(queryRef);
          setWrappedQueryRef(queryRef);
        } else {
          internal.updateWrappedQueryRef(queryRef, internal.getWrappedPromise(wrappedQueryRef));
        }
        var refetch = React__namespace.useCallback(function(variables) {
          var promise = internalQueryRef.refetch(variables);
          setWrappedQueryRef(internal.wrapQueryRef(internalQueryRef));
          return promise;
        }, [internalQueryRef]);
        var fetchMore = React__namespace.useCallback(function(options) {
          var promise = internalQueryRef.fetchMore(options);
          setWrappedQueryRef(internal.wrapQueryRef(internalQueryRef));
          return promise;
        }, [internalQueryRef]);
        return {
          refetch,
          fetchMore,
          subscribeToMore: internalQueryRef.observable.subscribeToMore
        };
      }
      function useReadQuery(queryRef) {
        var unwrapped = internal.unwrapQueryRef(queryRef);
        return wrapHook("useReadQuery", useReadQuery_, unwrapped ? unwrapped["observable"] : useApolloClient())(queryRef);
      }
      function useReadQuery_(queryRef) {
        internal.assertWrappedQueryRef(queryRef);
        var internalQueryRef = React__namespace.useMemo(function() {
          return internal.unwrapQueryRef(queryRef);
        }, [queryRef]);
        var getPromise = React__namespace.useCallback(function() {
          return internal.getWrappedPromise(queryRef);
        }, [queryRef]);
        if (internalQueryRef.disposed) {
          internalQueryRef.reinitialize();
          internal.updateWrappedQueryRef(queryRef, internalQueryRef.promise);
        }
        React__namespace.useEffect(function() {
          return internalQueryRef.retain();
        }, [internalQueryRef]);
        var promise = useSyncExternalStore(React__namespace.useCallback(function(forceUpdate) {
          return internalQueryRef.listen(function(promise2) {
            internal.updateWrappedQueryRef(queryRef, promise2);
            forceUpdate();
          });
        }, [internalQueryRef, queryRef]), getPromise, getPromise);
        var result = __use(promise);
        return React__namespace.useMemo(function() {
          return {
            data: result.data,
            networkStatus: result.networkStatus,
            error: toApolloError(result)
          };
        }, [result]);
      }
      exports.skipToken = skipToken;
      exports.useApolloClient = useApolloClient;
      exports.useBackgroundQuery = useBackgroundQuery;
      exports.useFragment = useFragment;
      exports.useLazyQuery = useLazyQuery;
      exports.useLoadableQuery = useLoadableQuery;
      exports.useMutation = useMutation;
      exports.useQuery = useQuery;
      exports.useQueryRefHandlers = useQueryRefHandlers;
      exports.useReactiveVar = useReactiveVar;
      exports.useReadQuery = useReadQuery;
      exports.useSubscription = useSubscription;
      exports.useSuspenseQuery = useSuspenseQuery;
    }
  });

  // node_modules/@apollo/client/react/react.cjs
  var require_react2 = __commonJS({
    "node_modules/@apollo/client/react/react.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      require_globals();
      var context2 = require_context2();
      var hooks = require_hooks();
      var parser = require_parser2();
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var internal = require_internal();
      var wrapperSymbol = Symbol.for("apollo.hook.wrappers");
      function wrapHook(hookName, useHook, clientOrObsQuery) {
        var queryManager = clientOrObsQuery["queryManager"];
        var wrappers = queryManager && queryManager[wrapperSymbol];
        var wrapper = wrappers && wrappers[hookName];
        return wrapper ? wrapper(useHook) : useHook;
      }
      function createQueryPreloader(client) {
        return wrapHook("createQueryPreloader", _createQueryPreloader, client)(client);
      }
      var _createQueryPreloader = function(client) {
        return function preloadQuery(query, options) {
          var _a, _b;
          if (options === void 0) {
            options = /* @__PURE__ */ Object.create(null);
          }
          var queryRef = new internal.InternalQueryReference(client.watchQuery(tslib.__assign(tslib.__assign({}, options), { query })), {
            autoDisposeTimeoutMs: (_b = (_a = client.defaultOptions.react) === null || _a === void 0 ? void 0 : _a.suspense) === null || _b === void 0 ? void 0 : _b.autoDisposeTimeoutMs
          });
          return internal.wrapQueryRef(queryRef);
        };
      };
      exports.ApolloConsumer = context2.ApolloConsumer;
      exports.ApolloProvider = context2.ApolloProvider;
      exports.getApolloContext = context2.getApolloContext;
      exports.resetApolloContext = context2.resetApolloContext;
      exports.DocumentType = parser.DocumentType;
      exports.operationName = parser.operationName;
      exports.parser = parser.parser;
      exports.createQueryPreloader = createQueryPreloader;
      for (k in hooks) {
        if (k !== "default" && !exports.hasOwnProperty(k)) exports[k] = hooks[k];
      }
      var k;
    }
  });

  // node_modules/@apollo/client/main.cjs
  var require_main3 = __commonJS({
    "node_modules/@apollo/client/main.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var core2 = require_core3();
      var react = require_react2();
      for (k in core2) {
        if (k !== "default" && !exports.hasOwnProperty(k)) exports[k] = core2[k];
      }
      var k;
      for (k in react) {
        if (k !== "default" && !exports.hasOwnProperty(k)) exports[k] = react[k];
      }
      var k;
    }
  });

  // node_modules/@apollo/client/link/context/context.cjs
  var require_context3 = __commonJS({
    "node_modules/@apollo/client/link/context/context.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var core2 = require_core2();
      var utilities = require_utilities2();
      function setContext(setter) {
        return new core2.ApolloLink(function(operation, forward) {
          var request2 = tslib.__rest(operation, []);
          return new utilities.Observable(function(observer) {
            var handle;
            var closed = false;
            Promise.resolve(request2).then(function(req) {
              return setter(req, operation.getContext());
            }).then(operation.setContext).then(function() {
              if (closed)
                return;
              handle = forward(operation).subscribe({
                next: observer.next.bind(observer),
                error: observer.error.bind(observer),
                complete: observer.complete.bind(observer)
              });
            }).catch(observer.error.bind(observer));
            return function() {
              closed = true;
              if (handle)
                handle.unsubscribe();
            };
          });
        });
      }
      exports.setContext = setContext;
    }
  });

  // node_modules/github-projectv2-csv-exporter/dist/api/github-projectv2-api.js
  var require_github_projectv2_api = __commonJS({
    "node_modules/github-projectv2-csv-exporter/dist/api/github-projectv2-api.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProjectItem = exports.fetchProjectItems = exports.Project = exports.Projects = exports.fetchProjects = exports.createGQLClient = exports.GITHUB_API_URL = void 0;
      var client_1 = require_main3();
      var context_1 = require_context3();
      exports.GITHUB_API_URL = "https://api.github.com/graphql";
      var createGQLClient = (token2) => {
        const httpLink = (0, client_1.createHttpLink)({
          uri: exports.GITHUB_API_URL
        });
        const authLink = (0, context_1.setContext)((_, { headers }) => {
          return {
            headers: Object.assign(Object.assign({}, headers), { authorization: token2 ? `Bearer ${token2}` : "" })
          };
        });
        const client = new client_1.ApolloClient({
          link: authLink.concat(httpLink),
          cache: new client_1.InMemoryCache()
        });
        return client;
      };
      exports.createGQLClient = createGQLClient;
      var fetchProjects = (login, isOrg, token2) => __awaiter2(void 0, void 0, void 0, function* () {
        const ORG_PROJECTS_QUERY = (0, client_1.gql)`
    query ProjectsQuery($login: String!, $projectsFirst: Int) {
      viewer {
        login
        name
        url
        avatarUrl
      }
      entity: ${isOrg ? "organization" : "user"}(login: $login) {
        avatarUrl
        login
        name
        url
        projectsV2(first: $projectsFirst) {
          edges {
            node {
              title
              number
              url
              items {
                totalCount
              }
            }
          }
        }
      }
    }
  `;
        const client = (0, exports.createGQLClient)(token2);
        const results = yield client.query({
          query: ORG_PROJECTS_QUERY,
          variables: {
            login,
            projectsFirst: 100
          }
        });
        return new Projects(results);
      });
      exports.fetchProjects = fetchProjects;
      var Projects = class {
        constructor(results) {
          this.results = results;
        }
        getViewerLogin() {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.results) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.viewer) === null || _c === void 0 ? void 0 : _c.login;
        }
        getViewerAvatarUrl() {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.results) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.viewer) === null || _c === void 0 ? void 0 : _c.avatarUrl;
        }
        getViewerUrl() {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.results) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.viewer) === null || _c === void 0 ? void 0 : _c.url;
        }
        getViewerName() {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.results) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.viewer) === null || _c === void 0 ? void 0 : _c.name;
        }
        getLogin() {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.results) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.entity) === null || _c === void 0 ? void 0 : _c.login;
        }
        getAvatarUrl() {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.results) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.entity) === null || _c === void 0 ? void 0 : _c.avatarUrl;
        }
        getUrl() {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.results) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.entity) === null || _c === void 0 ? void 0 : _c.url;
        }
        getName() {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.results) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.entity) === null || _c === void 0 ? void 0 : _c.name;
        }
        getProjects() {
          var _a, _b, _c, _d, _e;
          const edges = (_e = (_d = (_c = (_b = (_a = this.results) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.entity) === null || _c === void 0 ? void 0 : _c.projectsV2) === null || _d === void 0 ? void 0 : _d.edges) !== null && _e !== void 0 ? _e : [];
          return edges.map((edge) => new Project2(edge.node));
        }
      };
      exports.Projects = Projects;
      var Project2 = class {
        constructor(node) {
          this.node = node;
        }
        getTitle() {
          var _a;
          return (_a = this.node) === null || _a === void 0 ? void 0 : _a.title;
        }
        getProjectNumber() {
          var _a;
          return (_a = this.node) === null || _a === void 0 ? void 0 : _a.number;
        }
        getUrl() {
          var _a;
          return (_a = this.node) === null || _a === void 0 ? void 0 : _a.url;
        }
        getTotalItemCount() {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.totalCount) !== null && _c !== void 0 ? _c : 0;
        }
      };
      exports.Project = Project2;
      var fetchProjectItems2 = (login, isOrg, projectNumber, token2, progress) => __awaiter2(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const PROJECT_ITEMS_QUERY = (0, client_1.gql)`
    query ProjectQuery(
      $login: String!
      $projectNumber: Int!
      $itemsFirst: Int
      $itemsAfter: String
      $assigneesFirst: Int
      $labelsFirst: Int
      $statusFieldName: String!
    ) {
      entity: ${isOrg ? "organization" : "user"}(login: $login) {
        projectV2(number: $projectNumber) {
          items(first: $itemsFirst, after: $itemsAfter) {
            totalCount
            edges {
              node {
                content {
                  ... on Issue {
                    title
                    url
                    issueState: state
                    assignees(first: $assigneesFirst) {
                      nodes {
                        name
                        login
                      }
                    }
                    author {
                      login
                      ... on User {
                        name
                        login
                      }
                      ... on Organization {
                        name
                        login
                      }
                      ... on EnterpriseUserAccount {
                        name
                        login
                      }
                    }
                    milestone {
                      title
                    }
                    labels(first: $labelsFirst) {
                      nodes {
                        name
                      }
                    }
                    body
                    number
                    closedAt
                  }
                  ... on DraftIssue {
                    title
                    author: creator {
                      login
                      ... on User {
                        name
                        login
                      }
                      ... on Organization {
                        name
                        login
                      }
                      ... on EnterpriseUserAccount {
                        name
                        login
                      }
                    }
                    assignees(first: $assigneesFirst) {
                      nodes {
                        login
                        name
                      }
                    }
                    body
                  }
                  ... on PullRequest {
                    title
                    assignees(first: $assigneesFirst) {
                      nodes {
                        name
                        login
                      }
                    }
                    body
                    pullRequestState: state
                    url
                    number
                    author {
                      ... on User {
                        name
                        login
                      }
                      ... on Organization {
                        name
                        login
                      }
                      ... on EnterpriseUserAccount {
                        name
                        login
                      }
                    }
                    closedAt
                  }
                }
                createdAt
                updatedAt
                isArchived
                status: fieldValueByName(name: $statusFieldName) {
                  ... on ProjectV2ItemFieldSingleSelectValue {
                    name
                  }
                }
                type
              }
              cursor
            }
          }
        }
      }
    }
  `;
        const client = (0, exports.createGQLClient)(token2);
        let itemsAfter = null;
        let queryResults = void 0;
        let loadedEdges = [];
        let loadedAll = false;
        while (!loadedAll) {
          queryResults = yield client.query({
            query: PROJECT_ITEMS_QUERY,
            variables: {
              login,
              projectNumber,
              itemsFirst: 100,
              itemsAfter,
              assigneesFirst: 100,
              labelsFirst: 100,
              statusFieldName: "Status"
            }
          });
          const totalCount = (_e = (_d = (_c = (_b = (_a = queryResults.data) === null || _a === void 0 ? void 0 : _a.entity) === null || _b === void 0 ? void 0 : _b.projectV2) === null || _c === void 0 ? void 0 : _c.items) === null || _d === void 0 ? void 0 : _d.totalCount) !== null && _e !== void 0 ? _e : 0;
          const edges = (_k = (_j = (_h = (_g = (_f = queryResults === null || queryResults === void 0 ? void 0 : queryResults.data) === null || _f === void 0 ? void 0 : _f.entity) === null || _g === void 0 ? void 0 : _g.projectV2) === null || _h === void 0 ? void 0 : _h.items) === null || _j === void 0 ? void 0 : _j.edges) !== null && _k !== void 0 ? _k : [];
          loadedEdges = [...loadedEdges, ...edges];
          itemsAfter = edges[edges.length - 1].cursor;
          loadedAll = loadedEdges.length === totalCount;
          if (progress) {
            progress(loadedEdges.length, totalCount);
          }
        }
        return loadedEdges.map((edge) => new ProjectItem2(edge.node));
      });
      exports.fetchProjectItems = fetchProjectItems2;
      var ProjectItem2 = class {
        constructor(node) {
          this.node = node;
        }
        getCreatedAt() {
          var _a;
          return (_a = this.node) === null || _a === void 0 ? void 0 : _a.createdAt;
        }
        isArchived() {
          var _a;
          return !!((_a = this.node) === null || _a === void 0 ? void 0 : _a.isArchived);
        }
        getStatus() {
          var _a, _b;
          return (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.status) === null || _b === void 0 ? void 0 : _b.name;
        }
        getType() {
          var _a;
          return (_a = this.node) === null || _a === void 0 ? void 0 : _a.type;
        }
        getUpdatedAt() {
          var _a;
          return (_a = this.node) === null || _a === void 0 ? void 0 : _a.updatedAt;
        }
        getAssignees() {
          var _a, _b, _c, _d;
          return ((_d = (_c = (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.assignees) === null || _c === void 0 ? void 0 : _c.nodes) !== null && _d !== void 0 ? _d : []).map((data) => {
            var _a2, _b2;
            return { name: (_a2 = data === null || data === void 0 ? void 0 : data.name) !== null && _a2 !== void 0 ? _a2 : "", login: (_b2 = data === null || data === void 0 ? void 0 : data.login) !== null && _b2 !== void 0 ? _b2 : "" };
          });
        }
        getAuthor() {
          var _a, _b, _c, _d;
          const authorData = (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.author;
          return { name: (_c = authorData === null || authorData === void 0 ? void 0 : authorData.name) !== null && _c !== void 0 ? _c : "", login: (_d = authorData === null || authorData === void 0 ? void 0 : authorData.login) !== null && _d !== void 0 ? _d : "" };
        }
        getBody() {
          var _a, _b;
          return (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.body;
        }
        getClosedAt() {
          var _a, _b;
          return (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.closedAt;
        }
        getState() {
          var _a, _b, _c, _d;
          return ((_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.issueState) || ((_d = (_c = this.node) === null || _c === void 0 ? void 0 : _c.content) === null || _d === void 0 ? void 0 : _d.pullRequestState);
        }
        getLabels() {
          var _a, _b, _c, _d;
          return ((_d = (_c = (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.nodes) !== null && _d !== void 0 ? _d : []).map((labelData) => {
            var _a2;
            return (_a2 = labelData === null || labelData === void 0 ? void 0 : labelData.name) !== null && _a2 !== void 0 ? _a2 : "";
          });
        }
        getMilestone() {
          var _a, _b, _c;
          return (_c = (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.milestone) === null || _c === void 0 ? void 0 : _c.title;
        }
        getNumber() {
          var _a, _b;
          return (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.number;
        }
        getTitle() {
          var _a, _b;
          return (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.title;
        }
        getUrl() {
          var _a, _b;
          return (_b = (_a = this.node) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.url;
        }
      };
      exports.ProjectItem = ProjectItem2;
    }
  });

  // node_modules/github-projectv2-csv-exporter/dist/index.js
  var require_dist = __commonJS({
    "node_modules/github-projectv2-csv-exporter/dist/index.js"(exports) {
      "use strict";
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar2(require_github_projectv2_api(), exports);
    }
  });

  // src/card.graphql
  var require_card = __commonJS({
    "src/card.graphql"(exports, module) {
      module.exports = 'query($owner: String!, $repo: String!, $issueNumber: Int!) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueNumber) {\n      id\n      number\n      title\n      projectItems(first: 10) {\n        nodes {\n          id\n          project {\n            id\n            title\n            number\n            owner {\n              ... on Organization { login }\n              ... on User { login }\n            }\n          }\n          fieldValueByName(name: "Waiting") {\n            __typename\n            ... on ProjectV2ItemFieldTextValue { id text }\n            ... on ProjectV2ItemFieldNumberValue { id number }\n            ... on ProjectV2ItemFieldDateValue { id date }\n            ... on ProjectV2ItemFieldSingleSelectValue { name optionId }\n          }\n          fieldValues(first: 50) {\n            nodes {\n              __typename\n              ... on ProjectV2ItemFieldTextValue { text field { ... on ProjectV2FieldCommon { name } } }\n              ... on ProjectV2ItemFieldNumberValue { number field { ... on ProjectV2FieldCommon { name } } }\n              ... on ProjectV2ItemFieldDateValue { date field { ... on ProjectV2FieldCommon { name } } }\n              ... on ProjectV2ItemFieldSingleSelectValue { name field { ... on ProjectV2FieldCommon { name } } }\n              ... on ProjectV2ItemFieldLabelValue { labels(first: 10) { nodes { name } } field { ... on ProjectV2FieldCommon { name } } }\n              ... on ProjectV2ItemFieldRepositoryValue { repository { name } field { ... on ProjectV2FieldCommon { name } } }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n';
    }
  });

  // src/main.ts
  var core = __toESM(require_core());
  var import_github = __toESM(require_github());
  var import_github_projectv2_csv_exporter = __toESM(require_dist());
  var token = core.getInput("token", { required: true });
  var octokit = (0, import_github.getOctokit)(token);
  var sender = import_github.context.payload.sender?.login || "";
  var bot = import_github.context.payload.sender?.type === "Bot";
  var owner = import_github.context.payload.repository?.owner?.login || "";
  var repo = import_github.context.payload.repository?.name || "";
  if (core.getInput("verbose") && !core.getInput("verbose").match(/^(true|false)$/i)) throw new Error(`Unexpected verbose value ${core.getInput("verbose")}`);
  var q = {
    card: require_card()
  };
  function getState() {
    const state = core.getInput("state") || "all";
    switch (state) {
      case "all":
      case "closed":
      case "open":
        return state;
      default:
        console.log(`invalid state ${JSON.stringify(state)}, assuming "all"`);
        return "all";
    }
  }
  var input = {
    label: {
      awaiting: core.getInput("label.awaiting") || "",
      exempt: core.getInput("label.exempt") || "",
      reopened: core.getInput("label.reopened") || "",
      merge: core.getInput("label.merge") || ""
    },
    log: {
      regex: core.getInput("log.regex") ? new RegExp(core.getInput("log.regex")) : void 0,
      message: core.getInput("log.message"),
      label: core.getInput("log.label") || ""
    },
    assignee: core.getInput("assign"),
    state: getState(),
    verbose: (core.getInput("verbose") || "").toLowerCase() === "true",
    project: {
      token: core.getInput("project.token") || core.getInput("token") || "",
      url: core.getInput("project.url") || ""
    }
  };
  if (input.verbose) console.log(input);
  var Project = new class {
    constructor() {
      this.cards = [];
    }
    async load() {
      if (!input.project.url) return;
      const m = input.project.url.match(/https:\/\/github.com\/(users|orgs)\/([^/]+)\/projects\/(\d+)/);
      if (!m) throw new Error(`${input.project.url} is not a valid project URL`);
      const [, type, owner2, number] = m;
      this.cards = await (0, import_github_projectv2_csv_exporter.fetchProjectItems)(m[2], m[1] === "orgs", parseInt(m[3]), input.project.token);
    }
    card(issue) {
      const url = `https://github.com/${owner}/${repo}/issues/${issue.number}`;
      let card = this.cards.find((card2) => card2.getUrl() === url);
      return card;
    }
  }();
  var User = new class {
    #collaborator = {};
    async isCollaborator(username, allowBot = false) {
      if (!username) return false;
      if (username.endsWith("[bot]") || username === sender && bot) {
        if (input.verbose) console.log(username, "is a bot, which we", allowBot ? "consider" : "do not consider", "to be a contributor");
        return allowBot;
      }
      if (typeof this.#collaborator[username] !== "boolean") {
        const { data: user } = await octokit.rest.repos.getCollaboratorPermissionLevel({ owner, repo, username });
        this.#collaborator[username] = user.permission === "admin";
        if (input.verbose) console.log(username, "has permission", user.permission, "and is", this.#collaborator[username] ? "a" : "not a", "contributor");
      }
      return this.#collaborator[username];
    }
  }();
  async function update(issue, body) {
    if (!issue) throw new Error("No issue found");
    if (input.verbose) console.log("processing issue", issue.number);
    function $labeled(...name) {
      name = name.filter((_) => _);
      if (input.verbose) console.log("testing whether issue is labeled", name);
      return (issue.labels || []).find((label) => name.includes(typeof label === "string" ? label : label?.name || ""));
    }
    async function $label(name) {
      if (!name || $labeled(name)) return;
      if (input.verbose) console.log("labeling", name);
      await octokit.rest.issues.addLabels({ owner, repo, issue_number: issue.number, labels: [name] });
    }
    async function $unlabel(name) {
      if (!name || !$labeled(name)) return;
      if (input.verbose) console.log("unlabeling", name);
      await octokit.rest.issues.removeLabel({ owner, repo, issue_number: issue.number, name });
    }
    const { data: comments } = await octokit.rest.issues.listComments({ owner, repo, issue_number: issue.number });
    const active = {
      user: false,
      owner: false
    };
    for (const user of [sender, issue.user.login].concat(comments.map((comment) => comment.user?.login || ""))) {
      if (!user) continue;
      if (await User.isCollaborator(user)) {
        active.owner = true;
      } else {
        active.user = true;
      }
      if (active.user && active.owner) break;
    }
    const managed = active.user && !$labeled(input.label.exempt);
    if (input.verbose) console.log({ active, managed, exempt: $labeled(input.label.exempt) });
    if (input.assignee && issue.state === "closed") {
      const assignees = issue.assignees.map((assignee) => assignee.login);
      if (assignees.length) await octokit.rest.issues.removeAssignees({ owner, repo, issue_number: issue.number, assignees });
    } else if (active.owner && input.assignee && !issue.assignees.find((assignee) => assignee.login)) {
      const assignee = await User.isCollaborator(sender, false) ? sender : input.assignee;
      await octokit.rest.issues.addAssignees({ owner, repo, issue_number: issue.number, assignees: [assignee] });
    }
    if (input.verbose) console.log(sender, "collaborator:", await User.isCollaborator(sender));
    if (await User.isCollaborator(sender)) {
      if (import_github.context.payload.action != "edited" && managed) {
        await (issue.state === "open" ? $label(input.label.awaiting) : $unlabel(input.label.awaiting));
      }
    } else {
      if (managed && import_github.context.payload.action === "closed") {
        if (input.label.reopened && !$labeled(input.label.reopened)) await $label(input.label.merge);
      } else if (import_github.context.eventName === "issue_comment") {
        if (managed && issue.state === "closed") {
          await octokit.rest.issues.update({ owner, repo, issue_number: issue.number, state: "open" });
          await $label(input.label.reopened);
        }
      }
      await $unlabel(input.label.awaiting);
      if (managed && input.log.regex) {
        let found = issue.state === "closed" || !!body.match(input.log.regex);
        if (!found && import_github.context.eventName === "workflow_dispatch") {
          found = !![issue.body || "", ...comments.map((comment) => comment.body || "")].find((b) => b.match(input.log.regex));
        }
        if (found) {
          await $unlabel(input.log.label);
        } else if (import_github.context.eventName === "issues" && import_github.context.payload.action === "opened" && !$labeled(input.log.label)) {
          await $label(input.log.label);
          if (input.log.message && sender) {
            await octokit.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: input.log.message.replace("{{username}}", sender) });
          }
        }
      }
    }
  }
  async function run() {
    try {
      if (!owner || !repo) throw new Error("No repository found");
      await Project.load();
      switch (import_github.context.eventName) {
        case "issues": {
          const issue = import_github.context.payload.issue;
          return await update(issue, issue?.body || "");
        }
        case "issue_comment": {
          const issue = import_github.context.payload.issue;
          const comment = import_github.context.payload.comment;
          return await update(issue, comment?.body || "");
        }
        case "workflow_dispatch": {
          for (const issue of await octokit.paginate(octokit.rest.issues.listForRepo, { owner, repo, state: input.state, per_page: 100 })) {
            await update(issue, "");
          }
          return;
        }
        default: {
          throw new Error(`Unexpected event ${import_github.context.eventName}`);
        }
      }
      if (input.verbose) console.log("finished");
    } catch (err) {
      console.log(err);
      process.exit(1);
    }
  }
  run();
})();
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=index.js.map
